// Code generated from /Users/manyi/GolandProjects/gparser/internal/iantlr/HiveParser.g4 by ANTLR 4.13.1. DO NOT EDIT.

package parser // HiveParser

import (
	"fmt"
	"strconv"
  	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}


type HiveParser struct {
	*antlr.BaseParser
}

var HiveParserParserStaticData struct {
  once                   sync.Once
  serializedATN          []int32
  LiteralNames           []string
  SymbolicNames          []string
  RuleNames              []string
  PredictionContextCache *antlr.PredictionContextCache
  atn                    *antlr.ATN
  decisionToDFA          []*antlr.DFA
}

func hiveparserParserInit() {
  staticData := &HiveParserParserStaticData
  staticData.LiteralNames = []string{
    "", "'ABORT'", "'ACTIVATE'", "'ACTIVE'", "'ADD'", "'ADMIN'", "'AFTER'", 
    "'ALL'", "'ALLOC_FRACTION'", "'ALTER'", "'ANALYZE'", "'AND'", "'ANTI'", 
    "'ANY'", "'APPLICATION'", "'ARCHIVE'", "'ARRAY'", "'AS'", "'ASC'", "'AST'", 
    "'AT'", "'AUTHORIZATION'", "'AUTOCOMMIT'", "'KW_BATCH'", "'BEFORE'", 
    "'BETWEEN'", "'BIGINT'", "'BINARY'", "'BOOLEAN'", "'BOTH'", "'BUCKET'", 
    "'BUCKETS'", "'BY'", "'CACHE'", "'CASCADE'", "'CASE'", "'CAST'", "'CBO'", 
    "'CHANGE'", "'CHAR'", "'CHECK'", "'CLUSTER'", "'CLUSTERED'", "'CLUSTERSTATUS'", 
    "'COLLECTION'", "'COLUMN'", "'COLUMNS'", "'COMMENT'", "'COMMIT'", "'COMPACT'", 
    "'COMPACTIONS'", "'COMPACTIONID'", "'COMPUTE'", "'CONCATENATE'", "'CONF'", 
    "'CONSTRAINT'", "'CONTINUE'", "'COST'", "'CREATE'", "'CRON'", "'CROSS'", 
    "'CUBE'", "'CURRENT'", "'CURRENT_DATE'", "'CURRENT_TIMESTAMP'", "'CURSOR'", 
    "'DATA'", "'DATABASE'", "'DATABASES'", "'CONNECTOR'", "'CONNECTORS'", 
    "'DATE'", "'DATETIME'", "", "'KW_DAYOFWEEK'", "'DBPROPERTIES'", "'DCPROPERTIES'", 
    "'DDL'", "'DEBUG'", "", "'DEFAULT'", "'DEFERRED'", "'DEFINED'", "'DELETE'", 
    "'DELIMITED'", "'DEPENDENCY'", "'DESC'", "'DESCRIBE'", "'DETAIL'", "'DIRECTORIES'", 
    "'DIRECTORY'", "", "'DISTINCT'", "'DISTRIBUTE'", "'DISTRIBUTED'", "'DO'", 
    "'DOUBLE'", "'DAYOFWEEK'", "'DROP'", "'DUMP'", "'$ELEM$'", "'ELSE'", 
    "", "'END'", "'ENFORCED'", "'ESCAPED'", "'EVERY'", "'EXCEPT'", "'EXCHANGE'", 
    "'EXCLUSIVE'", "'EXECUTE'", "'EXECUTED'", "'EXISTS'", "'EXPIRE_SNAPSHOTS'", 
    "'EXPLAIN'", "'EXPORT'", "'EXPRESSION'", "'EXTENDED'", "'EXTERNAL'", 
    "'EXTRACT'", "'FALSE'", "'FETCH'", "'FIELDS'", "'FILE'", "'FILEFORMAT'", 
    "'FIRST'", "'FLOAT'", "'FLOOR'", "'FOLLOWING'", "'FOR'", "'FORCE'", 
    "'FOREIGN'", "'FORMAT'", "'FORMATTED'", "'FROM'", "'FULL'", "'FUNCTION'", 
    "'FUNCTIONS'", "'GRANT'", "'GROUP'", "'GROUPING'", "'HAVING'", "'KW_HOLD_DDLTIME'", 
    "", "'IDXPROPERTIES'", "'IF'", "'IGNORE'", "'IMPORT'", "'IN'", "'INDEX'", 
    "'INDEXES'", "'INNER'", "'INPATH'", "'INPUTDRIVER'", "'INPUTFORMAT'", 
    "'INSERT'", "", "'INTERSECT'", "'INTERVAL'", "'INTO'", "'IS'", "'ISOLATION'", 
    "'ITEMS'", "'JAR'", "'JOIN'", "'JOINCOST'", "'KEY'", "'KEYS'", "'$KEY$'", 
    "'KILL'", "'LAST'", "'LATERAL'", "'LEADING'", "'LEFT'", "'LESS'", "'LEVEL'", 
    "'LIKE'", "'LIMIT'", "'LINES'", "'LOAD'", "'LOCAL'", "'LOCATION'", "'LOCK'", 
    "'LOCKS'", "'LOGICAL'", "'LONG'", "'MACRO'", "'MANAGED'", "'MANAGEDLOCATION'", 
    "'MANAGEMENT'", "'MAP'", "'MAPJOIN'", "'MAPPING'", "'MATCHED'", "'MATERIALIZED'", 
    "'MERGE'", "'METADATA'", "'MINUS'", "", "", "'MORE'", "'MOVE'", "'MSCK'", 
    "'NONE'", "'NORELY'", "'NOSCAN'", "", "'NOVALIDATE'", "'KW_NO_DROP'", 
    "'NULL'", "'NULLS'", "'OF'", "'KW_OFFLINE'", "'OFFSET'", "'ON'", "'ONLY'", 
    "'OPERATOR'", "'OPTION'", "'OR'", "'ORDER'", "'OUT'", "'OUTER'", "'OUTPUTDRIVER'", 
    "'OUTPUTFORMAT'", "'OVER'", "'OVERWRITE'", "'OWNER'", "'PARTITION'", 
    "'PARTITIONED'", "'PARTITIONS'", "'PATH'", "'PERCENT'", "'PKFK_JOIN'", 
    "'PLAN'", "'PLANS'", "'PLUS'", "'POOL'", "'PRECEDING'", "'PRECISION'", 
    "'PREPARE'", "'PRESERVE'", "'PRIMARY'", "'PRINCIPALS'", "'PROCEDURE'", 
    "'KW_PROTECTION'", "'PURGE'", "'QUALIFY'", "'QUARTER'", "'QUERY'", "'QUERY_PARALLELISM'", 
    "'RANGE'", "'READ'", "'KW_READONLY'", "'READS'", "'REAL'", "'REBUILD'", 
    "'RECORDREADER'", "'RECORDWRITER'", "'REDUCE'", "'REFERENCES'", "'REGEXP'", 
    "'RELOAD'", "'RELY'", "'REMOTE'", "'RENAME'", "'REOPTIMIZATION'", "'REPAIR'", 
    "'REPL'", "'REPLACE'", "'REPLICATION'", "'RESOURCE'", "'RESPECT'", "'RESTRICT'", 
    "'REVOKE'", "'REWRITE'", "'RIGHT'", "'RLIKE'", "'ROLE'", "'ROLES'", 
    "'ROLLBACK'", "'ROLLUP'", "'ROW'", "'ROWS'", "'SCHEDULED'", "'SCHEDULING_POLICY'", 
    "'SCHEMA'", "'SCHEMAS'", "", "'SELECT'", "'SEMI'", "'SERDE'", "'SERDEPROPERTIES'", 
    "'SERVER'", "'SET'", "'SETS'", "'SET_CURRENT_SNAPSHOT'", "'SHARED'", 
    "'SHOW'", "'SHOW_DATABASE'", "'SKEWED'", "'SMALLINT'", "'SNAPSHOT'", 
    "'SOME'", "'SORT'", "'SORTED'", "'SPEC'", "'SSL'", "'START'", "'STATISTICS'", 
    "'STATUS'", "'STORED'", "'STREAMTABLE'", "'STRING'", "'STRUCT'", "'SUMMARY'", 
    "'SYNC'", "'SYSTEM_TIME'", "'SYSTEM_VERSION'", "'TABLE'", "'TABLES'", 
    "'TABLESAMPLE'", "'TBLPROPERTIES'", "'TEMPORARY'", "'TERMINATED'", "'THEN'", 
    "'TIME'", "'TIMESTAMP'", "'TIMESTAMPLOCALTZ'", "'KW_TIMESTAMPTZ'", "'TINYINT'", 
    "'TO'", "'TOUCH'", "'TRAILING'", "'TRANSACTION'", "'TRANSACTIONAL'", 
    "'TRANSACTIONS'", "'TRANSFORM'", "'TRIGGER'", "'TRIM'", "'TRUE'", "'TRUNCATE'", 
    "'TYPE'", "'UNARCHIVE'", "'UNBOUNDED'", "'UNDO'", "'UNION'", "'UNIONTYPE'", 
    "'UNIQUE'", "'UNIQUEJOIN'", "'UNKNOWN'", "'UNLOCK'", "'UNMANAGED'", 
    "'UNSET'", "'UNSIGNED'", "'UPDATE'", "'URI'", "'URL'", "'USE'", "'USER'", 
    "'USING'", "'UTC'", "'UTC_TMESTAMP'", "'VALIDATE'", "'VALUES'", "'$VALUE$'", 
    "'VARCHAR'", "'VECTORIZATION'", "'VIEW'", "'VIEWS'", "'WAIT'", "", "'WHEN'", 
    "'WHERE'", "'WHILE'", "'WINDOW'", "'WITH'", "'WITHIN'", "'WORK'", "'WORKLOAD'", 
    "'WRITE'", "", "'ZONE'", "'.'", "':'", "','", "';'", "'('", "')'", "'['", 
    "']'", "'{'", "'}'", "", "'<=>'", "", "'<='", "'<'", "'>='", "'>'", 
    "'/'", "'+'", "'-'", "'*'", "'%'", "'DIV'", "'&'", "'~'", "'|'", "'||'", 
    "'^'", "'?'", "'$'",
  }
  staticData.SymbolicNames = []string{
    "", "KW_ABORT", "KW_ACTIVATE", "KW_ACTIVE", "KW_ADD", "KW_ADMIN", "KW_AFTER", 
    "KW_ALL", "KW_ALLOC_FRACTION", "KW_ALTER", "KW_ANALYZE", "KW_AND", "KW_ANTI", 
    "KW_ANY", "KW_APPLICATION", "KW_ARCHIVE", "KW_ARRAY", "KW_AS", "KW_ASC", 
    "KW_AST", "KW_AT", "KW_AUTHORIZATION", "KW_AUTOCOMMIT", "KW_BATCH", 
    "KW_BEFORE", "KW_BETWEEN", "KW_BIGINT", "KW_BINARY", "KW_BOOLEAN", "KW_BOTH", 
    "KW_BUCKET", "KW_BUCKETS", "KW_BY", "KW_CACHE", "KW_CASCADE", "KW_CASE", 
    "KW_CAST", "KW_CBO", "KW_CHANGE", "KW_CHAR", "KW_CHECK", "KW_CLUSTER", 
    "KW_CLUSTERED", "KW_CLUSTERSTATUS", "KW_COLLECTION", "KW_COLUMN", "KW_COLUMNS", 
    "KW_COMMENT", "KW_COMMIT", "KW_COMPACT", "KW_COMPACTIONS", "KW_COMPACT_ID", 
    "KW_COMPUTE", "KW_CONCATENATE", "KW_CONF", "KW_CONSTRAINT", "KW_CONTINUE", 
    "KW_COST", "KW_CREATE", "KW_CRON", "KW_CROSS", "KW_CUBE", "KW_CURRENT", 
    "KW_CURRENT_DATE", "KW_CURRENT_TIMESTAMP", "KW_CURSOR", "KW_DATA", "KW_DATABASE", 
    "KW_DATABASES", "KW_DATACONNECTOR", "KW_DATACONNECTORS", "KW_DATE", 
    "KW_DATETIME", "KW_DAY", "KW_DAYOFWEEK", "KW_DBPROPERTIES", "KW_DCPROPERTIES", 
    "KW_DDL", "KW_DEBUG", "KW_DECIMAL", "KW_DEFAULT", "KW_DEFERRED", "KW_DEFINED", 
    "KW_DELETE", "KW_DELIMITED", "KW_DEPENDENCY", "KW_DESC", "KW_DESCRIBE", 
    "KW_DETAIL", "KW_DIRECTORIES", "KW_DIRECTORY", "KW_DISABLE", "KW_DISTINCT", 
    "KW_DISTRIBUTE", "KW_DISTRIBUTED", "KW_DO", "KW_DOUBLE", "KW_DOW", "KW_DROP", 
    "KW_DUMP", "KW_ELEM_TYPE", "KW_ELSE", "KW_ENABLE", "KW_END", "KW_ENFORCED", 
    "KW_ESCAPED", "KW_EVERY", "KW_EXCEPT", "KW_EXCHANGE", "KW_EXCLUSIVE", 
    "KW_EXECUTE", "KW_EXECUTED", "KW_EXISTS", "KW_EXPIRE_SNAPSHOTS", "KW_EXPLAIN", 
    "KW_EXPORT", "KW_EXPRESSION", "KW_EXTENDED", "KW_EXTERNAL", "KW_EXTRACT", 
    "KW_FALSE", "KW_FETCH", "KW_FIELDS", "KW_FILE", "KW_FILEFORMAT", "KW_FIRST", 
    "KW_FLOAT", "KW_FLOOR", "KW_FOLLOWING", "KW_FOR", "KW_FORCE", "KW_FOREIGN", 
    "KW_FORMAT", "KW_FORMATTED", "KW_FROM", "KW_FULL", "KW_FUNCTION", "KW_FUNCTIONS", 
    "KW_GRANT", "KW_GROUP", "KW_GROUPING", "KW_HAVING", "KW_HOLD_DDLTIME", 
    "KW_HOUR", "KW_IDXPROPERTIES", "KW_IF", "KW_IGNORE", "KW_IMPORT", "KW_IN", 
    "KW_INDEX", "KW_INDEXES", "KW_INNER", "KW_INPATH", "KW_INPUTDRIVER", 
    "KW_INPUTFORMAT", "KW_INSERT", "KW_INT", "KW_INTERSECT", "KW_INTERVAL", 
    "KW_INTO", "KW_IS", "KW_ISOLATION", "KW_ITEMS", "KW_JAR", "KW_JOIN", 
    "KW_JOINCOST", "KW_KEY", "KW_KEYS", "KW_KEY_TYPE", "KW_KILL", "KW_LAST", 
    "KW_LATERAL", "KW_LEADING", "KW_LEFT", "KW_LESS", "KW_LEVEL", "KW_LIKE", 
    "KW_LIMIT", "KW_LINES", "KW_LOAD", "KW_LOCAL", "KW_LOCATION", "KW_LOCK", 
    "KW_LOCKS", "KW_LOGICAL", "KW_LONG", "KW_MACRO", "KW_MANAGED", "KW_MANAGEDLOCATION", 
    "KW_MANAGEMENT", "KW_MAP", "KW_MAPJOIN", "KW_MAPPING", "KW_MATCHED", 
    "KW_MATERIALIZED", "KW_MERGE", "KW_METADATA", "KW_MINUS", "KW_MINUTE", 
    "KW_MONTH", "KW_MORE", "KW_MOVE", "KW_MSCK", "KW_NONE", "KW_NORELY", 
    "KW_NOSCAN", "KW_NOT", "KW_NOVALIDATE", "KW_NO_DROP", "KW_NULL", "KW_NULLS", 
    "KW_OF", "KW_OFFLINE", "KW_OFFSET", "KW_ON", "KW_ONLY", "KW_OPERATOR", 
    "KW_OPTION", "KW_OR", "KW_ORDER", "KW_OUT", "KW_OUTER", "KW_OUTPUTDRIVER", 
    "KW_OUTPUTFORMAT", "KW_OVER", "KW_OVERWRITE", "KW_OWNER", "KW_PARTITION", 
    "KW_PARTITIONED", "KW_PARTITIONS", "KW_PATH", "KW_PERCENT", "KW_PKFK_JOIN", 
    "KW_PLAN", "KW_PLANS", "KW_PLUS", "KW_POOL", "KW_PRECEDING", "KW_PRECISION", 
    "KW_PREPARE", "KW_PRESERVE", "KW_PRIMARY", "KW_PRINCIPALS", "KW_PROCEDURE", 
    "KW_PROTECTION", "KW_PURGE", "KW_QUALIFY", "KW_QUARTER", "KW_QUERY", 
    "KW_QUERY_PARALLELISM", "KW_RANGE", "KW_READ", "KW_READONLY", "KW_READS", 
    "KW_REAL", "KW_REBUILD", "KW_RECORDREADER", "KW_RECORDWRITER", "KW_REDUCE", 
    "KW_REFERENCES", "KW_REGEXP", "KW_RELOAD", "KW_RELY", "KW_REMOTE", "KW_RENAME", 
    "KW_REOPTIMIZATION", "KW_REPAIR", "KW_REPL", "KW_REPLACE", "KW_REPLICATION", 
    "KW_RESOURCE", "KW_RESPECT", "KW_RESTRICT", "KW_REVOKE", "KW_REWRITE", 
    "KW_RIGHT", "KW_RLIKE", "KW_ROLE", "KW_ROLES", "KW_ROLLBACK", "KW_ROLLUP", 
    "KW_ROW", "KW_ROWS", "KW_SCHEDULED", "KW_SCHEDULING_POLICY", "KW_SCHEMA", 
    "KW_SCHEMAS", "KW_SECOND", "KW_SELECT", "KW_SEMI", "KW_SERDE", "KW_SERDEPROPERTIES", 
    "KW_SERVER", "KW_SET", "KW_SETS", "KW_SET_CURRENT_SNAPSHOT", "KW_SHARED", 
    "KW_SHOW", "KW_SHOW_DATABASE", "KW_SKEWED", "KW_SMALLINT", "KW_SNAPSHOT", 
    "KW_SOME", "KW_SORT", "KW_SORTED", "KW_SPEC", "KW_SSL", "KW_START", 
    "KW_STATISTICS", "KW_STATUS", "KW_STORED", "KW_STREAMTABLE", "KW_STRING", 
    "KW_STRUCT", "KW_SUMMARY", "KW_SYNC", "KW_SYSTEM_TIME", "KW_SYSTEM_VERSION", 
    "KW_TABLE", "KW_TABLES", "KW_TABLESAMPLE", "KW_TBLPROPERTIES", "KW_TEMPORARY", 
    "KW_TERMINATED", "KW_THEN", "KW_TIME", "KW_TIMESTAMP", "KW_TIMESTAMPLOCALTZ", 
    "KW_TIMESTAMPTZ", "KW_TINYINT", "KW_TO", "KW_TOUCH", "KW_TRAILING", 
    "KW_TRANSACTION", "KW_TRANSACTIONAL", "KW_TRANSACTIONS", "KW_TRANSFORM", 
    "KW_TRIGGER", "KW_TRIM", "KW_TRUE", "KW_TRUNCATE", "KW_TYPE", "KW_UNARCHIVE", 
    "KW_UNBOUNDED", "KW_UNDO", "KW_UNION", "KW_UNIONTYPE", "KW_UNIQUE", 
    "KW_UNIQUEJOIN", "KW_UNKNOWN", "KW_UNLOCK", "KW_UNMANAGED", "KW_UNSET", 
    "KW_UNSIGNED", "KW_UPDATE", "KW_URI", "KW_URL", "KW_USE", "KW_USER", 
    "KW_USING", "KW_UTC", "KW_UTCTIMESTAMP", "KW_VALIDATE", "KW_VALUES", 
    "KW_VALUE_TYPE", "KW_VARCHAR", "KW_VECTORIZATION", "KW_VIEW", "KW_VIEWS", 
    "KW_WAIT", "KW_WEEK", "KW_WHEN", "KW_WHERE", "KW_WHILE", "KW_WINDOW", 
    "KW_WITH", "KW_WITHIN", "KW_WORK", "KW_WORKLOAD", "KW_WRITE", "KW_YEAR", 
    "KW_ZONE", "DOT", "COLON", "COMMA", "SEMICOLON", "LPAREN", "RPAREN", 
    "LSQUARE", "RSQUARE", "LCURLY", "RCURLY", "EQUAL", "EQUAL_NS", "NOTEQUAL", 
    "LESSTHANOREQUALTO", "LESSTHAN", "GREATERTHANOREQUALTO", "GREATERTHAN", 
    "DIVIDE", "PLUS", "MINUS", "STAR", "MOD", "DIV", "AMPERSAND", "TILDE", 
    "BITWISEOR", "CONCATENATE", "BITWISEXOR", "QUESTION", "DOLLAR", "StringLiteral", 
    "CharSetLiteral", "IntegralLiteral", "NumberLiteral", "ByteLengthLiteral", 
    "Number", "Identifier", "CharSetName", "WHITE_SPACE", "LINE_COMMENT", 
    "QUERY_HINT", "SHOW_HINT", "HIDDEN_HINT",
  }
  staticData.RuleNames = []string{
    "statement", "explainStatement", "explainOption", "vectorizationOnly", 
    "vectorizatonDetail", "execStatement", "loadStatement", "replicationClause", 
    "exportStatement", "importStatement", "replDumpStatement", "replDbPolicy", 
    "replLoadStatement", "replConfigs", "replConfigsList", "replTableLevelPolicy", 
    "replStatusStatement", "ddlStatement", "ifExists", "restrictOrCascade", 
    "ifNotExists", "force", "rewriteEnabled", "rewriteDisabled", "storedAsDirs", 
    "orReplace", "createDatabaseStatement", "dbLocation", "dbManagedLocation", 
    "dbProperties", "dbPropertiesList", "dbConnectorName", "switchDatabaseStatement", 
    "dropDatabaseStatement", "databaseComment", "truncateTableStatement", 
    "dropTableStatement", "inputFileFormat", "tabTypeExpr", "partTypeExpr", 
    "tabPartColTypeExpr", "descStatement", "analyzeStatement", "from_in", 
    "db_schema", "showStatement", "showTablesFilterExpr", "lockStatement", 
    "lockDatabase", "lockMode", "unlockStatement", "unlockDatabase", "createRoleStatement", 
    "dropRoleStatement", "grantPrivileges", "revokePrivileges", "grantRole", 
    "revokeRole", "showRoleGrants", "showRoles", "showCurrentRole", "setRole", 
    "showGrants", "showRolePrincipals", "privilegeIncludeColObject", "privilegeObject", 
    "privObject", "privObjectCols", "privilegeList", "privlegeDef", "privilegeType", 
    "principalSpecification", "principalName", "withGrantOption", "grantOptionFor", 
    "adminOptionFor", "withAdminOption", "metastoreCheck", "resourceList", 
    "resource", "resourceType", "createFunctionStatement", "dropFunctionStatement", 
    "reloadFunctionsStatement", "createMacroStatement", "dropMacroStatement", 
    "createViewStatement", "viewPartition", "viewOrganization", "viewClusterSpec", 
    "viewComplexSpec", "viewDistSpec", "viewSortSpec", "dropViewStatement", 
    "createMaterializedViewStatement", "dropMaterializedViewStatement", 
    "createScheduledQueryStatement", "dropScheduledQueryStatement", "alterScheduledQueryStatement", 
    "alterScheduledQueryChange", "scheduleSpec", "executedAsSpec", "definedAsSpec", 
    "showFunctionIdentifier", "showStmtIdentifier", "tableComment", "createTablePartitionSpec", 
    "createTablePartitionColumnTypeSpec", "createTablePartitionColumnSpec", 
    "partitionTransformSpec", "columnNameTransformConstraint", "partitionTransformType", 
    "tableBuckets", "tableImplBuckets", "tableSkewed", "rowFormat", "recordReader", 
    "recordWriter", "rowFormatSerde", "rowFormatDelimited", "tableRowFormat", 
    "tablePropertiesPrefixed", "tableProperties", "tablePropertiesList", 
    "keyValueProperty", "keyProperty", "tableRowFormatFieldIdentifier", 
    "tableRowFormatCollItemsIdentifier", "tableRowFormatMapKeysIdentifier", 
    "tableRowFormatLinesIdentifier", "tableRowNullFormat", "tableFileFormat", 
    "tableLocation", "columnNameTypeList", "columnNameTypeOrConstraintList", 
    "columnNameColonTypeList", "columnNameList", "columnName", "extColumnName", 
    "columnNameOrderList", "columnParenthesesList", "enableValidateSpecification", 
    "enableSpecification", "validateSpecification", "enforcedSpecification", 
    "relySpecification", "createConstraint", "alterConstraintWithName", 
    "tableLevelConstraint", "pkUkConstraint", "checkConstraint", "createForeignKey", 
    "alterForeignKeyWithName", "skewedValueElement", "skewedColumnValuePairList", 
    "skewedColumnValuePair", "skewedColumnValues", "skewedColumnValue", 
    "skewedValueLocationElement", "orderSpecification", "nullOrdering", 
    "columnNameOrder", "columnNameCommentList", "columnNameComment", "orderSpecificationRewrite", 
    "columnRefOrder", "columnNameType", "columnNameTypeOrConstraint", "tableConstraint", 
    "columnNameTypeConstraint", "columnConstraint", "foreignKeyConstraint", 
    "colConstraint", "alterColumnConstraint", "alterForeignKeyConstraint", 
    "alterColConstraint", "columnConstraintType", "defaultVal", "tableConstraintType", 
    "constraintOptsCreate", "constraintOptsAlter", "columnNameColonType", 
    "colType", "colTypeList", "type", "primitiveType", "listType", "structType", 
    "mapType", "unionType", "setOperator", "queryStatementExpression", "queryStatementExpressionBody", 
    "withClause", "cteStatement", "fromStatement", "singleFromStatement", 
    "regularBody", "atomSelectStatement", "selectStatement", "setOpSelectStatement", 
    "selectStatementWithCTE", "body", "insertClause", "destination", "limitClause", 
    "deleteStatement", "columnAssignmentClause", "precedencePlusExpressionOrDefault", 
    "setColumnsClause", "updateStatement", "sqlTransactionStatement", "startTransactionStatement", 
    "transactionMode", "transactionAccessMode", "isolationLevel", "levelOfIsolation", 
    "commitStatement", "rollbackStatement", "setAutoCommitStatement", "abortTransactionStatement", 
    "abortCompactionStatement", "mergeStatement", "whenClauses", "whenNotMatchedClause", 
    "whenMatchedAndClause", "whenMatchedThenClause", "updateOrDelete", "killQueryStatement", 
    "compactionId", "compactionPool", "compactionType", "compactionStatus", 
    "alterStatement", "alterTableStatementSuffix", "alterTblPartitionStatementSuffix", 
    "alterStatementPartitionKeyType", "alterViewStatementSuffix", "alterMaterializedViewStatementSuffix", 
    "alterMaterializedViewSuffixRewrite", "alterMaterializedViewSuffixRebuild", 
    "alterDatabaseStatementSuffix", "alterDatabaseSuffixProperties", "alterDatabaseSuffixSetOwner", 
    "alterDatabaseSuffixSetLocation", "alterDatabaseSuffixSetManagedLocation", 
    "alterStatementSuffixRename", "alterStatementSuffixAddCol", "alterStatementSuffixAddConstraint", 
    "alterStatementSuffixUpdateColumns", "alterStatementSuffixDropConstraint", 
    "alterStatementSuffixRenameCol", "alterStatementSuffixUpdateStatsCol", 
    "alterStatementSuffixUpdateStats", "alterStatementChangeColPosition", 
    "alterStatementSuffixAddPartitions", "alterStatementSuffixAddPartitionsElement", 
    "alterStatementSuffixTouch", "alterStatementSuffixArchive", "alterStatementSuffixUnArchive", 
    "partitionLocation", "alterStatementSuffixDropPartitions", "alterStatementSuffixProperties", 
    "alterViewSuffixProperties", "alterStatementSuffixSerdeProperties", 
    "tablePartitionPrefix", "alterStatementSuffixFileFormat", "alterStatementSuffixClusterbySortby", 
    "alterTblPartitionStatementSuffixSkewedLocation", "skewedLocations", 
    "skewedLocationsList", "skewedLocationMap", "alterStatementSuffixLocation", 
    "alterStatementSuffixSkewedby", "alterStatementSuffixExchangePartition", 
    "alterStatementSuffixRenamePart", "alterStatementSuffixStatsPart", "alterStatementSuffixMergeFiles", 
    "alterStatementSuffixBucketNum", "blocking", "compactPool", "alterStatementSuffixCompact", 
    "alterStatementSuffixSetOwner", "alterStatementSuffixSetPartSpec", "alterStatementSuffixExecute", 
    "fileFormat", "alterDataConnectorStatementSuffix", "alterDataConnectorSuffixProperties", 
    "alterDataConnectorSuffixSetOwner", "alterDataConnectorSuffixSetUrl", 
    "likeTableOrFile", "createTableStatement", "createDataConnectorStatement", 
    "dataConnectorComment", "dataConnectorUrl", "dataConnectorType", "dcProperties", 
    "dropDataConnectorStatement", "tableAllColumns", "tableOrColumn", "defaultValue", 
    "expressionList", "aliasList", "fromClause", "fromSource", "atomjoinSource", 
    "joinSource", "joinSourcePart", "uniqueJoinSource", "uniqueJoinExpr", 
    "uniqueJoinToken", "joinToken", "lateralView", "tableAlias", "tableBucketSample", 
    "splitSample", "tableSample", "tableSource", "asOfClause", "uniqueJoinTableSource", 
    "tableName", "viewName", "subQuerySource", "partitioningSpec", "partitionTableFunctionSource", 
    "partitionedTableFunction", "whereClause", "searchCondition", "valuesSource", 
    "valuesClause", "valuesTableConstructor", "valueRowConstructor", "firstValueRowConstructor", 
    "virtualTableSource", "selectClause", "all_distinct", "selectList", 
    "selectTrfmClause", "selectItem", "trfmClause", "selectExpression", 
    "selectExpressionList", "window_clause", "window_defn", "window_specification", 
    "window_frame", "window_range_expression", "window_value_expression", 
    "window_frame_start_boundary", "window_frame_boundary", "groupByClause", 
    "groupby_expression", "groupByEmpty", "rollupStandard", "rollupOldSyntax", 
    "groupingSetExpression", "groupingSetExpressionMultiple", "groupingExpressionSingle", 
    "havingClause", "qualifyClause", "havingCondition", "expressionsInParenthesis", 
    "expressionsNotInParenthesis", "expressionPart", "expressionOrDefault", 
    "firstExpressionsWithAlias", "expressionWithAlias", "expressions", "columnRefOrderInParenthesis", 
    "columnRefOrderNotInParenthesis", "orderByClause", "clusterByClause", 
    "partitionByClause", "distributeByClause", "sortByClause", "trimFunction", 
    "function_", "null_treatment", "functionName", "castExpression", "caseExpression", 
    "whenExpression", "floorExpression", "floorDateQualifiers", "extractExpression", 
    "timeQualifiers", "constant", "prepareStmtParam", "parameterIdx", "stringLiteralSequence", 
    "charSetStringLiteral", "dateLiteral", "timestampLiteral", "timestampLocalTZLiteral", 
    "intervalValue", "intervalLiteral", "intervalExpression", "intervalQualifiers", 
    "expression", "atomExpression", "precedenceFieldExpression", "precedenceUnaryOperator", 
    "precedenceUnaryPrefixExpression", "precedenceBitwiseXorOperator", "precedenceBitwiseXorExpression", 
    "precedenceStarOperator", "precedenceStarExpression", "precedencePlusOperator", 
    "precedencePlusExpression", "precedenceConcatenateOperator", "precedenceConcatenateExpression", 
    "precedenceAmpersandOperator", "precedenceAmpersandExpression", "precedenceBitwiseOrOperator", 
    "precedenceBitwiseOrExpression", "precedenceRegexpOperator", "precedenceSimilarOperator", 
    "subQueryExpression", "precedenceSimilarExpression", "precedenceSimilarExpressionMain", 
    "precedenceSimilarExpressionPart", "precedenceSimilarExpressionAtom", 
    "precedenceSimilarExpressionQuantifierPredicate", "quantifierType", 
    "precedenceSimilarExpressionIn", "precedenceSimilarExpressionPartNot", 
    "precedenceDistinctOperator", "precedenceEqualOperator", "precedenceEqualExpression", 
    "isCondition", "precedenceUnarySuffixExpression", "precedenceNotOperator", 
    "precedenceNotExpression", "precedenceAndOperator", "precedenceAndExpression", 
    "precedenceOrOperator", "precedenceOrExpression", "booleanValue", "booleanValueTok", 
    "tableOrPartition", "partitionSpec", "partitionVal", "partitionSelectorSpec", 
    "partitionSelectorVal", "partitionSelectorOperator", "subQuerySelectorOperator", 
    "sysFuncNames", "descFuncNames", "id_", "functionIdentifier", "principalIdentifier", 
    "nonReserved", "sql11ReservedKeywordsUsedAsFunctionName", "hint", "hintList", 
    "hintItem", "hintName", "hintArgs", "hintArgName", "prepareStatement", 
    "executeStatement", "executeParamList", "resourcePlanDdlStatements", 
    "rpAssign", "rpAssignList", "rpUnassign", "rpUnassignList", "createResourcePlanStatement", 
    "withReplace", "activate", "enable", "disable", "unmanaged", "alterResourcePlanStatement", 
    "globalWmStatement", "replaceResourcePlanStatement", "dropResourcePlanStatement", 
    "poolPath", "triggerExpression", "triggerExpressionStandalone", "triggerOrExpression", 
    "triggerAndExpression", "triggerAtomExpression", "triggerLiteral", "comparisionOperator", 
    "triggerActionExpression", "triggerActionExpressionStandalone", "createTriggerStatement", 
    "alterTriggerStatement", "dropTriggerStatement", "poolAssign", "poolAssignList", 
    "createPoolStatement", "alterPoolStatement", "dropPoolStatement", "createMappingStatement", 
    "alterMappingStatement", "dropMappingStatement",
  }
  staticData.PredictionContextCache = antlr.NewPredictionContextCache()
  staticData.serializedATN = []int32{
	4, 1, 424, 5262, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4, 
	7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10, 
	7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7, 
	15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20, 
	2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2, 
	26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31, 
	7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7, 
	36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41, 
	2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2, 
	47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52, 
	7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7, 
	57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62, 
	2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2, 
	68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73, 
	7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7, 
	78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83, 
	2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2, 
	89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94, 
	7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7, 
	99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2, 
	104, 7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 2, 107, 7, 107, 2, 108, 7, 
	108, 2, 109, 7, 109, 2, 110, 7, 110, 2, 111, 7, 111, 2, 112, 7, 112, 2, 
	113, 7, 113, 2, 114, 7, 114, 2, 115, 7, 115, 2, 116, 7, 116, 2, 117, 7, 
	117, 2, 118, 7, 118, 2, 119, 7, 119, 2, 120, 7, 120, 2, 121, 7, 121, 2, 
	122, 7, 122, 2, 123, 7, 123, 2, 124, 7, 124, 2, 125, 7, 125, 2, 126, 7, 
	126, 2, 127, 7, 127, 2, 128, 7, 128, 2, 129, 7, 129, 2, 130, 7, 130, 2, 
	131, 7, 131, 2, 132, 7, 132, 2, 133, 7, 133, 2, 134, 7, 134, 2, 135, 7, 
	135, 2, 136, 7, 136, 2, 137, 7, 137, 2, 138, 7, 138, 2, 139, 7, 139, 2, 
	140, 7, 140, 2, 141, 7, 141, 2, 142, 7, 142, 2, 143, 7, 143, 2, 144, 7, 
	144, 2, 145, 7, 145, 2, 146, 7, 146, 2, 147, 7, 147, 2, 148, 7, 148, 2, 
	149, 7, 149, 2, 150, 7, 150, 2, 151, 7, 151, 2, 152, 7, 152, 2, 153, 7, 
	153, 2, 154, 7, 154, 2, 155, 7, 155, 2, 156, 7, 156, 2, 157, 7, 157, 2, 
	158, 7, 158, 2, 159, 7, 159, 2, 160, 7, 160, 2, 161, 7, 161, 2, 162, 7, 
	162, 2, 163, 7, 163, 2, 164, 7, 164, 2, 165, 7, 165, 2, 166, 7, 166, 2, 
	167, 7, 167, 2, 168, 7, 168, 2, 169, 7, 169, 2, 170, 7, 170, 2, 171, 7, 
	171, 2, 172, 7, 172, 2, 173, 7, 173, 2, 174, 7, 174, 2, 175, 7, 175, 2, 
	176, 7, 176, 2, 177, 7, 177, 2, 178, 7, 178, 2, 179, 7, 179, 2, 180, 7, 
	180, 2, 181, 7, 181, 2, 182, 7, 182, 2, 183, 7, 183, 2, 184, 7, 184, 2, 
	185, 7, 185, 2, 186, 7, 186, 2, 187, 7, 187, 2, 188, 7, 188, 2, 189, 7, 
	189, 2, 190, 7, 190, 2, 191, 7, 191, 2, 192, 7, 192, 2, 193, 7, 193, 2, 
	194, 7, 194, 2, 195, 7, 195, 2, 196, 7, 196, 2, 197, 7, 197, 2, 198, 7, 
	198, 2, 199, 7, 199, 2, 200, 7, 200, 2, 201, 7, 201, 2, 202, 7, 202, 2, 
	203, 7, 203, 2, 204, 7, 204, 2, 205, 7, 205, 2, 206, 7, 206, 2, 207, 7, 
	207, 2, 208, 7, 208, 2, 209, 7, 209, 2, 210, 7, 210, 2, 211, 7, 211, 2, 
	212, 7, 212, 2, 213, 7, 213, 2, 214, 7, 214, 2, 215, 7, 215, 2, 216, 7, 
	216, 2, 217, 7, 217, 2, 218, 7, 218, 2, 219, 7, 219, 2, 220, 7, 220, 2, 
	221, 7, 221, 2, 222, 7, 222, 2, 223, 7, 223, 2, 224, 7, 224, 2, 225, 7, 
	225, 2, 226, 7, 226, 2, 227, 7, 227, 2, 228, 7, 228, 2, 229, 7, 229, 2, 
	230, 7, 230, 2, 231, 7, 231, 2, 232, 7, 232, 2, 233, 7, 233, 2, 234, 7, 
	234, 2, 235, 7, 235, 2, 236, 7, 236, 2, 237, 7, 237, 2, 238, 7, 238, 2, 
	239, 7, 239, 2, 240, 7, 240, 2, 241, 7, 241, 2, 242, 7, 242, 2, 243, 7, 
	243, 2, 244, 7, 244, 2, 245, 7, 245, 2, 246, 7, 246, 2, 247, 7, 247, 2, 
	248, 7, 248, 2, 249, 7, 249, 2, 250, 7, 250, 2, 251, 7, 251, 2, 252, 7, 
	252, 2, 253, 7, 253, 2, 254, 7, 254, 2, 255, 7, 255, 2, 256, 7, 256, 2, 
	257, 7, 257, 2, 258, 7, 258, 2, 259, 7, 259, 2, 260, 7, 260, 2, 261, 7, 
	261, 2, 262, 7, 262, 2, 263, 7, 263, 2, 264, 7, 264, 2, 265, 7, 265, 2, 
	266, 7, 266, 2, 267, 7, 267, 2, 268, 7, 268, 2, 269, 7, 269, 2, 270, 7, 
	270, 2, 271, 7, 271, 2, 272, 7, 272, 2, 273, 7, 273, 2, 274, 7, 274, 2, 
	275, 7, 275, 2, 276, 7, 276, 2, 277, 7, 277, 2, 278, 7, 278, 2, 279, 7, 
	279, 2, 280, 7, 280, 2, 281, 7, 281, 2, 282, 7, 282, 2, 283, 7, 283, 2, 
	284, 7, 284, 2, 285, 7, 285, 2, 286, 7, 286, 2, 287, 7, 287, 2, 288, 7, 
	288, 2, 289, 7, 289, 2, 290, 7, 290, 2, 291, 7, 291, 2, 292, 7, 292, 2, 
	293, 7, 293, 2, 294, 7, 294, 2, 295, 7, 295, 2, 296, 7, 296, 2, 297, 7, 
	297, 2, 298, 7, 298, 2, 299, 7, 299, 2, 300, 7, 300, 2, 301, 7, 301, 2, 
	302, 7, 302, 2, 303, 7, 303, 2, 304, 7, 304, 2, 305, 7, 305, 2, 306, 7, 
	306, 2, 307, 7, 307, 2, 308, 7, 308, 2, 309, 7, 309, 2, 310, 7, 310, 2, 
	311, 7, 311, 2, 312, 7, 312, 2, 313, 7, 313, 2, 314, 7, 314, 2, 315, 7, 
	315, 2, 316, 7, 316, 2, 317, 7, 317, 2, 318, 7, 318, 2, 319, 7, 319, 2, 
	320, 7, 320, 2, 321, 7, 321, 2, 322, 7, 322, 2, 323, 7, 323, 2, 324, 7, 
	324, 2, 325, 7, 325, 2, 326, 7, 326, 2, 327, 7, 327, 2, 328, 7, 328, 2, 
	329, 7, 329, 2, 330, 7, 330, 2, 331, 7, 331, 2, 332, 7, 332, 2, 333, 7, 
	333, 2, 334, 7, 334, 2, 335, 7, 335, 2, 336, 7, 336, 2, 337, 7, 337, 2, 
	338, 7, 338, 2, 339, 7, 339, 2, 340, 7, 340, 2, 341, 7, 341, 2, 342, 7, 
	342, 2, 343, 7, 343, 2, 344, 7, 344, 2, 345, 7, 345, 2, 346, 7, 346, 2, 
	347, 7, 347, 2, 348, 7, 348, 2, 349, 7, 349, 2, 350, 7, 350, 2, 351, 7, 
	351, 2, 352, 7, 352, 2, 353, 7, 353, 2, 354, 7, 354, 2, 355, 7, 355, 2, 
	356, 7, 356, 2, 357, 7, 357, 2, 358, 7, 358, 2, 359, 7, 359, 2, 360, 7, 
	360, 2, 361, 7, 361, 2, 362, 7, 362, 2, 363, 7, 363, 2, 364, 7, 364, 2, 
	365, 7, 365, 2, 366, 7, 366, 2, 367, 7, 367, 2, 368, 7, 368, 2, 369, 7, 
	369, 2, 370, 7, 370, 2, 371, 7, 371, 2, 372, 7, 372, 2, 373, 7, 373, 2, 
	374, 7, 374, 2, 375, 7, 375, 2, 376, 7, 376, 2, 377, 7, 377, 2, 378, 7, 
	378, 2, 379, 7, 379, 2, 380, 7, 380, 2, 381, 7, 381, 2, 382, 7, 382, 2, 
	383, 7, 383, 2, 384, 7, 384, 2, 385, 7, 385, 2, 386, 7, 386, 2, 387, 7, 
	387, 2, 388, 7, 388, 2, 389, 7, 389, 2, 390, 7, 390, 2, 391, 7, 391, 2, 
	392, 7, 392, 2, 393, 7, 393, 2, 394, 7, 394, 2, 395, 7, 395, 2, 396, 7, 
	396, 2, 397, 7, 397, 2, 398, 7, 398, 2, 399, 7, 399, 2, 400, 7, 400, 2, 
	401, 7, 401, 2, 402, 7, 402, 2, 403, 7, 403, 2, 404, 7, 404, 2, 405, 7, 
	405, 2, 406, 7, 406, 2, 407, 7, 407, 2, 408, 7, 408, 2, 409, 7, 409, 2, 
	410, 7, 410, 2, 411, 7, 411, 2, 412, 7, 412, 2, 413, 7, 413, 2, 414, 7, 
	414, 2, 415, 7, 415, 2, 416, 7, 416, 2, 417, 7, 417, 2, 418, 7, 418, 2, 
	419, 7, 419, 2, 420, 7, 420, 2, 421, 7, 421, 2, 422, 7, 422, 2, 423, 7, 
	423, 2, 424, 7, 424, 2, 425, 7, 425, 2, 426, 7, 426, 2, 427, 7, 427, 2, 
	428, 7, 428, 2, 429, 7, 429, 2, 430, 7, 430, 2, 431, 7, 431, 2, 432, 7, 
	432, 2, 433, 7, 433, 2, 434, 7, 434, 2, 435, 7, 435, 2, 436, 7, 436, 2, 
	437, 7, 437, 2, 438, 7, 438, 2, 439, 7, 439, 2, 440, 7, 440, 2, 441, 7, 
	441, 2, 442, 7, 442, 2, 443, 7, 443, 2, 444, 7, 444, 2, 445, 7, 445, 2, 
	446, 7, 446, 2, 447, 7, 447, 2, 448, 7, 448, 2, 449, 7, 449, 2, 450, 7, 
	450, 2, 451, 7, 451, 2, 452, 7, 452, 2, 453, 7, 453, 2, 454, 7, 454, 2, 
	455, 7, 455, 2, 456, 7, 456, 2, 457, 7, 457, 2, 458, 7, 458, 2, 459, 7, 
	459, 2, 460, 7, 460, 2, 461, 7, 461, 2, 462, 7, 462, 2, 463, 7, 463, 2, 
	464, 7, 464, 2, 465, 7, 465, 2, 466, 7, 466, 2, 467, 7, 467, 2, 468, 7, 
	468, 2, 469, 7, 469, 2, 470, 7, 470, 2, 471, 7, 471, 2, 472, 7, 472, 2, 
	473, 7, 473, 2, 474, 7, 474, 2, 475, 7, 475, 2, 476, 7, 476, 2, 477, 7, 
	477, 2, 478, 7, 478, 2, 479, 7, 479, 2, 480, 7, 480, 2, 481, 7, 481, 2, 
	482, 7, 482, 2, 483, 7, 483, 2, 484, 7, 484, 2, 485, 7, 485, 2, 486, 7, 
	486, 2, 487, 7, 487, 2, 488, 7, 488, 2, 489, 7, 489, 2, 490, 7, 490, 2, 
	491, 7, 491, 2, 492, 7, 492, 2, 493, 7, 493, 2, 494, 7, 494, 2, 495, 7, 
	495, 2, 496, 7, 496, 2, 497, 7, 497, 1, 0, 1, 0, 3, 0, 999, 8, 0, 1, 0, 
	1, 0, 1, 1, 1, 1, 5, 1, 1005, 8, 1, 10, 1, 12, 1, 1008, 9, 1, 1, 1, 1, 
	1, 1, 1, 3, 1, 1013, 8, 1, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 3, 2, 1020, 8, 
	2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 3, 2, 1030, 8, 2, 1, 
	2, 3, 2, 1033, 8, 2, 1, 2, 1, 2, 3, 2, 1037, 8, 2, 1, 3, 1, 3, 1, 4, 1, 
	4, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 
	5, 1, 5, 1, 5, 3, 5, 1057, 8, 5, 1, 6, 1, 6, 1, 6, 3, 6, 1062, 8, 6, 1, 
	6, 1, 6, 1, 6, 3, 6, 1067, 8, 6, 1, 6, 1, 6, 1, 6, 1, 6, 3, 6, 1073, 8, 
	6, 1, 7, 1, 7, 3, 7, 1077, 8, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 8, 1, 
	8, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 1090, 8, 8, 1, 9, 1, 9, 3, 9, 1094, 8, 
	9, 1, 9, 1, 9, 3, 9, 1098, 8, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1103, 8, 9, 1, 
	10, 1, 10, 1, 10, 1, 10, 1, 10, 3, 10, 1110, 8, 10, 1, 10, 1, 10, 3, 10, 
	1114, 8, 10, 1, 11, 1, 11, 1, 11, 3, 11, 1119, 8, 11, 1, 12, 1, 12, 1, 
	12, 1, 12, 1, 12, 3, 12, 1126, 8, 12, 1, 12, 1, 12, 3, 12, 1130, 8, 12, 
	1, 13, 1, 13, 1, 13, 1, 13, 1, 14, 1, 14, 1, 14, 5, 14, 1139, 8, 14, 10, 
	14, 12, 14, 1142, 9, 14, 1, 15, 1, 15, 1, 15, 3, 15, 1147, 8, 15, 1, 16, 
	1, 16, 1, 16, 1, 16, 1, 16, 3, 16, 1154, 8, 16, 1, 17, 1, 17, 1, 17, 1, 
	17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 
	1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 
	17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 
	1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 3, 
	17, 1201, 8, 17, 1, 18, 1, 18, 1, 18, 1, 19, 1, 19, 1, 20, 1, 20, 1, 20, 
	1, 20, 1, 21, 1, 21, 1, 22, 1, 22, 1, 22, 1, 23, 1, 23, 1, 23, 1, 24, 1, 
	24, 1, 24, 1, 24, 1, 25, 1, 25, 1, 25, 1, 26, 1, 26, 1, 26, 3, 26, 1230, 
	8, 26, 1, 26, 1, 26, 3, 26, 1234, 8, 26, 1, 26, 3, 26, 1237, 8, 26, 1, 
	26, 3, 26, 1240, 8, 26, 1, 26, 1, 26, 1, 26, 3, 26, 1245, 8, 26, 1, 26, 
	1, 26, 1, 26, 1, 26, 3, 26, 1251, 8, 26, 1, 26, 1, 26, 3, 26, 1255, 8, 
	26, 1, 26, 1, 26, 1, 26, 1, 26, 3, 26, 1261, 8, 26, 3, 26, 1263, 8, 26, 
	1, 27, 1, 27, 1, 27, 1, 28, 1, 28, 1, 28, 1, 29, 1, 29, 1, 29, 1, 29, 1, 
	30, 1, 30, 1, 30, 5, 30, 1278, 8, 30, 10, 30, 12, 30, 1281, 9, 30, 1, 31, 
	1, 31, 1, 31, 1, 32, 1, 32, 1, 32, 1, 33, 1, 33, 1, 33, 3, 33, 1292, 8, 
	33, 1, 33, 1, 33, 3, 33, 1296, 8, 33, 1, 34, 1, 34, 1, 34, 1, 35, 1, 35, 
	3, 35, 1303, 8, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 3, 35, 1311, 
	8, 35, 1, 35, 3, 35, 1314, 8, 35, 1, 36, 1, 36, 1, 36, 3, 36, 1319, 8, 
	36, 1, 36, 1, 36, 3, 36, 1323, 8, 36, 1, 36, 3, 36, 1326, 8, 36, 1, 37, 
	1, 37, 1, 37, 1, 37, 1, 37, 1, 38, 1, 38, 1, 38, 3, 38, 1336, 8, 38, 1, 
	38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 3, 38, 1344, 8, 38, 5, 38, 1346, 
	8, 38, 10, 38, 12, 38, 1349, 9, 38, 3, 38, 1351, 8, 38, 1, 39, 1, 39, 3, 
	39, 1355, 8, 39, 1, 40, 1, 40, 3, 40, 1359, 8, 40, 1, 40, 3, 40, 1362, 
	8, 40, 1, 41, 1, 41, 1, 41, 3, 41, 1367, 8, 41, 1, 41, 1, 41, 1, 41, 1, 
	41, 3, 41, 1373, 8, 41, 1, 41, 1, 41, 1, 41, 3, 41, 1378, 8, 41, 1, 41, 
	1, 41, 1, 41, 3, 41, 1383, 8, 41, 1, 41, 1, 41, 3, 41, 1387, 8, 41, 1, 
	42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 3, 42, 1398, 
	8, 42, 3, 42, 1400, 8, 42, 1, 42, 1, 42, 3, 42, 1404, 8, 42, 1, 43, 1, 
	43, 1, 44, 1, 44, 1, 45, 1, 45, 1, 45, 1, 45, 3, 45, 1414, 8, 45, 1, 45, 
	1, 45, 3, 45, 1418, 8, 45, 1, 45, 1, 45, 1, 45, 1, 45, 3, 45, 1424, 8, 
	45, 1, 45, 3, 45, 1427, 8, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 3, 45, 
	1434, 8, 45, 1, 45, 1, 45, 1, 45, 3, 45, 1439, 8, 45, 1, 45, 1, 45, 1, 
	45, 1, 45, 1, 45, 1, 45, 3, 45, 1447, 8, 45, 1, 45, 1, 45, 1, 45, 3, 45, 
	1452, 8, 45, 1, 45, 1, 45, 3, 45, 1456, 8, 45, 1, 45, 1, 45, 1, 45, 1, 
	45, 1, 45, 1, 45, 3, 45, 1464, 8, 45, 1, 45, 1, 45, 1, 45, 3, 45, 1469, 
	8, 45, 1, 45, 1, 45, 1, 45, 1, 45, 3, 45, 1475, 8, 45, 1, 45, 1, 45, 1, 
	45, 1, 45, 3, 45, 1481, 8, 45, 1, 45, 3, 45, 1484, 8, 45, 1, 45, 3, 45, 
	1487, 8, 45, 1, 45, 3, 45, 1490, 8, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 
	45, 1, 45, 1, 45, 3, 45, 1499, 8, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 
	1, 45, 3, 45, 1507, 8, 45, 1, 45, 1, 45, 1, 45, 3, 45, 1512, 8, 45, 1, 
	45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 3, 45, 1520, 8, 45, 1, 45, 1, 45, 
	1, 45, 1, 45, 1, 45, 3, 45, 1527, 8, 45, 1, 45, 3, 45, 1530, 8, 45, 1, 
	45, 3, 45, 1533, 8, 45, 3, 45, 1535, 8, 45, 1, 45, 1, 45, 1, 45, 1, 45, 
	1, 45, 1, 45, 3, 45, 1543, 8, 45, 1, 45, 3, 45, 1546, 8, 45, 1, 45, 3, 
	45, 1549, 8, 45, 1, 45, 3, 45, 1552, 8, 45, 1, 45, 3, 45, 1555, 8, 45, 
	1, 45, 3, 45, 1558, 8, 45, 1, 45, 3, 45, 1561, 8, 45, 1, 45, 3, 45, 1564, 
	8, 45, 1, 45, 3, 45, 1567, 8, 45, 1, 45, 3, 45, 1570, 8, 45, 1, 45, 3, 
	45, 1573, 8, 45, 3, 45, 1575, 8, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 
	1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 3, 45, 1587, 8, 45, 1, 45, 1, 45, 3, 
	45, 1591, 8, 45, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 
	3, 46, 1601, 8, 46, 1, 47, 1, 47, 1, 47, 1, 47, 3, 47, 1607, 8, 47, 1, 
	47, 1, 47, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 49, 1, 49, 1, 50, 1, 50, 
	1, 50, 1, 50, 3, 50, 1622, 8, 50, 1, 51, 1, 51, 1, 51, 1, 51, 1, 52, 1, 
	52, 1, 52, 1, 52, 1, 53, 1, 53, 1, 53, 1, 53, 1, 54, 1, 54, 1, 54, 3, 54, 
	1639, 8, 54, 1, 54, 1, 54, 1, 54, 3, 54, 1644, 8, 54, 1, 55, 1, 55, 3, 
	55, 1648, 8, 55, 1, 55, 1, 55, 3, 55, 1652, 8, 55, 1, 55, 1, 55, 1, 55, 
	1, 56, 1, 56, 3, 56, 1659, 8, 56, 1, 56, 1, 56, 1, 56, 5, 56, 1664, 8, 
	56, 10, 56, 12, 56, 1667, 9, 56, 1, 56, 1, 56, 1, 56, 3, 56, 1672, 8, 56, 
	1, 57, 1, 57, 3, 57, 1676, 8, 57, 1, 57, 3, 57, 1679, 8, 57, 1, 57, 1, 
	57, 1, 57, 5, 57, 1684, 8, 57, 10, 57, 12, 57, 1687, 9, 57, 1, 57, 1, 57, 
	1, 57, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 59, 1, 59, 1, 59, 1, 60, 1, 
	60, 1, 60, 1, 60, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 3, 61, 1709, 8, 61, 
	1, 62, 1, 62, 1, 62, 3, 62, 1714, 8, 62, 1, 62, 1, 62, 3, 62, 1718, 8, 
	62, 1, 63, 1, 63, 1, 63, 1, 63, 1, 64, 1, 64, 3, 64, 1726, 8, 64, 1, 65, 
	1, 65, 1, 65, 1, 66, 1, 66, 1, 66, 1, 66, 3, 66, 1735, 8, 66, 1, 66, 1, 
	66, 3, 66, 1739, 8, 66, 1, 66, 1, 66, 1, 66, 1, 66, 3, 66, 1745, 8, 66, 
	1, 67, 1, 67, 1, 67, 1, 67, 3, 67, 1751, 8, 67, 1, 67, 1, 67, 1, 67, 1, 
	67, 1, 67, 3, 67, 1758, 8, 67, 1, 67, 3, 67, 1761, 8, 67, 1, 67, 1, 67, 
	1, 67, 1, 67, 3, 67, 1767, 8, 67, 1, 68, 1, 68, 1, 68, 5, 68, 1772, 8, 
	68, 10, 68, 12, 68, 1775, 9, 68, 1, 69, 1, 69, 1, 69, 1, 69, 1, 69, 3, 
	69, 1782, 8, 69, 1, 70, 1, 70, 1, 71, 1, 71, 1, 71, 5, 71, 1789, 8, 71, 
	10, 71, 12, 71, 1792, 9, 71, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 
	3, 72, 1800, 8, 72, 1, 73, 1, 73, 1, 73, 1, 73, 1, 74, 1, 74, 1, 74, 1, 
	74, 1, 75, 1, 75, 1, 75, 1, 75, 1, 76, 1, 76, 1, 76, 1, 76, 1, 77, 1, 77, 
	3, 77, 1820, 8, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 3, 77, 1827, 8, 
	77, 3, 77, 1829, 8, 77, 1, 78, 1, 78, 1, 78, 5, 78, 1834, 8, 78, 10, 78, 
	12, 78, 1837, 9, 78, 1, 79, 1, 79, 1, 79, 1, 80, 1, 80, 1, 81, 1, 81, 3, 
	81, 1846, 8, 81, 1, 81, 1, 81, 1, 81, 1, 81, 1, 81, 1, 81, 3, 81, 1854, 
	8, 81, 1, 82, 1, 82, 3, 82, 1858, 8, 82, 1, 82, 1, 82, 3, 82, 1862, 8, 
	82, 1, 82, 1, 82, 1, 83, 1, 83, 1, 83, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 
	1, 84, 3, 84, 1875, 8, 84, 1, 84, 1, 84, 1, 84, 1, 85, 1, 85, 1, 85, 1, 
	85, 3, 85, 1884, 8, 85, 1, 85, 1, 85, 1, 86, 1, 86, 3, 86, 1890, 8, 86, 
	1, 86, 1, 86, 3, 86, 1894, 8, 86, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 3, 
	86, 1901, 8, 86, 1, 86, 3, 86, 1904, 8, 86, 1, 86, 3, 86, 1907, 8, 86, 
	1, 86, 3, 86, 1910, 8, 86, 1, 86, 1, 86, 1, 86, 1, 87, 1, 87, 1, 87, 1, 
	87, 1, 87, 1, 87, 1, 87, 3, 87, 1922, 8, 87, 1, 87, 1, 87, 1, 88, 1, 88, 
	3, 88, 1928, 8, 88, 1, 89, 1, 89, 1, 89, 1, 89, 1, 89, 1, 89, 1, 90, 1, 
	90, 1, 90, 1, 91, 1, 91, 1, 91, 1, 91, 1, 91, 1, 91, 1, 92, 1, 92, 1, 92, 
	1, 92, 1, 92, 1, 92, 1, 93, 1, 93, 1, 93, 3, 93, 1954, 8, 93, 1, 93, 1, 
	93, 1, 94, 1, 94, 1, 94, 1, 94, 3, 94, 1962, 8, 94, 1, 94, 1, 94, 3, 94, 
	1966, 8, 94, 1, 94, 3, 94, 1969, 8, 94, 1, 94, 3, 94, 1972, 8, 94, 1, 94, 
	3, 94, 1975, 8, 94, 1, 94, 3, 94, 1978, 8, 94, 1, 94, 3, 94, 1981, 8, 94, 
	1, 94, 3, 94, 1984, 8, 94, 1, 94, 3, 94, 1987, 8, 94, 1, 94, 1, 94, 1, 
	94, 1, 95, 1, 95, 1, 95, 1, 95, 3, 95, 1996, 8, 95, 1, 95, 1, 95, 1, 96, 
	1, 96, 1, 96, 1, 96, 1, 96, 1, 96, 3, 96, 2006, 8, 96, 1, 96, 3, 96, 2009, 
	8, 96, 1, 96, 1, 96, 1, 97, 1, 97, 1, 97, 1, 97, 1, 97, 1, 98, 1, 98, 1, 
	98, 1, 98, 1, 98, 1, 98, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 3, 99, 2029, 
	8, 99, 1, 100, 1, 100, 1, 100, 1, 100, 3, 100, 2035, 8, 100, 1, 100, 1, 
	100, 1, 100, 1, 100, 3, 100, 2041, 8, 100, 1, 100, 3, 100, 2044, 8, 100, 
	3, 100, 2046, 8, 100, 1, 101, 1, 101, 1, 101, 1, 101, 1, 102, 3, 102, 2053, 
	8, 102, 1, 102, 1, 102, 1, 102, 1, 103, 1, 103, 3, 103, 2060, 8, 103, 1, 
	104, 1, 104, 3, 104, 2064, 8, 104, 1, 105, 1, 105, 1, 105, 1, 106, 1, 106, 
	1, 106, 1, 106, 1, 106, 3, 106, 2074, 8, 106, 1, 106, 1, 106, 1, 106, 3, 
	106, 2079, 8, 106, 1, 106, 1, 106, 1, 107, 1, 107, 1, 107, 5, 107, 2086, 
	8, 107, 10, 107, 12, 107, 2089, 9, 107, 1, 108, 1, 108, 1, 108, 5, 108, 
	2094, 8, 108, 10, 108, 12, 108, 2097, 9, 108, 1, 109, 1, 109, 1, 109, 5, 
	109, 2102, 8, 109, 10, 109, 12, 109, 2105, 9, 109, 1, 110, 1, 110, 1, 111, 
	1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 
	1, 111, 1, 111, 1, 111, 3, 111, 2122, 8, 111, 1, 112, 1, 112, 1, 112, 1, 
	112, 1, 112, 1, 112, 1, 112, 1, 112, 1, 112, 1, 112, 1, 112, 3, 112, 2135, 
	8, 112, 1, 112, 1, 112, 1, 112, 1, 112, 1, 113, 1, 113, 1, 113, 1, 113, 
	1, 113, 1, 114, 1, 114, 1, 114, 1, 114, 1, 114, 1, 114, 1, 114, 1, 114, 
	1, 114, 1, 114, 3, 114, 2156, 8, 114, 1, 115, 1, 115, 3, 115, 2160, 8, 
	115, 1, 116, 1, 116, 1, 116, 1, 117, 1, 117, 1, 117, 1, 118, 1, 118, 1, 
	118, 1, 118, 1, 118, 1, 118, 1, 118, 3, 118, 2175, 8, 118, 1, 119, 1, 119, 
	1, 119, 1, 119, 3, 119, 2181, 8, 119, 1, 119, 3, 119, 2184, 8, 119, 1, 
	119, 3, 119, 2187, 8, 119, 1, 119, 3, 119, 2190, 8, 119, 1, 119, 3, 119, 
	2193, 8, 119, 1, 120, 1, 120, 3, 120, 2197, 8, 120, 1, 121, 1, 121, 1, 
	121, 1, 122, 1, 122, 1, 122, 1, 122, 1, 123, 1, 123, 1, 123, 5, 123, 2209, 
	8, 123, 10, 123, 12, 123, 2212, 9, 123, 1, 123, 1, 123, 1, 123, 5, 123, 
	2217, 8, 123, 10, 123, 12, 123, 2220, 9, 123, 3, 123, 2222, 8, 123, 1, 
	124, 1, 124, 1, 124, 1, 124, 1, 125, 1, 125, 1, 126, 1, 126, 1, 126, 1, 
	126, 1, 126, 1, 126, 1, 126, 3, 126, 2237, 8, 126, 1, 127, 1, 127, 1, 127, 
	1, 127, 1, 127, 1, 127, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 
	1, 129, 1, 129, 1, 129, 1, 129, 1, 129, 1, 130, 1, 130, 1, 130, 1, 130, 
	1, 130, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 
	1, 131, 1, 131, 3, 131, 2271, 8, 131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 
	131, 1, 131, 3, 131, 2279, 8, 131, 1, 131, 1, 131, 1, 131, 3, 131, 2284, 
	8, 131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 3, 131, 2292, 8, 
	131, 1, 131, 1, 131, 1, 131, 3, 131, 2297, 8, 131, 1, 131, 1, 131, 1, 131, 
	3, 131, 2302, 8, 131, 1, 132, 1, 132, 1, 132, 1, 133, 1, 133, 1, 133, 5, 
	133, 2310, 8, 133, 10, 133, 12, 133, 2313, 9, 133, 1, 134, 1, 134, 1, 134, 
	5, 134, 2318, 8, 134, 10, 134, 12, 134, 2321, 9, 134, 1, 135, 1, 135, 1, 
	135, 5, 135, 2326, 8, 135, 10, 135, 12, 135, 2329, 9, 135, 1, 136, 1, 136, 
	1, 136, 5, 136, 2334, 8, 136, 10, 136, 12, 136, 2337, 9, 136, 1, 137, 1, 
	137, 1, 138, 1, 138, 1, 138, 1, 138, 1, 138, 1, 138, 3, 138, 2347, 8, 138, 
	5, 138, 2349, 8, 138, 10, 138, 12, 138, 2352, 9, 138, 1, 139, 1, 139, 1, 
	139, 5, 139, 2357, 8, 139, 10, 139, 12, 139, 2360, 9, 139, 1, 140, 1, 140, 
	1, 140, 1, 140, 1, 141, 1, 141, 3, 141, 2368, 8, 141, 1, 141, 3, 141, 2371, 
	8, 141, 1, 142, 1, 142, 1, 143, 1, 143, 1, 144, 1, 144, 1, 144, 3, 144, 
	2380, 8, 144, 1, 145, 1, 145, 1, 146, 1, 146, 3, 146, 2386, 8, 146, 1, 
	146, 1, 146, 3, 146, 2390, 8, 146, 1, 147, 1, 147, 1, 147, 1, 147, 3, 147, 
	2396, 8, 147, 1, 148, 1, 148, 3, 148, 2400, 8, 148, 1, 149, 1, 149, 1, 
	149, 1, 150, 1, 150, 1, 150, 1, 150, 1, 150, 1, 151, 1, 151, 3, 151, 2412, 
	8, 151, 1, 151, 1, 151, 1, 151, 1, 151, 1, 151, 1, 151, 1, 151, 3, 151, 
	2421, 8, 151, 1, 152, 1, 152, 1, 152, 1, 152, 1, 152, 1, 152, 1, 152, 1, 
	152, 1, 152, 3, 152, 2432, 8, 152, 1, 153, 1, 153, 3, 153, 2436, 8, 153, 
	1, 154, 1, 154, 1, 154, 5, 154, 2441, 8, 154, 10, 154, 12, 154, 2444, 9, 
	154, 1, 155, 1, 155, 1, 155, 1, 155, 1, 156, 1, 156, 1, 156, 5, 156, 2453, 
	8, 156, 10, 156, 12, 156, 2456, 9, 156, 1, 157, 1, 157, 1, 158, 1, 158, 
	3, 158, 2462, 8, 158, 1, 159, 1, 159, 1, 160, 1, 160, 1, 160, 1, 161, 1, 
	161, 3, 161, 2471, 8, 161, 1, 161, 3, 161, 2474, 8, 161, 1, 162, 1, 162, 
	1, 162, 5, 162, 2479, 8, 162, 10, 162, 12, 162, 2482, 9, 162, 1, 163, 1, 
	163, 1, 163, 3, 163, 2487, 8, 163, 1, 164, 1, 164, 1, 165, 1, 165, 3, 165, 
	2493, 8, 165, 1, 165, 3, 165, 2496, 8, 165, 1, 166, 1, 166, 1, 166, 1, 
	166, 3, 166, 2502, 8, 166, 1, 167, 1, 167, 3, 167, 2506, 8, 167, 1, 168, 
	1, 168, 3, 168, 2510, 8, 168, 1, 169, 1, 169, 1, 169, 3, 169, 2515, 8, 
	169, 1, 169, 1, 169, 3, 169, 2519, 8, 169, 1, 170, 1, 170, 3, 170, 2523, 
	8, 170, 1, 171, 1, 171, 3, 171, 2527, 8, 171, 1, 171, 1, 171, 1, 171, 1, 
	171, 1, 171, 1, 171, 3, 171, 2535, 8, 171, 1, 172, 1, 172, 3, 172, 2539, 
	8, 172, 1, 172, 1, 172, 3, 172, 2543, 8, 172, 1, 173, 1, 173, 3, 173, 2547, 
	8, 173, 1, 174, 1, 174, 3, 174, 2551, 8, 174, 1, 174, 1, 174, 1, 174, 1, 
	174, 1, 174, 1, 174, 3, 174, 2559, 8, 174, 1, 175, 1, 175, 3, 175, 2563, 
	8, 175, 1, 175, 1, 175, 3, 175, 2567, 8, 175, 1, 176, 1, 176, 1, 176, 1, 
	176, 1, 176, 1, 176, 3, 176, 2575, 8, 176, 1, 177, 1, 177, 1, 177, 3, 177, 
	2580, 8, 177, 1, 178, 1, 178, 1, 178, 3, 178, 2585, 8, 178, 1, 179, 1, 
	179, 3, 179, 2589, 8, 179, 1, 180, 1, 180, 3, 180, 2593, 8, 180, 1, 181, 
	1, 181, 1, 181, 1, 181, 1, 181, 3, 181, 2600, 8, 181, 1, 182, 1, 182, 1, 
	183, 1, 183, 1, 183, 5, 183, 2607, 8, 183, 10, 183, 12, 183, 2610, 9, 183, 
	1, 184, 1, 184, 1, 184, 1, 184, 1, 184, 3, 184, 2617, 8, 184, 1, 185, 1, 
	185, 1, 185, 1, 185, 1, 185, 1, 185, 1, 185, 1, 185, 1, 185, 3, 185, 2628, 
	8, 185, 1, 185, 1, 185, 1, 185, 1, 185, 1, 185, 1, 185, 1, 185, 1, 185, 
	1, 185, 1, 185, 1, 185, 1, 185, 1, 185, 1, 185, 1, 185, 1, 185, 3, 185, 
	2646, 8, 185, 1, 185, 3, 185, 2649, 8, 185, 1, 185, 1, 185, 1, 185, 1, 
	185, 3, 185, 2655, 8, 185, 1, 186, 1, 186, 1, 186, 1, 186, 1, 186, 1, 187, 
	1, 187, 1, 187, 1, 187, 1, 187, 1, 188, 1, 188, 1, 188, 1, 188, 1, 188, 
	1, 188, 1, 188, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 190, 1, 190, 
	3, 190, 2681, 8, 190, 1, 191, 3, 191, 2684, 8, 191, 1, 191, 1, 191, 1, 
	192, 1, 192, 3, 192, 2690, 8, 192, 1, 193, 1, 193, 1, 193, 1, 193, 5, 193, 
	2696, 8, 193, 10, 193, 12, 193, 2699, 9, 193, 1, 194, 1, 194, 1, 194, 1, 
	194, 1, 194, 3, 194, 2706, 8, 194, 1, 194, 1, 194, 1, 194, 1, 194, 1, 194, 
	1, 195, 1, 195, 1, 195, 1, 195, 5, 195, 2717, 8, 195, 10, 195, 12, 195, 
	2720, 9, 195, 1, 196, 1, 196, 4, 196, 2724, 8, 196, 11, 196, 12, 196, 2725, 
	1, 197, 1, 197, 1, 197, 1, 197, 3, 197, 2732, 8, 197, 1, 198, 1, 198, 3, 
	198, 2736, 8, 198, 1, 198, 3, 198, 2739, 8, 198, 1, 198, 3, 198, 2742, 
	8, 198, 1, 198, 3, 198, 2745, 8, 198, 1, 198, 3, 198, 2748, 8, 198, 1, 
	198, 3, 198, 2751, 8, 198, 1, 198, 1, 198, 1, 198, 1, 198, 1, 198, 3, 198, 
	2758, 8, 198, 1, 199, 1, 199, 3, 199, 2762, 8, 199, 1, 199, 3, 199, 2765, 
	8, 199, 1, 199, 3, 199, 2768, 8, 199, 1, 199, 3, 199, 2771, 8, 199, 1, 
	199, 3, 199, 2774, 8, 199, 1, 199, 3, 199, 2777, 8, 199, 1, 200, 1, 200, 
	1, 200, 4, 200, 2782, 8, 200, 11, 200, 12, 200, 2783, 1, 201, 3, 201, 2787, 
	8, 201, 1, 201, 1, 201, 1, 202, 1, 202, 1, 202, 3, 202, 2794, 8, 202, 1, 
	202, 3, 202, 2797, 8, 202, 1, 202, 3, 202, 2800, 8, 202, 1, 202, 3, 202, 
	2803, 8, 202, 1, 202, 3, 202, 2806, 8, 202, 1, 202, 3, 202, 2809, 8, 202, 
	1, 202, 3, 202, 2812, 8, 202, 1, 202, 3, 202, 2815, 8, 202, 1, 202, 3, 
	202, 2818, 8, 202, 1, 202, 3, 202, 2821, 8, 202, 1, 202, 3, 202, 2824, 
	8, 202, 1, 202, 1, 202, 3, 202, 2828, 8, 202, 1, 202, 3, 202, 2831, 8, 
	202, 1, 202, 3, 202, 2834, 8, 202, 1, 202, 3, 202, 2837, 8, 202, 1, 202, 
	3, 202, 2840, 8, 202, 1, 202, 3, 202, 2843, 8, 202, 1, 202, 3, 202, 2846, 
	8, 202, 1, 202, 3, 202, 2849, 8, 202, 1, 202, 3, 202, 2852, 8, 202, 1, 
	202, 3, 202, 2855, 8, 202, 1, 202, 3, 202, 2858, 8, 202, 3, 202, 2860, 
	8, 202, 1, 203, 1, 203, 1, 203, 1, 203, 3, 203, 2866, 8, 203, 1, 203, 1, 
	203, 3, 203, 2870, 8, 203, 1, 203, 1, 203, 1, 203, 1, 203, 1, 203, 3, 203, 
	2877, 8, 203, 3, 203, 2879, 8, 203, 1, 204, 3, 204, 2882, 8, 204, 1, 204, 
	1, 204, 1, 204, 3, 204, 2887, 8, 204, 1, 204, 3, 204, 2890, 8, 204, 1, 
	204, 1, 204, 3, 204, 2894, 8, 204, 1, 205, 1, 205, 1, 205, 3, 205, 2899, 
	8, 205, 1, 205, 1, 205, 1, 205, 1, 205, 3, 205, 2905, 8, 205, 1, 206, 1, 
	206, 1, 206, 1, 206, 3, 206, 2911, 8, 206, 1, 207, 1, 207, 1, 207, 1, 207, 
	1, 208, 1, 208, 3, 208, 2919, 8, 208, 1, 209, 1, 209, 1, 209, 1, 209, 5, 
	209, 2925, 8, 209, 10, 209, 12, 209, 2928, 9, 209, 1, 210, 1, 210, 1, 210, 
	1, 210, 3, 210, 2934, 8, 210, 1, 211, 1, 211, 1, 211, 1, 211, 3, 211, 2940, 
	8, 211, 1, 212, 1, 212, 1, 212, 1, 212, 1, 212, 5, 212, 2947, 8, 212, 10, 
	212, 12, 212, 2950, 9, 212, 3, 212, 2952, 8, 212, 1, 213, 1, 213, 3, 213, 
	2956, 8, 213, 1, 214, 1, 214, 1, 214, 1, 215, 1, 215, 1, 215, 1, 215, 1, 
	216, 1, 216, 1, 217, 1, 217, 3, 217, 2969, 8, 217, 1, 218, 1, 218, 3, 218, 
	2973, 8, 218, 1, 219, 1, 219, 1, 219, 1, 219, 1, 220, 1, 220, 1, 220, 4, 
	220, 2982, 8, 220, 11, 220, 12, 220, 2983, 1, 221, 1, 221, 1, 221, 4, 221, 
	2989, 8, 221, 11, 221, 12, 221, 2990, 1, 222, 1, 222, 3, 222, 2995, 8, 
	222, 1, 222, 1, 222, 1, 222, 3, 222, 3000, 8, 222, 1, 222, 3, 222, 3003, 
	8, 222, 1, 222, 1, 222, 1, 222, 1, 222, 1, 222, 1, 222, 1, 223, 1, 223, 
	5, 223, 3013, 8, 223, 10, 223, 12, 223, 3016, 9, 223, 1, 223, 3, 223, 3019, 
	8, 223, 1, 224, 1, 224, 1, 224, 1, 224, 1, 224, 3, 224, 3026, 8, 224, 1, 
	224, 1, 224, 1, 224, 3, 224, 3031, 8, 224, 1, 224, 1, 224, 1, 224, 1, 225, 
	1, 225, 1, 225, 1, 225, 1, 225, 1, 225, 1, 225, 1, 226, 1, 226, 1, 226, 
	1, 226, 1, 226, 1, 227, 1, 227, 1, 227, 3, 227, 3051, 8, 227, 1, 228, 1, 
	228, 1, 228, 4, 228, 3056, 8, 228, 11, 228, 12, 228, 3057, 1, 229, 1, 229, 
	1, 229, 1, 229, 1, 230, 1, 230, 1, 230, 1, 231, 1, 231, 1, 231, 1, 232, 
	1, 232, 1, 232, 1, 233, 1, 233, 1, 233, 1, 233, 1, 233, 1, 233, 1, 233, 
	1, 233, 3, 233, 3081, 8, 233, 1, 233, 1, 233, 1, 233, 1, 233, 1, 233, 1, 
	233, 1, 233, 1, 233, 1, 233, 1, 233, 1, 233, 1, 233, 3, 233, 3095, 8, 233, 
	1, 234, 1, 234, 1, 234, 1, 234, 1, 234, 1, 234, 1, 234, 1, 234, 1, 234, 
	1, 234, 1, 234, 1, 234, 1, 234, 1, 234, 1, 234, 1, 234, 1, 234, 1, 234, 
	1, 234, 3, 234, 3116, 8, 234, 1, 235, 1, 235, 1, 235, 1, 235, 1, 235, 1, 
	235, 1, 235, 1, 235, 1, 235, 1, 235, 1, 235, 1, 235, 1, 235, 1, 235, 3, 
	235, 3132, 8, 235, 1, 236, 1, 236, 1, 236, 1, 236, 1, 236, 1, 236, 1, 237, 
	1, 237, 1, 237, 1, 237, 1, 237, 3, 237, 3145, 8, 237, 1, 238, 1, 238, 3, 
	238, 3149, 8, 238, 1, 239, 1, 239, 3, 239, 3153, 8, 239, 1, 240, 1, 240, 
	1, 241, 1, 241, 1, 241, 3, 241, 3160, 8, 241, 1, 242, 1, 242, 1, 242, 1, 
	242, 1, 242, 1, 243, 1, 243, 1, 243, 1, 243, 1, 243, 1, 244, 1, 244, 1, 
	244, 1, 244, 1, 244, 1, 245, 1, 245, 1, 245, 1, 245, 1, 245, 1, 246, 1, 
	246, 1, 246, 1, 246, 1, 247, 1, 247, 3, 247, 3188, 8, 247, 1, 247, 1, 247, 
	1, 247, 1, 247, 1, 247, 3, 247, 3195, 8, 247, 1, 248, 1, 248, 1, 248, 3, 
	248, 3200, 8, 248, 1, 249, 1, 249, 1, 249, 3, 249, 3205, 8, 249, 1, 250, 
	1, 250, 1, 250, 1, 250, 1, 251, 1, 251, 3, 251, 3213, 8, 251, 1, 251, 1, 
	251, 1, 251, 1, 251, 3, 251, 3219, 8, 251, 1, 251, 1, 251, 3, 251, 3223, 
	8, 251, 1, 251, 3, 251, 3226, 8, 251, 1, 251, 3, 251, 3229, 8, 251, 1, 
	252, 1, 252, 1, 252, 1, 252, 3, 252, 3235, 8, 252, 1, 252, 1, 252, 1, 252, 
	1, 252, 1, 252, 3, 252, 3242, 8, 252, 1, 253, 1, 253, 1, 253, 1, 253, 1, 
	253, 1, 254, 1, 254, 1, 254, 3, 254, 3252, 8, 254, 1, 255, 1, 255, 3, 255, 
	3256, 8, 255, 1, 255, 4, 255, 3259, 8, 255, 11, 255, 12, 255, 3260, 1, 
	256, 1, 256, 3, 256, 3265, 8, 256, 1, 257, 1, 257, 5, 257, 3269, 8, 257, 
	10, 257, 12, 257, 3272, 9, 257, 1, 258, 1, 258, 5, 258, 3276, 8, 258, 10, 
	258, 12, 258, 3279, 9, 258, 1, 259, 1, 259, 5, 259, 3283, 8, 259, 10, 259, 
	12, 259, 3286, 9, 259, 1, 260, 1, 260, 1, 260, 1, 261, 1, 261, 3, 261, 
	3293, 8, 261, 1, 261, 1, 261, 1, 261, 1, 261, 1, 261, 5, 261, 3300, 8, 
	261, 10, 261, 12, 261, 3303, 9, 261, 1, 261, 3, 261, 3306, 8, 261, 1, 261, 
	3, 261, 3309, 8, 261, 1, 262, 1, 262, 1, 262, 1, 262, 1, 262, 1, 262, 3, 
	262, 3317, 8, 262, 1, 262, 3, 262, 3320, 8, 262, 1, 263, 1, 263, 1, 263, 
	1, 263, 1, 263, 1, 263, 3, 263, 3328, 8, 263, 1, 263, 3, 263, 3331, 8, 
	263, 1, 264, 1, 264, 1, 264, 1, 264, 1, 264, 1, 264, 3, 264, 3339, 8, 264, 
	1, 264, 1, 264, 3, 264, 3343, 8, 264, 1, 264, 1, 264, 1, 264, 3, 264, 3348, 
	8, 264, 1, 265, 1, 265, 3, 265, 3352, 8, 265, 1, 266, 1, 266, 1, 266, 1, 
	266, 1, 267, 1, 267, 1, 267, 3, 267, 3361, 8, 267, 1, 268, 1, 268, 1, 268, 
	1, 268, 1, 268, 1, 269, 1, 269, 1, 269, 1, 269, 1, 270, 1, 270, 1, 270, 
	5, 270, 3375, 8, 270, 10, 270, 12, 270, 3378, 9, 270, 1, 271, 1, 271, 1, 
	271, 1, 271, 1, 272, 1, 272, 1, 272, 1, 272, 1, 273, 1, 273, 1, 273, 1, 
	273, 3, 273, 3392, 8, 273, 3, 273, 3394, 8, 273, 1, 274, 1, 274, 1, 274, 
	1, 274, 1, 274, 1, 274, 1, 275, 1, 275, 1, 275, 1, 275, 1, 276, 1, 276, 
	1, 276, 1, 276, 3, 276, 3410, 8, 276, 1, 276, 1, 276, 1, 276, 1, 276, 1, 
	276, 3, 276, 3417, 8, 276, 1, 277, 1, 277, 1, 278, 1, 278, 1, 278, 1, 278, 
	1, 279, 1, 279, 1, 279, 1, 280, 1, 280, 1, 280, 1, 281, 1, 281, 1, 281, 
	3, 281, 3434, 8, 281, 1, 281, 3, 281, 3437, 8, 281, 1, 281, 3, 281, 3440, 
	8, 281, 1, 281, 1, 281, 1, 281, 1, 281, 3, 281, 3446, 8, 281, 1, 282, 1, 
	282, 1, 282, 1, 282, 1, 283, 1, 283, 1, 283, 1, 283, 1, 283, 1, 283, 1, 
	283, 1, 284, 1, 284, 1, 284, 1, 284, 1, 284, 1, 284, 1, 284, 1, 284, 1, 
	284, 1, 284, 3, 284, 3469, 8, 284, 1, 284, 1, 284, 1, 285, 1, 285, 1, 285, 
	1, 285, 1, 285, 1, 285, 1, 285, 1, 285, 1, 285, 1, 285, 3, 285, 3483, 8, 
	285, 1, 285, 3, 285, 3486, 8, 285, 1, 286, 1, 286, 1, 286, 3, 286, 3491, 
	8, 286, 1, 287, 1, 287, 1, 287, 1, 287, 1, 287, 1, 288, 1, 288, 1, 288, 
	1, 288, 1, 288, 1, 289, 1, 289, 1, 289, 1, 289, 1, 289, 1, 290, 1, 290, 
	1, 290, 1, 290, 1, 290, 1, 290, 1, 290, 1, 290, 1, 290, 3, 290, 3517, 8, 
	290, 1, 291, 1, 291, 3, 291, 3521, 8, 291, 1, 291, 3, 291, 3524, 8, 291, 
	1, 291, 3, 291, 3527, 8, 291, 1, 291, 1, 291, 3, 291, 3531, 8, 291, 1, 
	291, 1, 291, 1, 291, 3, 291, 3536, 8, 291, 1, 291, 3, 291, 3539, 8, 291, 
	1, 291, 3, 291, 3542, 8, 291, 1, 291, 3, 291, 3545, 8, 291, 1, 291, 3, 
	291, 3548, 8, 291, 1, 291, 1, 291, 1, 291, 1, 291, 3, 291, 3554, 8, 291, 
	1, 291, 3, 291, 3557, 8, 291, 1, 291, 3, 291, 3560, 8, 291, 1, 291, 3, 
	291, 3563, 8, 291, 1, 291, 3, 291, 3566, 8, 291, 1, 291, 3, 291, 3569, 
	8, 291, 1, 291, 3, 291, 3572, 8, 291, 1, 291, 3, 291, 3575, 8, 291, 1, 
	291, 3, 291, 3578, 8, 291, 1, 291, 1, 291, 3, 291, 3582, 8, 291, 3, 291, 
	3584, 8, 291, 1, 291, 1, 291, 1, 291, 1, 291, 3, 291, 3590, 8, 291, 1, 
	291, 1, 291, 1, 291, 3, 291, 3595, 8, 291, 1, 291, 3, 291, 3598, 8, 291, 
	1, 291, 3, 291, 3601, 8, 291, 1, 291, 3, 291, 3604, 8, 291, 1, 291, 1, 
	291, 1, 291, 1, 291, 3, 291, 3610, 8, 291, 1, 291, 3, 291, 3613, 8, 291, 
	1, 291, 3, 291, 3616, 8, 291, 1, 291, 3, 291, 3619, 8, 291, 1, 291, 3, 
	291, 3622, 8, 291, 1, 291, 3, 291, 3625, 8, 291, 1, 291, 3, 291, 3628, 
	8, 291, 1, 291, 3, 291, 3631, 8, 291, 1, 291, 3, 291, 3634, 8, 291, 1, 
	291, 1, 291, 3, 291, 3638, 8, 291, 3, 291, 3640, 8, 291, 3, 291, 3642, 
	8, 291, 1, 292, 1, 292, 1, 292, 3, 292, 3647, 8, 292, 1, 292, 1, 292, 1, 
	292, 1, 292, 3, 292, 3653, 8, 292, 1, 292, 1, 292, 1, 292, 3, 292, 3658, 
	8, 292, 1, 293, 1, 293, 1, 293, 1, 294, 1, 294, 1, 294, 1, 295, 1, 295, 
	1, 295, 1, 296, 1, 296, 1, 296, 1, 296, 1, 297, 1, 297, 1, 297, 3, 297, 
	3676, 8, 297, 1, 297, 1, 297, 1, 298, 1, 298, 1, 298, 1, 298, 1, 298, 3, 
	298, 3685, 8, 298, 1, 299, 1, 299, 1, 300, 1, 300, 1, 301, 1, 301, 1, 301, 
	5, 301, 3694, 8, 301, 10, 301, 12, 301, 3697, 9, 301, 1, 302, 1, 302, 1, 
	302, 5, 302, 3702, 8, 302, 10, 302, 12, 302, 3705, 9, 302, 1, 303, 1, 303, 
	1, 303, 1, 304, 1, 304, 1, 304, 1, 304, 4, 304, 3714, 8, 304, 11, 304, 
	12, 304, 3715, 1, 304, 3, 304, 3719, 8, 304, 1, 305, 1, 305, 5, 305, 3723, 
	8, 305, 10, 305, 12, 305, 3726, 9, 305, 1, 305, 1, 305, 5, 305, 3730, 8, 
	305, 10, 305, 12, 305, 3733, 9, 305, 1, 305, 1, 305, 5, 305, 3737, 8, 305, 
	10, 305, 12, 305, 3740, 9, 305, 1, 305, 1, 305, 5, 305, 3744, 8, 305, 10, 
	305, 12, 305, 3747, 9, 305, 1, 305, 1, 305, 1, 305, 1, 305, 3, 305, 3753, 
	8, 305, 1, 306, 1, 306, 1, 306, 1, 306, 1, 306, 1, 306, 1, 306, 3, 306, 
	3762, 8, 306, 5, 306, 3764, 8, 306, 10, 306, 12, 306, 3767, 9, 306, 1, 
	307, 1, 307, 1, 307, 1, 307, 3, 307, 3773, 8, 307, 1, 307, 5, 307, 3776, 
	8, 307, 10, 307, 12, 307, 3779, 9, 307, 1, 308, 3, 308, 3782, 8, 308, 1, 
	308, 1, 308, 1, 308, 1, 309, 1, 309, 1, 309, 1, 309, 1, 310, 1, 310, 1, 
	311, 1, 311, 1, 311, 1, 311, 1, 311, 3, 311, 3798, 8, 311, 1, 311, 1, 311, 
	3, 311, 3802, 8, 311, 3, 311, 3804, 8, 311, 1, 311, 3, 311, 3807, 8, 311, 
	1, 312, 1, 312, 1, 312, 1, 312, 1, 312, 1, 312, 1, 312, 1, 312, 1, 312, 
	5, 312, 3818, 8, 312, 10, 312, 12, 312, 3821, 9, 312, 3, 312, 3823, 8, 
	312, 1, 312, 3, 312, 3826, 8, 312, 1, 312, 1, 312, 1, 312, 1, 312, 1, 312, 
	1, 312, 1, 312, 1, 312, 5, 312, 3836, 8, 312, 10, 312, 12, 312, 3839, 9, 
	312, 3, 312, 3841, 8, 312, 1, 312, 1, 312, 1, 312, 1, 312, 1, 312, 3, 312, 
	3848, 8, 312, 1, 312, 1, 312, 1, 312, 1, 312, 1, 312, 5, 312, 3855, 8, 
	312, 10, 312, 12, 312, 3858, 9, 312, 1, 312, 1, 312, 3, 312, 3862, 8, 312, 
	3, 312, 3864, 8, 312, 3, 312, 3866, 8, 312, 1, 313, 1, 313, 1, 314, 1, 
	314, 1, 314, 1, 314, 1, 314, 1, 314, 1, 314, 1, 314, 1, 314, 1, 314, 1, 
	314, 5, 314, 3881, 8, 314, 10, 314, 12, 314, 3884, 9, 314, 3, 314, 3886, 
	8, 314, 1, 314, 1, 314, 1, 315, 1, 315, 1, 315, 1, 315, 1, 315, 3, 315, 
	3895, 8, 315, 1, 315, 1, 315, 1, 316, 1, 316, 3, 316, 3901, 8, 316, 1, 
	317, 1, 317, 3, 317, 3905, 8, 317, 1, 317, 3, 317, 3908, 8, 317, 1, 317, 
	3, 317, 3911, 8, 317, 1, 317, 3, 317, 3914, 8, 317, 1, 317, 3, 317, 3917, 
	8, 317, 1, 318, 1, 318, 1, 318, 1, 318, 1, 318, 1, 318, 1, 318, 1, 318, 
	1, 318, 1, 318, 3, 318, 3929, 8, 318, 1, 319, 1, 319, 3, 319, 3933, 8, 
	319, 1, 319, 3, 319, 3936, 8, 319, 1, 319, 3, 319, 3939, 8, 319, 1, 320, 
	1, 320, 1, 320, 1, 320, 1, 320, 3, 320, 3946, 8, 320, 1, 320, 3, 320, 3949, 
	8, 320, 1, 321, 1, 321, 1, 321, 3, 321, 3954, 8, 321, 1, 321, 1, 321, 1, 
	322, 1, 322, 1, 322, 1, 322, 3, 322, 3962, 8, 322, 1, 322, 1, 322, 1, 323, 
	1, 323, 3, 323, 3968, 8, 323, 1, 323, 1, 323, 1, 323, 3, 323, 3973, 8, 
	323, 1, 323, 1, 323, 3, 323, 3977, 8, 323, 1, 324, 1, 324, 1, 324, 3, 324, 
	3982, 8, 324, 1, 325, 1, 325, 1, 325, 1, 325, 1, 325, 3, 325, 3989, 8, 
	325, 1, 325, 1, 325, 1, 325, 1, 325, 1, 325, 1, 325, 1, 325, 1, 325, 1, 
	325, 1, 325, 5, 325, 4001, 8, 325, 10, 325, 12, 325, 4004, 9, 325, 3, 325, 
	4006, 8, 325, 1, 325, 1, 325, 3, 325, 4010, 8, 325, 1, 326, 1, 326, 1, 
	326, 1, 327, 1, 327, 1, 328, 1, 328, 1, 329, 1, 329, 1, 329, 1, 330, 1, 
	330, 1, 330, 5, 330, 4025, 8, 330, 10, 330, 12, 330, 4028, 9, 330, 1, 330, 
	1, 330, 1, 330, 5, 330, 4033, 8, 330, 10, 330, 12, 330, 4036, 9, 330, 3, 
	330, 4038, 8, 330, 1, 331, 1, 331, 1, 332, 1, 332, 1, 332, 1, 332, 1, 333, 
	1, 333, 1, 333, 1, 333, 1, 333, 3, 333, 4051, 8, 333, 1, 333, 1, 333, 1, 
	333, 1, 333, 1, 333, 5, 333, 4058, 8, 333, 10, 333, 12, 333, 4061, 9, 333, 
	3, 333, 4063, 8, 333, 1, 333, 1, 333, 1, 334, 1, 334, 3, 334, 4069, 8, 
	334, 1, 334, 3, 334, 4072, 8, 334, 1, 334, 1, 334, 1, 334, 3, 334, 4077, 
	8, 334, 1, 334, 3, 334, 4080, 8, 334, 1, 335, 1, 335, 1, 336, 1, 336, 1, 
	336, 5, 336, 4087, 8, 336, 10, 336, 12, 336, 4090, 9, 336, 1, 337, 1, 337, 
	1, 337, 1, 337, 1, 337, 1, 337, 1, 337, 1, 337, 1, 337, 1, 337, 1, 337, 
	3, 337, 4103, 8, 337, 1, 337, 1, 337, 1, 337, 1, 337, 3, 337, 4109, 8, 
	337, 3, 337, 4111, 8, 337, 1, 337, 1, 337, 1, 337, 1, 338, 1, 338, 1, 338, 
	3, 338, 4119, 8, 338, 1, 338, 1, 338, 1, 338, 1, 338, 1, 338, 1, 338, 5, 
	338, 4127, 8, 338, 10, 338, 12, 338, 4130, 9, 338, 1, 338, 1, 338, 3, 338, 
	4134, 8, 338, 3, 338, 4136, 8, 338, 1, 339, 1, 339, 1, 339, 1, 339, 1, 
	339, 1, 339, 1, 339, 1, 339, 1, 339, 1, 339, 3, 339, 4148, 8, 339, 1, 339, 
	1, 339, 1, 339, 1, 339, 3, 339, 4154, 8, 339, 3, 339, 4156, 8, 339, 1, 
	339, 1, 339, 1, 339, 1, 340, 1, 340, 3, 340, 4163, 8, 340, 1, 341, 1, 341, 
	1, 341, 5, 341, 4168, 8, 341, 10, 341, 12, 341, 4171, 9, 341, 1, 342, 1, 
	342, 1, 342, 1, 342, 5, 342, 4177, 8, 342, 10, 342, 12, 342, 4180, 9, 342, 
	1, 343, 1, 343, 1, 343, 1, 343, 1, 344, 1, 344, 1, 344, 3, 344, 4189, 8, 
	344, 1, 344, 3, 344, 4192, 8, 344, 1, 344, 3, 344, 4195, 8, 344, 1, 344, 
	3, 344, 4198, 8, 344, 1, 345, 1, 345, 3, 345, 4202, 8, 345, 1, 346, 1, 
	346, 1, 346, 1, 346, 1, 346, 1, 346, 1, 346, 3, 346, 4211, 8, 346, 1, 347, 
	1, 347, 1, 347, 1, 347, 1, 347, 1, 347, 1, 347, 3, 347, 4220, 8, 347, 1, 
	348, 1, 348, 1, 348, 1, 348, 1, 348, 1, 348, 3, 348, 4228, 8, 348, 1, 349, 
	1, 349, 1, 349, 1, 349, 3, 349, 4234, 8, 349, 1, 350, 1, 350, 1, 350, 1, 
	350, 1, 351, 1, 351, 1, 351, 3, 351, 4243, 8, 351, 1, 352, 1, 352, 1, 352, 
	1, 353, 1, 353, 3, 353, 4250, 8, 353, 1, 353, 1, 353, 1, 353, 1, 353, 5, 
	353, 4256, 8, 353, 10, 353, 12, 353, 4259, 9, 353, 1, 353, 1, 353, 1, 354, 
	1, 354, 1, 354, 1, 354, 1, 354, 3, 354, 4268, 8, 354, 1, 354, 1, 354, 1, 
	354, 1, 354, 1, 354, 1, 354, 5, 354, 4276, 8, 354, 10, 354, 12, 354, 4279, 
	9, 354, 1, 354, 1, 354, 3, 354, 4283, 8, 354, 1, 355, 1, 355, 3, 355, 4287, 
	8, 355, 1, 356, 1, 356, 3, 356, 4291, 8, 356, 1, 356, 1, 356, 5, 356, 4295, 
	8, 356, 10, 356, 12, 356, 4298, 9, 356, 1, 356, 1, 356, 1, 357, 1, 357, 
	1, 358, 1, 358, 1, 358, 1, 359, 1, 359, 1, 359, 1, 360, 1, 360, 1, 361, 
	1, 361, 1, 361, 1, 361, 1, 362, 1, 362, 3, 362, 4318, 8, 362, 1, 363, 1, 
	363, 4, 363, 4322, 8, 363, 11, 363, 12, 363, 4323, 1, 364, 1, 364, 3, 364, 
	4328, 8, 364, 1, 365, 1, 365, 3, 365, 4332, 8, 365, 1, 365, 3, 365, 4335, 
	8, 365, 1, 365, 1, 365, 5, 365, 4339, 8, 365, 10, 365, 12, 365, 4342, 9, 
	365, 1, 366, 1, 366, 3, 366, 4346, 8, 366, 1, 366, 3, 366, 4349, 8, 366, 
	1, 367, 1, 367, 3, 367, 4353, 8, 367, 1, 368, 1, 368, 1, 368, 1, 368, 5, 
	368, 4359, 8, 368, 10, 368, 12, 368, 4362, 9, 368, 1, 368, 1, 368, 1, 369, 
	1, 369, 1, 369, 5, 369, 4369, 8, 369, 10, 369, 12, 369, 4372, 9, 369, 1, 
	370, 1, 370, 1, 370, 1, 370, 1, 370, 5, 370, 4379, 8, 370, 10, 370, 12, 
	370, 4382, 9, 370, 1, 371, 1, 371, 1, 371, 1, 371, 1, 372, 1, 372, 1, 372, 
	1, 372, 1, 373, 1, 373, 1, 373, 1, 373, 1, 374, 1, 374, 1, 374, 1, 374, 
	3, 374, 4400, 8, 374, 1, 375, 1, 375, 1, 375, 1, 375, 1, 375, 3, 375, 4407, 
	8, 375, 1, 375, 3, 375, 4410, 8, 375, 1, 375, 1, 375, 1, 375, 1, 375, 1, 
	376, 1, 376, 1, 376, 1, 376, 1, 376, 3, 376, 4421, 8, 376, 1, 376, 1, 376, 
	1, 376, 5, 376, 4426, 8, 376, 10, 376, 12, 376, 4429, 9, 376, 3, 376, 4431, 
	8, 376, 3, 376, 4433, 8, 376, 1, 376, 1, 376, 1, 376, 1, 376, 1, 376, 1, 
	376, 1, 376, 1, 376, 1, 376, 3, 376, 4444, 8, 376, 1, 376, 1, 376, 1, 376, 
	1, 376, 1, 376, 1, 376, 1, 376, 1, 376, 3, 376, 4454, 8, 376, 3, 376, 4456, 
	8, 376, 1, 377, 1, 377, 1, 377, 1, 377, 3, 377, 4462, 8, 377, 1, 378, 1, 
	378, 3, 378, 4466, 8, 378, 1, 379, 1, 379, 1, 379, 1, 379, 1, 379, 1, 379, 
	1, 379, 3, 379, 4475, 8, 379, 1, 379, 1, 379, 1, 380, 1, 380, 1, 380, 1, 
	380, 1, 380, 1, 380, 1, 380, 4, 380, 4486, 8, 380, 11, 380, 12, 380, 4487, 
	1, 380, 1, 380, 3, 380, 4492, 8, 380, 1, 380, 1, 380, 1, 381, 1, 381, 1, 
	381, 1, 381, 1, 381, 1, 381, 4, 381, 4502, 8, 381, 11, 381, 12, 381, 4503, 
	1, 381, 1, 381, 3, 381, 4508, 8, 381, 1, 381, 1, 381, 1, 382, 1, 382, 1, 
	382, 1, 382, 1, 382, 3, 382, 4517, 8, 382, 1, 382, 1, 382, 1, 383, 1, 383, 
	1, 384, 1, 384, 1, 384, 1, 384, 1, 384, 1, 384, 1, 384, 1, 385, 1, 385, 
	1, 386, 1, 386, 1, 386, 1, 386, 1, 386, 1, 386, 1, 386, 1, 386, 1, 386, 
	1, 386, 1, 386, 1, 386, 1, 386, 3, 386, 4545, 8, 386, 1, 387, 1, 387, 1, 
	388, 1, 388, 1, 389, 1, 389, 4, 389, 4553, 8, 389, 11, 389, 12, 389, 4554, 
	1, 390, 1, 390, 1, 390, 1, 391, 1, 391, 1, 391, 3, 391, 4563, 8, 391, 1, 
	392, 1, 392, 1, 392, 3, 392, 4568, 8, 392, 1, 393, 1, 393, 1, 393, 1, 394, 
	1, 394, 1, 395, 1, 395, 1, 395, 1, 396, 1, 396, 1, 396, 1, 396, 1, 396, 
	1, 396, 1, 396, 1, 396, 1, 396, 1, 396, 1, 396, 3, 396, 4589, 8, 396, 1, 
	396, 1, 396, 3, 396, 4593, 8, 396, 1, 397, 1, 397, 1, 397, 1, 397, 1, 397, 
	1, 397, 1, 397, 1, 397, 1, 397, 1, 397, 1, 397, 1, 397, 3, 397, 4607, 8, 
	397, 1, 398, 1, 398, 1, 399, 1, 399, 1, 399, 1, 399, 1, 399, 1, 399, 1, 
	399, 1, 399, 1, 399, 1, 399, 1, 399, 3, 399, 4622, 8, 399, 1, 400, 1, 400, 
	1, 400, 1, 400, 1, 400, 1, 400, 1, 400, 5, 400, 4631, 8, 400, 10, 400, 
	12, 400, 4634, 9, 400, 1, 401, 1, 401, 1, 402, 5, 402, 4639, 8, 402, 10, 
	402, 12, 402, 4642, 9, 402, 1, 402, 1, 402, 1, 403, 1, 403, 1, 404, 1, 
	404, 1, 404, 1, 404, 5, 404, 4652, 8, 404, 10, 404, 12, 404, 4655, 9, 404, 
	1, 405, 1, 405, 1, 406, 1, 406, 1, 406, 1, 406, 5, 406, 4663, 8, 406, 10, 
	406, 12, 406, 4666, 9, 406, 1, 407, 1, 407, 1, 408, 1, 408, 1, 408, 1, 
	408, 5, 408, 4674, 8, 408, 10, 408, 12, 408, 4677, 9, 408, 1, 409, 1, 409, 
	1, 410, 1, 410, 1, 410, 1, 410, 5, 410, 4685, 8, 410, 10, 410, 12, 410, 
	4688, 9, 410, 1, 411, 1, 411, 1, 412, 1, 412, 1, 412, 1, 412, 5, 412, 4696, 
	8, 412, 10, 412, 12, 412, 4699, 9, 412, 1, 413, 1, 413, 1, 414, 1, 414, 
	1, 414, 1, 414, 5, 414, 4707, 8, 414, 10, 414, 12, 414, 4710, 9, 414, 1, 
	415, 1, 415, 1, 416, 1, 416, 1, 416, 1, 416, 1, 416, 3, 416, 4719, 8, 416, 
	1, 417, 1, 417, 1, 417, 1, 417, 1, 418, 1, 418, 1, 418, 3, 418, 4728, 8, 
	418, 1, 419, 1, 419, 3, 419, 4732, 8, 419, 1, 420, 1, 420, 1, 420, 1, 420, 
	1, 420, 1, 420, 3, 420, 4740, 8, 420, 1, 421, 1, 421, 1, 421, 1, 421, 1, 
	421, 1, 421, 1, 421, 1, 421, 1, 421, 1, 421, 1, 421, 3, 421, 4753, 8, 421, 
	1, 422, 1, 422, 1, 422, 1, 422, 1, 423, 1, 423, 1, 424, 1, 424, 3, 424, 
	4763, 8, 424, 1, 425, 1, 425, 1, 425, 1, 425, 3, 425, 4769, 8, 425, 1, 
	426, 1, 426, 1, 426, 1, 426, 1, 427, 1, 427, 1, 427, 1, 427, 1, 427, 1, 
	427, 1, 427, 3, 427, 4782, 8, 427, 1, 428, 1, 428, 1, 428, 1, 428, 1, 428, 
	1, 428, 1, 428, 5, 428, 4791, 8, 428, 10, 428, 12, 428, 4794, 9, 428, 1, 
	429, 1, 429, 1, 429, 1, 429, 1, 429, 1, 429, 1, 429, 1, 429, 1, 429, 1, 
	429, 1, 429, 1, 429, 3, 429, 4808, 8, 429, 1, 430, 1, 430, 1, 430, 3, 430, 
	4813, 8, 430, 1, 431, 1, 431, 1, 432, 5, 432, 4818, 8, 432, 10, 432, 12, 
	432, 4821, 9, 432, 1, 432, 1, 432, 1, 433, 1, 433, 1, 434, 1, 434, 1, 434, 
	1, 434, 5, 434, 4831, 8, 434, 10, 434, 12, 434, 4834, 9, 434, 1, 435, 1, 
	435, 1, 436, 1, 436, 1, 436, 1, 436, 5, 436, 4842, 8, 436, 10, 436, 12, 
	436, 4845, 9, 436, 1, 437, 1, 437, 1, 438, 1, 438, 1, 439, 1, 439, 3, 439, 
	4853, 8, 439, 1, 440, 1, 440, 1, 440, 1, 440, 1, 440, 5, 440, 4860, 8, 
	440, 10, 440, 12, 440, 4863, 9, 440, 1, 440, 1, 440, 1, 441, 1, 441, 1, 
	441, 3, 441, 4870, 8, 441, 1, 442, 1, 442, 1, 442, 1, 442, 5, 442, 4876, 
	8, 442, 10, 442, 12, 442, 4879, 9, 442, 1, 442, 1, 442, 1, 443, 1, 443, 
	1, 443, 1, 443, 1, 444, 1, 444, 3, 444, 4889, 8, 444, 1, 445, 1, 445, 1, 
	446, 1, 446, 1, 447, 1, 447, 1, 447, 3, 447, 4898, 8, 447, 1, 448, 1, 448, 
	3, 448, 4902, 8, 448, 1, 449, 1, 449, 1, 449, 3, 449, 4907, 8, 449, 1, 
	450, 1, 450, 1, 451, 1, 451, 1, 452, 1, 452, 1, 453, 1, 453, 1, 453, 1, 
	454, 1, 454, 1, 454, 5, 454, 4921, 8, 454, 10, 454, 12, 454, 4924, 9, 454, 
	1, 455, 1, 455, 1, 455, 1, 455, 1, 455, 3, 455, 4931, 8, 455, 1, 456, 1, 
	456, 1, 457, 1, 457, 1, 457, 5, 457, 4938, 8, 457, 10, 457, 12, 457, 4941, 
	9, 457, 1, 458, 1, 458, 1, 459, 1, 459, 1, 459, 1, 459, 1, 459, 1, 460, 
	1, 460, 1, 460, 1, 460, 1, 460, 1, 461, 1, 461, 1, 461, 5, 461, 4958, 8, 
	461, 10, 461, 12, 461, 4961, 9, 461, 1, 462, 1, 462, 1, 462, 1, 462, 1, 
	462, 1, 462, 1, 462, 1, 462, 1, 462, 1, 462, 1, 462, 1, 462, 1, 462, 1, 
	462, 3, 462, 4977, 8, 462, 1, 463, 1, 463, 1, 463, 1, 463, 1, 463, 1, 463, 
	1, 463, 3, 463, 4986, 8, 463, 1, 464, 1, 464, 1, 464, 5, 464, 4991, 8, 
	464, 10, 464, 12, 464, 4994, 9, 464, 1, 465, 1, 465, 1, 465, 3, 465, 4999, 
	8, 465, 1, 466, 1, 466, 1, 466, 5, 466, 5004, 8, 466, 10, 466, 12, 466, 
	5007, 9, 466, 1, 467, 1, 467, 1, 467, 1, 467, 3, 467, 5013, 8, 467, 1, 
	467, 1, 467, 1, 467, 1, 467, 1, 467, 1, 467, 1, 467, 3, 467, 5022, 8, 467, 
	3, 467, 5024, 8, 467, 1, 468, 1, 468, 1, 468, 1, 469, 1, 469, 3, 469, 5031, 
	8, 469, 1, 470, 1, 470, 1, 471, 1, 471, 1, 472, 1, 472, 1, 473, 1, 473, 
	1, 473, 1, 473, 1, 473, 1, 473, 1, 473, 1, 473, 1, 473, 1, 473, 1, 473, 
	1, 473, 1, 473, 1, 473, 1, 473, 3, 473, 5054, 8, 473, 1, 473, 1, 473, 3, 
	473, 5058, 8, 473, 3, 473, 5060, 8, 473, 1, 474, 1, 474, 1, 474, 1, 474, 
	1, 475, 1, 475, 1, 475, 1, 475, 1, 475, 1, 475, 1, 475, 1, 475, 1, 475, 
	1, 475, 1, 475, 1, 475, 3, 475, 5078, 8, 475, 1, 476, 1, 476, 1, 476, 1, 
	476, 3, 476, 5084, 8, 476, 1, 476, 1, 476, 1, 477, 1, 477, 1, 477, 5, 477, 
	5091, 8, 477, 10, 477, 12, 477, 5094, 9, 477, 1, 478, 1, 478, 1, 479, 1, 
	479, 1, 479, 1, 480, 1, 480, 1, 480, 5, 480, 5104, 8, 480, 10, 480, 12, 
	480, 5107, 9, 480, 1, 481, 1, 481, 1, 481, 5, 481, 5112, 8, 481, 10, 481, 
	12, 481, 5115, 9, 481, 1, 482, 1, 482, 1, 482, 1, 482, 1, 483, 1, 483, 
	1, 484, 1, 484, 1, 485, 1, 485, 1, 485, 1, 485, 3, 485, 5129, 8, 485, 1, 
	486, 1, 486, 1, 486, 1, 487, 1, 487, 1, 487, 1, 487, 1, 487, 1, 487, 1, 
	487, 1, 487, 1, 487, 1, 487, 1, 488, 1, 488, 1, 488, 1, 488, 1, 488, 1, 
	488, 1, 488, 1, 488, 1, 488, 1, 488, 1, 488, 1, 488, 1, 488, 1, 488, 3, 
	488, 5158, 8, 488, 1, 488, 1, 488, 1, 488, 3, 488, 5163, 8, 488, 3, 488, 
	5165, 8, 488, 1, 489, 1, 489, 1, 489, 1, 489, 1, 489, 1, 489, 1, 490, 1, 
	490, 1, 490, 1, 490, 1, 490, 1, 490, 1, 490, 1, 490, 1, 490, 1, 490, 1, 
	490, 1, 490, 3, 490, 5185, 8, 490, 1, 491, 1, 491, 1, 491, 5, 491, 5190, 
	8, 491, 10, 491, 12, 491, 5193, 9, 491, 1, 492, 1, 492, 1, 492, 1, 492, 
	1, 492, 1, 492, 1, 492, 1, 492, 1, 493, 1, 493, 1, 493, 1, 493, 1, 493, 
	1, 493, 1, 493, 1, 493, 1, 493, 1, 493, 1, 493, 1, 493, 3, 493, 5215, 8, 
	493, 1, 494, 1, 494, 1, 494, 1, 494, 1, 494, 1, 494, 1, 495, 1, 495, 1, 
	495, 1, 495, 1, 495, 1, 495, 1, 495, 1, 495, 1, 495, 3, 495, 5232, 8, 495, 
	1, 495, 1, 495, 1, 495, 3, 495, 5237, 8, 495, 1, 496, 1, 496, 1, 496, 1, 
	496, 1, 496, 1, 496, 1, 496, 1, 496, 1, 496, 3, 496, 5248, 8, 496, 1, 496, 
	1, 496, 1, 496, 3, 496, 5253, 8, 496, 1, 497, 1, 497, 1, 497, 1, 497, 1, 
	497, 1, 497, 1, 497, 1, 497, 0, 0, 498, 0, 2, 4, 6, 8, 10, 12, 14, 16, 
	18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 
	54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 
	90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 
	122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 
	152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180, 
	182, 184, 186, 188, 190, 192, 194, 196, 198, 200, 202, 204, 206, 208, 210, 
	212, 214, 216, 218, 220, 222, 224, 226, 228, 230, 232, 234, 236, 238, 240, 
	242, 244, 246, 248, 250, 252, 254, 256, 258, 260, 262, 264, 266, 268, 270, 
	272, 274, 276, 278, 280, 282, 284, 286, 288, 290, 292, 294, 296, 298, 300, 
	302, 304, 306, 308, 310, 312, 314, 316, 318, 320, 322, 324, 326, 328, 330, 
	332, 334, 336, 338, 340, 342, 344, 346, 348, 350, 352, 354, 356, 358, 360, 
	362, 364, 366, 368, 370, 372, 374, 376, 378, 380, 382, 384, 386, 388, 390, 
	392, 394, 396, 398, 400, 402, 404, 406, 408, 410, 412, 414, 416, 418, 420, 
	422, 424, 426, 428, 430, 432, 434, 436, 438, 440, 442, 444, 446, 448, 450, 
	452, 454, 456, 458, 460, 462, 464, 466, 468, 470, 472, 474, 476, 478, 480, 
	482, 484, 486, 488, 490, 492, 494, 496, 498, 500, 502, 504, 506, 508, 510, 
	512, 514, 516, 518, 520, 522, 524, 526, 528, 530, 532, 534, 536, 538, 540, 
	542, 544, 546, 548, 550, 552, 554, 556, 558, 560, 562, 564, 566, 568, 570, 
	572, 574, 576, 578, 580, 582, 584, 586, 588, 590, 592, 594, 596, 598, 600, 
	602, 604, 606, 608, 610, 612, 614, 616, 618, 620, 622, 624, 626, 628, 630, 
	632, 634, 636, 638, 640, 642, 644, 646, 648, 650, 652, 654, 656, 658, 660, 
	662, 664, 666, 668, 670, 672, 674, 676, 678, 680, 682, 684, 686, 688, 690, 
	692, 694, 696, 698, 700, 702, 704, 706, 708, 710, 712, 714, 716, 718, 720, 
	722, 724, 726, 728, 730, 732, 734, 736, 738, 740, 742, 744, 746, 748, 750, 
	752, 754, 756, 758, 760, 762, 764, 766, 768, 770, 772, 774, 776, 778, 780, 
	782, 784, 786, 788, 790, 792, 794, 796, 798, 800, 802, 804, 806, 808, 810, 
	812, 814, 816, 818, 820, 822, 824, 826, 828, 830, 832, 834, 836, 838, 840, 
	842, 844, 846, 848, 850, 852, 854, 856, 858, 860, 862, 864, 866, 868, 870, 
	872, 874, 876, 878, 880, 882, 884, 886, 888, 890, 892, 894, 896, 898, 900, 
	902, 904, 906, 908, 910, 912, 914, 916, 918, 920, 922, 924, 926, 928, 930, 
	932, 934, 936, 938, 940, 942, 944, 946, 948, 950, 952, 954, 956, 958, 960, 
	962, 964, 966, 968, 970, 972, 974, 976, 978, 980, 982, 984, 986, 988, 990, 
	992, 994, 0, 49, 2, 0, 57, 57, 165, 165, 4, 0, 88, 88, 116, 116, 216, 216, 
	314, 314, 2, 0, 34, 34, 272, 272, 1, 0, 86, 87, 2, 0, 134, 134, 148, 148, 
	2, 0, 67, 67, 285, 285, 2, 0, 68, 68, 286, 286, 2, 0, 109, 109, 296, 296, 
	10, 0, 7, 7, 9, 9, 58, 58, 83, 83, 98, 98, 155, 155, 182, 182, 288, 288, 
	298, 298, 354, 354, 3, 0, 4, 4, 98, 98, 315, 315, 3, 0, 15, 15, 123, 123, 
	163, 163, 1, 0, 136, 137, 4, 0, 73, 73, 143, 143, 199, 199, 380, 380, 2, 
	0, 30, 30, 340, 340, 2, 0, 91, 91, 102, 102, 2, 0, 207, 207, 362, 362, 
	2, 0, 204, 204, 262, 262, 2, 0, 18, 18, 86, 86, 2, 0, 125, 125, 170, 170, 
	2, 0, 39, 39, 365, 365, 4, 0, 107, 107, 157, 157, 197, 197, 345, 345, 2, 
	0, 7, 7, 92, 92, 2, 0, 215, 215, 379, 379, 2, 0, 181, 181, 188, 188, 2, 
	0, 42, 42, 304, 304, 2, 0, 412, 412, 417, 417, 2, 0, 135, 135, 275, 275, 
	3, 0, 12, 12, 221, 221, 289, 289, 2, 0, 231, 231, 282, 282, 2, 0, 190, 
	190, 258, 258, 2, 0, 343, 343, 417, 417, 2, 0, 128, 128, 237, 237, 7, 0, 
	73, 73, 143, 143, 198, 199, 247, 247, 287, 287, 370, 370, 380, 380, 8, 
	0, 73, 73, 97, 97, 143, 143, 198, 199, 247, 247, 287, 287, 370, 370, 380, 
	380, 2, 0, 400, 401, 406, 406, 2, 0, 399, 399, 402, 404, 1, 0, 400, 401, 
	3, 0, 176, 176, 260, 260, 276, 276, 2, 0, 7, 7, 13, 13, 3, 0, 7, 7, 13, 
	13, 302, 302, 2, 0, 120, 120, 339, 339, 2, 0, 392, 392, 394, 398, 23, 0, 
	11, 11, 16, 16, 25, 28, 35, 35, 96, 96, 126, 127, 145, 145, 148, 148, 156, 
	156, 176, 176, 190, 190, 206, 206, 218, 218, 254, 254, 260, 260, 276, 276, 
	300, 300, 312, 313, 329, 329, 346, 346, 371, 371, 392, 407, 409, 409, 86, 
	0, 1, 6, 8, 8, 10, 10, 15, 15, 18, 20, 22, 24, 30, 31, 33, 34, 37, 38, 
	40, 44, 46, 47, 49, 50, 52, 53, 56, 57, 59, 59, 66, 66, 68, 68, 72, 76, 
	78, 78, 80, 82, 84, 86, 88, 91, 93, 95, 97, 97, 99, 100, 102, 102, 104, 
	106, 109, 111, 113, 116, 122, 125, 132, 133, 137, 137, 142, 144, 146, 146, 
	149, 150, 152, 154, 161, 163, 165, 170, 175, 175, 177, 179, 181, 185, 187, 
	189, 191, 194, 196, 196, 198, 199, 201, 202, 204, 205, 207, 208, 210, 210, 
	212, 213, 216, 217, 222, 223, 225, 226, 228, 230, 233, 236, 242, 242, 244, 
	245, 247, 249, 251, 252, 255, 257, 261, 272, 274, 274, 277, 278, 283, 287, 
	289, 292, 294, 299, 301, 301, 303, 306, 308, 314, 316, 317, 319, 319, 321, 
	323, 328, 329, 331, 331, 333, 335, 338, 338, 341, 342, 344, 344, 346, 346, 
	349, 353, 355, 357, 360, 362, 364, 364, 366, 370, 373, 373, 376, 381, 13, 
	0, 16, 16, 26, 28, 63, 64, 71, 71, 96, 96, 126, 126, 140, 140, 145, 145, 
	156, 156, 190, 190, 254, 254, 300, 300, 326, 326, 4, 0, 191, 191, 232, 
	232, 289, 289, 311, 311, 2, 0, 203, 203, 417, 418, 2, 0, 4, 4, 98, 98, 
	3, 0, 14, 14, 139, 139, 358, 358, 5626, 0, 998, 1, 0, 0, 0, 2, 1002, 1, 
	0, 0, 0, 4, 1036, 1, 0, 0, 0, 6, 1038, 1, 0, 0, 0, 8, 1040, 1, 0, 0, 0, 
	10, 1056, 1, 0, 0, 0, 12, 1058, 1, 0, 0, 0, 14, 1074, 1, 0, 0, 0, 16, 1083, 
	1, 0, 0, 0, 18, 1091, 1, 0, 0, 0, 20, 1104, 1, 0, 0, 0, 22, 1115, 1, 0, 
	0, 0, 24, 1120, 1, 0, 0, 0, 26, 1131, 1, 0, 0, 0, 28, 1135, 1, 0, 0, 0, 
	30, 1143, 1, 0, 0, 0, 32, 1148, 1, 0, 0, 0, 34, 1200, 1, 0, 0, 0, 36, 1202, 
	1, 0, 0, 0, 38, 1205, 1, 0, 0, 0, 40, 1207, 1, 0, 0, 0, 42, 1211, 1, 0, 
	0, 0, 44, 1213, 1, 0, 0, 0, 46, 1216, 1, 0, 0, 0, 48, 1219, 1, 0, 0, 0, 
	50, 1223, 1, 0, 0, 0, 52, 1262, 1, 0, 0, 0, 54, 1264, 1, 0, 0, 0, 56, 1267, 
	1, 0, 0, 0, 58, 1270, 1, 0, 0, 0, 60, 1274, 1, 0, 0, 0, 62, 1282, 1, 0, 
	0, 0, 64, 1285, 1, 0, 0, 0, 66, 1288, 1, 0, 0, 0, 68, 1297, 1, 0, 0, 0, 
	70, 1300, 1, 0, 0, 0, 72, 1315, 1, 0, 0, 0, 74, 1327, 1, 0, 0, 0, 76, 1332, 
	1, 0, 0, 0, 78, 1352, 1, 0, 0, 0, 80, 1356, 1, 0, 0, 0, 82, 1363, 1, 0, 
	0, 0, 84, 1388, 1, 0, 0, 0, 86, 1405, 1, 0, 0, 0, 88, 1407, 1, 0, 0, 0, 
	90, 1590, 1, 0, 0, 0, 92, 1600, 1, 0, 0, 0, 94, 1602, 1, 0, 0, 0, 96, 1610, 
	1, 0, 0, 0, 98, 1615, 1, 0, 0, 0, 100, 1617, 1, 0, 0, 0, 102, 1623, 1, 
	0, 0, 0, 104, 1627, 1, 0, 0, 0, 106, 1631, 1, 0, 0, 0, 108, 1635, 1, 0, 
	0, 0, 110, 1645, 1, 0, 0, 0, 112, 1656, 1, 0, 0, 0, 114, 1673, 1, 0, 0, 
	0, 116, 1691, 1, 0, 0, 0, 118, 1696, 1, 0, 0, 0, 120, 1699, 1, 0, 0, 0, 
	122, 1703, 1, 0, 0, 0, 124, 1710, 1, 0, 0, 0, 126, 1719, 1, 0, 0, 0, 128, 
	1725, 1, 0, 0, 0, 130, 1727, 1, 0, 0, 0, 132, 1744, 1, 0, 0, 0, 134, 1766, 
	1, 0, 0, 0, 136, 1768, 1, 0, 0, 0, 138, 1776, 1, 0, 0, 0, 140, 1783, 1, 
	0, 0, 0, 142, 1785, 1, 0, 0, 0, 144, 1799, 1, 0, 0, 0, 146, 1801, 1, 0, 
	0, 0, 148, 1805, 1, 0, 0, 0, 150, 1809, 1, 0, 0, 0, 152, 1813, 1, 0, 0, 
	0, 154, 1817, 1, 0, 0, 0, 156, 1830, 1, 0, 0, 0, 158, 1838, 1, 0, 0, 0, 
	160, 1841, 1, 0, 0, 0, 162, 1843, 1, 0, 0, 0, 164, 1855, 1, 0, 0, 0, 166, 
	1865, 1, 0, 0, 0, 168, 1868, 1, 0, 0, 0, 170, 1879, 1, 0, 0, 0, 172, 1887, 
	1, 0, 0, 0, 174, 1914, 1, 0, 0, 0, 176, 1927, 1, 0, 0, 0, 178, 1929, 1, 
	0, 0, 0, 180, 1935, 1, 0, 0, 0, 182, 1938, 1, 0, 0, 0, 184, 1944, 1, 0, 
	0, 0, 186, 1950, 1, 0, 0, 0, 188, 1957, 1, 0, 0, 0, 190, 1991, 1, 0, 0, 
	0, 192, 1999, 1, 0, 0, 0, 194, 2012, 1, 0, 0, 0, 196, 2017, 1, 0, 0, 0, 
	198, 2028, 1, 0, 0, 0, 200, 2045, 1, 0, 0, 0, 202, 2047, 1, 0, 0, 0, 204, 
	2052, 1, 0, 0, 0, 206, 2059, 1, 0, 0, 0, 208, 2063, 1, 0, 0, 0, 210, 2065, 
	1, 0, 0, 0, 212, 2068, 1, 0, 0, 0, 214, 2082, 1, 0, 0, 0, 216, 2090, 1, 
	0, 0, 0, 218, 2098, 1, 0, 0, 0, 220, 2106, 1, 0, 0, 0, 222, 2121, 1, 0, 
	0, 0, 224, 2123, 1, 0, 0, 0, 226, 2140, 1, 0, 0, 0, 228, 2145, 1, 0, 0, 
	0, 230, 2159, 1, 0, 0, 0, 232, 2161, 1, 0, 0, 0, 234, 2164, 1, 0, 0, 0, 
	236, 2167, 1, 0, 0, 0, 238, 2176, 1, 0, 0, 0, 240, 2196, 1, 0, 0, 0, 242, 
	2198, 1, 0, 0, 0, 244, 2201, 1, 0, 0, 0, 246, 2221, 1, 0, 0, 0, 248, 2223, 
	1, 0, 0, 0, 250, 2227, 1, 0, 0, 0, 252, 2229, 1, 0, 0, 0, 254, 2238, 1, 
	0, 0, 0, 256, 2244, 1, 0, 0, 0, 258, 2250, 1, 0, 0, 0, 260, 2255, 1, 0, 
	0, 0, 262, 2301, 1, 0, 0, 0, 264, 2303, 1, 0, 0, 0, 266, 2306, 1, 0, 0, 
	0, 268, 2314, 1, 0, 0, 0, 270, 2322, 1, 0, 0, 0, 272, 2330, 1, 0, 0, 0, 
	274, 2338, 1, 0, 0, 0, 276, 2340, 1, 0, 0, 0, 278, 2353, 1, 0, 0, 0, 280, 
	2361, 1, 0, 0, 0, 282, 2370, 1, 0, 0, 0, 284, 2372, 1, 0, 0, 0, 286, 2374, 
	1, 0, 0, 0, 288, 2379, 1, 0, 0, 0, 290, 2381, 1, 0, 0, 0, 292, 2385, 1, 
	0, 0, 0, 294, 2391, 1, 0, 0, 0, 296, 2399, 1, 0, 0, 0, 298, 2401, 1, 0, 
	0, 0, 300, 2404, 1, 0, 0, 0, 302, 2411, 1, 0, 0, 0, 304, 2422, 1, 0, 0, 
	0, 306, 2435, 1, 0, 0, 0, 308, 2437, 1, 0, 0, 0, 310, 2445, 1, 0, 0, 0, 
	312, 2449, 1, 0, 0, 0, 314, 2457, 1, 0, 0, 0, 316, 2461, 1, 0, 0, 0, 318, 
	2463, 1, 0, 0, 0, 320, 2465, 1, 0, 0, 0, 322, 2468, 1, 0, 0, 0, 324, 2475, 
	1, 0, 0, 0, 326, 2483, 1, 0, 0, 0, 328, 2488, 1, 0, 0, 0, 330, 2490, 1, 
	0, 0, 0, 332, 2497, 1, 0, 0, 0, 334, 2505, 1, 0, 0, 0, 336, 2509, 1, 0, 
	0, 0, 338, 2511, 1, 0, 0, 0, 340, 2522, 1, 0, 0, 0, 342, 2526, 1, 0, 0, 
	0, 344, 2538, 1, 0, 0, 0, 346, 2546, 1, 0, 0, 0, 348, 2550, 1, 0, 0, 0, 
	350, 2562, 1, 0, 0, 0, 352, 2574, 1, 0, 0, 0, 354, 2579, 1, 0, 0, 0, 356, 
	2584, 1, 0, 0, 0, 358, 2586, 1, 0, 0, 0, 360, 2590, 1, 0, 0, 0, 362, 2594, 
	1, 0, 0, 0, 364, 2601, 1, 0, 0, 0, 366, 2603, 1, 0, 0, 0, 368, 2616, 1, 
	0, 0, 0, 370, 2654, 1, 0, 0, 0, 372, 2656, 1, 0, 0, 0, 374, 2661, 1, 0, 
	0, 0, 376, 2666, 1, 0, 0, 0, 378, 2673, 1, 0, 0, 0, 380, 2678, 1, 0, 0, 
	0, 382, 2683, 1, 0, 0, 0, 384, 2689, 1, 0, 0, 0, 386, 2691, 1, 0, 0, 0, 
	388, 2700, 1, 0, 0, 0, 390, 2712, 1, 0, 0, 0, 392, 2721, 1, 0, 0, 0, 394, 
	2731, 1, 0, 0, 0, 396, 2757, 1, 0, 0, 0, 398, 2759, 1, 0, 0, 0, 400, 2781, 
	1, 0, 0, 0, 402, 2786, 1, 0, 0, 0, 404, 2859, 1, 0, 0, 0, 406, 2861, 1, 
	0, 0, 0, 408, 2893, 1, 0, 0, 0, 410, 2895, 1, 0, 0, 0, 412, 2906, 1, 0, 
	0, 0, 414, 2912, 1, 0, 0, 0, 416, 2918, 1, 0, 0, 0, 418, 2920, 1, 0, 0, 
	0, 420, 2929, 1, 0, 0, 0, 422, 2939, 1, 0, 0, 0, 424, 2941, 1, 0, 0, 0, 
	426, 2955, 1, 0, 0, 0, 428, 2957, 1, 0, 0, 0, 430, 2960, 1, 0, 0, 0, 432, 
	2964, 1, 0, 0, 0, 434, 2966, 1, 0, 0, 0, 436, 2970, 1, 0, 0, 0, 438, 2974, 
	1, 0, 0, 0, 440, 2978, 1, 0, 0, 0, 442, 2985, 1, 0, 0, 0, 444, 2992, 1, 
	0, 0, 0, 446, 3014, 1, 0, 0, 0, 448, 3020, 1, 0, 0, 0, 450, 3035, 1, 0, 
	0, 0, 452, 3042, 1, 0, 0, 0, 454, 3050, 1, 0, 0, 0, 456, 3052, 1, 0, 0, 
	0, 458, 3059, 1, 0, 0, 0, 460, 3063, 1, 0, 0, 0, 462, 3066, 1, 0, 0, 0, 
	464, 3069, 1, 0, 0, 0, 466, 3072, 1, 0, 0, 0, 468, 3115, 1, 0, 0, 0, 470, 
	3131, 1, 0, 0, 0, 472, 3133, 1, 0, 0, 0, 474, 3144, 1, 0, 0, 0, 476, 3148, 
	1, 0, 0, 0, 478, 3152, 1, 0, 0, 0, 480, 3154, 1, 0, 0, 0, 482, 3159, 1, 
	0, 0, 0, 484, 3161, 1, 0, 0, 0, 486, 3166, 1, 0, 0, 0, 488, 3171, 1, 0, 
	0, 0, 490, 3176, 1, 0, 0, 0, 492, 3181, 1, 0, 0, 0, 494, 3187, 1, 0, 0, 
	0, 496, 3196, 1, 0, 0, 0, 498, 3201, 1, 0, 0, 0, 500, 3206, 1, 0, 0, 0, 
	502, 3210, 1, 0, 0, 0, 504, 3230, 1, 0, 0, 0, 506, 3243, 1, 0, 0, 0, 508, 
	3251, 1, 0, 0, 0, 510, 3253, 1, 0, 0, 0, 512, 3262, 1, 0, 0, 0, 514, 3266, 
	1, 0, 0, 0, 516, 3273, 1, 0, 0, 0, 518, 3280, 1, 0, 0, 0, 520, 3287, 1, 
	0, 0, 0, 522, 3290, 1, 0, 0, 0, 524, 3319, 1, 0, 0, 0, 526, 3330, 1, 0, 
	0, 0, 528, 3347, 1, 0, 0, 0, 530, 3349, 1, 0, 0, 0, 532, 3353, 1, 0, 0, 
	0, 534, 3360, 1, 0, 0, 0, 536, 3362, 1, 0, 0, 0, 538, 3367, 1, 0, 0, 0, 
	540, 3371, 1, 0, 0, 0, 542, 3379, 1, 0, 0, 0, 544, 3383, 1, 0, 0, 0, 546, 
	3393, 1, 0, 0, 0, 548, 3395, 1, 0, 0, 0, 550, 3401, 1, 0, 0, 0, 552, 3405, 
	1, 0, 0, 0, 554, 3418, 1, 0, 0, 0, 556, 3420, 1, 0, 0, 0, 558, 3424, 1, 
	0, 0, 0, 560, 3427, 1, 0, 0, 0, 562, 3430, 1, 0, 0, 0, 564, 3447, 1, 0, 
	0, 0, 566, 3451, 1, 0, 0, 0, 568, 3458, 1, 0, 0, 0, 570, 3485, 1, 0, 0, 
	0, 572, 3490, 1, 0, 0, 0, 574, 3492, 1, 0, 0, 0, 576, 3497, 1, 0, 0, 0, 
	578, 3502, 1, 0, 0, 0, 580, 3516, 1, 0, 0, 0, 582, 3641, 1, 0, 0, 0, 584, 
	3643, 1, 0, 0, 0, 586, 3659, 1, 0, 0, 0, 588, 3662, 1, 0, 0, 0, 590, 3665, 
	1, 0, 0, 0, 592, 3668, 1, 0, 0, 0, 594, 3672, 1, 0, 0, 0, 596, 3684, 1, 
	0, 0, 0, 598, 3686, 1, 0, 0, 0, 600, 3688, 1, 0, 0, 0, 602, 3690, 1, 0, 
	0, 0, 604, 3698, 1, 0, 0, 0, 606, 3706, 1, 0, 0, 0, 608, 3718, 1, 0, 0, 
	0, 610, 3752, 1, 0, 0, 0, 612, 3754, 1, 0, 0, 0, 614, 3772, 1, 0, 0, 0, 
	616, 3781, 1, 0, 0, 0, 618, 3786, 1, 0, 0, 0, 620, 3790, 1, 0, 0, 0, 622, 
	3806, 1, 0, 0, 0, 624, 3865, 1, 0, 0, 0, 626, 3867, 1, 0, 0, 0, 628, 3869, 
	1, 0, 0, 0, 630, 3889, 1, 0, 0, 0, 632, 3900, 1, 0, 0, 0, 634, 3902, 1, 
	0, 0, 0, 636, 3918, 1, 0, 0, 0, 638, 3930, 1, 0, 0, 0, 640, 3948, 1, 0, 
	0, 0, 642, 3953, 1, 0, 0, 0, 644, 3957, 1, 0, 0, 0, 646, 3976, 1, 0, 0, 
	0, 648, 3981, 1, 0, 0, 0, 650, 3983, 1, 0, 0, 0, 652, 4011, 1, 0, 0, 0, 
	654, 4014, 1, 0, 0, 0, 656, 4016, 1, 0, 0, 0, 658, 4018, 1, 0, 0, 0, 660, 
	4037, 1, 0, 0, 0, 662, 4039, 1, 0, 0, 0, 664, 4041, 1, 0, 0, 0, 666, 4045, 
	1, 0, 0, 0, 668, 4079, 1, 0, 0, 0, 670, 4081, 1, 0, 0, 0, 672, 4083, 1, 
	0, 0, 0, 674, 4091, 1, 0, 0, 0, 676, 4135, 1, 0, 0, 0, 678, 4137, 1, 0, 
	0, 0, 680, 4162, 1, 0, 0, 0, 682, 4164, 1, 0, 0, 0, 684, 4172, 1, 0, 0, 
	0, 686, 4181, 1, 0, 0, 0, 688, 4197, 1, 0, 0, 0, 690, 4201, 1, 0, 0, 0, 
	692, 4203, 1, 0, 0, 0, 694, 4212, 1, 0, 0, 0, 696, 4227, 1, 0, 0, 0, 698, 
	4233, 1, 0, 0, 0, 700, 4235, 1, 0, 0, 0, 702, 4242, 1, 0, 0, 0, 704, 4244, 
	1, 0, 0, 0, 706, 4249, 1, 0, 0, 0, 708, 4262, 1, 0, 0, 0, 710, 4286, 1, 
	0, 0, 0, 712, 4288, 1, 0, 0, 0, 714, 4301, 1, 0, 0, 0, 716, 4303, 1, 0, 
	0, 0, 718, 4306, 1, 0, 0, 0, 720, 4309, 1, 0, 0, 0, 722, 4311, 1, 0, 0, 
	0, 724, 4315, 1, 0, 0, 0, 726, 4321, 1, 0, 0, 0, 728, 4327, 1, 0, 0, 0, 
	730, 4329, 1, 0, 0, 0, 732, 4343, 1, 0, 0, 0, 734, 4352, 1, 0, 0, 0, 736, 
	4354, 1, 0, 0, 0, 738, 4365, 1, 0, 0, 0, 740, 4373, 1, 0, 0, 0, 742, 4383, 
	1, 0, 0, 0, 744, 4387, 1, 0, 0, 0, 746, 4391, 1, 0, 0, 0, 748, 4395, 1, 
	0, 0, 0, 750, 4401, 1, 0, 0, 0, 752, 4455, 1, 0, 0, 0, 754, 4461, 1, 0, 
	0, 0, 756, 4465, 1, 0, 0, 0, 758, 4467, 1, 0, 0, 0, 760, 4478, 1, 0, 0, 
	0, 762, 4495, 1, 0, 0, 0, 764, 4511, 1, 0, 0, 0, 766, 4520, 1, 0, 0, 0, 
	768, 4522, 1, 0, 0, 0, 770, 4529, 1, 0, 0, 0, 772, 4544, 1, 0, 0, 0, 774, 
	4546, 1, 0, 0, 0, 776, 4548, 1, 0, 0, 0, 778, 4550, 1, 0, 0, 0, 780, 4556, 
	1, 0, 0, 0, 782, 4562, 1, 0, 0, 0, 784, 4567, 1, 0, 0, 0, 786, 4569, 1, 
	0, 0, 0, 788, 4572, 1, 0, 0, 0, 790, 4574, 1, 0, 0, 0, 792, 4592, 1, 0, 
	0, 0, 794, 4606, 1, 0, 0, 0, 796, 4608, 1, 0, 0, 0, 798, 4621, 1, 0, 0, 
	0, 800, 4623, 1, 0, 0, 0, 802, 4635, 1, 0, 0, 0, 804, 4640, 1, 0, 0, 0, 
	806, 4645, 1, 0, 0, 0, 808, 4647, 1, 0, 0, 0, 810, 4656, 1, 0, 0, 0, 812, 
	4658, 1, 0, 0, 0, 814, 4667, 1, 0, 0, 0, 816, 4669, 1, 0, 0, 0, 818, 4678, 
	1, 0, 0, 0, 820, 4680, 1, 0, 0, 0, 822, 4689, 1, 0, 0, 0, 824, 4691, 1, 
	0, 0, 0, 826, 4700, 1, 0, 0, 0, 828, 4702, 1, 0, 0, 0, 830, 4711, 1, 0, 
	0, 0, 832, 4718, 1, 0, 0, 0, 834, 4720, 1, 0, 0, 0, 836, 4727, 1, 0, 0, 
	0, 838, 4729, 1, 0, 0, 0, 840, 4739, 1, 0, 0, 0, 842, 4752, 1, 0, 0, 0, 
	844, 4754, 1, 0, 0, 0, 846, 4758, 1, 0, 0, 0, 848, 4762, 1, 0, 0, 0, 850, 
	4768, 1, 0, 0, 0, 852, 4770, 1, 0, 0, 0, 854, 4781, 1, 0, 0, 0, 856, 4783, 
	1, 0, 0, 0, 858, 4807, 1, 0, 0, 0, 860, 4809, 1, 0, 0, 0, 862, 4814, 1, 
	0, 0, 0, 864, 4819, 1, 0, 0, 0, 866, 4824, 1, 0, 0, 0, 868, 4826, 1, 0, 
	0, 0, 870, 4835, 1, 0, 0, 0, 872, 4837, 1, 0, 0, 0, 874, 4846, 1, 0, 0, 
	0, 876, 4848, 1, 0, 0, 0, 878, 4850, 1, 0, 0, 0, 880, 4854, 1, 0, 0, 0, 
	882, 4866, 1, 0, 0, 0, 884, 4871, 1, 0, 0, 0, 886, 4882, 1, 0, 0, 0, 888, 
	4888, 1, 0, 0, 0, 890, 4890, 1, 0, 0, 0, 892, 4892, 1, 0, 0, 0, 894, 4897, 
	1, 0, 0, 0, 896, 4901, 1, 0, 0, 0, 898, 4903, 1, 0, 0, 0, 900, 4908, 1, 
	0, 0, 0, 902, 4910, 1, 0, 0, 0, 904, 4912, 1, 0, 0, 0, 906, 4914, 1, 0, 
	0, 0, 908, 4917, 1, 0, 0, 0, 910, 4925, 1, 0, 0, 0, 912, 4932, 1, 0, 0, 
	0, 914, 4934, 1, 0, 0, 0, 916, 4942, 1, 0, 0, 0, 918, 4944, 1, 0, 0, 0, 
	920, 4949, 1, 0, 0, 0, 922, 4954, 1, 0, 0, 0, 924, 4976, 1, 0, 0, 0, 926, 
	4985, 1, 0, 0, 0, 928, 4987, 1, 0, 0, 0, 930, 4998, 1, 0, 0, 0, 932, 5000, 
	1, 0, 0, 0, 934, 5008, 1, 0, 0, 0, 936, 5025, 1, 0, 0, 0, 938, 5028, 1, 
	0, 0, 0, 940, 5032, 1, 0, 0, 0, 942, 5034, 1, 0, 0, 0, 944, 5036, 1, 0, 
	0, 0, 946, 5038, 1, 0, 0, 0, 948, 5061, 1, 0, 0, 0, 950, 5065, 1, 0, 0, 
	0, 952, 5079, 1, 0, 0, 0, 954, 5087, 1, 0, 0, 0, 956, 5095, 1, 0, 0, 0, 
	958, 5097, 1, 0, 0, 0, 960, 5100, 1, 0, 0, 0, 962, 5108, 1, 0, 0, 0, 964, 
	5116, 1, 0, 0, 0, 966, 5120, 1, 0, 0, 0, 968, 5122, 1, 0, 0, 0, 970, 5128, 
	1, 0, 0, 0, 972, 5130, 1, 0, 0, 0, 974, 5133, 1, 0, 0, 0, 976, 5143, 1, 
	0, 0, 0, 978, 5166, 1, 0, 0, 0, 980, 5184, 1, 0, 0, 0, 982, 5186, 1, 0, 
	0, 0, 984, 5194, 1, 0, 0, 0, 986, 5202, 1, 0, 0, 0, 988, 5216, 1, 0, 0, 
	0, 990, 5222, 1, 0, 0, 0, 992, 5238, 1, 0, 0, 0, 994, 5254, 1, 0, 0, 0, 
	996, 999, 3, 2, 1, 0, 997, 999, 3, 10, 5, 0, 998, 996, 1, 0, 0, 0, 998, 
	997, 1, 0, 0, 0, 999, 1000, 1, 0, 0, 0, 1000, 1001, 5, 0, 0, 1, 1001, 1, 
	1, 0, 0, 0, 1002, 1012, 5, 114, 0, 0, 1003, 1005, 3, 4, 2, 0, 1004, 1003, 
	1, 0, 0, 0, 1005, 1008, 1, 0, 0, 0, 1006, 1004, 1, 0, 0, 0, 1006, 1007, 
	1, 0, 0, 0, 1007, 1009, 1, 0, 0, 0, 1008, 1006, 1, 0, 0, 0, 1009, 1013, 
	3, 10, 5, 0, 1010, 1011, 5, 274, 0, 0, 1011, 1013, 3, 382, 191, 0, 1012, 
	1006, 1, 0, 0, 0, 1012, 1010, 1, 0, 0, 0, 1013, 3, 1, 0, 0, 0, 1014, 1037, 
	5, 117, 0, 0, 1015, 1037, 5, 133, 0, 0, 1016, 1037, 5, 85, 0, 0, 1017, 
	1019, 5, 37, 0, 0, 1018, 1020, 7, 0, 0, 0, 1019, 1018, 1, 0, 0, 0, 1019, 
	1020, 1, 0, 0, 0, 1020, 1037, 1, 0, 0, 0, 1021, 1037, 5, 184, 0, 0, 1022, 
	1037, 5, 21, 0, 0, 1023, 1037, 5, 10, 0, 0, 1024, 1037, 5, 265, 0, 0, 1025, 
	1037, 5, 183, 0, 0, 1026, 1037, 5, 19, 0, 0, 1027, 1029, 5, 366, 0, 0, 
	1028, 1030, 3, 6, 3, 0, 1029, 1028, 1, 0, 0, 0, 1029, 1030, 1, 0, 0, 0, 
	1030, 1032, 1, 0, 0, 0, 1031, 1033, 3, 8, 4, 0, 1032, 1031, 1, 0, 0, 0, 
	1032, 1033, 1, 0, 0, 0, 1033, 1037, 1, 0, 0, 0, 1034, 1037, 5, 78, 0, 0, 
	1035, 1037, 5, 77, 0, 0, 1036, 1014, 1, 0, 0, 0, 1036, 1015, 1, 0, 0, 0, 
	1036, 1016, 1, 0, 0, 0, 1036, 1017, 1, 0, 0, 0, 1036, 1021, 1, 0, 0, 0, 
	1036, 1022, 1, 0, 0, 0, 1036, 1023, 1, 0, 0, 0, 1036, 1024, 1, 0, 0, 0, 
	1036, 1025, 1, 0, 0, 0, 1036, 1026, 1, 0, 0, 0, 1036, 1027, 1, 0, 0, 0, 
	1036, 1034, 1, 0, 0, 0, 1036, 1035, 1, 0, 0, 0, 1037, 5, 1, 0, 0, 0, 1038, 
	1039, 5, 215, 0, 0, 1039, 7, 1, 0, 0, 0, 1040, 1041, 7, 1, 0, 0, 1041, 
	9, 1, 0, 0, 0, 1042, 1057, 3, 382, 191, 0, 1043, 1057, 3, 12, 6, 0, 1044, 
	1057, 3, 16, 8, 0, 1045, 1057, 3, 18, 9, 0, 1046, 1057, 3, 20, 10, 0, 1047, 
	1057, 3, 24, 12, 0, 1048, 1057, 3, 32, 16, 0, 1049, 1057, 3, 34, 17, 0, 
	1050, 1057, 3, 412, 206, 0, 1051, 1057, 3, 420, 210, 0, 1052, 1057, 3, 
	422, 211, 0, 1053, 1057, 3, 444, 222, 0, 1054, 1057, 3, 918, 459, 0, 1055, 
	1057, 3, 920, 460, 0, 1056, 1042, 1, 0, 0, 0, 1056, 1043, 1, 0, 0, 0, 1056, 
	1044, 1, 0, 0, 0, 1056, 1045, 1, 0, 0, 0, 1056, 1046, 1, 0, 0, 0, 1056, 
	1047, 1, 0, 0, 0, 1056, 1048, 1, 0, 0, 0, 1056, 1049, 1, 0, 0, 0, 1056, 
	1050, 1, 0, 0, 0, 1056, 1051, 1, 0, 0, 0, 1056, 1052, 1, 0, 0, 0, 1056, 
	1053, 1, 0, 0, 0, 1056, 1054, 1, 0, 0, 0, 1056, 1055, 1, 0, 0, 0, 1057, 
	11, 1, 0, 0, 0, 1058, 1059, 5, 179, 0, 0, 1059, 1061, 5, 66, 0, 0, 1060, 
	1062, 5, 180, 0, 0, 1061, 1060, 1, 0, 0, 0, 1061, 1062, 1, 0, 0, 0, 1062, 
	1063, 1, 0, 0, 0, 1063, 1064, 5, 152, 0, 0, 1064, 1066, 5, 412, 0, 0, 1065, 
	1067, 5, 225, 0, 0, 1066, 1065, 1, 0, 0, 0, 1066, 1067, 1, 0, 0, 0, 1067, 
	1068, 1, 0, 0, 0, 1068, 1069, 5, 159, 0, 0, 1069, 1070, 5, 318, 0, 0, 1070, 
	1072, 3, 878, 439, 0, 1071, 1073, 3, 74, 37, 0, 1072, 1071, 1, 0, 0, 0, 
	1072, 1073, 1, 0, 0, 0, 1073, 13, 1, 0, 0, 0, 1074, 1076, 5, 129, 0, 0, 
	1075, 1077, 5, 196, 0, 0, 1076, 1075, 1, 0, 0, 0, 1076, 1077, 1, 0, 0, 
	0, 1077, 1078, 1, 0, 0, 0, 1078, 1079, 5, 269, 0, 0, 1079, 1080, 5, 386, 
	0, 0, 1080, 1081, 5, 412, 0, 0, 1081, 1082, 5, 387, 0, 0, 1082, 15, 1, 
	0, 0, 0, 1083, 1084, 5, 115, 0, 0, 1084, 1085, 5, 318, 0, 0, 1085, 1086, 
	3, 878, 439, 0, 1086, 1087, 5, 330, 0, 0, 1087, 1089, 5, 412, 0, 0, 1088, 
	1090, 3, 14, 7, 0, 1089, 1088, 1, 0, 0, 0, 1089, 1090, 1, 0, 0, 0, 1090, 
	17, 1, 0, 0, 0, 1091, 1097, 5, 147, 0, 0, 1092, 1094, 5, 118, 0, 0, 1093, 
	1092, 1, 0, 0, 0, 1093, 1094, 1, 0, 0, 0, 1094, 1095, 1, 0, 0, 0, 1095, 
	1096, 5, 318, 0, 0, 1096, 1098, 3, 878, 439, 0, 1097, 1093, 1, 0, 0, 0, 
	1097, 1098, 1, 0, 0, 0, 1098, 1099, 1, 0, 0, 0, 1099, 1100, 5, 134, 0, 
	0, 1100, 1102, 5, 412, 0, 0, 1101, 1103, 3, 264, 132, 0, 1102, 1101, 1, 
	0, 0, 0, 1102, 1103, 1, 0, 0, 0, 1103, 19, 1, 0, 0, 0, 1104, 1105, 5, 267, 
	0, 0, 1105, 1106, 5, 99, 0, 0, 1106, 1109, 3, 22, 11, 0, 1107, 1108, 5, 
	268, 0, 0, 1108, 1110, 3, 22, 11, 0, 1109, 1107, 1, 0, 0, 0, 1109, 1110, 
	1, 0, 0, 0, 1110, 1113, 1, 0, 0, 0, 1111, 1112, 5, 375, 0, 0, 1112, 1114, 
	3, 26, 13, 0, 1113, 1111, 1, 0, 0, 0, 1113, 1114, 1, 0, 0, 0, 1114, 21, 
	1, 0, 0, 0, 1115, 1118, 3, 896, 448, 0, 1116, 1117, 5, 382, 0, 0, 1117, 
	1119, 3, 30, 15, 0, 1118, 1116, 1, 0, 0, 0, 1118, 1119, 1, 0, 0, 0, 1119, 
	23, 1, 0, 0, 0, 1120, 1121, 5, 267, 0, 0, 1121, 1122, 5, 179, 0, 0, 1122, 
	1125, 3, 22, 11, 0, 1123, 1124, 5, 159, 0, 0, 1124, 1126, 3, 896, 448, 
	0, 1125, 1123, 1, 0, 0, 0, 1125, 1126, 1, 0, 0, 0, 1126, 1129, 1, 0, 0, 
	0, 1127, 1128, 5, 375, 0, 0, 1128, 1130, 3, 26, 13, 0, 1129, 1127, 1, 0, 
	0, 0, 1129, 1130, 1, 0, 0, 0, 1130, 25, 1, 0, 0, 0, 1131, 1132, 5, 386, 
	0, 0, 1132, 1133, 3, 28, 14, 0, 1133, 1134, 5, 387, 0, 0, 1134, 27, 1, 
	0, 0, 0, 1135, 1140, 3, 248, 124, 0, 1136, 1137, 5, 384, 0, 0, 1137, 1139, 
	3, 248, 124, 0, 1138, 1136, 1, 0, 0, 0, 1139, 1142, 1, 0, 0, 0, 1140, 1138, 
	1, 0, 0, 0, 1140, 1141, 1, 0, 0, 0, 1141, 29, 1, 0, 0, 0, 1142, 1140, 1, 
	0, 0, 0, 1143, 1146, 5, 412, 0, 0, 1144, 1145, 5, 382, 0, 0, 1145, 1147, 
	5, 412, 0, 0, 1146, 1144, 1, 0, 0, 0, 1146, 1147, 1, 0, 0, 0, 1147, 31, 
	1, 0, 0, 0, 1148, 1149, 5, 267, 0, 0, 1149, 1150, 5, 309, 0, 0, 1150, 1153, 
	3, 896, 448, 0, 1151, 1152, 5, 375, 0, 0, 1152, 1154, 3, 26, 13, 0, 1153, 
	1151, 1, 0, 0, 0, 1153, 1154, 1, 0, 0, 0, 1154, 33, 1, 0, 0, 0, 1155, 1201, 
	3, 52, 26, 0, 1156, 1201, 3, 64, 32, 0, 1157, 1201, 3, 66, 33, 0, 1158, 
	1201, 3, 582, 291, 0, 1159, 1201, 3, 72, 36, 0, 1160, 1201, 3, 70, 35, 
	0, 1161, 1201, 3, 466, 233, 0, 1162, 1201, 3, 82, 41, 0, 1163, 1201, 3, 
	90, 45, 0, 1164, 1201, 3, 154, 77, 0, 1165, 1201, 3, 172, 86, 0, 1166, 
	1201, 3, 188, 94, 0, 1167, 1201, 3, 192, 96, 0, 1168, 1201, 3, 196, 98, 
	0, 1169, 1201, 3, 194, 97, 0, 1170, 1201, 3, 186, 93, 0, 1171, 1201, 3, 
	190, 95, 0, 1172, 1201, 3, 162, 81, 0, 1173, 1201, 3, 168, 84, 0, 1174, 
	1201, 3, 164, 82, 0, 1175, 1201, 3, 166, 83, 0, 1176, 1201, 3, 170, 85, 
	0, 1177, 1201, 3, 84, 42, 0, 1178, 1201, 3, 94, 47, 0, 1179, 1201, 3, 100, 
	50, 0, 1180, 1201, 3, 96, 48, 0, 1181, 1201, 3, 102, 51, 0, 1182, 1201, 
	3, 104, 52, 0, 1183, 1201, 3, 106, 53, 0, 1184, 1201, 3, 108, 54, 0, 1185, 
	1201, 3, 110, 55, 0, 1186, 1201, 3, 124, 62, 0, 1187, 1201, 3, 116, 58, 
	0, 1188, 1201, 3, 126, 63, 0, 1189, 1201, 3, 118, 59, 0, 1190, 1201, 3, 
	112, 56, 0, 1191, 1201, 3, 114, 57, 0, 1192, 1201, 3, 122, 61, 0, 1193, 
	1201, 3, 120, 60, 0, 1194, 1201, 3, 440, 220, 0, 1195, 1201, 3, 442, 221, 
	0, 1196, 1201, 3, 456, 228, 0, 1197, 1201, 3, 924, 462, 0, 1198, 1201, 
	3, 584, 292, 0, 1199, 1201, 3, 594, 297, 0, 1200, 1155, 1, 0, 0, 0, 1200, 
	1156, 1, 0, 0, 0, 1200, 1157, 1, 0, 0, 0, 1200, 1158, 1, 0, 0, 0, 1200, 
	1159, 1, 0, 0, 0, 1200, 1160, 1, 0, 0, 0, 1200, 1161, 1, 0, 0, 0, 1200, 
	1162, 1, 0, 0, 0, 1200, 1163, 1, 0, 0, 0, 1200, 1164, 1, 0, 0, 0, 1200, 
	1165, 1, 0, 0, 0, 1200, 1166, 1, 0, 0, 0, 1200, 1167, 1, 0, 0, 0, 1200, 
	1168, 1, 0, 0, 0, 1200, 1169, 1, 0, 0, 0, 1200, 1170, 1, 0, 0, 0, 1200, 
	1171, 1, 0, 0, 0, 1200, 1172, 1, 0, 0, 0, 1200, 1173, 1, 0, 0, 0, 1200, 
	1174, 1, 0, 0, 0, 1200, 1175, 1, 0, 0, 0, 1200, 1176, 1, 0, 0, 0, 1200, 
	1177, 1, 0, 0, 0, 1200, 1178, 1, 0, 0, 0, 1200, 1179, 1, 0, 0, 0, 1200, 
	1180, 1, 0, 0, 0, 1200, 1181, 1, 0, 0, 0, 1200, 1182, 1, 0, 0, 0, 1200, 
	1183, 1, 0, 0, 0, 1200, 1184, 1, 0, 0, 0, 1200, 1185, 1, 0, 0, 0, 1200, 
	1186, 1, 0, 0, 0, 1200, 1187, 1, 0, 0, 0, 1200, 1188, 1, 0, 0, 0, 1200, 
	1189, 1, 0, 0, 0, 1200, 1190, 1, 0, 0, 0, 1200, 1191, 1, 0, 0, 0, 1200, 
	1192, 1, 0, 0, 0, 1200, 1193, 1, 0, 0, 0, 1200, 1194, 1, 0, 0, 0, 1200, 
	1195, 1, 0, 0, 0, 1200, 1196, 1, 0, 0, 0, 1200, 1197, 1, 0, 0, 0, 1200, 
	1198, 1, 0, 0, 0, 1200, 1199, 1, 0, 0, 0, 1201, 35, 1, 0, 0, 0, 1202, 1203, 
	5, 145, 0, 0, 1203, 1204, 5, 112, 0, 0, 1204, 37, 1, 0, 0, 0, 1205, 1206, 
	7, 2, 0, 0, 1206, 39, 1, 0, 0, 0, 1207, 1208, 5, 145, 0, 0, 1208, 1209, 
	5, 206, 0, 0, 1209, 1210, 5, 112, 0, 0, 1210, 41, 1, 0, 0, 0, 1211, 1212, 
	5, 130, 0, 0, 1212, 43, 1, 0, 0, 0, 1213, 1214, 5, 102, 0, 0, 1214, 1215, 
	5, 274, 0, 0, 1215, 45, 1, 0, 0, 0, 1216, 1217, 5, 91, 0, 0, 1217, 1218, 
	5, 274, 0, 0, 1218, 47, 1, 0, 0, 0, 1219, 1220, 5, 310, 0, 0, 1220, 1221, 
	5, 17, 0, 0, 1221, 1222, 5, 89, 0, 0, 1222, 49, 1, 0, 0, 0, 1223, 1224, 
	5, 218, 0, 0, 1224, 1225, 5, 268, 0, 0, 1225, 51, 1, 0, 0, 0, 1226, 1227, 
	5, 58, 0, 0, 1227, 1229, 3, 88, 44, 0, 1228, 1230, 3, 40, 20, 0, 1229, 
	1228, 1, 0, 0, 0, 1229, 1230, 1, 0, 0, 0, 1230, 1231, 1, 0, 0, 0, 1231, 
	1233, 3, 896, 448, 0, 1232, 1234, 3, 68, 34, 0, 1233, 1232, 1, 0, 0, 0, 
	1233, 1234, 1, 0, 0, 0, 1234, 1236, 1, 0, 0, 0, 1235, 1237, 3, 54, 27, 
	0, 1236, 1235, 1, 0, 0, 0, 1236, 1237, 1, 0, 0, 0, 1237, 1239, 1, 0, 0, 
	0, 1238, 1240, 3, 56, 28, 0, 1239, 1238, 1, 0, 0, 0, 1239, 1240, 1, 0, 
	0, 0, 1240, 1244, 1, 0, 0, 0, 1241, 1242, 5, 375, 0, 0, 1242, 1243, 5, 
	75, 0, 0, 1243, 1245, 3, 58, 29, 0, 1244, 1241, 1, 0, 0, 0, 1244, 1245, 
	1, 0, 0, 0, 1245, 1263, 1, 0, 0, 0, 1246, 1247, 5, 58, 0, 0, 1247, 1248, 
	5, 263, 0, 0, 1248, 1250, 3, 88, 44, 0, 1249, 1251, 3, 40, 20, 0, 1250, 
	1249, 1, 0, 0, 0, 1250, 1251, 1, 0, 0, 0, 1251, 1252, 1, 0, 0, 0, 1252, 
	1254, 3, 896, 448, 0, 1253, 1255, 3, 68, 34, 0, 1254, 1253, 1, 0, 0, 0, 
	1254, 1255, 1, 0, 0, 0, 1255, 1256, 1, 0, 0, 0, 1256, 1260, 3, 62, 31, 
	0, 1257, 1258, 5, 375, 0, 0, 1258, 1259, 5, 75, 0, 0, 1259, 1261, 3, 58, 
	29, 0, 1260, 1257, 1, 0, 0, 0, 1260, 1261, 1, 0, 0, 0, 1261, 1263, 1, 0, 
	0, 0, 1262, 1226, 1, 0, 0, 0, 1262, 1246, 1, 0, 0, 0, 1263, 53, 1, 0, 0, 
	0, 1264, 1265, 5, 181, 0, 0, 1265, 1266, 5, 412, 0, 0, 1266, 55, 1, 0, 
	0, 0, 1267, 1268, 5, 188, 0, 0, 1268, 1269, 5, 412, 0, 0, 1269, 57, 1, 
	0, 0, 0, 1270, 1271, 5, 386, 0, 0, 1271, 1272, 3, 60, 30, 0, 1272, 1273, 
	5, 387, 0, 0, 1273, 59, 1, 0, 0, 0, 1274, 1279, 3, 248, 124, 0, 1275, 1276, 
	5, 384, 0, 0, 1276, 1278, 3, 248, 124, 0, 1277, 1275, 1, 0, 0, 0, 1278, 
	1281, 1, 0, 0, 0, 1279, 1277, 1, 0, 0, 0, 1279, 1280, 1, 0, 0, 0, 1280, 
	61, 1, 0, 0, 0, 1281, 1279, 1, 0, 0, 0, 1282, 1283, 5, 359, 0, 0, 1283, 
	1284, 3, 896, 448, 0, 1284, 63, 1, 0, 0, 0, 1285, 1286, 5, 357, 0, 0, 1286, 
	1287, 3, 896, 448, 0, 1287, 65, 1, 0, 0, 0, 1288, 1289, 5, 98, 0, 0, 1289, 
	1291, 3, 88, 44, 0, 1290, 1292, 3, 36, 18, 0, 1291, 1290, 1, 0, 0, 0, 1291, 
	1292, 1, 0, 0, 0, 1292, 1293, 1, 0, 0, 0, 1293, 1295, 3, 896, 448, 0, 1294, 
	1296, 3, 38, 19, 0, 1295, 1294, 1, 0, 0, 0, 1295, 1296, 1, 0, 0, 0, 1296, 
	67, 1, 0, 0, 0, 1297, 1298, 5, 47, 0, 0, 1298, 1299, 5, 412, 0, 0, 1299, 
	69, 1, 0, 0, 0, 1300, 1302, 5, 340, 0, 0, 1301, 1303, 5, 318, 0, 0, 1302, 
	1301, 1, 0, 0, 0, 1302, 1303, 1, 0, 0, 0, 1303, 1304, 1, 0, 0, 0, 1304, 
	1310, 3, 530, 265, 0, 1305, 1306, 5, 46, 0, 0, 1306, 1307, 5, 386, 0, 0, 
	1307, 1308, 3, 272, 136, 0, 1308, 1309, 5, 387, 0, 0, 1309, 1311, 1, 0, 
	0, 0, 1310, 1305, 1, 0, 0, 0, 1310, 1311, 1, 0, 0, 0, 1311, 1313, 1, 0, 
	0, 0, 1312, 1314, 3, 42, 21, 0, 1313, 1312, 1, 0, 0, 0, 1313, 1314, 1, 
	0, 0, 0, 1314, 71, 1, 0, 0, 0, 1315, 1316, 5, 98, 0, 0, 1316, 1318, 5, 
	318, 0, 0, 1317, 1319, 3, 36, 18, 0, 1318, 1317, 1, 0, 0, 0, 1318, 1319, 
	1, 0, 0, 0, 1319, 1320, 1, 0, 0, 0, 1320, 1322, 3, 640, 320, 0, 1321, 1323, 
	5, 245, 0, 0, 1322, 1321, 1, 0, 0, 0, 1322, 1323, 1, 0, 0, 0, 1323, 1325, 
	1, 0, 0, 0, 1324, 1326, 3, 14, 7, 0, 1325, 1324, 1, 0, 0, 0, 1325, 1326, 
	1, 0, 0, 0, 1326, 73, 1, 0, 0, 0, 1327, 1328, 5, 154, 0, 0, 1328, 1329, 
	5, 412, 0, 0, 1329, 1330, 5, 290, 0, 0, 1330, 1331, 5, 412, 0, 0, 1331, 
	75, 1, 0, 0, 0, 1332, 1335, 3, 896, 448, 0, 1333, 1334, 5, 382, 0, 0, 1334, 
	1336, 3, 896, 448, 0, 1335, 1333, 1, 0, 0, 0, 1335, 1336, 1, 0, 0, 0, 1336, 
	1350, 1, 0, 0, 0, 1337, 1347, 3, 896, 448, 0, 1338, 1343, 5, 382, 0, 0, 
	1339, 1344, 5, 100, 0, 0, 1340, 1344, 5, 168, 0, 0, 1341, 1344, 5, 364, 
	0, 0, 1342, 1344, 3, 896, 448, 0, 1343, 1339, 1, 0, 0, 0, 1343, 1340, 1, 
	0, 0, 0, 1343, 1341, 1, 0, 0, 0, 1343, 1342, 1, 0, 0, 0, 1344, 1346, 1, 
	0, 0, 0, 1345, 1338, 1, 0, 0, 0, 1346, 1349, 1, 0, 0, 0, 1347, 1345, 1, 
	0, 0, 0, 1347, 1348, 1, 0, 0, 0, 1348, 1351, 1, 0, 0, 0, 1349, 1347, 1, 
	0, 0, 0, 1350, 1337, 1, 0, 0, 0, 1350, 1351, 1, 0, 0, 0, 1351, 77, 1, 0, 
	0, 0, 1352, 1354, 3, 76, 38, 0, 1353, 1355, 3, 880, 440, 0, 1354, 1353, 
	1, 0, 0, 0, 1354, 1355, 1, 0, 0, 0, 1355, 79, 1, 0, 0, 0, 1356, 1358, 3, 
	640, 320, 0, 1357, 1359, 3, 880, 440, 0, 1358, 1357, 1, 0, 0, 0, 1358, 
	1359, 1, 0, 0, 0, 1359, 1361, 1, 0, 0, 0, 1360, 1362, 3, 276, 138, 0, 1361, 
	1360, 1, 0, 0, 0, 1361, 1362, 1, 0, 0, 0, 1362, 81, 1, 0, 0, 0, 1363, 1386, 
	7, 3, 0, 0, 1364, 1366, 3, 88, 44, 0, 1365, 1367, 5, 117, 0, 0, 1366, 1365, 
	1, 0, 0, 0, 1366, 1367, 1, 0, 0, 0, 1367, 1368, 1, 0, 0, 0, 1368, 1369, 
	3, 896, 448, 0, 1369, 1387, 1, 0, 0, 0, 1370, 1372, 5, 69, 0, 0, 1371, 
	1373, 5, 117, 0, 0, 1372, 1371, 1, 0, 0, 0, 1372, 1373, 1, 0, 0, 0, 1373, 
	1374, 1, 0, 0, 0, 1374, 1387, 3, 896, 448, 0, 1375, 1377, 5, 136, 0, 0, 
	1376, 1378, 5, 117, 0, 0, 1377, 1376, 1, 0, 0, 0, 1377, 1378, 1, 0, 0, 
	0, 1378, 1379, 1, 0, 0, 0, 1379, 1387, 3, 894, 447, 0, 1380, 1383, 5, 133, 
	0, 0, 1381, 1383, 5, 117, 0, 0, 1382, 1380, 1, 0, 0, 0, 1382, 1381, 1, 
	0, 0, 0, 1383, 1384, 1, 0, 0, 0, 1384, 1387, 3, 80, 40, 0, 1385, 1387, 
	3, 80, 40, 0, 1386, 1364, 1, 0, 0, 0, 1386, 1370, 1, 0, 0, 0, 1386, 1375, 
	1, 0, 0, 0, 1386, 1382, 1, 0, 0, 0, 1386, 1385, 1, 0, 0, 0, 1387, 83, 1, 
	0, 0, 0, 1388, 1389, 5, 10, 0, 0, 1389, 1390, 5, 318, 0, 0, 1390, 1403, 
	3, 878, 439, 0, 1391, 1392, 5, 52, 0, 0, 1392, 1399, 5, 308, 0, 0, 1393, 
	1400, 5, 205, 0, 0, 1394, 1395, 5, 129, 0, 0, 1395, 1397, 5, 46, 0, 0, 
	1396, 1398, 3, 272, 136, 0, 1397, 1396, 1, 0, 0, 0, 1397, 1398, 1, 0, 0, 
	0, 1398, 1400, 1, 0, 0, 0, 1399, 1393, 1, 0, 0, 0, 1399, 1394, 1, 0, 0, 
	0, 1399, 1400, 1, 0, 0, 0, 1400, 1404, 1, 0, 0, 0, 1401, 1402, 5, 33, 0, 
	0, 1402, 1404, 5, 196, 0, 0, 1403, 1391, 1, 0, 0, 0, 1403, 1401, 1, 0, 
	0, 0, 1404, 85, 1, 0, 0, 0, 1405, 1406, 7, 4, 0, 0, 1406, 87, 1, 0, 0, 
	0, 1407, 1408, 7, 5, 0, 0, 1408, 89, 1, 0, 0, 0, 1409, 1410, 5, 297, 0, 
	0, 1410, 1413, 7, 6, 0, 0, 1411, 1412, 5, 176, 0, 0, 1412, 1414, 3, 208, 
	104, 0, 1413, 1411, 1, 0, 0, 0, 1413, 1414, 1, 0, 0, 0, 1414, 1591, 1, 
	0, 0, 0, 1415, 1417, 5, 297, 0, 0, 1416, 1418, 5, 117, 0, 0, 1417, 1416, 
	1, 0, 0, 0, 1417, 1418, 1, 0, 0, 0, 1418, 1419, 1, 0, 0, 0, 1419, 1423, 
	5, 319, 0, 0, 1420, 1421, 3, 86, 43, 0, 1421, 1422, 3, 896, 448, 0, 1422, 
	1424, 1, 0, 0, 0, 1423, 1420, 1, 0, 0, 0, 1423, 1424, 1, 0, 0, 0, 1424, 
	1426, 1, 0, 0, 0, 1425, 1427, 3, 92, 46, 0, 1426, 1425, 1, 0, 0, 0, 1426, 
	1427, 1, 0, 0, 0, 1427, 1591, 1, 0, 0, 0, 1428, 1429, 5, 297, 0, 0, 1429, 
	1433, 5, 368, 0, 0, 1430, 1431, 3, 86, 43, 0, 1431, 1432, 3, 896, 448, 
	0, 1432, 1434, 1, 0, 0, 0, 1433, 1430, 1, 0, 0, 0, 1433, 1434, 1, 0, 0, 
	0, 1434, 1438, 1, 0, 0, 0, 1435, 1436, 5, 176, 0, 0, 1436, 1439, 3, 208, 
	104, 0, 1437, 1439, 3, 208, 104, 0, 1438, 1435, 1, 0, 0, 0, 1438, 1437, 
	1, 0, 0, 0, 1438, 1439, 1, 0, 0, 0, 1439, 1591, 1, 0, 0, 0, 1440, 1441, 
	5, 297, 0, 0, 1441, 1442, 5, 194, 0, 0, 1442, 1446, 5, 368, 0, 0, 1443, 
	1444, 3, 86, 43, 0, 1444, 1445, 3, 896, 448, 0, 1445, 1447, 1, 0, 0, 0, 
	1446, 1443, 1, 0, 0, 0, 1446, 1447, 1, 0, 0, 0, 1447, 1451, 1, 0, 0, 0, 
	1448, 1449, 5, 176, 0, 0, 1449, 1452, 3, 208, 104, 0, 1450, 1452, 3, 208, 
	104, 0, 1451, 1448, 1, 0, 0, 0, 1451, 1450, 1, 0, 0, 0, 1451, 1452, 1, 
	0, 0, 0, 1452, 1591, 1, 0, 0, 0, 1453, 1455, 5, 297, 0, 0, 1454, 1456, 
	5, 304, 0, 0, 1455, 1454, 1, 0, 0, 0, 1455, 1456, 1, 0, 0, 0, 1456, 1457, 
	1, 0, 0, 0, 1457, 1458, 5, 46, 0, 0, 1458, 1459, 3, 86, 43, 0, 1459, 1463, 
	3, 640, 320, 0, 1460, 1461, 3, 86, 43, 0, 1461, 1462, 3, 896, 448, 0, 1462, 
	1464, 1, 0, 0, 0, 1463, 1460, 1, 0, 0, 0, 1463, 1464, 1, 0, 0, 0, 1464, 
	1468, 1, 0, 0, 0, 1465, 1466, 5, 176, 0, 0, 1466, 1469, 3, 208, 104, 0, 
	1467, 1469, 3, 208, 104, 0, 1468, 1465, 1, 0, 0, 0, 1468, 1467, 1, 0, 0, 
	0, 1468, 1469, 1, 0, 0, 0, 1469, 1591, 1, 0, 0, 0, 1470, 1471, 5, 297, 
	0, 0, 1471, 1474, 5, 137, 0, 0, 1472, 1473, 5, 176, 0, 0, 1473, 1475, 3, 
	206, 103, 0, 1474, 1472, 1, 0, 0, 0, 1474, 1475, 1, 0, 0, 0, 1475, 1591, 
	1, 0, 0, 0, 1476, 1477, 5, 297, 0, 0, 1477, 1478, 5, 229, 0, 0, 1478, 1480, 
	3, 640, 320, 0, 1479, 1481, 3, 880, 440, 0, 1480, 1479, 1, 0, 0, 0, 1480, 
	1481, 1, 0, 0, 0, 1481, 1483, 1, 0, 0, 0, 1482, 1484, 3, 652, 326, 0, 1483, 
	1482, 1, 0, 0, 0, 1483, 1484, 1, 0, 0, 0, 1484, 1486, 1, 0, 0, 0, 1485, 
	1487, 3, 740, 370, 0, 1486, 1485, 1, 0, 0, 0, 1486, 1487, 1, 0, 0, 0, 1487, 
	1489, 1, 0, 0, 0, 1488, 1490, 3, 410, 205, 0, 1489, 1488, 1, 0, 0, 0, 1489, 
	1490, 1, 0, 0, 0, 1490, 1591, 1, 0, 0, 0, 1491, 1492, 5, 297, 0, 0, 1492, 
	1498, 5, 58, 0, 0, 1493, 1494, 3, 88, 44, 0, 1494, 1495, 3, 896, 448, 0, 
	1495, 1499, 1, 0, 0, 0, 1496, 1497, 5, 318, 0, 0, 1497, 1499, 3, 640, 320, 
	0, 1498, 1493, 1, 0, 0, 0, 1498, 1496, 1, 0, 0, 0, 1499, 1591, 1, 0, 0, 
	0, 1500, 1501, 5, 297, 0, 0, 1501, 1502, 5, 318, 0, 0, 1502, 1506, 5, 117, 
	0, 0, 1503, 1504, 3, 86, 43, 0, 1504, 1505, 3, 896, 448, 0, 1505, 1507, 
	1, 0, 0, 0, 1506, 1503, 1, 0, 0, 0, 1506, 1507, 1, 0, 0, 0, 1507, 1508, 
	1, 0, 0, 0, 1508, 1509, 5, 176, 0, 0, 1509, 1511, 3, 208, 104, 0, 1510, 
	1512, 3, 880, 440, 0, 1511, 1510, 1, 0, 0, 0, 1511, 1512, 1, 0, 0, 0, 1512, 
	1591, 1, 0, 0, 0, 1513, 1514, 5, 297, 0, 0, 1514, 1515, 5, 321, 0, 0, 1515, 
	1519, 3, 640, 320, 0, 1516, 1517, 5, 386, 0, 0, 1517, 1518, 5, 412, 0, 
	0, 1518, 1520, 5, 387, 0, 0, 1519, 1516, 1, 0, 0, 0, 1519, 1520, 1, 0, 
	0, 0, 1520, 1591, 1, 0, 0, 0, 1521, 1522, 5, 297, 0, 0, 1522, 1534, 5, 
	183, 0, 0, 1523, 1524, 3, 88, 44, 0, 1524, 1526, 3, 896, 448, 0, 1525, 
	1527, 5, 117, 0, 0, 1526, 1525, 1, 0, 0, 0, 1526, 1527, 1, 0, 0, 0, 1527, 
	1535, 1, 0, 0, 0, 1528, 1530, 3, 78, 39, 0, 1529, 1528, 1, 0, 0, 0, 1529, 
	1530, 1, 0, 0, 0, 1530, 1532, 1, 0, 0, 0, 1531, 1533, 5, 117, 0, 0, 1532, 
	1531, 1, 0, 0, 0, 1532, 1533, 1, 0, 0, 0, 1533, 1535, 1, 0, 0, 0, 1534, 
	1523, 1, 0, 0, 0, 1534, 1529, 1, 0, 0, 0, 1535, 1591, 1, 0, 0, 0, 1536, 
	1537, 5, 297, 0, 0, 1537, 1574, 5, 50, 0, 0, 1538, 1575, 3, 458, 229, 0, 
	1539, 1540, 3, 88, 44, 0, 1540, 1542, 3, 896, 448, 0, 1541, 1543, 3, 460, 
	230, 0, 1542, 1541, 1, 0, 0, 0, 1542, 1543, 1, 0, 0, 0, 1543, 1545, 1, 
	0, 0, 0, 1544, 1546, 3, 462, 231, 0, 1545, 1544, 1, 0, 0, 0, 1545, 1546, 
	1, 0, 0, 0, 1546, 1548, 1, 0, 0, 0, 1547, 1549, 3, 464, 232, 0, 1548, 1547, 
	1, 0, 0, 0, 1548, 1549, 1, 0, 0, 0, 1549, 1551, 1, 0, 0, 0, 1550, 1552, 
	3, 740, 370, 0, 1551, 1550, 1, 0, 0, 0, 1551, 1552, 1, 0, 0, 0, 1552, 1554, 
	1, 0, 0, 0, 1553, 1555, 3, 410, 205, 0, 1554, 1553, 1, 0, 0, 0, 1554, 1555, 
	1, 0, 0, 0, 1555, 1575, 1, 0, 0, 0, 1556, 1558, 3, 78, 39, 0, 1557, 1556, 
	1, 0, 0, 0, 1557, 1558, 1, 0, 0, 0, 1558, 1560, 1, 0, 0, 0, 1559, 1561, 
	3, 460, 230, 0, 1560, 1559, 1, 0, 0, 0, 1560, 1561, 1, 0, 0, 0, 1561, 1563, 
	1, 0, 0, 0, 1562, 1564, 3, 462, 231, 0, 1563, 1562, 1, 0, 0, 0, 1563, 1564, 
	1, 0, 0, 0, 1564, 1566, 1, 0, 0, 0, 1565, 1567, 3, 464, 232, 0, 1566, 1565, 
	1, 0, 0, 0, 1566, 1567, 1, 0, 0, 0, 1567, 1569, 1, 0, 0, 0, 1568, 1570, 
	3, 740, 370, 0, 1569, 1568, 1, 0, 0, 0, 1569, 1570, 1, 0, 0, 0, 1570, 1572, 
	1, 0, 0, 0, 1571, 1573, 3, 410, 205, 0, 1572, 1571, 1, 0, 0, 0, 1572, 1573, 
	1, 0, 0, 0, 1573, 1575, 1, 0, 0, 0, 1574, 1538, 1, 0, 0, 0, 1574, 1539, 
	1, 0, 0, 0, 1574, 1557, 1, 0, 0, 0, 1575, 1591, 1, 0, 0, 0, 1576, 1577, 
	5, 297, 0, 0, 1577, 1591, 5, 335, 0, 0, 1578, 1579, 5, 297, 0, 0, 1579, 
	1580, 5, 54, 0, 0, 1580, 1591, 5, 412, 0, 0, 1581, 1582, 5, 297, 0, 0, 
	1582, 1586, 5, 270, 0, 0, 1583, 1584, 5, 233, 0, 0, 1584, 1587, 3, 896, 
	448, 0, 1585, 1587, 5, 234, 0, 0, 1586, 1583, 1, 0, 0, 0, 1586, 1585, 1, 
	0, 0, 0, 1587, 1591, 1, 0, 0, 0, 1588, 1589, 5, 297, 0, 0, 1589, 1591, 
	5, 70, 0, 0, 1590, 1409, 1, 0, 0, 0, 1590, 1415, 1, 0, 0, 0, 1590, 1428, 
	1, 0, 0, 0, 1590, 1440, 1, 0, 0, 0, 1590, 1453, 1, 0, 0, 0, 1590, 1470, 
	1, 0, 0, 0, 1590, 1476, 1, 0, 0, 0, 1590, 1491, 1, 0, 0, 0, 1590, 1500, 
	1, 0, 0, 0, 1590, 1513, 1, 0, 0, 0, 1590, 1521, 1, 0, 0, 0, 1590, 1536, 
	1, 0, 0, 0, 1590, 1576, 1, 0, 0, 0, 1590, 1578, 1, 0, 0, 0, 1590, 1581, 
	1, 0, 0, 0, 1590, 1588, 1, 0, 0, 0, 1591, 91, 1, 0, 0, 0, 1592, 1593, 5, 
	372, 0, 0, 1593, 1594, 3, 896, 448, 0, 1594, 1595, 5, 392, 0, 0, 1595, 
	1596, 5, 412, 0, 0, 1596, 1601, 1, 0, 0, 0, 1597, 1598, 5, 176, 0, 0, 1598, 
	1601, 3, 208, 104, 0, 1599, 1601, 3, 208, 104, 0, 1600, 1592, 1, 0, 0, 
	0, 1600, 1597, 1, 0, 0, 0, 1600, 1599, 1, 0, 0, 0, 1601, 93, 1, 0, 0, 0, 
	1602, 1603, 5, 182, 0, 0, 1603, 1604, 5, 318, 0, 0, 1604, 1606, 3, 640, 
	320, 0, 1605, 1607, 3, 880, 440, 0, 1606, 1605, 1, 0, 0, 0, 1606, 1607, 
	1, 0, 0, 0, 1607, 1608, 1, 0, 0, 0, 1608, 1609, 3, 98, 49, 0, 1609, 95, 
	1, 0, 0, 0, 1610, 1611, 5, 182, 0, 0, 1611, 1612, 3, 88, 44, 0, 1612, 1613, 
	3, 896, 448, 0, 1613, 1614, 3, 98, 49, 0, 1614, 97, 1, 0, 0, 0, 1615, 1616, 
	7, 7, 0, 0, 1616, 99, 1, 0, 0, 0, 1617, 1618, 5, 350, 0, 0, 1618, 1619, 
	5, 318, 0, 0, 1619, 1621, 3, 640, 320, 0, 1620, 1622, 3, 880, 440, 0, 1621, 
	1620, 1, 0, 0, 0, 1621, 1622, 1, 0, 0, 0, 1622, 101, 1, 0, 0, 0, 1623, 
	1624, 5, 350, 0, 0, 1624, 1625, 3, 88, 44, 0, 1625, 1626, 3, 896, 448, 
	0, 1626, 103, 1, 0, 0, 0, 1627, 1628, 5, 58, 0, 0, 1628, 1629, 5, 277, 
	0, 0, 1629, 1630, 3, 896, 448, 0, 1630, 105, 1, 0, 0, 0, 1631, 1632, 5, 
	98, 0, 0, 1632, 1633, 5, 277, 0, 0, 1633, 1634, 3, 896, 448, 0, 1634, 107, 
	1, 0, 0, 0, 1635, 1636, 5, 138, 0, 0, 1636, 1638, 3, 136, 68, 0, 1637, 
	1639, 3, 130, 65, 0, 1638, 1637, 1, 0, 0, 0, 1638, 1639, 1, 0, 0, 0, 1639, 
	1640, 1, 0, 0, 0, 1640, 1641, 5, 330, 0, 0, 1641, 1643, 3, 142, 71, 0, 
	1642, 1644, 3, 146, 73, 0, 1643, 1642, 1, 0, 0, 0, 1643, 1644, 1, 0, 0, 
	0, 1644, 109, 1, 0, 0, 0, 1645, 1647, 5, 273, 0, 0, 1646, 1648, 3, 148, 
	74, 0, 1647, 1646, 1, 0, 0, 0, 1647, 1648, 1, 0, 0, 0, 1648, 1649, 1, 0, 
	0, 0, 1649, 1651, 3, 136, 68, 0, 1650, 1652, 3, 130, 65, 0, 1651, 1650, 
	1, 0, 0, 0, 1651, 1652, 1, 0, 0, 0, 1652, 1653, 1, 0, 0, 0, 1653, 1654, 
	5, 134, 0, 0, 1654, 1655, 3, 142, 71, 0, 1655, 111, 1, 0, 0, 0, 1656, 1658, 
	5, 138, 0, 0, 1657, 1659, 5, 277, 0, 0, 1658, 1657, 1, 0, 0, 0, 1658, 1659, 
	1, 0, 0, 0, 1659, 1660, 1, 0, 0, 0, 1660, 1665, 3, 896, 448, 0, 1661, 1662, 
	5, 384, 0, 0, 1662, 1664, 3, 896, 448, 0, 1663, 1661, 1, 0, 0, 0, 1664, 
	1667, 1, 0, 0, 0, 1665, 1663, 1, 0, 0, 0, 1665, 1666, 1, 0, 0, 0, 1666, 
	1668, 1, 0, 0, 0, 1667, 1665, 1, 0, 0, 0, 1668, 1669, 5, 330, 0, 0, 1669, 
	1671, 3, 142, 71, 0, 1670, 1672, 3, 152, 76, 0, 1671, 1670, 1, 0, 0, 0, 
	1671, 1672, 1, 0, 0, 0, 1672, 113, 1, 0, 0, 0, 1673, 1675, 5, 273, 0, 0, 
	1674, 1676, 3, 150, 75, 0, 1675, 1674, 1, 0, 0, 0, 1675, 1676, 1, 0, 0, 
	0, 1676, 1678, 1, 0, 0, 0, 1677, 1679, 5, 277, 0, 0, 1678, 1677, 1, 0, 
	0, 0, 1678, 1679, 1, 0, 0, 0, 1679, 1680, 1, 0, 0, 0, 1680, 1685, 3, 896, 
	448, 0, 1681, 1682, 5, 384, 0, 0, 1682, 1684, 3, 896, 448, 0, 1683, 1681, 
	1, 0, 0, 0, 1684, 1687, 1, 0, 0, 0, 1685, 1683, 1, 0, 0, 0, 1685, 1686, 
	1, 0, 0, 0, 1686, 1688, 1, 0, 0, 0, 1687, 1685, 1, 0, 0, 0, 1688, 1689, 
	5, 134, 0, 0, 1689, 1690, 3, 142, 71, 0, 1690, 115, 1, 0, 0, 0, 1691, 1692, 
	5, 297, 0, 0, 1692, 1693, 5, 277, 0, 0, 1693, 1694, 5, 138, 0, 0, 1694, 
	1695, 3, 144, 72, 0, 1695, 117, 1, 0, 0, 0, 1696, 1697, 5, 297, 0, 0, 1697, 
	1698, 5, 278, 0, 0, 1698, 119, 1, 0, 0, 0, 1699, 1700, 5, 297, 0, 0, 1700, 
	1701, 5, 62, 0, 0, 1701, 1702, 5, 278, 0, 0, 1702, 121, 1, 0, 0, 0, 1703, 
	1704, 5, 293, 0, 0, 1704, 1708, 5, 277, 0, 0, 1705, 1709, 5, 7, 0, 0, 1706, 
	1709, 5, 203, 0, 0, 1707, 1709, 3, 896, 448, 0, 1708, 1705, 1, 0, 0, 0, 
	1708, 1706, 1, 0, 0, 0, 1708, 1707, 1, 0, 0, 0, 1709, 123, 1, 0, 0, 0, 
	1710, 1711, 5, 297, 0, 0, 1711, 1713, 5, 138, 0, 0, 1712, 1714, 3, 144, 
	72, 0, 1713, 1712, 1, 0, 0, 0, 1713, 1714, 1, 0, 0, 0, 1714, 1717, 1, 0, 
	0, 0, 1715, 1716, 5, 214, 0, 0, 1716, 1718, 3, 128, 64, 0, 1717, 1715, 
	1, 0, 0, 0, 1717, 1718, 1, 0, 0, 0, 1718, 125, 1, 0, 0, 0, 1719, 1720, 
	5, 297, 0, 0, 1720, 1721, 5, 242, 0, 0, 1721, 1722, 3, 896, 448, 0, 1722, 
	127, 1, 0, 0, 0, 1723, 1726, 5, 7, 0, 0, 1724, 1726, 3, 134, 67, 0, 1725, 
	1723, 1, 0, 0, 0, 1725, 1724, 1, 0, 0, 0, 1726, 129, 1, 0, 0, 0, 1727, 
	1728, 5, 214, 0, 0, 1728, 1729, 3, 132, 66, 0, 1729, 131, 1, 0, 0, 0, 1730, 
	1731, 3, 88, 44, 0, 1731, 1732, 3, 896, 448, 0, 1732, 1745, 1, 0, 0, 0, 
	1733, 1735, 5, 318, 0, 0, 1734, 1733, 1, 0, 0, 0, 1734, 1735, 1, 0, 0, 
	0, 1735, 1736, 1, 0, 0, 0, 1736, 1738, 3, 640, 320, 0, 1737, 1739, 3, 880, 
	440, 0, 1738, 1737, 1, 0, 0, 0, 1738, 1739, 1, 0, 0, 0, 1739, 1745, 1, 
	0, 0, 0, 1740, 1741, 5, 355, 0, 0, 1741, 1745, 5, 412, 0, 0, 1742, 1743, 
	5, 292, 0, 0, 1743, 1745, 3, 896, 448, 0, 1744, 1730, 1, 0, 0, 0, 1744, 
	1734, 1, 0, 0, 0, 1744, 1740, 1, 0, 0, 0, 1744, 1742, 1, 0, 0, 0, 1745, 
	133, 1, 0, 0, 0, 1746, 1747, 3, 88, 44, 0, 1747, 1748, 3, 896, 448, 0, 
	1748, 1767, 1, 0, 0, 0, 1749, 1751, 5, 318, 0, 0, 1750, 1749, 1, 0, 0, 
	0, 1750, 1751, 1, 0, 0, 0, 1751, 1752, 1, 0, 0, 0, 1752, 1757, 3, 640, 
	320, 0, 1753, 1754, 5, 386, 0, 0, 1754, 1755, 3, 272, 136, 0, 1755, 1756, 
	5, 387, 0, 0, 1756, 1758, 1, 0, 0, 0, 1757, 1753, 1, 0, 0, 0, 1757, 1758, 
	1, 0, 0, 0, 1758, 1760, 1, 0, 0, 0, 1759, 1761, 3, 880, 440, 0, 1760, 1759, 
	1, 0, 0, 0, 1760, 1761, 1, 0, 0, 0, 1761, 1767, 1, 0, 0, 0, 1762, 1763, 
	5, 355, 0, 0, 1763, 1767, 5, 412, 0, 0, 1764, 1765, 5, 292, 0, 0, 1765, 
	1767, 3, 896, 448, 0, 1766, 1746, 1, 0, 0, 0, 1766, 1750, 1, 0, 0, 0, 1766, 
	1762, 1, 0, 0, 0, 1766, 1764, 1, 0, 0, 0, 1767, 135, 1, 0, 0, 0, 1768, 
	1773, 3, 138, 69, 0, 1769, 1770, 5, 384, 0, 0, 1770, 1772, 3, 138, 69, 
	0, 1771, 1769, 1, 0, 0, 0, 1772, 1775, 1, 0, 0, 0, 1773, 1771, 1, 0, 0, 
	0, 1773, 1774, 1, 0, 0, 0, 1774, 137, 1, 0, 0, 0, 1775, 1773, 1, 0, 0, 
	0, 1776, 1781, 3, 140, 70, 0, 1777, 1778, 5, 386, 0, 0, 1778, 1779, 3, 
	272, 136, 0, 1779, 1780, 5, 387, 0, 0, 1780, 1782, 1, 0, 0, 0, 1781, 1777, 
	1, 0, 0, 0, 1781, 1782, 1, 0, 0, 0, 1782, 139, 1, 0, 0, 0, 1783, 1784, 
	7, 8, 0, 0, 1784, 141, 1, 0, 0, 0, 1785, 1790, 3, 144, 72, 0, 1786, 1787, 
	5, 384, 0, 0, 1787, 1789, 3, 144, 72, 0, 1788, 1786, 1, 0, 0, 0, 1789, 
	1792, 1, 0, 0, 0, 1790, 1788, 1, 0, 0, 0, 1790, 1791, 1, 0, 0, 0, 1791, 
	143, 1, 0, 0, 0, 1792, 1790, 1, 0, 0, 0, 1793, 1794, 5, 358, 0, 0, 1794, 
	1800, 3, 900, 450, 0, 1795, 1796, 5, 139, 0, 0, 1796, 1800, 3, 900, 450, 
	0, 1797, 1798, 5, 277, 0, 0, 1798, 1800, 3, 896, 448, 0, 1799, 1793, 1, 
	0, 0, 0, 1799, 1795, 1, 0, 0, 0, 1799, 1797, 1, 0, 0, 0, 1800, 145, 1, 
	0, 0, 0, 1801, 1802, 5, 375, 0, 0, 1802, 1803, 5, 138, 0, 0, 1803, 1804, 
	5, 217, 0, 0, 1804, 147, 1, 0, 0, 0, 1805, 1806, 5, 138, 0, 0, 1806, 1807, 
	5, 217, 0, 0, 1807, 1808, 5, 129, 0, 0, 1808, 149, 1, 0, 0, 0, 1809, 1810, 
	5, 5, 0, 0, 1810, 1811, 5, 217, 0, 0, 1811, 1812, 5, 129, 0, 0, 1812, 151, 
	1, 0, 0, 0, 1813, 1814, 5, 375, 0, 0, 1814, 1815, 5, 5, 0, 0, 1815, 1816, 
	5, 217, 0, 0, 1816, 153, 1, 0, 0, 0, 1817, 1819, 5, 202, 0, 0, 1818, 1820, 
	5, 266, 0, 0, 1819, 1818, 1, 0, 0, 0, 1819, 1820, 1, 0, 0, 0, 1820, 1821, 
	1, 0, 0, 0, 1821, 1822, 5, 318, 0, 0, 1822, 1828, 3, 640, 320, 0, 1823, 
	1824, 7, 9, 0, 0, 1824, 1826, 5, 229, 0, 0, 1825, 1827, 3, 884, 442, 0, 
	1826, 1825, 1, 0, 0, 0, 1826, 1827, 1, 0, 0, 0, 1827, 1829, 1, 0, 0, 0, 
	1828, 1823, 1, 0, 0, 0, 1828, 1829, 1, 0, 0, 0, 1829, 155, 1, 0, 0, 0, 
	1830, 1835, 3, 158, 79, 0, 1831, 1832, 5, 384, 0, 0, 1832, 1834, 3, 158, 
	79, 0, 1833, 1831, 1, 0, 0, 0, 1834, 1837, 1, 0, 0, 0, 1835, 1833, 1, 0, 
	0, 0, 1835, 1836, 1, 0, 0, 0, 1836, 157, 1, 0, 0, 0, 1837, 1835, 1, 0, 
	0, 0, 1838, 1839, 3, 160, 80, 0, 1839, 1840, 5, 412, 0, 0, 1840, 159, 1, 
	0, 0, 0, 1841, 1842, 7, 10, 0, 0, 1842, 161, 1, 0, 0, 0, 1843, 1845, 5, 
	58, 0, 0, 1844, 1846, 5, 322, 0, 0, 1845, 1844, 1, 0, 0, 0, 1845, 1846, 
	1, 0, 0, 0, 1846, 1847, 1, 0, 0, 0, 1847, 1848, 5, 136, 0, 0, 1848, 1849, 
	3, 898, 449, 0, 1849, 1850, 5, 17, 0, 0, 1850, 1853, 5, 412, 0, 0, 1851, 
	1852, 5, 359, 0, 0, 1852, 1854, 3, 156, 78, 0, 1853, 1851, 1, 0, 0, 0, 
	1853, 1854, 1, 0, 0, 0, 1854, 163, 1, 0, 0, 0, 1855, 1857, 5, 98, 0, 0, 
	1856, 1858, 5, 322, 0, 0, 1857, 1856, 1, 0, 0, 0, 1857, 1858, 1, 0, 0, 
	0, 1858, 1859, 1, 0, 0, 0, 1859, 1861, 5, 136, 0, 0, 1860, 1862, 3, 36, 
	18, 0, 1861, 1860, 1, 0, 0, 0, 1861, 1862, 1, 0, 0, 0, 1862, 1863, 1, 0, 
	0, 0, 1863, 1864, 3, 898, 449, 0, 1864, 165, 1, 0, 0, 0, 1865, 1866, 5, 
	261, 0, 0, 1866, 1867, 7, 11, 0, 0, 1867, 167, 1, 0, 0, 0, 1868, 1869, 
	5, 58, 0, 0, 1869, 1870, 5, 322, 0, 0, 1870, 1871, 5, 186, 0, 0, 1871, 
	1872, 5, 418, 0, 0, 1872, 1874, 5, 386, 0, 0, 1873, 1875, 3, 266, 133, 
	0, 1874, 1873, 1, 0, 0, 0, 1874, 1875, 1, 0, 0, 0, 1875, 1876, 1, 0, 0, 
	0, 1876, 1877, 5, 387, 0, 0, 1877, 1878, 3, 796, 398, 0, 1878, 169, 1, 
	0, 0, 0, 1879, 1880, 5, 98, 0, 0, 1880, 1881, 5, 322, 0, 0, 1881, 1883, 
	5, 186, 0, 0, 1882, 1884, 3, 36, 18, 0, 1883, 1882, 1, 0, 0, 0, 1883, 1884, 
	1, 0, 0, 0, 1884, 1885, 1, 0, 0, 0, 1885, 1886, 5, 418, 0, 0, 1886, 171, 
	1, 0, 0, 0, 1887, 1889, 5, 58, 0, 0, 1888, 1890, 3, 50, 25, 0, 1889, 1888, 
	1, 0, 0, 0, 1889, 1890, 1, 0, 0, 0, 1890, 1891, 1, 0, 0, 0, 1891, 1893, 
	5, 367, 0, 0, 1892, 1894, 3, 40, 20, 0, 1893, 1892, 1, 0, 0, 0, 1893, 1894, 
	1, 0, 0, 0, 1894, 1895, 1, 0, 0, 0, 1895, 1900, 3, 640, 320, 0, 1896, 1897, 
	5, 386, 0, 0, 1897, 1898, 3, 324, 162, 0, 1898, 1899, 5, 387, 0, 0, 1899, 
	1901, 1, 0, 0, 0, 1900, 1896, 1, 0, 0, 0, 1900, 1901, 1, 0, 0, 0, 1901, 
	1903, 1, 0, 0, 0, 1902, 1904, 3, 210, 105, 0, 1903, 1902, 1, 0, 0, 0, 1903, 
	1904, 1, 0, 0, 0, 1904, 1906, 1, 0, 0, 0, 1905, 1907, 3, 174, 87, 0, 1906, 
	1905, 1, 0, 0, 0, 1906, 1907, 1, 0, 0, 0, 1907, 1909, 1, 0, 0, 0, 1908, 
	1910, 3, 242, 121, 0, 1909, 1908, 1, 0, 0, 0, 1909, 1910, 1, 0, 0, 0, 1910, 
	1911, 1, 0, 0, 0, 1911, 1912, 5, 17, 0, 0, 1912, 1913, 3, 402, 201, 0, 
	1913, 173, 1, 0, 0, 0, 1914, 1915, 5, 228, 0, 0, 1915, 1921, 5, 214, 0, 
	0, 1916, 1917, 5, 386, 0, 0, 1917, 1922, 3, 272, 136, 0, 1918, 1919, 5, 
	305, 0, 0, 1919, 1920, 5, 386, 0, 0, 1920, 1922, 3, 218, 109, 0, 1921, 
	1916, 1, 0, 0, 0, 1921, 1918, 1, 0, 0, 0, 1922, 1923, 1, 0, 0, 0, 1923, 
	1924, 5, 387, 0, 0, 1924, 175, 1, 0, 0, 0, 1925, 1928, 3, 178, 89, 0, 1926, 
	1928, 3, 180, 90, 0, 1927, 1925, 1, 0, 0, 0, 1927, 1926, 1, 0, 0, 0, 1928, 
	177, 1, 0, 0, 0, 1929, 1930, 5, 42, 0, 0, 1930, 1931, 5, 214, 0, 0, 1931, 
	1932, 5, 386, 0, 0, 1932, 1933, 3, 272, 136, 0, 1933, 1934, 5, 387, 0, 
	0, 1934, 179, 1, 0, 0, 0, 1935, 1936, 3, 182, 91, 0, 1936, 1937, 3, 184, 
	92, 0, 1937, 181, 1, 0, 0, 0, 1938, 1939, 5, 94, 0, 0, 1939, 1940, 5, 214, 
	0, 0, 1940, 1941, 5, 386, 0, 0, 1941, 1942, 3, 272, 136, 0, 1942, 1943, 
	5, 387, 0, 0, 1943, 183, 1, 0, 0, 0, 1944, 1945, 5, 304, 0, 0, 1945, 1946, 
	5, 214, 0, 0, 1946, 1947, 5, 386, 0, 0, 1947, 1948, 3, 272, 136, 0, 1948, 
	1949, 5, 387, 0, 0, 1949, 185, 1, 0, 0, 0, 1950, 1951, 5, 98, 0, 0, 1951, 
	1953, 5, 367, 0, 0, 1952, 1954, 3, 36, 18, 0, 1953, 1952, 1, 0, 0, 0, 1953, 
	1954, 1, 0, 0, 0, 1954, 1955, 1, 0, 0, 0, 1955, 1956, 3, 642, 321, 0, 1956, 
	187, 1, 0, 0, 0, 1957, 1958, 5, 58, 0, 0, 1958, 1959, 5, 194, 0, 0, 1959, 
	1961, 5, 367, 0, 0, 1960, 1962, 3, 40, 20, 0, 1961, 1960, 1, 0, 0, 0, 1961, 
	1962, 1, 0, 0, 0, 1962, 1963, 1, 0, 0, 0, 1963, 1965, 3, 640, 320, 0, 1964, 
	1966, 3, 46, 23, 0, 1965, 1964, 1, 0, 0, 0, 1965, 1966, 1, 0, 0, 0, 1966, 
	1968, 1, 0, 0, 0, 1967, 1969, 3, 210, 105, 0, 1968, 1967, 1, 0, 0, 0, 1968, 
	1969, 1, 0, 0, 0, 1969, 1971, 1, 0, 0, 0, 1970, 1972, 3, 174, 87, 0, 1971, 
	1970, 1, 0, 0, 0, 1971, 1972, 1, 0, 0, 0, 1972, 1974, 1, 0, 0, 0, 1973, 
	1975, 3, 176, 88, 0, 1974, 1973, 1, 0, 0, 0, 1974, 1975, 1, 0, 0, 0, 1975, 
	1977, 1, 0, 0, 0, 1976, 1978, 3, 240, 120, 0, 1977, 1976, 1, 0, 0, 0, 1977, 
	1978, 1, 0, 0, 0, 1978, 1980, 1, 0, 0, 0, 1979, 1981, 3, 262, 131, 0, 1980, 
	1979, 1, 0, 0, 0, 1980, 1981, 1, 0, 0, 0, 1981, 1983, 1, 0, 0, 0, 1982, 
	1984, 3, 264, 132, 0, 1983, 1982, 1, 0, 0, 0, 1983, 1984, 1, 0, 0, 0, 1984, 
	1986, 1, 0, 0, 0, 1985, 1987, 3, 242, 121, 0, 1986, 1985, 1, 0, 0, 0, 1986, 
	1987, 1, 0, 0, 0, 1987, 1988, 1, 0, 0, 0, 1988, 1989, 5, 17, 0, 0, 1989, 
	1990, 3, 402, 201, 0, 1990, 189, 1, 0, 0, 0, 1991, 1992, 5, 98, 0, 0, 1992, 
	1993, 5, 194, 0, 0, 1993, 1995, 5, 367, 0, 0, 1994, 1996, 3, 36, 18, 0, 
	1995, 1994, 1, 0, 0, 0, 1995, 1996, 1, 0, 0, 0, 1996, 1997, 1, 0, 0, 0, 
	1997, 1998, 3, 642, 321, 0, 1998, 191, 1, 0, 0, 0, 1999, 2000, 5, 58, 0, 
	0, 2000, 2001, 5, 283, 0, 0, 2001, 2002, 5, 248, 0, 0, 2002, 2003, 3, 896, 
	448, 0, 2003, 2005, 3, 200, 100, 0, 2004, 2006, 3, 202, 101, 0, 2005, 2004, 
	1, 0, 0, 0, 2005, 2006, 1, 0, 0, 0, 2006, 2008, 1, 0, 0, 0, 2007, 2009, 
	3, 284, 142, 0, 2008, 2007, 1, 0, 0, 0, 2008, 2009, 1, 0, 0, 0, 2009, 2010, 
	1, 0, 0, 0, 2010, 2011, 3, 204, 102, 0, 2011, 193, 1, 0, 0, 0, 2012, 2013, 
	5, 98, 0, 0, 2013, 2014, 5, 283, 0, 0, 2014, 2015, 5, 248, 0, 0, 2015, 
	2016, 3, 896, 448, 0, 2016, 195, 1, 0, 0, 0, 2017, 2018, 5, 9, 0, 0, 2018, 
	2019, 5, 283, 0, 0, 2019, 2020, 5, 248, 0, 0, 2020, 2021, 3, 896, 448, 
	0, 2021, 2022, 3, 198, 99, 0, 2022, 197, 1, 0, 0, 0, 2023, 2029, 3, 200, 
	100, 0, 2024, 2029, 3, 202, 101, 0, 2025, 2029, 3, 284, 142, 0, 2026, 2029, 
	3, 204, 102, 0, 2027, 2029, 5, 110, 0, 0, 2028, 2023, 1, 0, 0, 0, 2028, 
	2024, 1, 0, 0, 0, 2028, 2025, 1, 0, 0, 0, 2028, 2026, 1, 0, 0, 0, 2028, 
	2027, 1, 0, 0, 0, 2029, 199, 1, 0, 0, 0, 2030, 2031, 5, 59, 0, 0, 2031, 
	2046, 5, 412, 0, 0, 2032, 2034, 5, 106, 0, 0, 2033, 2035, 5, 417, 0, 0, 
	2034, 2033, 1, 0, 0, 0, 2034, 2035, 1, 0, 0, 0, 2035, 2036, 1, 0, 0, 0, 
	2036, 2043, 3, 794, 397, 0, 2037, 2041, 5, 20, 0, 0, 2038, 2039, 5, 213, 
	0, 0, 2039, 2041, 5, 32, 0, 0, 2040, 2037, 1, 0, 0, 0, 2040, 2038, 1, 0, 
	0, 0, 2041, 2042, 1, 0, 0, 0, 2042, 2044, 5, 412, 0, 0, 2043, 2040, 1, 
	0, 0, 0, 2043, 2044, 1, 0, 0, 0, 2044, 2046, 1, 0, 0, 0, 2045, 2030, 1, 
	0, 0, 0, 2045, 2032, 1, 0, 0, 0, 2046, 201, 1, 0, 0, 0, 2047, 2048, 5, 
	111, 0, 0, 2048, 2049, 5, 17, 0, 0, 2049, 2050, 5, 412, 0, 0, 2050, 203, 
	1, 0, 0, 0, 2051, 2053, 5, 82, 0, 0, 2052, 2051, 1, 0, 0, 0, 2052, 2053, 
	1, 0, 0, 0, 2053, 2054, 1, 0, 0, 0, 2054, 2055, 5, 17, 0, 0, 2055, 2056, 
	3, 0, 0, 0, 2056, 205, 1, 0, 0, 0, 2057, 2060, 3, 898, 449, 0, 2058, 2060, 
	5, 412, 0, 0, 2059, 2057, 1, 0, 0, 0, 2059, 2058, 1, 0, 0, 0, 2060, 207, 
	1, 0, 0, 0, 2061, 2064, 3, 896, 448, 0, 2062, 2064, 5, 412, 0, 0, 2063, 
	2061, 1, 0, 0, 0, 2063, 2062, 1, 0, 0, 0, 2064, 209, 1, 0, 0, 0, 2065, 
	2066, 5, 47, 0, 0, 2066, 2067, 5, 412, 0, 0, 2067, 211, 1, 0, 0, 0, 2068, 
	2069, 5, 228, 0, 0, 2069, 2078, 5, 32, 0, 0, 2070, 2073, 5, 386, 0, 0, 
	2071, 2074, 3, 214, 107, 0, 2072, 2074, 3, 216, 108, 0, 2073, 2071, 1, 
	0, 0, 0, 2073, 2072, 1, 0, 0, 0, 2074, 2079, 1, 0, 0, 0, 2075, 2076, 5, 
	305, 0, 0, 2076, 2077, 5, 386, 0, 0, 2077, 2079, 3, 218, 109, 0, 2078, 
	2070, 1, 0, 0, 0, 2078, 2075, 1, 0, 0, 0, 2079, 2080, 1, 0, 0, 0, 2080, 
	2081, 5, 387, 0, 0, 2081, 213, 1, 0, 0, 0, 2082, 2087, 3, 338, 169, 0, 
	2083, 2084, 5, 384, 0, 0, 2084, 2086, 3, 338, 169, 0, 2085, 2083, 1, 0, 
	0, 0, 2086, 2089, 1, 0, 0, 0, 2087, 2085, 1, 0, 0, 0, 2087, 2088, 1, 0, 
	0, 0, 2088, 215, 1, 0, 0, 0, 2089, 2087, 1, 0, 0, 0, 2090, 2095, 3, 274, 
	137, 0, 2091, 2092, 5, 384, 0, 0, 2092, 2094, 3, 274, 137, 0, 2093, 2091, 
	1, 0, 0, 0, 2094, 2097, 1, 0, 0, 0, 2095, 2093, 1, 0, 0, 0, 2095, 2096, 
	1, 0, 0, 0, 2096, 217, 1, 0, 0, 0, 2097, 2095, 1, 0, 0, 0, 2098, 2103, 
	3, 220, 110, 0, 2099, 2100, 5, 384, 0, 0, 2100, 2102, 3, 220, 110, 0, 2101, 
	2099, 1, 0, 0, 0, 2102, 2105, 1, 0, 0, 0, 2103, 2101, 1, 0, 0, 0, 2103, 
	2104, 1, 0, 0, 0, 2104, 219, 1, 0, 0, 0, 2105, 2103, 1, 0, 0, 0, 2106, 
	2107, 3, 222, 111, 0, 2107, 221, 1, 0, 0, 0, 2108, 2122, 3, 274, 137, 0, 
	2109, 2110, 7, 12, 0, 0, 2110, 2111, 5, 386, 0, 0, 2111, 2112, 3, 274, 
	137, 0, 2112, 2113, 5, 387, 0, 0, 2113, 2122, 1, 0, 0, 0, 2114, 2115, 7, 
	13, 0, 0, 2115, 2116, 5, 386, 0, 0, 2116, 2117, 5, 417, 0, 0, 2117, 2118, 
	5, 384, 0, 0, 2118, 2119, 3, 274, 137, 0, 2119, 2120, 5, 387, 0, 0, 2120, 
	2122, 1, 0, 0, 0, 2121, 2108, 1, 0, 0, 0, 2121, 2109, 1, 0, 0, 0, 2121, 
	2114, 1, 0, 0, 0, 2122, 223, 1, 0, 0, 0, 2123, 2124, 5, 42, 0, 0, 2124, 
	2125, 5, 32, 0, 0, 2125, 2126, 5, 386, 0, 0, 2126, 2127, 3, 272, 136, 0, 
	2127, 2134, 5, 387, 0, 0, 2128, 2129, 5, 304, 0, 0, 2129, 2130, 5, 32, 
	0, 0, 2130, 2131, 5, 386, 0, 0, 2131, 2132, 3, 278, 139, 0, 2132, 2133, 
	5, 387, 0, 0, 2133, 2135, 1, 0, 0, 0, 2134, 2128, 1, 0, 0, 0, 2134, 2135, 
	1, 0, 0, 0, 2135, 2136, 1, 0, 0, 0, 2136, 2137, 5, 159, 0, 0, 2137, 2138, 
	5, 417, 0, 0, 2138, 2139, 5, 31, 0, 0, 2139, 225, 1, 0, 0, 0, 2140, 2141, 
	5, 42, 0, 0, 2141, 2142, 5, 159, 0, 0, 2142, 2143, 5, 417, 0, 0, 2143, 
	2144, 5, 31, 0, 0, 2144, 227, 1, 0, 0, 0, 2145, 2146, 5, 299, 0, 0, 2146, 
	2147, 5, 32, 0, 0, 2147, 2148, 5, 386, 0, 0, 2148, 2149, 3, 272, 136, 0, 
	2149, 2150, 5, 387, 0, 0, 2150, 2151, 5, 214, 0, 0, 2151, 2152, 5, 386, 
	0, 0, 2152, 2153, 3, 306, 153, 0, 2153, 2155, 5, 387, 0, 0, 2154, 2156, 
	3, 48, 24, 0, 2155, 2154, 1, 0, 0, 0, 2155, 2156, 1, 0, 0, 0, 2156, 229, 
	1, 0, 0, 0, 2157, 2160, 3, 236, 118, 0, 2158, 2160, 3, 238, 119, 0, 2159, 
	2157, 1, 0, 0, 0, 2159, 2158, 1, 0, 0, 0, 2160, 231, 1, 0, 0, 0, 2161, 
	2162, 5, 256, 0, 0, 2162, 2163, 5, 412, 0, 0, 2163, 233, 1, 0, 0, 0, 2164, 
	2165, 5, 257, 0, 0, 2165, 2166, 5, 412, 0, 0, 2166, 235, 1, 0, 0, 0, 2167, 
	2168, 5, 281, 0, 0, 2168, 2169, 5, 132, 0, 0, 2169, 2170, 5, 290, 0, 0, 
	2170, 2174, 5, 412, 0, 0, 2171, 2172, 5, 375, 0, 0, 2172, 2173, 5, 291, 
	0, 0, 2173, 2175, 3, 244, 122, 0, 2174, 2171, 1, 0, 0, 0, 2174, 2175, 1, 
	0, 0, 0, 2175, 237, 1, 0, 0, 0, 2176, 2177, 5, 281, 0, 0, 2177, 2178, 5, 
	132, 0, 0, 2178, 2180, 5, 84, 0, 0, 2179, 2181, 3, 252, 126, 0, 2180, 2179, 
	1, 0, 0, 0, 2180, 2181, 1, 0, 0, 0, 2181, 2183, 1, 0, 0, 0, 2182, 2184, 
	3, 254, 127, 0, 2183, 2182, 1, 0, 0, 0, 2183, 2184, 1, 0, 0, 0, 2184, 2186, 
	1, 0, 0, 0, 2185, 2187, 3, 256, 128, 0, 2186, 2185, 1, 0, 0, 0, 2186, 2187, 
	1, 0, 0, 0, 2187, 2189, 1, 0, 0, 0, 2188, 2190, 3, 258, 129, 0, 2189, 2188, 
	1, 0, 0, 0, 2189, 2190, 1, 0, 0, 0, 2190, 2192, 1, 0, 0, 0, 2191, 2193, 
	3, 260, 130, 0, 2192, 2191, 1, 0, 0, 0, 2192, 2193, 1, 0, 0, 0, 2193, 239, 
	1, 0, 0, 0, 2194, 2197, 3, 238, 119, 0, 2195, 2197, 3, 236, 118, 0, 2196, 
	2194, 1, 0, 0, 0, 2196, 2195, 1, 0, 0, 0, 2197, 241, 1, 0, 0, 0, 2198, 
	2199, 5, 321, 0, 0, 2199, 2200, 3, 244, 122, 0, 2200, 243, 1, 0, 0, 0, 
	2201, 2202, 5, 386, 0, 0, 2202, 2203, 3, 246, 123, 0, 2203, 2204, 5, 387, 
	0, 0, 2204, 245, 1, 0, 0, 0, 2205, 2210, 3, 248, 124, 0, 2206, 2207, 5, 
	384, 0, 0, 2207, 2209, 3, 248, 124, 0, 2208, 2206, 1, 0, 0, 0, 2209, 2212, 
	1, 0, 0, 0, 2210, 2208, 1, 0, 0, 0, 2210, 2211, 1, 0, 0, 0, 2211, 2222, 
	1, 0, 0, 0, 2212, 2210, 1, 0, 0, 0, 2213, 2218, 3, 250, 125, 0, 2214, 2215, 
	5, 384, 0, 0, 2215, 2217, 3, 250, 125, 0, 2216, 2214, 1, 0, 0, 0, 2217, 
	2220, 1, 0, 0, 0, 2218, 2216, 1, 0, 0, 0, 2218, 2219, 1, 0, 0, 0, 2219, 
	2222, 1, 0, 0, 0, 2220, 2218, 1, 0, 0, 0, 2221, 2205, 1, 0, 0, 0, 2221, 
	2213, 1, 0, 0, 0, 2222, 247, 1, 0, 0, 0, 2223, 2224, 5, 412, 0, 0, 2224, 
	2225, 5, 392, 0, 0, 2225, 2226, 5, 412, 0, 0, 2226, 249, 1, 0, 0, 0, 2227, 
	2228, 5, 412, 0, 0, 2228, 251, 1, 0, 0, 0, 2229, 2230, 5, 122, 0, 0, 2230, 
	2231, 5, 323, 0, 0, 2231, 2232, 5, 32, 0, 0, 2232, 2236, 5, 412, 0, 0, 
	2233, 2234, 5, 105, 0, 0, 2234, 2235, 5, 32, 0, 0, 2235, 2237, 5, 412, 
	0, 0, 2236, 2233, 1, 0, 0, 0, 2236, 2237, 1, 0, 0, 0, 2237, 253, 1, 0, 
	0, 0, 2238, 2239, 5, 44, 0, 0, 2239, 2240, 5, 162, 0, 0, 2240, 2241, 5, 
	323, 0, 0, 2241, 2242, 5, 32, 0, 0, 2242, 2243, 5, 412, 0, 0, 2243, 255, 
	1, 0, 0, 0, 2244, 2245, 5, 190, 0, 0, 2245, 2246, 5, 167, 0, 0, 2246, 2247, 
	5, 323, 0, 0, 2247, 2248, 5, 32, 0, 0, 2248, 2249, 5, 412, 0, 0, 2249, 
	257, 1, 0, 0, 0, 2250, 2251, 5, 178, 0, 0, 2251, 2252, 5, 323, 0, 0, 2252, 
	2253, 5, 32, 0, 0, 2253, 2254, 5, 412, 0, 0, 2254, 259, 1, 0, 0, 0, 2255, 
	2256, 5, 209, 0, 0, 2256, 2257, 5, 82, 0, 0, 2257, 2258, 5, 17, 0, 0, 2258, 
	2259, 5, 412, 0, 0, 2259, 261, 1, 0, 0, 0, 2260, 2261, 5, 310, 0, 0, 2261, 
	2262, 5, 17, 0, 0, 2262, 2263, 5, 154, 0, 0, 2263, 2264, 5, 412, 0, 0, 
	2264, 2265, 5, 223, 0, 0, 2265, 2270, 5, 412, 0, 0, 2266, 2267, 5, 153, 
	0, 0, 2267, 2268, 5, 412, 0, 0, 2268, 2269, 5, 222, 0, 0, 2269, 2271, 5, 
	412, 0, 0, 2270, 2266, 1, 0, 0, 0, 2270, 2271, 1, 0, 0, 0, 2271, 2302, 
	1, 0, 0, 0, 2272, 2273, 5, 310, 0, 0, 2273, 2274, 5, 32, 0, 0, 2274, 2278, 
	5, 412, 0, 0, 2275, 2276, 5, 375, 0, 0, 2276, 2277, 5, 291, 0, 0, 2277, 
	2279, 3, 244, 122, 0, 2278, 2275, 1, 0, 0, 0, 2278, 2279, 1, 0, 0, 0, 2279, 
	2283, 1, 0, 0, 0, 2280, 2281, 5, 310, 0, 0, 2281, 2282, 5, 17, 0, 0, 2282, 
	2284, 3, 896, 448, 0, 2283, 2280, 1, 0, 0, 0, 2283, 2284, 1, 0, 0, 0, 2284, 
	2302, 1, 0, 0, 0, 2285, 2286, 5, 310, 0, 0, 2286, 2287, 5, 32, 0, 0, 2287, 
	2291, 3, 896, 448, 0, 2288, 2289, 5, 375, 0, 0, 2289, 2290, 5, 291, 0, 
	0, 2290, 2292, 3, 244, 122, 0, 2291, 2288, 1, 0, 0, 0, 2291, 2292, 1, 0, 
	0, 0, 2292, 2296, 1, 0, 0, 0, 2293, 2294, 5, 310, 0, 0, 2294, 2295, 5, 
	17, 0, 0, 2295, 2297, 3, 896, 448, 0, 2296, 2293, 1, 0, 0, 0, 2296, 2297, 
	1, 0, 0, 0, 2297, 2302, 1, 0, 0, 0, 2298, 2299, 5, 310, 0, 0, 2299, 2300, 
	5, 17, 0, 0, 2300, 2302, 3, 896, 448, 0, 2301, 2260, 1, 0, 0, 0, 2301, 
	2272, 1, 0, 0, 0, 2301, 2285, 1, 0, 0, 0, 2301, 2298, 1, 0, 0, 0, 2302, 
	263, 1, 0, 0, 0, 2303, 2304, 5, 181, 0, 0, 2304, 2305, 5, 412, 0, 0, 2305, 
	265, 1, 0, 0, 0, 2306, 2311, 3, 332, 166, 0, 2307, 2308, 5, 384, 0, 0, 
	2308, 2310, 3, 332, 166, 0, 2309, 2307, 1, 0, 0, 0, 2310, 2313, 1, 0, 0, 
	0, 2311, 2309, 1, 0, 0, 0, 2311, 2312, 1, 0, 0, 0, 2312, 267, 1, 0, 0, 
	0, 2313, 2311, 1, 0, 0, 0, 2314, 2319, 3, 334, 167, 0, 2315, 2316, 5, 384, 
	0, 0, 2316, 2318, 3, 334, 167, 0, 2317, 2315, 1, 0, 0, 0, 2318, 2321, 1, 
	0, 0, 0, 2319, 2317, 1, 0, 0, 0, 2319, 2320, 1, 0, 0, 0, 2320, 269, 1, 
	0, 0, 0, 2321, 2319, 1, 0, 0, 0, 2322, 2327, 3, 362, 181, 0, 2323, 2324, 
	5, 384, 0, 0, 2324, 2326, 3, 362, 181, 0, 2325, 2323, 1, 0, 0, 0, 2326, 
	2329, 1, 0, 0, 0, 2327, 2325, 1, 0, 0, 0, 2327, 2328, 1, 0, 0, 0, 2328, 
	271, 1, 0, 0, 0, 2329, 2327, 1, 0, 0, 0, 2330, 2335, 3, 274, 137, 0, 2331, 
	2332, 5, 384, 0, 0, 2332, 2334, 3, 274, 137, 0, 2333, 2331, 1, 0, 0, 0, 
	2334, 2337, 1, 0, 0, 0, 2335, 2333, 1, 0, 0, 0, 2335, 2336, 1, 0, 0, 0, 
	2336, 273, 1, 0, 0, 0, 2337, 2335, 1, 0, 0, 0, 2338, 2339, 3, 896, 448, 
	0, 2339, 275, 1, 0, 0, 0, 2340, 2350, 3, 896, 448, 0, 2341, 2346, 5, 382, 
	0, 0, 2342, 2347, 5, 100, 0, 0, 2343, 2347, 5, 168, 0, 0, 2344, 2347, 5, 
	364, 0, 0, 2345, 2347, 3, 896, 448, 0, 2346, 2342, 1, 0, 0, 0, 2346, 2343, 
	1, 0, 0, 0, 2346, 2344, 1, 0, 0, 0, 2346, 2345, 1, 0, 0, 0, 2347, 2349, 
	1, 0, 0, 0, 2348, 2341, 1, 0, 0, 0, 2349, 2352, 1, 0, 0, 0, 2350, 2348, 
	1, 0, 0, 0, 2350, 2351, 1, 0, 0, 0, 2351, 277, 1, 0, 0, 0, 2352, 2350, 
	1, 0, 0, 0, 2353, 2358, 3, 322, 161, 0, 2354, 2355, 5, 384, 0, 0, 2355, 
	2357, 3, 322, 161, 0, 2356, 2354, 1, 0, 0, 0, 2357, 2360, 1, 0, 0, 0, 2358, 
	2356, 1, 0, 0, 0, 2358, 2359, 1, 0, 0, 0, 2359, 279, 1, 0, 0, 0, 2360, 
	2358, 1, 0, 0, 0, 2361, 2362, 5, 386, 0, 0, 2362, 2363, 3, 272, 136, 0, 
	2363, 2364, 5, 387, 0, 0, 2364, 281, 1, 0, 0, 0, 2365, 2367, 3, 284, 142, 
	0, 2366, 2368, 3, 286, 143, 0, 2367, 2366, 1, 0, 0, 0, 2367, 2368, 1, 0, 
	0, 0, 2368, 2371, 1, 0, 0, 0, 2369, 2371, 3, 288, 144, 0, 2370, 2365, 1, 
	0, 0, 0, 2370, 2369, 1, 0, 0, 0, 2371, 283, 1, 0, 0, 0, 2372, 2373, 7, 
	14, 0, 0, 2373, 285, 1, 0, 0, 0, 2374, 2375, 7, 15, 0, 0, 2375, 287, 1, 
	0, 0, 0, 2376, 2380, 5, 104, 0, 0, 2377, 2378, 5, 206, 0, 0, 2378, 2380, 
	5, 104, 0, 0, 2379, 2376, 1, 0, 0, 0, 2379, 2377, 1, 0, 0, 0, 2380, 289, 
	1, 0, 0, 0, 2381, 2382, 7, 16, 0, 0, 2382, 291, 1, 0, 0, 0, 2383, 2384, 
	5, 55, 0, 0, 2384, 2386, 3, 896, 448, 0, 2385, 2383, 1, 0, 0, 0, 2385, 
	2386, 1, 0, 0, 0, 2386, 2387, 1, 0, 0, 0, 2387, 2389, 3, 296, 148, 0, 2388, 
	2390, 3, 358, 179, 0, 2389, 2388, 1, 0, 0, 0, 2389, 2390, 1, 0, 0, 0, 2390, 
	293, 1, 0, 0, 0, 2391, 2392, 5, 55, 0, 0, 2392, 2393, 3, 896, 448, 0, 2393, 
	2395, 3, 296, 148, 0, 2394, 2396, 3, 360, 180, 0, 2395, 2394, 1, 0, 0, 
	0, 2395, 2396, 1, 0, 0, 0, 2396, 295, 1, 0, 0, 0, 2397, 2400, 3, 298, 149, 
	0, 2398, 2400, 3, 300, 150, 0, 2399, 2397, 1, 0, 0, 0, 2399, 2398, 1, 0, 
	0, 0, 2400, 297, 1, 0, 0, 0, 2401, 2402, 3, 356, 178, 0, 2402, 2403, 3, 
	280, 140, 0, 2403, 299, 1, 0, 0, 0, 2404, 2405, 5, 40, 0, 0, 2405, 2406, 
	5, 386, 0, 0, 2406, 2407, 3, 796, 398, 0, 2407, 2408, 5, 387, 0, 0, 2408, 
	301, 1, 0, 0, 0, 2409, 2410, 5, 55, 0, 0, 2410, 2412, 3, 896, 448, 0, 2411, 
	2409, 1, 0, 0, 0, 2411, 2412, 1, 0, 0, 0, 2412, 2413, 1, 0, 0, 0, 2413, 
	2414, 5, 131, 0, 0, 2414, 2415, 5, 166, 0, 0, 2415, 2416, 3, 280, 140, 
	0, 2416, 2417, 5, 259, 0, 0, 2417, 2418, 3, 640, 320, 0, 2418, 2420, 3, 
	280, 140, 0, 2419, 2421, 3, 358, 179, 0, 2420, 2419, 1, 0, 0, 0, 2420, 
	2421, 1, 0, 0, 0, 2421, 303, 1, 0, 0, 0, 2422, 2423, 5, 55, 0, 0, 2423, 
	2424, 3, 896, 448, 0, 2424, 2425, 5, 131, 0, 0, 2425, 2426, 5, 166, 0, 
	0, 2426, 2427, 3, 280, 140, 0, 2427, 2428, 5, 259, 0, 0, 2428, 2429, 3, 
	640, 320, 0, 2429, 2431, 3, 280, 140, 0, 2430, 2432, 3, 360, 180, 0, 2431, 
	2430, 1, 0, 0, 0, 2431, 2432, 1, 0, 0, 0, 2432, 305, 1, 0, 0, 0, 2433, 
	2436, 3, 312, 156, 0, 2434, 2436, 3, 308, 154, 0, 2435, 2433, 1, 0, 0, 
	0, 2435, 2434, 1, 0, 0, 0, 2436, 307, 1, 0, 0, 0, 2437, 2442, 3, 310, 155, 
	0, 2438, 2439, 5, 384, 0, 0, 2439, 2441, 3, 310, 155, 0, 2440, 2438, 1, 
	0, 0, 0, 2441, 2444, 1, 0, 0, 0, 2442, 2440, 1, 0, 0, 0, 2442, 2443, 1, 
	0, 0, 0, 2443, 309, 1, 0, 0, 0, 2444, 2442, 1, 0, 0, 0, 2445, 2446, 5, 
	386, 0, 0, 2446, 2447, 3, 312, 156, 0, 2447, 2448, 5, 387, 0, 0, 2448, 
	311, 1, 0, 0, 0, 2449, 2454, 3, 314, 157, 0, 2450, 2451, 5, 384, 0, 0, 
	2451, 2453, 3, 314, 157, 0, 2452, 2450, 1, 0, 0, 0, 2453, 2456, 1, 0, 0, 
	0, 2454, 2452, 1, 0, 0, 0, 2454, 2455, 1, 0, 0, 0, 2455, 313, 1, 0, 0, 
	0, 2456, 2454, 1, 0, 0, 0, 2457, 2458, 3, 772, 386, 0, 2458, 315, 1, 0, 
	0, 0, 2459, 2462, 3, 314, 157, 0, 2460, 2462, 3, 310, 155, 0, 2461, 2459, 
	1, 0, 0, 0, 2461, 2460, 1, 0, 0, 0, 2462, 317, 1, 0, 0, 0, 2463, 2464, 
	7, 17, 0, 0, 2464, 319, 1, 0, 0, 0, 2465, 2466, 5, 210, 0, 0, 2466, 2467, 
	7, 18, 0, 0, 2467, 321, 1, 0, 0, 0, 2468, 2470, 3, 896, 448, 0, 2469, 2471, 
	3, 318, 159, 0, 2470, 2469, 1, 0, 0, 0, 2470, 2471, 1, 0, 0, 0, 2471, 2473, 
	1, 0, 0, 0, 2472, 2474, 3, 320, 160, 0, 2473, 2472, 1, 0, 0, 0, 2473, 2474, 
	1, 0, 0, 0, 2474, 323, 1, 0, 0, 0, 2475, 2480, 3, 326, 163, 0, 2476, 2477, 
	5, 384, 0, 0, 2477, 2479, 3, 326, 163, 0, 2478, 2476, 1, 0, 0, 0, 2479, 
	2482, 1, 0, 0, 0, 2480, 2478, 1, 0, 0, 0, 2480, 2481, 1, 0, 0, 0, 2481, 
	325, 1, 0, 0, 0, 2482, 2480, 1, 0, 0, 0, 2483, 2486, 3, 896, 448, 0, 2484, 
	2485, 5, 47, 0, 0, 2485, 2487, 5, 412, 0, 0, 2486, 2484, 1, 0, 0, 0, 2486, 
	2487, 1, 0, 0, 0, 2487, 327, 1, 0, 0, 0, 2488, 2489, 7, 17, 0, 0, 2489, 
	329, 1, 0, 0, 0, 2490, 2492, 3, 796, 398, 0, 2491, 2493, 3, 328, 164, 0, 
	2492, 2491, 1, 0, 0, 0, 2492, 2493, 1, 0, 0, 0, 2493, 2495, 1, 0, 0, 0, 
	2494, 2496, 3, 320, 160, 0, 2495, 2494, 1, 0, 0, 0, 2495, 2496, 1, 0, 0, 
	0, 2496, 331, 1, 0, 0, 0, 2497, 2498, 3, 896, 448, 0, 2498, 2501, 3, 364, 
	182, 0, 2499, 2500, 5, 47, 0, 0, 2500, 2502, 5, 412, 0, 0, 2501, 2499, 
	1, 0, 0, 0, 2501, 2502, 1, 0, 0, 0, 2502, 333, 1, 0, 0, 0, 2503, 2506, 
	3, 336, 168, 0, 2504, 2506, 3, 338, 169, 0, 2505, 2503, 1, 0, 0, 0, 2505, 
	2504, 1, 0, 0, 0, 2506, 335, 1, 0, 0, 0, 2507, 2510, 3, 302, 151, 0, 2508, 
	2510, 3, 292, 146, 0, 2509, 2507, 1, 0, 0, 0, 2509, 2508, 1, 0, 0, 0, 2510, 
	337, 1, 0, 0, 0, 2511, 2512, 3, 896, 448, 0, 2512, 2514, 3, 364, 182, 0, 
	2513, 2515, 3, 340, 170, 0, 2514, 2513, 1, 0, 0, 0, 2514, 2515, 1, 0, 0, 
	0, 2515, 2518, 1, 0, 0, 0, 2516, 2517, 5, 47, 0, 0, 2517, 2519, 5, 412, 
	0, 0, 2518, 2516, 1, 0, 0, 0, 2518, 2519, 1, 0, 0, 0, 2519, 339, 1, 0, 
	0, 0, 2520, 2523, 3, 342, 171, 0, 2521, 2523, 3, 344, 172, 0, 2522, 2520, 
	1, 0, 0, 0, 2522, 2521, 1, 0, 0, 0, 2523, 341, 1, 0, 0, 0, 2524, 2525, 
	5, 55, 0, 0, 2525, 2527, 3, 896, 448, 0, 2526, 2524, 1, 0, 0, 0, 2526, 
	2527, 1, 0, 0, 0, 2527, 2528, 1, 0, 0, 0, 2528, 2529, 5, 259, 0, 0, 2529, 
	2530, 3, 640, 320, 0, 2530, 2531, 5, 386, 0, 0, 2531, 2532, 3, 274, 137, 
	0, 2532, 2534, 5, 387, 0, 0, 2533, 2535, 3, 358, 179, 0, 2534, 2533, 1, 
	0, 0, 0, 2534, 2535, 1, 0, 0, 0, 2535, 343, 1, 0, 0, 0, 2536, 2537, 5, 
	55, 0, 0, 2537, 2539, 3, 896, 448, 0, 2538, 2536, 1, 0, 0, 0, 2538, 2539, 
	1, 0, 0, 0, 2539, 2540, 1, 0, 0, 0, 2540, 2542, 3, 352, 176, 0, 2541, 2543, 
	3, 358, 179, 0, 2542, 2541, 1, 0, 0, 0, 2542, 2543, 1, 0, 0, 0, 2543, 345, 
	1, 0, 0, 0, 2544, 2547, 3, 348, 174, 0, 2545, 2547, 3, 350, 175, 0, 2546, 
	2544, 1, 0, 0, 0, 2546, 2545, 1, 0, 0, 0, 2547, 347, 1, 0, 0, 0, 2548, 
	2549, 5, 55, 0, 0, 2549, 2551, 3, 896, 448, 0, 2550, 2548, 1, 0, 0, 0, 
	2550, 2551, 1, 0, 0, 0, 2551, 2552, 1, 0, 0, 0, 2552, 2553, 5, 259, 0, 
	0, 2553, 2554, 3, 640, 320, 0, 2554, 2555, 5, 386, 0, 0, 2555, 2556, 3, 
	274, 137, 0, 2556, 2558, 5, 387, 0, 0, 2557, 2559, 3, 360, 180, 0, 2558, 
	2557, 1, 0, 0, 0, 2558, 2559, 1, 0, 0, 0, 2559, 349, 1, 0, 0, 0, 2560, 
	2561, 5, 55, 0, 0, 2561, 2563, 3, 896, 448, 0, 2562, 2560, 1, 0, 0, 0, 
	2562, 2563, 1, 0, 0, 0, 2563, 2564, 1, 0, 0, 0, 2564, 2566, 3, 352, 176, 
	0, 2565, 2567, 3, 360, 180, 0, 2566, 2565, 1, 0, 0, 0, 2566, 2567, 1, 0, 
	0, 0, 2567, 351, 1, 0, 0, 0, 2568, 2569, 5, 206, 0, 0, 2569, 2575, 5, 209, 
	0, 0, 2570, 2571, 5, 80, 0, 0, 2571, 2575, 3, 354, 177, 0, 2572, 2575, 
	3, 300, 150, 0, 2573, 2575, 3, 356, 178, 0, 2574, 2568, 1, 0, 0, 0, 2574, 
	2570, 1, 0, 0, 0, 2574, 2572, 1, 0, 0, 0, 2574, 2573, 1, 0, 0, 0, 2575, 
	353, 1, 0, 0, 0, 2576, 2580, 3, 772, 386, 0, 2577, 2580, 3, 752, 376, 0, 
	2578, 2580, 3, 758, 379, 0, 2579, 2576, 1, 0, 0, 0, 2579, 2577, 1, 0, 0, 
	0, 2579, 2578, 1, 0, 0, 0, 2580, 355, 1, 0, 0, 0, 2581, 2582, 5, 241, 0, 
	0, 2582, 2585, 5, 166, 0, 0, 2583, 2585, 5, 347, 0, 0, 2584, 2581, 1, 0, 
	0, 0, 2584, 2583, 1, 0, 0, 0, 2585, 357, 1, 0, 0, 0, 2586, 2588, 3, 282, 
	141, 0, 2587, 2589, 3, 290, 145, 0, 2588, 2587, 1, 0, 0, 0, 2588, 2589, 
	1, 0, 0, 0, 2589, 359, 1, 0, 0, 0, 2590, 2592, 3, 282, 141, 0, 2591, 2593, 
	3, 290, 145, 0, 2592, 2591, 1, 0, 0, 0, 2592, 2593, 1, 0, 0, 0, 2593, 361, 
	1, 0, 0, 0, 2594, 2595, 3, 896, 448, 0, 2595, 2596, 5, 383, 0, 0, 2596, 
	2599, 3, 364, 182, 0, 2597, 2598, 5, 47, 0, 0, 2598, 2600, 5, 412, 0, 0, 
	2599, 2597, 1, 0, 0, 0, 2599, 2600, 1, 0, 0, 0, 2600, 363, 1, 0, 0, 0, 
	2601, 2602, 3, 368, 184, 0, 2602, 365, 1, 0, 0, 0, 2603, 2608, 3, 364, 
	182, 0, 2604, 2605, 5, 384, 0, 0, 2605, 2607, 3, 364, 182, 0, 2606, 2604, 
	1, 0, 0, 0, 2607, 2610, 1, 0, 0, 0, 2608, 2606, 1, 0, 0, 0, 2608, 2609, 
	1, 0, 0, 0, 2609, 367, 1, 0, 0, 0, 2610, 2608, 1, 0, 0, 0, 2611, 2617, 
	3, 370, 185, 0, 2612, 2617, 3, 372, 186, 0, 2613, 2617, 3, 374, 187, 0, 
	2614, 2617, 3, 376, 188, 0, 2615, 2617, 3, 378, 189, 0, 2616, 2611, 1, 
	0, 0, 0, 2616, 2612, 1, 0, 0, 0, 2616, 2613, 1, 0, 0, 0, 2616, 2614, 1, 
	0, 0, 0, 2616, 2615, 1, 0, 0, 0, 2617, 369, 1, 0, 0, 0, 2618, 2655, 5, 
	329, 0, 0, 2619, 2655, 5, 300, 0, 0, 2620, 2655, 5, 156, 0, 0, 2621, 2655, 
	5, 26, 0, 0, 2622, 2655, 5, 28, 0, 0, 2623, 2655, 5, 126, 0, 0, 2624, 2655, 
	5, 254, 0, 0, 2625, 2627, 5, 96, 0, 0, 2626, 2628, 5, 238, 0, 0, 2627, 
	2626, 1, 0, 0, 0, 2627, 2628, 1, 0, 0, 0, 2628, 2655, 1, 0, 0, 0, 2629, 
	2655, 5, 71, 0, 0, 2630, 2655, 5, 72, 0, 0, 2631, 2655, 5, 326, 0, 0, 2632, 
	2655, 5, 327, 0, 0, 2633, 2634, 5, 326, 0, 0, 2634, 2635, 5, 375, 0, 0, 
	2635, 2636, 5, 180, 0, 0, 2636, 2637, 5, 325, 0, 0, 2637, 2655, 5, 381, 
	0, 0, 2638, 2655, 5, 312, 0, 0, 2639, 2655, 5, 27, 0, 0, 2640, 2648, 5, 
	79, 0, 0, 2641, 2642, 5, 386, 0, 0, 2642, 2645, 5, 417, 0, 0, 2643, 2644, 
	5, 384, 0, 0, 2644, 2646, 5, 417, 0, 0, 2645, 2643, 1, 0, 0, 0, 2645, 2646, 
	1, 0, 0, 0, 2646, 2647, 1, 0, 0, 0, 2647, 2649, 5, 387, 0, 0, 2648, 2641, 
	1, 0, 0, 0, 2648, 2649, 1, 0, 0, 0, 2649, 2655, 1, 0, 0, 0, 2650, 2651, 
	7, 19, 0, 0, 2651, 2652, 5, 386, 0, 0, 2652, 2653, 5, 417, 0, 0, 2653, 
	2655, 5, 387, 0, 0, 2654, 2618, 1, 0, 0, 0, 2654, 2619, 1, 0, 0, 0, 2654, 
	2620, 1, 0, 0, 0, 2654, 2621, 1, 0, 0, 0, 2654, 2622, 1, 0, 0, 0, 2654, 
	2623, 1, 0, 0, 0, 2654, 2624, 1, 0, 0, 0, 2654, 2625, 1, 0, 0, 0, 2654, 
	2629, 1, 0, 0, 0, 2654, 2630, 1, 0, 0, 0, 2654, 2631, 1, 0, 0, 0, 2654, 
	2632, 1, 0, 0, 0, 2654, 2633, 1, 0, 0, 0, 2654, 2638, 1, 0, 0, 0, 2654, 
	2639, 1, 0, 0, 0, 2654, 2640, 1, 0, 0, 0, 2654, 2650, 1, 0, 0, 0, 2655, 
	371, 1, 0, 0, 0, 2656, 2657, 5, 16, 0, 0, 2657, 2658, 5, 396, 0, 0, 2658, 
	2659, 3, 368, 184, 0, 2659, 2660, 5, 398, 0, 0, 2660, 373, 1, 0, 0, 0, 
	2661, 2662, 5, 313, 0, 0, 2662, 2663, 5, 396, 0, 0, 2663, 2664, 3, 270, 
	135, 0, 2664, 2665, 5, 398, 0, 0, 2665, 375, 1, 0, 0, 0, 2666, 2667, 5, 
	190, 0, 0, 2667, 2668, 5, 396, 0, 0, 2668, 2669, 3, 370, 185, 0, 2669, 
	2670, 5, 384, 0, 0, 2670, 2671, 3, 368, 184, 0, 2671, 2672, 5, 398, 0, 
	0, 2672, 377, 1, 0, 0, 0, 2673, 2674, 5, 346, 0, 0, 2674, 2675, 5, 396, 
	0, 0, 2675, 2676, 3, 366, 183, 0, 2676, 2677, 5, 398, 0, 0, 2677, 379, 
	1, 0, 0, 0, 2678, 2680, 7, 20, 0, 0, 2679, 2681, 7, 21, 0, 0, 2680, 2679, 
	1, 0, 0, 0, 2680, 2681, 1, 0, 0, 0, 2681, 381, 1, 0, 0, 0, 2682, 2684, 
	3, 386, 193, 0, 2683, 2682, 1, 0, 0, 0, 2683, 2684, 1, 0, 0, 0, 2684, 2685, 
	1, 0, 0, 0, 2685, 2686, 3, 384, 192, 0, 2686, 383, 1, 0, 0, 0, 2687, 2690, 
	3, 390, 195, 0, 2688, 2690, 3, 394, 197, 0, 2689, 2687, 1, 0, 0, 0, 2689, 
	2688, 1, 0, 0, 0, 2690, 385, 1, 0, 0, 0, 2691, 2692, 5, 375, 0, 0, 2692, 
	2697, 3, 388, 194, 0, 2693, 2694, 5, 384, 0, 0, 2694, 2696, 3, 388, 194, 
	0, 2695, 2693, 1, 0, 0, 0, 2696, 2699, 1, 0, 0, 0, 2697, 2695, 1, 0, 0, 
	0, 2697, 2698, 1, 0, 0, 0, 2698, 387, 1, 0, 0, 0, 2699, 2697, 1, 0, 0, 
	0, 2700, 2705, 3, 896, 448, 0, 2701, 2702, 5, 386, 0, 0, 2702, 2703, 3, 
	272, 136, 0, 2703, 2704, 5, 387, 0, 0, 2704, 2706, 1, 0, 0, 0, 2705, 2701, 
	1, 0, 0, 0, 2705, 2706, 1, 0, 0, 0, 2706, 2707, 1, 0, 0, 0, 2707, 2708, 
	5, 17, 0, 0, 2708, 2709, 5, 386, 0, 0, 2709, 2710, 3, 382, 191, 0, 2710, 
	2711, 5, 387, 0, 0, 2711, 389, 1, 0, 0, 0, 2712, 2718, 3, 392, 196, 0, 
	2713, 2714, 3, 380, 190, 0, 2714, 2715, 3, 392, 196, 0, 2715, 2717, 1, 
	0, 0, 0, 2716, 2713, 1, 0, 0, 0, 2717, 2720, 1, 0, 0, 0, 2718, 2716, 1, 
	0, 0, 0, 2718, 2719, 1, 0, 0, 0, 2719, 391, 1, 0, 0, 0, 2720, 2718, 1, 
	0, 0, 0, 2721, 2723, 3, 606, 303, 0, 2722, 2724, 3, 404, 202, 0, 2723, 
	2722, 1, 0, 0, 0, 2724, 2725, 1, 0, 0, 0, 2725, 2723, 1, 0, 0, 0, 2725, 
	2726, 1, 0, 0, 0, 2726, 393, 1, 0, 0, 0, 2727, 2728, 3, 406, 203, 0, 2728, 
	2729, 3, 398, 199, 0, 2729, 2732, 1, 0, 0, 0, 2730, 2732, 3, 398, 199, 
	0, 2731, 2727, 1, 0, 0, 0, 2731, 2730, 1, 0, 0, 0, 2732, 395, 1, 0, 0, 
	0, 2733, 2735, 3, 668, 334, 0, 2734, 2736, 3, 606, 303, 0, 2735, 2734, 
	1, 0, 0, 0, 2735, 2736, 1, 0, 0, 0, 2736, 2738, 1, 0, 0, 0, 2737, 2739, 
	3, 652, 326, 0, 2738, 2737, 1, 0, 0, 0, 2738, 2739, 1, 0, 0, 0, 2739, 2741, 
	1, 0, 0, 0, 2740, 2742, 3, 700, 350, 0, 2741, 2740, 1, 0, 0, 0, 2741, 2742, 
	1, 0, 0, 0, 2742, 2744, 1, 0, 0, 0, 2743, 2745, 3, 716, 358, 0, 2744, 2743, 
	1, 0, 0, 0, 2744, 2745, 1, 0, 0, 0, 2745, 2747, 1, 0, 0, 0, 2746, 2748, 
	3, 684, 342, 0, 2747, 2746, 1, 0, 0, 0, 2747, 2748, 1, 0, 0, 0, 2748, 2750, 
	1, 0, 0, 0, 2749, 2751, 3, 718, 359, 0, 2750, 2749, 1, 0, 0, 0, 2750, 2751, 
	1, 0, 0, 0, 2751, 2758, 1, 0, 0, 0, 2752, 2753, 5, 386, 0, 0, 2753, 2754, 
	3, 398, 199, 0, 2754, 2755, 5, 387, 0, 0, 2755, 2758, 1, 0, 0, 0, 2756, 
	2758, 3, 656, 328, 0, 2757, 2733, 1, 0, 0, 0, 2757, 2752, 1, 0, 0, 0, 2757, 
	2756, 1, 0, 0, 0, 2758, 397, 1, 0, 0, 0, 2759, 2761, 3, 396, 198, 0, 2760, 
	2762, 3, 400, 200, 0, 2761, 2760, 1, 0, 0, 0, 2761, 2762, 1, 0, 0, 0, 2762, 
	2764, 1, 0, 0, 0, 2763, 2765, 3, 740, 370, 0, 2764, 2763, 1, 0, 0, 0, 2764, 
	2765, 1, 0, 0, 0, 2765, 2767, 1, 0, 0, 0, 2766, 2768, 3, 742, 371, 0, 2767, 
	2766, 1, 0, 0, 0, 2767, 2768, 1, 0, 0, 0, 2768, 2770, 1, 0, 0, 0, 2769, 
	2771, 3, 746, 373, 0, 2770, 2769, 1, 0, 0, 0, 2770, 2771, 1, 0, 0, 0, 2771, 
	2773, 1, 0, 0, 0, 2772, 2774, 3, 748, 374, 0, 2773, 2772, 1, 0, 0, 0, 2773, 
	2774, 1, 0, 0, 0, 2774, 2776, 1, 0, 0, 0, 2775, 2777, 3, 410, 205, 0, 2776, 
	2775, 1, 0, 0, 0, 2776, 2777, 1, 0, 0, 0, 2777, 399, 1, 0, 0, 0, 2778, 
	2779, 3, 380, 190, 0, 2779, 2780, 3, 396, 198, 0, 2780, 2782, 1, 0, 0, 
	0, 2781, 2778, 1, 0, 0, 0, 2782, 2783, 1, 0, 0, 0, 2783, 2781, 1, 0, 0, 
	0, 2783, 2784, 1, 0, 0, 0, 2784, 401, 1, 0, 0, 0, 2785, 2787, 3, 386, 193, 
	0, 2786, 2785, 1, 0, 0, 0, 2786, 2787, 1, 0, 0, 0, 2787, 2788, 1, 0, 0, 
	0, 2788, 2789, 3, 398, 199, 0, 2789, 403, 1, 0, 0, 0, 2790, 2791, 3, 406, 
	203, 0, 2791, 2793, 3, 668, 334, 0, 2792, 2794, 3, 624, 312, 0, 2793, 2792, 
	1, 0, 0, 0, 2793, 2794, 1, 0, 0, 0, 2794, 2796, 1, 0, 0, 0, 2795, 2797, 
	3, 652, 326, 0, 2796, 2795, 1, 0, 0, 0, 2796, 2797, 1, 0, 0, 0, 2797, 2799, 
	1, 0, 0, 0, 2798, 2800, 3, 700, 350, 0, 2799, 2798, 1, 0, 0, 0, 2799, 2800, 
	1, 0, 0, 0, 2800, 2802, 1, 0, 0, 0, 2801, 2803, 3, 716, 358, 0, 2802, 2801, 
	1, 0, 0, 0, 2802, 2803, 1, 0, 0, 0, 2803, 2805, 1, 0, 0, 0, 2804, 2806, 
	3, 684, 342, 0, 2805, 2804, 1, 0, 0, 0, 2805, 2806, 1, 0, 0, 0, 2806, 2808, 
	1, 0, 0, 0, 2807, 2809, 3, 718, 359, 0, 2808, 2807, 1, 0, 0, 0, 2808, 2809, 
	1, 0, 0, 0, 2809, 2811, 1, 0, 0, 0, 2810, 2812, 3, 740, 370, 0, 2811, 2810, 
	1, 0, 0, 0, 2811, 2812, 1, 0, 0, 0, 2812, 2814, 1, 0, 0, 0, 2813, 2815, 
	3, 742, 371, 0, 2814, 2813, 1, 0, 0, 0, 2814, 2815, 1, 0, 0, 0, 2815, 2817, 
	1, 0, 0, 0, 2816, 2818, 3, 746, 373, 0, 2817, 2816, 1, 0, 0, 0, 2817, 2818, 
	1, 0, 0, 0, 2818, 2820, 1, 0, 0, 0, 2819, 2821, 3, 748, 374, 0, 2820, 2819, 
	1, 0, 0, 0, 2820, 2821, 1, 0, 0, 0, 2821, 2823, 1, 0, 0, 0, 2822, 2824, 
	3, 410, 205, 0, 2823, 2822, 1, 0, 0, 0, 2823, 2824, 1, 0, 0, 0, 2824, 2860, 
	1, 0, 0, 0, 2825, 2827, 3, 668, 334, 0, 2826, 2828, 3, 624, 312, 0, 2827, 
	2826, 1, 0, 0, 0, 2827, 2828, 1, 0, 0, 0, 2828, 2830, 1, 0, 0, 0, 2829, 
	2831, 3, 652, 326, 0, 2830, 2829, 1, 0, 0, 0, 2830, 2831, 1, 0, 0, 0, 2831, 
	2833, 1, 0, 0, 0, 2832, 2834, 3, 700, 350, 0, 2833, 2832, 1, 0, 0, 0, 2833, 
	2834, 1, 0, 0, 0, 2834, 2836, 1, 0, 0, 0, 2835, 2837, 3, 716, 358, 0, 2836, 
	2835, 1, 0, 0, 0, 2836, 2837, 1, 0, 0, 0, 2837, 2839, 1, 0, 0, 0, 2838, 
	2840, 3, 684, 342, 0, 2839, 2838, 1, 0, 0, 0, 2839, 2840, 1, 0, 0, 0, 2840, 
	2842, 1, 0, 0, 0, 2841, 2843, 3, 718, 359, 0, 2842, 2841, 1, 0, 0, 0, 2842, 
	2843, 1, 0, 0, 0, 2843, 2845, 1, 0, 0, 0, 2844, 2846, 3, 740, 370, 0, 2845, 
	2844, 1, 0, 0, 0, 2845, 2846, 1, 0, 0, 0, 2846, 2848, 1, 0, 0, 0, 2847, 
	2849, 3, 742, 371, 0, 2848, 2847, 1, 0, 0, 0, 2848, 2849, 1, 0, 0, 0, 2849, 
	2851, 1, 0, 0, 0, 2850, 2852, 3, 746, 373, 0, 2851, 2850, 1, 0, 0, 0, 2851, 
	2852, 1, 0, 0, 0, 2852, 2854, 1, 0, 0, 0, 2853, 2855, 3, 748, 374, 0, 2854, 
	2853, 1, 0, 0, 0, 2854, 2855, 1, 0, 0, 0, 2855, 2857, 1, 0, 0, 0, 2856, 
	2858, 3, 410, 205, 0, 2857, 2856, 1, 0, 0, 0, 2857, 2858, 1, 0, 0, 0, 2858, 
	2860, 1, 0, 0, 0, 2859, 2790, 1, 0, 0, 0, 2859, 2825, 1, 0, 0, 0, 2860, 
	405, 1, 0, 0, 0, 2861, 2878, 5, 155, 0, 0, 2862, 2863, 5, 225, 0, 0, 2863, 
	2865, 3, 408, 204, 0, 2864, 2866, 3, 40, 20, 0, 2865, 2864, 1, 0, 0, 0, 
	2865, 2866, 1, 0, 0, 0, 2866, 2879, 1, 0, 0, 0, 2867, 2869, 5, 159, 0, 
	0, 2868, 2870, 5, 318, 0, 0, 2869, 2868, 1, 0, 0, 0, 2869, 2870, 1, 0, 
	0, 0, 2870, 2871, 1, 0, 0, 0, 2871, 2876, 3, 878, 439, 0, 2872, 2873, 5, 
	386, 0, 0, 2873, 2874, 3, 272, 136, 0, 2874, 2875, 5, 387, 0, 0, 2875, 
	2877, 1, 0, 0, 0, 2876, 2872, 1, 0, 0, 0, 2876, 2877, 1, 0, 0, 0, 2877, 
	2879, 1, 0, 0, 0, 2878, 2862, 1, 0, 0, 0, 2878, 2867, 1, 0, 0, 0, 2879, 
	407, 1, 0, 0, 0, 2880, 2882, 5, 180, 0, 0, 2881, 2880, 1, 0, 0, 0, 2881, 
	2882, 1, 0, 0, 0, 2882, 2883, 1, 0, 0, 0, 2883, 2884, 5, 90, 0, 0, 2884, 
	2886, 5, 412, 0, 0, 2885, 2887, 3, 240, 120, 0, 2886, 2885, 1, 0, 0, 0, 
	2886, 2887, 1, 0, 0, 0, 2887, 2889, 1, 0, 0, 0, 2888, 2890, 3, 262, 131, 
	0, 2889, 2888, 1, 0, 0, 0, 2889, 2890, 1, 0, 0, 0, 2890, 2894, 1, 0, 0, 
	0, 2891, 2892, 5, 318, 0, 0, 2892, 2894, 3, 878, 439, 0, 2893, 2881, 1, 
	0, 0, 0, 2893, 2891, 1, 0, 0, 0, 2894, 409, 1, 0, 0, 0, 2895, 2904, 5, 
	177, 0, 0, 2896, 2897, 5, 417, 0, 0, 2897, 2899, 5, 384, 0, 0, 2898, 2896, 
	1, 0, 0, 0, 2898, 2899, 1, 0, 0, 0, 2899, 2900, 1, 0, 0, 0, 2900, 2905, 
	5, 417, 0, 0, 2901, 2902, 5, 417, 0, 0, 2902, 2903, 5, 213, 0, 0, 2903, 
	2905, 5, 417, 0, 0, 2904, 2898, 1, 0, 0, 0, 2904, 2901, 1, 0, 0, 0, 2905, 
	411, 1, 0, 0, 0, 2906, 2907, 5, 83, 0, 0, 2907, 2908, 5, 134, 0, 0, 2908, 
	2910, 3, 640, 320, 0, 2909, 2911, 3, 652, 326, 0, 2910, 2909, 1, 0, 0, 
	0, 2910, 2911, 1, 0, 0, 0, 2911, 413, 1, 0, 0, 0, 2912, 2913, 3, 598, 299, 
	0, 2913, 2914, 5, 392, 0, 0, 2914, 2915, 3, 416, 208, 0, 2915, 415, 1, 
	0, 0, 0, 2916, 2919, 3, 600, 300, 0, 2917, 2919, 3, 816, 408, 0, 2918, 
	2916, 1, 0, 0, 0, 2918, 2917, 1, 0, 0, 0, 2919, 417, 1, 0, 0, 0, 2920, 
	2921, 5, 293, 0, 0, 2921, 2926, 3, 414, 207, 0, 2922, 2923, 5, 384, 0, 
	0, 2923, 2925, 3, 414, 207, 0, 2924, 2922, 1, 0, 0, 0, 2925, 2928, 1, 0, 
	0, 0, 2926, 2924, 1, 0, 0, 0, 2926, 2927, 1, 0, 0, 0, 2927, 419, 1, 0, 
	0, 0, 2928, 2926, 1, 0, 0, 0, 2929, 2930, 5, 354, 0, 0, 2930, 2931, 3, 
	640, 320, 0, 2931, 2933, 3, 418, 209, 0, 2932, 2934, 3, 652, 326, 0, 2933, 
	2932, 1, 0, 0, 0, 2933, 2934, 1, 0, 0, 0, 2934, 421, 1, 0, 0, 0, 2935, 
	2940, 3, 424, 212, 0, 2936, 2940, 3, 434, 217, 0, 2937, 2940, 3, 436, 218, 
	0, 2938, 2940, 3, 438, 219, 0, 2939, 2935, 1, 0, 0, 0, 2939, 2936, 1, 0, 
	0, 0, 2939, 2937, 1, 0, 0, 0, 2939, 2938, 1, 0, 0, 0, 2940, 423, 1, 0, 
	0, 0, 2941, 2942, 5, 307, 0, 0, 2942, 2951, 5, 333, 0, 0, 2943, 2948, 3, 
	426, 213, 0, 2944, 2945, 5, 384, 0, 0, 2945, 2947, 3, 426, 213, 0, 2946, 
	2944, 1, 0, 0, 0, 2947, 2950, 1, 0, 0, 0, 2948, 2946, 1, 0, 0, 0, 2948, 
	2949, 1, 0, 0, 0, 2949, 2952, 1, 0, 0, 0, 2950, 2948, 1, 0, 0, 0, 2951, 
	2943, 1, 0, 0, 0, 2951, 2952, 1, 0, 0, 0, 2952, 425, 1, 0, 0, 0, 2953, 
	2956, 3, 430, 215, 0, 2954, 2956, 3, 428, 214, 0, 2955, 2953, 1, 0, 0, 
	0, 2955, 2954, 1, 0, 0, 0, 2956, 427, 1, 0, 0, 0, 2957, 2958, 5, 251, 0, 
	0, 2958, 2959, 7, 22, 0, 0, 2959, 429, 1, 0, 0, 0, 2960, 2961, 5, 161, 
	0, 0, 2961, 2962, 5, 175, 0, 0, 2962, 2963, 3, 432, 216, 0, 2963, 431, 
	1, 0, 0, 0, 2964, 2965, 5, 301, 0, 0, 2965, 433, 1, 0, 0, 0, 2966, 2968, 
	5, 48, 0, 0, 2967, 2969, 5, 377, 0, 0, 2968, 2967, 1, 0, 0, 0, 2968, 2969, 
	1, 0, 0, 0, 2969, 435, 1, 0, 0, 0, 2970, 2972, 5, 279, 0, 0, 2971, 2973, 
	5, 377, 0, 0, 2972, 2971, 1, 0, 0, 0, 2972, 2973, 1, 0, 0, 0, 2973, 437, 
	1, 0, 0, 0, 2974, 2975, 5, 293, 0, 0, 2975, 2976, 5, 22, 0, 0, 2976, 2977, 
	3, 876, 438, 0, 2977, 439, 1, 0, 0, 0, 2978, 2979, 5, 1, 0, 0, 2979, 2981, 
	5, 335, 0, 0, 2980, 2982, 5, 417, 0, 0, 2981, 2980, 1, 0, 0, 0, 2982, 2983, 
	1, 0, 0, 0, 2983, 2981, 1, 0, 0, 0, 2983, 2984, 1, 0, 0, 0, 2984, 441, 
	1, 0, 0, 0, 2985, 2986, 5, 1, 0, 0, 2986, 2988, 5, 50, 0, 0, 2987, 2989, 
	5, 417, 0, 0, 2988, 2987, 1, 0, 0, 0, 2989, 2990, 1, 0, 0, 0, 2990, 2988, 
	1, 0, 0, 0, 2990, 2991, 1, 0, 0, 0, 2991, 443, 1, 0, 0, 0, 2992, 2994, 
	5, 195, 0, 0, 2993, 2995, 5, 422, 0, 0, 2994, 2993, 1, 0, 0, 0, 2994, 2995, 
	1, 0, 0, 0, 2995, 2996, 1, 0, 0, 0, 2996, 2997, 5, 159, 0, 0, 2997, 3002, 
	3, 640, 320, 0, 2998, 3000, 5, 17, 0, 0, 2999, 2998, 1, 0, 0, 0, 2999, 
	3000, 1, 0, 0, 0, 3000, 3001, 1, 0, 0, 0, 3001, 3003, 3, 896, 448, 0, 3002, 
	2999, 1, 0, 0, 0, 3002, 3003, 1, 0, 0, 0, 3003, 3004, 1, 0, 0, 0, 3004, 
	3005, 5, 359, 0, 0, 3005, 3006, 3, 614, 307, 0, 3006, 3007, 5, 214, 0, 
	0, 3007, 3008, 3, 796, 398, 0, 3008, 3009, 3, 446, 223, 0, 3009, 445, 1, 
	0, 0, 0, 3010, 3013, 3, 450, 225, 0, 3011, 3013, 3, 452, 226, 0, 3012, 
	3010, 1, 0, 0, 0, 3012, 3011, 1, 0, 0, 0, 3013, 3016, 1, 0, 0, 0, 3014, 
	3012, 1, 0, 0, 0, 3014, 3015, 1, 0, 0, 0, 3015, 3018, 1, 0, 0, 0, 3016, 
	3014, 1, 0, 0, 0, 3017, 3019, 3, 448, 224, 0, 3018, 3017, 1, 0, 0, 0, 3018, 
	3019, 1, 0, 0, 0, 3019, 447, 1, 0, 0, 0, 3020, 3021, 5, 371, 0, 0, 3021, 
	3022, 5, 206, 0, 0, 3022, 3025, 5, 193, 0, 0, 3023, 3024, 5, 11, 0, 0, 
	3024, 3026, 3, 796, 398, 0, 3025, 3023, 1, 0, 0, 0, 3025, 3026, 1, 0, 0, 
	0, 3026, 3027, 1, 0, 0, 0, 3027, 3028, 5, 324, 0, 0, 3028, 3030, 5, 155, 
	0, 0, 3029, 3031, 3, 280, 140, 0, 3030, 3029, 1, 0, 0, 0, 3030, 3031, 1, 
	0, 0, 0, 3031, 3032, 1, 0, 0, 0, 3032, 3033, 5, 363, 0, 0, 3033, 3034, 
	3, 662, 331, 0, 3034, 449, 1, 0, 0, 0, 3035, 3036, 5, 371, 0, 0, 3036, 
	3037, 5, 193, 0, 0, 3037, 3038, 5, 11, 0, 0, 3038, 3039, 3, 796, 398, 0, 
	3039, 3040, 5, 324, 0, 0, 3040, 3041, 3, 454, 227, 0, 3041, 451, 1, 0, 
	0, 0, 3042, 3043, 5, 371, 0, 0, 3043, 3044, 5, 193, 0, 0, 3044, 3045, 5, 
	324, 0, 0, 3045, 3046, 3, 454, 227, 0, 3046, 453, 1, 0, 0, 0, 3047, 3048, 
	5, 354, 0, 0, 3048, 3051, 3, 418, 209, 0, 3049, 3051, 5, 83, 0, 0, 3050, 
	3047, 1, 0, 0, 0, 3050, 3049, 1, 0, 0, 0, 3051, 455, 1, 0, 0, 0, 3052, 
	3053, 5, 169, 0, 0, 3053, 3055, 5, 248, 0, 0, 3054, 3056, 5, 412, 0, 0, 
	3055, 3054, 1, 0, 0, 0, 3056, 3057, 1, 0, 0, 0, 3057, 3055, 1, 0, 0, 0, 
	3057, 3058, 1, 0, 0, 0, 3058, 457, 1, 0, 0, 0, 3059, 3060, 5, 51, 0, 0, 
	3060, 3061, 5, 392, 0, 0, 3061, 3062, 5, 417, 0, 0, 3062, 459, 1, 0, 0, 
	0, 3063, 3064, 5, 236, 0, 0, 3064, 3065, 5, 412, 0, 0, 3065, 461, 1, 0, 
	0, 0, 3066, 3067, 5, 341, 0, 0, 3067, 3068, 5, 412, 0, 0, 3068, 463, 1, 
	0, 0, 0, 3069, 3070, 5, 309, 0, 0, 3070, 3071, 5, 412, 0, 0, 3071, 465, 
	1, 0, 0, 0, 3072, 3094, 5, 9, 0, 0, 3073, 3074, 5, 318, 0, 0, 3074, 3075, 
	3, 640, 320, 0, 3075, 3076, 3, 468, 234, 0, 3076, 3095, 1, 0, 0, 0, 3077, 
	3078, 5, 367, 0, 0, 3078, 3080, 3, 640, 320, 0, 3079, 3081, 5, 17, 0, 0, 
	3080, 3079, 1, 0, 0, 0, 3080, 3081, 1, 0, 0, 0, 3081, 3082, 1, 0, 0, 0, 
	3082, 3083, 3, 474, 237, 0, 3083, 3095, 1, 0, 0, 0, 3084, 3085, 5, 194, 
	0, 0, 3085, 3086, 5, 367, 0, 0, 3086, 3087, 3, 640, 320, 0, 3087, 3088, 
	3, 476, 238, 0, 3088, 3095, 1, 0, 0, 0, 3089, 3090, 3, 88, 44, 0, 3090, 
	3091, 3, 482, 241, 0, 3091, 3095, 1, 0, 0, 0, 3092, 3093, 5, 69, 0, 0, 
	3093, 3095, 3, 572, 286, 0, 3094, 3073, 1, 0, 0, 0, 3094, 3077, 1, 0, 0, 
	0, 3094, 3084, 1, 0, 0, 0, 3094, 3089, 1, 0, 0, 0, 3094, 3092, 1, 0, 0, 
	0, 3095, 467, 1, 0, 0, 0, 3096, 3116, 3, 492, 246, 0, 3097, 3116, 3, 522, 
	261, 0, 3098, 3116, 3, 510, 255, 0, 3099, 3116, 3, 514, 257, 0, 3100, 3116, 
	3, 516, 258, 0, 3101, 3116, 3, 518, 259, 0, 3102, 3116, 3, 524, 262, 0, 
	3103, 3116, 3, 546, 273, 0, 3104, 3116, 3, 548, 274, 0, 3105, 3116, 3, 
	472, 236, 0, 3106, 3116, 3, 500, 250, 0, 3107, 3116, 3, 496, 248, 0, 3108, 
	3116, 3, 470, 235, 0, 3109, 3110, 3, 880, 440, 0, 3110, 3111, 3, 470, 235, 
	0, 3111, 3116, 1, 0, 0, 0, 3112, 3116, 3, 564, 282, 0, 3113, 3116, 3, 566, 
	283, 0, 3114, 3116, 3, 568, 284, 0, 3115, 3096, 1, 0, 0, 0, 3115, 3097, 
	1, 0, 0, 0, 3115, 3098, 1, 0, 0, 0, 3115, 3099, 1, 0, 0, 0, 3115, 3100, 
	1, 0, 0, 0, 3115, 3101, 1, 0, 0, 0, 3115, 3102, 1, 0, 0, 0, 3115, 3103, 
	1, 0, 0, 0, 3115, 3104, 1, 0, 0, 0, 3115, 3105, 1, 0, 0, 0, 3115, 3106, 
	1, 0, 0, 0, 3115, 3107, 1, 0, 0, 0, 3115, 3108, 1, 0, 0, 0, 3115, 3109, 
	1, 0, 0, 0, 3115, 3112, 1, 0, 0, 0, 3115, 3113, 1, 0, 0, 0, 3115, 3114, 
	1, 0, 0, 0, 3116, 469, 1, 0, 0, 0, 3117, 3132, 3, 532, 266, 0, 3118, 3132, 
	3, 544, 272, 0, 3119, 3132, 3, 554, 277, 0, 3120, 3132, 3, 528, 264, 0, 
	3121, 3132, 3, 550, 275, 0, 3122, 3132, 3, 556, 278, 0, 3123, 3132, 3, 
	536, 268, 0, 3124, 3132, 3, 534, 267, 0, 3125, 3132, 3, 562, 281, 0, 3126, 
	3132, 3, 504, 252, 0, 3127, 3132, 3, 506, 253, 0, 3128, 3132, 3, 502, 251, 
	0, 3129, 3132, 3, 494, 247, 0, 3130, 3132, 3, 498, 249, 0, 3131, 3117, 
	1, 0, 0, 0, 3131, 3118, 1, 0, 0, 0, 3131, 3119, 1, 0, 0, 0, 3131, 3120, 
	1, 0, 0, 0, 3131, 3121, 1, 0, 0, 0, 3131, 3122, 1, 0, 0, 0, 3131, 3123, 
	1, 0, 0, 0, 3131, 3124, 1, 0, 0, 0, 3131, 3125, 1, 0, 0, 0, 3131, 3126, 
	1, 0, 0, 0, 3131, 3127, 1, 0, 0, 0, 3131, 3128, 1, 0, 0, 0, 3131, 3129, 
	1, 0, 0, 0, 3131, 3130, 1, 0, 0, 0, 3132, 471, 1, 0, 0, 0, 3133, 3134, 
	5, 227, 0, 0, 3134, 3135, 5, 45, 0, 0, 3135, 3136, 5, 386, 0, 0, 3136, 
	3137, 3, 332, 166, 0, 3137, 3138, 5, 387, 0, 0, 3138, 473, 1, 0, 0, 0, 
	3139, 3145, 3, 526, 263, 0, 3140, 3145, 3, 492, 246, 0, 3141, 3145, 3, 
	510, 255, 0, 3142, 3145, 3, 522, 261, 0, 3143, 3145, 3, 402, 201, 0, 3144, 
	3139, 1, 0, 0, 0, 3144, 3140, 1, 0, 0, 0, 3144, 3141, 1, 0, 0, 0, 3144, 
	3142, 1, 0, 0, 0, 3144, 3143, 1, 0, 0, 0, 3145, 475, 1, 0, 0, 0, 3146, 
	3149, 3, 478, 239, 0, 3147, 3149, 3, 480, 240, 0, 3148, 3146, 1, 0, 0, 
	0, 3148, 3147, 1, 0, 0, 0, 3149, 477, 1, 0, 0, 0, 3150, 3153, 3, 44, 22, 
	0, 3151, 3153, 3, 46, 23, 0, 3152, 3150, 1, 0, 0, 0, 3152, 3151, 1, 0, 
	0, 0, 3153, 479, 1, 0, 0, 0, 3154, 3155, 5, 255, 0, 0, 3155, 481, 1, 0, 
	0, 0, 3156, 3160, 3, 484, 242, 0, 3157, 3160, 3, 486, 243, 0, 3158, 3160, 
	3, 488, 244, 0, 3159, 3156, 1, 0, 0, 0, 3159, 3157, 1, 0, 0, 0, 3159, 3158, 
	1, 0, 0, 0, 3160, 483, 1, 0, 0, 0, 3161, 3162, 3, 896, 448, 0, 3162, 3163, 
	5, 293, 0, 0, 3163, 3164, 5, 75, 0, 0, 3164, 3165, 3, 58, 29, 0, 3165, 
	485, 1, 0, 0, 0, 3166, 3167, 3, 896, 448, 0, 3167, 3168, 5, 293, 0, 0, 
	3168, 3169, 5, 226, 0, 0, 3169, 3170, 3, 144, 72, 0, 3170, 487, 1, 0, 0, 
	0, 3171, 3172, 3, 896, 448, 0, 3172, 3173, 5, 293, 0, 0, 3173, 3174, 7, 
	23, 0, 0, 3174, 3175, 5, 412, 0, 0, 3175, 489, 1, 0, 0, 0, 3176, 3177, 
	3, 896, 448, 0, 3177, 3178, 5, 293, 0, 0, 3178, 3179, 5, 188, 0, 0, 3179, 
	3180, 5, 412, 0, 0, 3180, 491, 1, 0, 0, 0, 3181, 3182, 5, 264, 0, 0, 3182, 
	3183, 5, 330, 0, 0, 3183, 3184, 3, 640, 320, 0, 3184, 493, 1, 0, 0, 0, 
	3185, 3188, 5, 4, 0, 0, 3186, 3188, 5, 268, 0, 0, 3187, 3185, 1, 0, 0, 
	0, 3187, 3186, 1, 0, 0, 0, 3188, 3189, 1, 0, 0, 0, 3189, 3190, 5, 46, 0, 
	0, 3190, 3191, 5, 386, 0, 0, 3191, 3192, 3, 266, 133, 0, 3192, 3194, 5, 
	387, 0, 0, 3193, 3195, 3, 38, 19, 0, 3194, 3193, 1, 0, 0, 0, 3194, 3195, 
	1, 0, 0, 0, 3195, 495, 1, 0, 0, 0, 3196, 3199, 5, 4, 0, 0, 3197, 3200, 
	3, 304, 152, 0, 3198, 3200, 3, 294, 147, 0, 3199, 3197, 1, 0, 0, 0, 3199, 
	3198, 1, 0, 0, 0, 3200, 497, 1, 0, 0, 0, 3201, 3202, 5, 354, 0, 0, 3202, 
	3204, 5, 46, 0, 0, 3203, 3205, 3, 38, 19, 0, 3204, 3203, 1, 0, 0, 0, 3204, 
	3205, 1, 0, 0, 0, 3205, 499, 1, 0, 0, 0, 3206, 3207, 5, 98, 0, 0, 3207, 
	3208, 5, 55, 0, 0, 3208, 3209, 3, 896, 448, 0, 3209, 501, 1, 0, 0, 0, 3210, 
	3212, 5, 38, 0, 0, 3211, 3213, 5, 45, 0, 0, 3212, 3211, 1, 0, 0, 0, 3212, 
	3213, 1, 0, 0, 0, 3213, 3214, 1, 0, 0, 0, 3214, 3215, 3, 896, 448, 0, 3215, 
	3216, 3, 896, 448, 0, 3216, 3218, 3, 364, 182, 0, 3217, 3219, 3, 346, 173, 
	0, 3218, 3217, 1, 0, 0, 0, 3218, 3219, 1, 0, 0, 0, 3219, 3222, 1, 0, 0, 
	0, 3220, 3221, 5, 47, 0, 0, 3221, 3223, 5, 412, 0, 0, 3222, 3220, 1, 0, 
	0, 0, 3222, 3223, 1, 0, 0, 0, 3223, 3225, 1, 0, 0, 0, 3224, 3226, 3, 508, 
	254, 0, 3225, 3224, 1, 0, 0, 0, 3225, 3226, 1, 0, 0, 0, 3226, 3228, 1, 
	0, 0, 0, 3227, 3229, 3, 38, 19, 0, 3228, 3227, 1, 0, 0, 0, 3228, 3229, 
	1, 0, 0, 0, 3229, 503, 1, 0, 0, 0, 3230, 3231, 5, 354, 0, 0, 3231, 3232, 
	5, 308, 0, 0, 3232, 3234, 5, 129, 0, 0, 3233, 3235, 5, 45, 0, 0, 3234, 
	3233, 1, 0, 0, 0, 3234, 3235, 1, 0, 0, 0, 3235, 3236, 1, 0, 0, 0, 3236, 
	3237, 3, 896, 448, 0, 3237, 3238, 5, 293, 0, 0, 3238, 3241, 3, 244, 122, 
	0, 3239, 3240, 5, 47, 0, 0, 3240, 3242, 5, 412, 0, 0, 3241, 3239, 1, 0, 
	0, 0, 3241, 3242, 1, 0, 0, 0, 3242, 505, 1, 0, 0, 0, 3243, 3244, 5, 354, 
	0, 0, 3244, 3245, 5, 308, 0, 0, 3245, 3246, 5, 293, 0, 0, 3246, 3247, 3, 
	244, 122, 0, 3247, 507, 1, 0, 0, 0, 3248, 3252, 5, 125, 0, 0, 3249, 3250, 
	5, 6, 0, 0, 3250, 3252, 3, 896, 448, 0, 3251, 3248, 1, 0, 0, 0, 3251, 3249, 
	1, 0, 0, 0, 3252, 509, 1, 0, 0, 0, 3253, 3255, 5, 4, 0, 0, 3254, 3256, 
	3, 40, 20, 0, 3255, 3254, 1, 0, 0, 0, 3255, 3256, 1, 0, 0, 0, 3256, 3258, 
	1, 0, 0, 0, 3257, 3259, 3, 512, 256, 0, 3258, 3257, 1, 0, 0, 0, 3259, 3260, 
	1, 0, 0, 0, 3260, 3258, 1, 0, 0, 0, 3260, 3261, 1, 0, 0, 0, 3261, 511, 
	1, 0, 0, 0, 3262, 3264, 3, 880, 440, 0, 3263, 3265, 3, 520, 260, 0, 3264, 
	3263, 1, 0, 0, 0, 3264, 3265, 1, 0, 0, 0, 3265, 513, 1, 0, 0, 0, 3266, 
	3270, 5, 331, 0, 0, 3267, 3269, 3, 880, 440, 0, 3268, 3267, 1, 0, 0, 0, 
	3269, 3272, 1, 0, 0, 0, 3270, 3268, 1, 0, 0, 0, 3270, 3271, 1, 0, 0, 0, 
	3271, 515, 1, 0, 0, 0, 3272, 3270, 1, 0, 0, 0, 3273, 3277, 5, 15, 0, 0, 
	3274, 3276, 3, 880, 440, 0, 3275, 3274, 1, 0, 0, 0, 3276, 3279, 1, 0, 0, 
	0, 3277, 3275, 1, 0, 0, 0, 3277, 3278, 1, 0, 0, 0, 3278, 517, 1, 0, 0, 
	0, 3279, 3277, 1, 0, 0, 0, 3280, 3284, 5, 342, 0, 0, 3281, 3283, 3, 880, 
	440, 0, 3282, 3281, 1, 0, 0, 0, 3283, 3286, 1, 0, 0, 0, 3284, 3282, 1, 
	0, 0, 0, 3284, 3285, 1, 0, 0, 0, 3285, 519, 1, 0, 0, 0, 3286, 3284, 1, 
	0, 0, 0, 3287, 3288, 5, 181, 0, 0, 3288, 3289, 5, 412, 0, 0, 3289, 521, 
	1, 0, 0, 0, 3290, 3292, 5, 98, 0, 0, 3291, 3293, 3, 36, 18, 0, 3292, 3291, 
	1, 0, 0, 0, 3292, 3293, 1, 0, 0, 0, 3293, 3294, 1, 0, 0, 0, 3294, 3295, 
	5, 227, 0, 0, 3295, 3301, 3, 884, 442, 0, 3296, 3297, 5, 384, 0, 0, 3297, 
	3298, 5, 227, 0, 0, 3298, 3300, 3, 884, 442, 0, 3299, 3296, 1, 0, 0, 0, 
	3300, 3303, 1, 0, 0, 0, 3301, 3299, 1, 0, 0, 0, 3301, 3302, 1, 0, 0, 0, 
	3302, 3305, 1, 0, 0, 0, 3303, 3301, 1, 0, 0, 0, 3304, 3306, 5, 245, 0, 
	0, 3305, 3304, 1, 0, 0, 0, 3305, 3306, 1, 0, 0, 0, 3306, 3308, 1, 0, 0, 
	0, 3307, 3309, 3, 14, 7, 0, 3308, 3307, 1, 0, 0, 0, 3308, 3309, 1, 0, 0, 
	0, 3309, 523, 1, 0, 0, 0, 3310, 3311, 5, 293, 0, 0, 3311, 3312, 5, 321, 
	0, 0, 3312, 3320, 3, 244, 122, 0, 3313, 3314, 5, 352, 0, 0, 3314, 3316, 
	5, 321, 0, 0, 3315, 3317, 3, 36, 18, 0, 3316, 3315, 1, 0, 0, 0, 3316, 3317, 
	1, 0, 0, 0, 3317, 3318, 1, 0, 0, 0, 3318, 3320, 3, 244, 122, 0, 3319, 3310, 
	1, 0, 0, 0, 3319, 3313, 1, 0, 0, 0, 3320, 525, 1, 0, 0, 0, 3321, 3322, 
	5, 293, 0, 0, 3322, 3323, 5, 321, 0, 0, 3323, 3331, 3, 244, 122, 0, 3324, 
	3325, 5, 352, 0, 0, 3325, 3327, 5, 321, 0, 0, 3326, 3328, 3, 36, 18, 0, 
	3327, 3326, 1, 0, 0, 0, 3327, 3328, 1, 0, 0, 0, 3328, 3329, 1, 0, 0, 0, 
	3329, 3331, 3, 244, 122, 0, 3330, 3321, 1, 0, 0, 0, 3330, 3324, 1, 0, 0, 
	0, 3331, 527, 1, 0, 0, 0, 3332, 3342, 5, 293, 0, 0, 3333, 3334, 5, 290, 
	0, 0, 3334, 3338, 5, 412, 0, 0, 3335, 3336, 5, 375, 0, 0, 3336, 3337, 5, 
	291, 0, 0, 3337, 3339, 3, 244, 122, 0, 3338, 3335, 1, 0, 0, 0, 3338, 3339, 
	1, 0, 0, 0, 3339, 3343, 1, 0, 0, 0, 3340, 3341, 5, 291, 0, 0, 3341, 3343, 
	3, 244, 122, 0, 3342, 3333, 1, 0, 0, 0, 3342, 3340, 1, 0, 0, 0, 3343, 3348, 
	1, 0, 0, 0, 3344, 3345, 5, 352, 0, 0, 3345, 3346, 5, 291, 0, 0, 3346, 3348, 
	3, 244, 122, 0, 3347, 3332, 1, 0, 0, 0, 3347, 3344, 1, 0, 0, 0, 3348, 529, 
	1, 0, 0, 0, 3349, 3351, 3, 640, 320, 0, 3350, 3352, 3, 880, 440, 0, 3351, 
	3350, 1, 0, 0, 0, 3351, 3352, 1, 0, 0, 0, 3352, 531, 1, 0, 0, 0, 3353, 
	3354, 5, 293, 0, 0, 3354, 3355, 5, 124, 0, 0, 3355, 3356, 3, 570, 285, 
	0, 3356, 533, 1, 0, 0, 0, 3357, 3358, 5, 206, 0, 0, 3358, 3361, 7, 24, 
	0, 0, 3359, 3361, 3, 224, 112, 0, 3360, 3357, 1, 0, 0, 0, 3360, 3359, 1, 
	0, 0, 0, 3361, 535, 1, 0, 0, 0, 3362, 3363, 5, 293, 0, 0, 3363, 3364, 5, 
	299, 0, 0, 3364, 3365, 5, 181, 0, 0, 3365, 3366, 3, 538, 269, 0, 3366, 
	537, 1, 0, 0, 0, 3367, 3368, 5, 386, 0, 0, 3368, 3369, 3, 540, 270, 0, 
	3369, 3370, 5, 387, 0, 0, 3370, 539, 1, 0, 0, 0, 3371, 3376, 3, 542, 271, 
	0, 3372, 3373, 5, 384, 0, 0, 3373, 3375, 3, 542, 271, 0, 3374, 3372, 1, 
	0, 0, 0, 3375, 3378, 1, 0, 0, 0, 3376, 3374, 1, 0, 0, 0, 3376, 3377, 1, 
	0, 0, 0, 3377, 541, 1, 0, 0, 0, 3378, 3376, 1, 0, 0, 0, 3379, 3380, 3, 
	316, 158, 0, 3380, 3381, 5, 392, 0, 0, 3381, 3382, 5, 412, 0, 0, 3382, 
	543, 1, 0, 0, 0, 3383, 3384, 5, 293, 0, 0, 3384, 3385, 5, 181, 0, 0, 3385, 
	3386, 5, 412, 0, 0, 3386, 545, 1, 0, 0, 0, 3387, 3394, 3, 228, 114, 0, 
	3388, 3391, 5, 206, 0, 0, 3389, 3392, 5, 299, 0, 0, 3390, 3392, 3, 48, 
	24, 0, 3391, 3389, 1, 0, 0, 0, 3391, 3390, 1, 0, 0, 0, 3392, 3394, 1, 0, 
	0, 0, 3393, 3387, 1, 0, 0, 0, 3393, 3388, 1, 0, 0, 0, 3394, 547, 1, 0, 
	0, 0, 3395, 3396, 5, 108, 0, 0, 3396, 3397, 3, 880, 440, 0, 3397, 3398, 
	5, 375, 0, 0, 3398, 3399, 5, 318, 0, 0, 3399, 3400, 3, 640, 320, 0, 3400, 
	549, 1, 0, 0, 0, 3401, 3402, 5, 264, 0, 0, 3402, 3403, 5, 330, 0, 0, 3403, 
	3404, 3, 880, 440, 0, 3404, 551, 1, 0, 0, 0, 3405, 3406, 5, 354, 0, 0, 
	3406, 3407, 5, 308, 0, 0, 3407, 3409, 5, 129, 0, 0, 3408, 3410, 5, 45, 
	0, 0, 3409, 3408, 1, 0, 0, 0, 3409, 3410, 1, 0, 0, 0, 3410, 3411, 1, 0, 
	0, 0, 3411, 3412, 3, 896, 448, 0, 3412, 3413, 5, 293, 0, 0, 3413, 3416, 
	3, 244, 122, 0, 3414, 3415, 5, 47, 0, 0, 3415, 3417, 5, 412, 0, 0, 3416, 
	3414, 1, 0, 0, 0, 3416, 3417, 1, 0, 0, 0, 3417, 553, 1, 0, 0, 0, 3418, 
	3419, 5, 53, 0, 0, 3419, 555, 1, 0, 0, 0, 3420, 3421, 5, 159, 0, 0, 3421, 
	3422, 5, 417, 0, 0, 3422, 3423, 5, 31, 0, 0, 3423, 557, 1, 0, 0, 0, 3424, 
	3425, 5, 11, 0, 0, 3425, 3426, 5, 369, 0, 0, 3426, 559, 1, 0, 0, 0, 3427, 
	3428, 5, 236, 0, 0, 3428, 3429, 5, 412, 0, 0, 3429, 561, 1, 0, 0, 0, 3430, 
	3431, 5, 49, 0, 0, 3431, 3433, 5, 412, 0, 0, 3432, 3434, 3, 226, 113, 0, 
	3433, 3432, 1, 0, 0, 0, 3433, 3434, 1, 0, 0, 0, 3434, 3436, 1, 0, 0, 0, 
	3435, 3437, 3, 558, 279, 0, 3436, 3435, 1, 0, 0, 0, 3436, 3437, 1, 0, 0, 
	0, 3437, 3439, 1, 0, 0, 0, 3438, 3440, 3, 560, 280, 0, 3439, 3438, 1, 0, 
	0, 0, 3439, 3440, 1, 0, 0, 0, 3440, 3445, 1, 0, 0, 0, 3441, 3442, 5, 375, 
	0, 0, 3442, 3443, 5, 225, 0, 0, 3443, 3444, 5, 321, 0, 0, 3444, 3446, 3, 
	244, 122, 0, 3445, 3441, 1, 0, 0, 0, 3445, 3446, 1, 0, 0, 0, 3446, 563, 
	1, 0, 0, 0, 3447, 3448, 5, 293, 0, 0, 3448, 3449, 5, 226, 0, 0, 3449, 3450, 
	3, 144, 72, 0, 3450, 565, 1, 0, 0, 0, 3451, 3452, 5, 293, 0, 0, 3452, 3453, 
	5, 227, 0, 0, 3453, 3454, 5, 305, 0, 0, 3454, 3455, 5, 386, 0, 0, 3455, 
	3456, 3, 218, 109, 0, 3456, 3457, 5, 387, 0, 0, 3457, 567, 1, 0, 0, 0, 
	3458, 3468, 5, 110, 0, 0, 3459, 3460, 5, 279, 0, 0, 3460, 3461, 5, 386, 
	0, 0, 3461, 3469, 7, 25, 0, 0, 3462, 3463, 5, 113, 0, 0, 3463, 3464, 5, 
	386, 0, 0, 3464, 3469, 5, 412, 0, 0, 3465, 3466, 5, 295, 0, 0, 3466, 3467, 
	5, 386, 0, 0, 3467, 3469, 5, 417, 0, 0, 3468, 3459, 1, 0, 0, 0, 3468, 3462, 
	1, 0, 0, 0, 3468, 3465, 1, 0, 0, 0, 3469, 3470, 1, 0, 0, 0, 3470, 3471, 
	5, 387, 0, 0, 3471, 569, 1, 0, 0, 0, 3472, 3473, 5, 154, 0, 0, 3473, 3474, 
	5, 412, 0, 0, 3474, 3475, 5, 223, 0, 0, 3475, 3476, 5, 412, 0, 0, 3476, 
	3477, 5, 290, 0, 0, 3477, 3482, 5, 412, 0, 0, 3478, 3479, 5, 153, 0, 0, 
	3479, 3480, 5, 412, 0, 0, 3480, 3481, 5, 222, 0, 0, 3481, 3483, 5, 412, 
	0, 0, 3482, 3478, 1, 0, 0, 0, 3482, 3483, 1, 0, 0, 0, 3483, 3486, 1, 0, 
	0, 0, 3484, 3486, 3, 896, 448, 0, 3485, 3472, 1, 0, 0, 0, 3485, 3484, 1, 
	0, 0, 0, 3486, 571, 1, 0, 0, 0, 3487, 3491, 3, 574, 287, 0, 3488, 3491, 
	3, 576, 288, 0, 3489, 3491, 3, 578, 289, 0, 3490, 3487, 1, 0, 0, 0, 3490, 
	3488, 1, 0, 0, 0, 3490, 3489, 1, 0, 0, 0, 3491, 573, 1, 0, 0, 0, 3492, 
	3493, 3, 896, 448, 0, 3493, 3494, 5, 293, 0, 0, 3494, 3495, 5, 76, 0, 0, 
	3495, 3496, 3, 592, 296, 0, 3496, 575, 1, 0, 0, 0, 3497, 3498, 3, 896, 
	448, 0, 3498, 3499, 5, 293, 0, 0, 3499, 3500, 5, 226, 0, 0, 3500, 3501, 
	3, 144, 72, 0, 3501, 577, 1, 0, 0, 0, 3502, 3503, 3, 896, 448, 0, 3503, 
	3504, 5, 293, 0, 0, 3504, 3505, 5, 356, 0, 0, 3505, 3506, 5, 412, 0, 0, 
	3506, 579, 1, 0, 0, 0, 3507, 3508, 5, 176, 0, 0, 3508, 3517, 5, 123, 0, 
	0, 3509, 3510, 5, 176, 0, 0, 3510, 3511, 5, 123, 0, 0, 3511, 3512, 3, 896, 
	448, 0, 3512, 3513, 5, 412, 0, 0, 3513, 3517, 1, 0, 0, 0, 3514, 3515, 5, 
	176, 0, 0, 3515, 3517, 3, 640, 320, 0, 3516, 3507, 1, 0, 0, 0, 3516, 3509, 
	1, 0, 0, 0, 3516, 3514, 1, 0, 0, 0, 3517, 581, 1, 0, 0, 0, 3518, 3520, 
	5, 58, 0, 0, 3519, 3521, 5, 322, 0, 0, 3520, 3519, 1, 0, 0, 0, 3520, 3521, 
	1, 0, 0, 0, 3521, 3523, 1, 0, 0, 0, 3522, 3524, 5, 334, 0, 0, 3523, 3522, 
	1, 0, 0, 0, 3523, 3524, 1, 0, 0, 0, 3524, 3526, 1, 0, 0, 0, 3525, 3527, 
	5, 118, 0, 0, 3526, 3525, 1, 0, 0, 0, 3526, 3527, 1, 0, 0, 0, 3527, 3528, 
	1, 0, 0, 0, 3528, 3530, 5, 318, 0, 0, 3529, 3531, 3, 40, 20, 0, 3530, 3529, 
	1, 0, 0, 0, 3530, 3531, 1, 0, 0, 0, 3531, 3532, 1, 0, 0, 0, 3532, 3583, 
	3, 640, 320, 0, 3533, 3535, 3, 580, 290, 0, 3534, 3536, 3, 212, 106, 0, 
	3535, 3534, 1, 0, 0, 0, 3535, 3536, 1, 0, 0, 0, 3536, 3538, 1, 0, 0, 0, 
	3537, 3539, 3, 240, 120, 0, 3538, 3537, 1, 0, 0, 0, 3538, 3539, 1, 0, 0, 
	0, 3539, 3541, 1, 0, 0, 0, 3540, 3542, 3, 262, 131, 0, 3541, 3540, 1, 0, 
	0, 0, 3541, 3542, 1, 0, 0, 0, 3542, 3544, 1, 0, 0, 0, 3543, 3545, 3, 264, 
	132, 0, 3544, 3543, 1, 0, 0, 0, 3544, 3545, 1, 0, 0, 0, 3545, 3547, 1, 
	0, 0, 0, 3546, 3548, 3, 242, 121, 0, 3547, 3546, 1, 0, 0, 0, 3547, 3548, 
	1, 0, 0, 0, 3548, 3584, 1, 0, 0, 0, 3549, 3550, 5, 386, 0, 0, 3550, 3551, 
	3, 268, 134, 0, 3551, 3552, 5, 387, 0, 0, 3552, 3554, 1, 0, 0, 0, 3553, 
	3549, 1, 0, 0, 0, 3553, 3554, 1, 0, 0, 0, 3554, 3556, 1, 0, 0, 0, 3555, 
	3557, 3, 210, 105, 0, 3556, 3555, 1, 0, 0, 0, 3556, 3557, 1, 0, 0, 0, 3557, 
	3559, 1, 0, 0, 0, 3558, 3560, 3, 212, 106, 0, 3559, 3558, 1, 0, 0, 0, 3559, 
	3560, 1, 0, 0, 0, 3560, 3562, 1, 0, 0, 0, 3561, 3563, 3, 224, 112, 0, 3562, 
	3561, 1, 0, 0, 0, 3562, 3563, 1, 0, 0, 0, 3563, 3565, 1, 0, 0, 0, 3564, 
	3566, 3, 228, 114, 0, 3565, 3564, 1, 0, 0, 0, 3565, 3566, 1, 0, 0, 0, 3566, 
	3568, 1, 0, 0, 0, 3567, 3569, 3, 240, 120, 0, 3568, 3567, 1, 0, 0, 0, 3568, 
	3569, 1, 0, 0, 0, 3569, 3571, 1, 0, 0, 0, 3570, 3572, 3, 262, 131, 0, 3571, 
	3570, 1, 0, 0, 0, 3571, 3572, 1, 0, 0, 0, 3572, 3574, 1, 0, 0, 0, 3573, 
	3575, 3, 264, 132, 0, 3574, 3573, 1, 0, 0, 0, 3574, 3575, 1, 0, 0, 0, 3575, 
	3577, 1, 0, 0, 0, 3576, 3578, 3, 242, 121, 0, 3577, 3576, 1, 0, 0, 0, 3577, 
	3578, 1, 0, 0, 0, 3578, 3581, 1, 0, 0, 0, 3579, 3580, 5, 17, 0, 0, 3580, 
	3582, 3, 402, 201, 0, 3581, 3579, 1, 0, 0, 0, 3581, 3582, 1, 0, 0, 0, 3582, 
	3584, 1, 0, 0, 0, 3583, 3533, 1, 0, 0, 0, 3583, 3553, 1, 0, 0, 0, 3584, 
	3642, 1, 0, 0, 0, 3585, 3586, 5, 58, 0, 0, 3586, 3587, 5, 187, 0, 0, 3587, 
	3589, 5, 318, 0, 0, 3588, 3590, 3, 40, 20, 0, 3589, 3588, 1, 0, 0, 0, 3589, 
	3590, 1, 0, 0, 0, 3590, 3591, 1, 0, 0, 0, 3591, 3639, 3, 640, 320, 0, 3592, 
	3594, 3, 580, 290, 0, 3593, 3595, 3, 240, 120, 0, 3594, 3593, 1, 0, 0, 
	0, 3594, 3595, 1, 0, 0, 0, 3595, 3597, 1, 0, 0, 0, 3596, 3598, 3, 262, 
	131, 0, 3597, 3596, 1, 0, 0, 0, 3597, 3598, 1, 0, 0, 0, 3598, 3600, 1, 
	0, 0, 0, 3599, 3601, 3, 264, 132, 0, 3600, 3599, 1, 0, 0, 0, 3600, 3601, 
	1, 0, 0, 0, 3601, 3603, 1, 0, 0, 0, 3602, 3604, 3, 242, 121, 0, 3603, 3602, 
	1, 0, 0, 0, 3603, 3604, 1, 0, 0, 0, 3604, 3640, 1, 0, 0, 0, 3605, 3606, 
	5, 386, 0, 0, 3606, 3607, 3, 268, 134, 0, 3607, 3608, 5, 387, 0, 0, 3608, 
	3610, 1, 0, 0, 0, 3609, 3605, 1, 0, 0, 0, 3609, 3610, 1, 0, 0, 0, 3610, 
	3612, 1, 0, 0, 0, 3611, 3613, 3, 210, 105, 0, 3612, 3611, 1, 0, 0, 0, 3612, 
	3613, 1, 0, 0, 0, 3613, 3615, 1, 0, 0, 0, 3614, 3616, 3, 212, 106, 0, 3615, 
	3614, 1, 0, 0, 0, 3615, 3616, 1, 0, 0, 0, 3616, 3618, 1, 0, 0, 0, 3617, 
	3619, 3, 224, 112, 0, 3618, 3617, 1, 0, 0, 0, 3618, 3619, 1, 0, 0, 0, 3619, 
	3621, 1, 0, 0, 0, 3620, 3622, 3, 228, 114, 0, 3621, 3620, 1, 0, 0, 0, 3621, 
	3622, 1, 0, 0, 0, 3622, 3624, 1, 0, 0, 0, 3623, 3625, 3, 240, 120, 0, 3624, 
	3623, 1, 0, 0, 0, 3624, 3625, 1, 0, 0, 0, 3625, 3627, 1, 0, 0, 0, 3626, 
	3628, 3, 262, 131, 0, 3627, 3626, 1, 0, 0, 0, 3627, 3628, 1, 0, 0, 0, 3628, 
	3630, 1, 0, 0, 0, 3629, 3631, 3, 264, 132, 0, 3630, 3629, 1, 0, 0, 0, 3630, 
	3631, 1, 0, 0, 0, 3631, 3633, 1, 0, 0, 0, 3632, 3634, 3, 242, 121, 0, 3633, 
	3632, 1, 0, 0, 0, 3633, 3634, 1, 0, 0, 0, 3634, 3637, 1, 0, 0, 0, 3635, 
	3636, 5, 17, 0, 0, 3636, 3638, 3, 402, 201, 0, 3637, 3635, 1, 0, 0, 0, 
	3637, 3638, 1, 0, 0, 0, 3638, 3640, 1, 0, 0, 0, 3639, 3592, 1, 0, 0, 0, 
	3639, 3609, 1, 0, 0, 0, 3640, 3642, 1, 0, 0, 0, 3641, 3518, 1, 0, 0, 0, 
	3641, 3585, 1, 0, 0, 0, 3642, 583, 1, 0, 0, 0, 3643, 3644, 5, 58, 0, 0, 
	3644, 3646, 5, 69, 0, 0, 3645, 3647, 3, 40, 20, 0, 3646, 3645, 1, 0, 0, 
	0, 3646, 3647, 1, 0, 0, 0, 3647, 3648, 1, 0, 0, 0, 3648, 3649, 3, 896, 
	448, 0, 3649, 3650, 3, 590, 295, 0, 3650, 3652, 3, 588, 294, 0, 3651, 3653, 
	3, 586, 293, 0, 3652, 3651, 1, 0, 0, 0, 3652, 3653, 1, 0, 0, 0, 3653, 3657, 
	1, 0, 0, 0, 3654, 3655, 5, 375, 0, 0, 3655, 3656, 5, 76, 0, 0, 3656, 3658, 
	3, 592, 296, 0, 3657, 3654, 1, 0, 0, 0, 3657, 3658, 1, 0, 0, 0, 3658, 585, 
	1, 0, 0, 0, 3659, 3660, 5, 47, 0, 0, 3660, 3661, 5, 412, 0, 0, 3661, 587, 
	1, 0, 0, 0, 3662, 3663, 5, 356, 0, 0, 3663, 3664, 5, 412, 0, 0, 3664, 589, 
	1, 0, 0, 0, 3665, 3666, 5, 341, 0, 0, 3666, 3667, 5, 412, 0, 0, 3667, 591, 
	1, 0, 0, 0, 3668, 3669, 5, 386, 0, 0, 3669, 3670, 3, 60, 30, 0, 3670, 3671, 
	5, 387, 0, 0, 3671, 593, 1, 0, 0, 0, 3672, 3673, 5, 98, 0, 0, 3673, 3675, 
	5, 69, 0, 0, 3674, 3676, 3, 36, 18, 0, 3675, 3674, 1, 0, 0, 0, 3675, 3676, 
	1, 0, 0, 0, 3676, 3677, 1, 0, 0, 0, 3677, 3678, 3, 896, 448, 0, 3678, 595, 
	1, 0, 0, 0, 3679, 3685, 5, 402, 0, 0, 3680, 3681, 3, 640, 320, 0, 3681, 
	3682, 5, 382, 0, 0, 3682, 3683, 5, 402, 0, 0, 3683, 3685, 1, 0, 0, 0, 3684, 
	3679, 1, 0, 0, 0, 3684, 3680, 1, 0, 0, 0, 3685, 597, 1, 0, 0, 0, 3686, 
	3687, 3, 896, 448, 0, 3687, 599, 1, 0, 0, 0, 3688, 3689, 5, 80, 0, 0, 3689, 
	601, 1, 0, 0, 0, 3690, 3695, 3, 796, 398, 0, 3691, 3692, 5, 384, 0, 0, 
	3692, 3694, 3, 796, 398, 0, 3693, 3691, 1, 0, 0, 0, 3694, 3697, 1, 0, 0, 
	0, 3695, 3693, 1, 0, 0, 0, 3695, 3696, 1, 0, 0, 0, 3696, 603, 1, 0, 0, 
	0, 3697, 3695, 1, 0, 0, 0, 3698, 3703, 3, 896, 448, 0, 3699, 3700, 5, 384, 
	0, 0, 3700, 3702, 3, 896, 448, 0, 3701, 3699, 1, 0, 0, 0, 3702, 3705, 1, 
	0, 0, 0, 3703, 3701, 1, 0, 0, 0, 3703, 3704, 1, 0, 0, 0, 3704, 605, 1, 
	0, 0, 0, 3705, 3703, 1, 0, 0, 0, 3706, 3707, 5, 134, 0, 0, 3707, 3708, 
	3, 608, 304, 0, 3708, 607, 1, 0, 0, 0, 3709, 3710, 3, 620, 310, 0, 3710, 
	3713, 3, 616, 308, 0, 3711, 3712, 5, 384, 0, 0, 3712, 3714, 3, 616, 308, 
	0, 3713, 3711, 1, 0, 0, 0, 3714, 3715, 1, 0, 0, 0, 3715, 3713, 1, 0, 0, 
	0, 3715, 3716, 1, 0, 0, 0, 3716, 3719, 1, 0, 0, 0, 3717, 3719, 3, 612, 
	306, 0, 3718, 3709, 1, 0, 0, 0, 3718, 3717, 1, 0, 0, 0, 3719, 609, 1, 0, 
	0, 0, 3720, 3724, 3, 634, 317, 0, 3721, 3723, 3, 624, 312, 0, 3722, 3721, 
	1, 0, 0, 0, 3723, 3726, 1, 0, 0, 0, 3724, 3722, 1, 0, 0, 0, 3724, 3725, 
	1, 0, 0, 0, 3725, 3753, 1, 0, 0, 0, 3726, 3724, 1, 0, 0, 0, 3727, 3731, 
	3, 666, 333, 0, 3728, 3730, 3, 624, 312, 0, 3729, 3728, 1, 0, 0, 0, 3730, 
	3733, 1, 0, 0, 0, 3731, 3729, 1, 0, 0, 0, 3731, 3732, 1, 0, 0, 0, 3732, 
	3753, 1, 0, 0, 0, 3733, 3731, 1, 0, 0, 0, 3734, 3738, 3, 644, 322, 0, 3735, 
	3737, 3, 624, 312, 0, 3736, 3735, 1, 0, 0, 0, 3737, 3740, 1, 0, 0, 0, 3738, 
	3736, 1, 0, 0, 0, 3738, 3739, 1, 0, 0, 0, 3739, 3753, 1, 0, 0, 0, 3740, 
	3738, 1, 0, 0, 0, 3741, 3745, 3, 650, 325, 0, 3742, 3744, 3, 624, 312, 
	0, 3743, 3742, 1, 0, 0, 0, 3744, 3747, 1, 0, 0, 0, 3745, 3743, 1, 0, 0, 
	0, 3745, 3746, 1, 0, 0, 0, 3746, 3753, 1, 0, 0, 0, 3747, 3745, 1, 0, 0, 
	0, 3748, 3749, 5, 386, 0, 0, 3749, 3750, 3, 612, 306, 0, 3750, 3751, 5, 
	387, 0, 0, 3751, 3753, 1, 0, 0, 0, 3752, 3720, 1, 0, 0, 0, 3752, 3727, 
	1, 0, 0, 0, 3752, 3734, 1, 0, 0, 0, 3752, 3741, 1, 0, 0, 0, 3752, 3748, 
	1, 0, 0, 0, 3753, 611, 1, 0, 0, 0, 3754, 3765, 3, 610, 305, 0, 3755, 3756, 
	3, 622, 311, 0, 3756, 3761, 3, 614, 307, 0, 3757, 3758, 5, 214, 0, 0, 3758, 
	3762, 3, 796, 398, 0, 3759, 3760, 5, 359, 0, 0, 3760, 3762, 3, 280, 140, 
	0, 3761, 3757, 1, 0, 0, 0, 3761, 3759, 1, 0, 0, 0, 3761, 3762, 1, 0, 0, 
	0, 3762, 3764, 1, 0, 0, 0, 3763, 3755, 1, 0, 0, 0, 3764, 3767, 1, 0, 0, 
	0, 3765, 3763, 1, 0, 0, 0, 3765, 3766, 1, 0, 0, 0, 3766, 613, 1, 0, 0, 
	0, 3767, 3765, 1, 0, 0, 0, 3768, 3773, 3, 634, 317, 0, 3769, 3773, 3, 666, 
	333, 0, 3770, 3773, 3, 644, 322, 0, 3771, 3773, 3, 650, 325, 0, 3772, 3768, 
	1, 0, 0, 0, 3772, 3769, 1, 0, 0, 0, 3772, 3770, 1, 0, 0, 0, 3772, 3771, 
	1, 0, 0, 0, 3773, 3777, 1, 0, 0, 0, 3774, 3776, 3, 624, 312, 0, 3775, 3774, 
	1, 0, 0, 0, 3776, 3779, 1, 0, 0, 0, 3777, 3775, 1, 0, 0, 0, 3777, 3778, 
	1, 0, 0, 0, 3778, 615, 1, 0, 0, 0, 3779, 3777, 1, 0, 0, 0, 3780, 3782, 
	5, 240, 0, 0, 3781, 3780, 1, 0, 0, 0, 3781, 3782, 1, 0, 0, 0, 3782, 3783, 
	1, 0, 0, 0, 3783, 3784, 3, 638, 319, 0, 3784, 3785, 3, 618, 309, 0, 3785, 
	617, 1, 0, 0, 0, 3786, 3787, 5, 386, 0, 0, 3787, 3788, 3, 602, 301, 0, 
	3788, 3789, 5, 387, 0, 0, 3789, 619, 1, 0, 0, 0, 3790, 3791, 5, 348, 0, 
	0, 3791, 621, 1, 0, 0, 0, 3792, 3807, 5, 384, 0, 0, 3793, 3804, 5, 151, 
	0, 0, 3794, 3804, 5, 60, 0, 0, 3795, 3797, 7, 26, 0, 0, 3796, 3798, 5, 
	221, 0, 0, 3797, 3796, 1, 0, 0, 0, 3797, 3798, 1, 0, 0, 0, 3798, 3804, 
	1, 0, 0, 0, 3799, 3801, 5, 173, 0, 0, 3800, 3802, 7, 27, 0, 0, 3801, 3800, 
	1, 0, 0, 0, 3801, 3802, 1, 0, 0, 0, 3802, 3804, 1, 0, 0, 0, 3803, 3793, 
	1, 0, 0, 0, 3803, 3794, 1, 0, 0, 0, 3803, 3795, 1, 0, 0, 0, 3803, 3799, 
	1, 0, 0, 0, 3803, 3804, 1, 0, 0, 0, 3804, 3805, 1, 0, 0, 0, 3805, 3807, 
	5, 164, 0, 0, 3806, 3792, 1, 0, 0, 0, 3806, 3803, 1, 0, 0, 0, 3807, 623, 
	1, 0, 0, 0, 3808, 3809, 5, 171, 0, 0, 3809, 3810, 5, 367, 0, 0, 3810, 3811, 
	5, 221, 0, 0, 3811, 3812, 3, 752, 376, 0, 3812, 3822, 3, 626, 313, 0, 3813, 
	3814, 5, 17, 0, 0, 3814, 3819, 3, 896, 448, 0, 3815, 3816, 5, 384, 0, 0, 
	3816, 3818, 3, 896, 448, 0, 3817, 3815, 1, 0, 0, 0, 3818, 3821, 1, 0, 0, 
	0, 3819, 3817, 1, 0, 0, 0, 3819, 3820, 1, 0, 0, 0, 3820, 3823, 1, 0, 0, 
	0, 3821, 3819, 1, 0, 0, 0, 3822, 3813, 1, 0, 0, 0, 3822, 3823, 1, 0, 0, 
	0, 3823, 3866, 1, 0, 0, 0, 3824, 3826, 5, 384, 0, 0, 3825, 3824, 1, 0, 
	0, 0, 3825, 3826, 1, 0, 0, 0, 3826, 3827, 1, 0, 0, 0, 3827, 3863, 5, 171, 
	0, 0, 3828, 3829, 5, 367, 0, 0, 3829, 3830, 3, 752, 376, 0, 3830, 3840, 
	3, 626, 313, 0, 3831, 3832, 5, 17, 0, 0, 3832, 3837, 3, 896, 448, 0, 3833, 
	3834, 5, 384, 0, 0, 3834, 3836, 3, 896, 448, 0, 3835, 3833, 1, 0, 0, 0, 
	3836, 3839, 1, 0, 0, 0, 3837, 3835, 1, 0, 0, 0, 3837, 3838, 1, 0, 0, 0, 
	3838, 3841, 1, 0, 0, 0, 3839, 3837, 1, 0, 0, 0, 3840, 3831, 1, 0, 0, 0, 
	3840, 3841, 1, 0, 0, 0, 3841, 3864, 1, 0, 0, 0, 3842, 3843, 5, 318, 0, 
	0, 3843, 3844, 5, 386, 0, 0, 3844, 3845, 3, 658, 329, 0, 3845, 3847, 5, 
	387, 0, 0, 3846, 3848, 5, 17, 0, 0, 3847, 3846, 1, 0, 0, 0, 3847, 3848, 
	1, 0, 0, 0, 3848, 3849, 1, 0, 0, 0, 3849, 3861, 3, 626, 313, 0, 3850, 3851, 
	5, 386, 0, 0, 3851, 3856, 3, 896, 448, 0, 3852, 3853, 5, 384, 0, 0, 3853, 
	3855, 3, 896, 448, 0, 3854, 3852, 1, 0, 0, 0, 3855, 3858, 1, 0, 0, 0, 3856, 
	3854, 1, 0, 0, 0, 3856, 3857, 1, 0, 0, 0, 3857, 3859, 1, 0, 0, 0, 3858, 
	3856, 1, 0, 0, 0, 3859, 3860, 5, 387, 0, 0, 3860, 3862, 1, 0, 0, 0, 3861, 
	3850, 1, 0, 0, 0, 3861, 3862, 1, 0, 0, 0, 3862, 3864, 1, 0, 0, 0, 3863, 
	3828, 1, 0, 0, 0, 3863, 3842, 1, 0, 0, 0, 3864, 3866, 1, 0, 0, 0, 3865, 
	3808, 1, 0, 0, 0, 3865, 3825, 1, 0, 0, 0, 3866, 625, 1, 0, 0, 0, 3867, 
	3868, 3, 896, 448, 0, 3868, 627, 1, 0, 0, 0, 3869, 3870, 5, 320, 0, 0, 
	3870, 3871, 5, 386, 0, 0, 3871, 3872, 5, 30, 0, 0, 3872, 3873, 5, 417, 
	0, 0, 3873, 3874, 5, 220, 0, 0, 3874, 3875, 5, 211, 0, 0, 3875, 3885, 5, 
	417, 0, 0, 3876, 3877, 5, 214, 0, 0, 3877, 3882, 3, 796, 398, 0, 3878, 
	3879, 5, 384, 0, 0, 3879, 3881, 3, 796, 398, 0, 3880, 3878, 1, 0, 0, 0, 
	3881, 3884, 1, 0, 0, 0, 3882, 3880, 1, 0, 0, 0, 3882, 3883, 1, 0, 0, 0, 
	3883, 3886, 1, 0, 0, 0, 3884, 3882, 1, 0, 0, 0, 3885, 3876, 1, 0, 0, 0, 
	3885, 3886, 1, 0, 0, 0, 3886, 3887, 1, 0, 0, 0, 3887, 3888, 5, 387, 0, 
	0, 3888, 629, 1, 0, 0, 0, 3889, 3890, 5, 320, 0, 0, 3890, 3894, 5, 386, 
	0, 0, 3891, 3892, 5, 417, 0, 0, 3892, 3895, 7, 28, 0, 0, 3893, 3895, 5, 
	416, 0, 0, 3894, 3891, 1, 0, 0, 0, 3894, 3893, 1, 0, 0, 0, 3895, 3896, 
	1, 0, 0, 0, 3896, 3897, 5, 387, 0, 0, 3897, 631, 1, 0, 0, 0, 3898, 3901, 
	3, 628, 314, 0, 3899, 3901, 3, 630, 315, 0, 3900, 3898, 1, 0, 0, 0, 3900, 
	3899, 1, 0, 0, 0, 3901, 633, 1, 0, 0, 0, 3902, 3904, 3, 640, 320, 0, 3903, 
	3905, 3, 244, 122, 0, 3904, 3903, 1, 0, 0, 0, 3904, 3905, 1, 0, 0, 0, 3905, 
	3907, 1, 0, 0, 0, 3906, 3908, 3, 632, 316, 0, 3907, 3906, 1, 0, 0, 0, 3907, 
	3908, 1, 0, 0, 0, 3908, 3910, 1, 0, 0, 0, 3909, 3911, 3, 636, 318, 0, 3910, 
	3909, 1, 0, 0, 0, 3910, 3911, 1, 0, 0, 0, 3911, 3916, 1, 0, 0, 0, 3912, 
	3914, 5, 17, 0, 0, 3913, 3912, 1, 0, 0, 0, 3913, 3914, 1, 0, 0, 0, 3914, 
	3915, 1, 0, 0, 0, 3915, 3917, 3, 896, 448, 0, 3916, 3913, 1, 0, 0, 0, 3916, 
	3917, 1, 0, 0, 0, 3917, 635, 1, 0, 0, 0, 3918, 3928, 5, 129, 0, 0, 3919, 
	3920, 5, 316, 0, 0, 3920, 3921, 5, 17, 0, 0, 3921, 3922, 5, 211, 0, 0, 
	3922, 3929, 3, 796, 398, 0, 3923, 3924, 5, 129, 0, 0, 3924, 3925, 5, 317, 
	0, 0, 3925, 3926, 5, 17, 0, 0, 3926, 3927, 5, 211, 0, 0, 3927, 3929, 5, 
	417, 0, 0, 3928, 3919, 1, 0, 0, 0, 3928, 3923, 1, 0, 0, 0, 3929, 637, 1, 
	0, 0, 0, 3930, 3932, 3, 640, 320, 0, 3931, 3933, 3, 632, 316, 0, 3932, 
	3931, 1, 0, 0, 0, 3932, 3933, 1, 0, 0, 0, 3933, 3938, 1, 0, 0, 0, 3934, 
	3936, 5, 17, 0, 0, 3935, 3934, 1, 0, 0, 0, 3935, 3936, 1, 0, 0, 0, 3936, 
	3937, 1, 0, 0, 0, 3937, 3939, 3, 896, 448, 0, 3938, 3935, 1, 0, 0, 0, 3938, 
	3939, 1, 0, 0, 0, 3939, 639, 1, 0, 0, 0, 3940, 3941, 3, 896, 448, 0, 3941, 
	3942, 5, 382, 0, 0, 3942, 3945, 3, 896, 448, 0, 3943, 3944, 5, 382, 0, 
	0, 3944, 3946, 3, 896, 448, 0, 3945, 3943, 1, 0, 0, 0, 3945, 3946, 1, 0, 
	0, 0, 3946, 3949, 1, 0, 0, 0, 3947, 3949, 3, 896, 448, 0, 3948, 3940, 1, 
	0, 0, 0, 3948, 3947, 1, 0, 0, 0, 3949, 641, 1, 0, 0, 0, 3950, 3951, 3, 
	896, 448, 0, 3951, 3952, 5, 382, 0, 0, 3952, 3954, 1, 0, 0, 0, 3953, 3950, 
	1, 0, 0, 0, 3953, 3954, 1, 0, 0, 0, 3954, 3955, 1, 0, 0, 0, 3955, 3956, 
	3, 896, 448, 0, 3956, 643, 1, 0, 0, 0, 3957, 3958, 5, 386, 0, 0, 3958, 
	3959, 3, 382, 191, 0, 3959, 3961, 5, 387, 0, 0, 3960, 3962, 5, 17, 0, 0, 
	3961, 3960, 1, 0, 0, 0, 3961, 3962, 1, 0, 0, 0, 3962, 3963, 1, 0, 0, 0, 
	3963, 3964, 3, 896, 448, 0, 3964, 645, 1, 0, 0, 0, 3965, 3967, 3, 744, 
	372, 0, 3966, 3968, 3, 740, 370, 0, 3967, 3966, 1, 0, 0, 0, 3967, 3968, 
	1, 0, 0, 0, 3968, 3977, 1, 0, 0, 0, 3969, 3977, 3, 740, 370, 0, 3970, 3972, 
	3, 746, 373, 0, 3971, 3973, 3, 748, 374, 0, 3972, 3971, 1, 0, 0, 0, 3972, 
	3973, 1, 0, 0, 0, 3973, 3977, 1, 0, 0, 0, 3974, 3977, 3, 748, 374, 0, 3975, 
	3977, 3, 742, 371, 0, 3976, 3965, 1, 0, 0, 0, 3976, 3969, 1, 0, 0, 0, 3976, 
	3970, 1, 0, 0, 0, 3976, 3974, 1, 0, 0, 0, 3976, 3975, 1, 0, 0, 0, 3977, 
	647, 1, 0, 0, 0, 3978, 3982, 3, 644, 322, 0, 3979, 3982, 3, 634, 317, 0, 
	3980, 3982, 3, 650, 325, 0, 3981, 3978, 1, 0, 0, 0, 3981, 3979, 1, 0, 0, 
	0, 3981, 3980, 1, 0, 0, 0, 3982, 649, 1, 0, 0, 0, 3983, 3984, 3, 896, 448, 
	0, 3984, 3985, 5, 386, 0, 0, 3985, 3986, 5, 214, 0, 0, 3986, 3988, 3, 648, 
	324, 0, 3987, 3989, 3, 646, 323, 0, 3988, 3987, 1, 0, 0, 0, 3988, 3989, 
	1, 0, 0, 0, 3989, 4005, 1, 0, 0, 0, 3990, 3991, 5, 418, 0, 0, 3991, 3992, 
	5, 386, 0, 0, 3992, 3993, 3, 796, 398, 0, 3993, 4002, 5, 387, 0, 0, 3994, 
	3995, 5, 384, 0, 0, 3995, 3996, 5, 418, 0, 0, 3996, 3997, 5, 386, 0, 0, 
	3997, 3998, 3, 796, 398, 0, 3998, 3999, 5, 387, 0, 0, 3999, 4001, 1, 0, 
	0, 0, 4000, 3994, 1, 0, 0, 0, 4001, 4004, 1, 0, 0, 0, 4002, 4000, 1, 0, 
	0, 0, 4002, 4003, 1, 0, 0, 0, 4003, 4006, 1, 0, 0, 0, 4004, 4002, 1, 0, 
	0, 0, 4005, 3990, 1, 0, 0, 0, 4005, 4006, 1, 0, 0, 0, 4006, 4007, 1, 0, 
	0, 0, 4007, 4009, 5, 387, 0, 0, 4008, 4010, 3, 896, 448, 0, 4009, 4008, 
	1, 0, 0, 0, 4009, 4010, 1, 0, 0, 0, 4010, 651, 1, 0, 0, 0, 4011, 4012, 
	5, 372, 0, 0, 4012, 4013, 3, 654, 327, 0, 4013, 653, 1, 0, 0, 0, 4014, 
	4015, 3, 796, 398, 0, 4015, 655, 1, 0, 0, 0, 4016, 4017, 3, 658, 329, 0, 
	4017, 657, 1, 0, 0, 0, 4018, 4019, 5, 363, 0, 0, 4019, 4020, 3, 660, 330, 
	0, 4020, 659, 1, 0, 0, 0, 4021, 4026, 3, 662, 331, 0, 4022, 4023, 5, 384, 
	0, 0, 4023, 4025, 3, 662, 331, 0, 4024, 4022, 1, 0, 0, 0, 4025, 4028, 1, 
	0, 0, 0, 4026, 4024, 1, 0, 0, 0, 4026, 4027, 1, 0, 0, 0, 4027, 4038, 1, 
	0, 0, 0, 4028, 4026, 1, 0, 0, 0, 4029, 4034, 3, 664, 332, 0, 4030, 4031, 
	5, 384, 0, 0, 4031, 4033, 3, 662, 331, 0, 4032, 4030, 1, 0, 0, 0, 4033, 
	4036, 1, 0, 0, 0, 4034, 4032, 1, 0, 0, 0, 4034, 4035, 1, 0, 0, 0, 4035, 
	4038, 1, 0, 0, 0, 4036, 4034, 1, 0, 0, 0, 4037, 4021, 1, 0, 0, 0, 4037, 
	4029, 1, 0, 0, 0, 4038, 661, 1, 0, 0, 0, 4039, 4040, 3, 722, 361, 0, 4040, 
	663, 1, 0, 0, 0, 4041, 4042, 5, 386, 0, 0, 4042, 4043, 3, 730, 365, 0, 
	4043, 4044, 5, 387, 0, 0, 4044, 665, 1, 0, 0, 0, 4045, 4046, 5, 318, 0, 
	0, 4046, 4047, 5, 386, 0, 0, 4047, 4048, 3, 658, 329, 0, 4048, 4050, 5, 
	387, 0, 0, 4049, 4051, 5, 17, 0, 0, 4050, 4049, 1, 0, 0, 0, 4050, 4051, 
	1, 0, 0, 0, 4051, 4052, 1, 0, 0, 0, 4052, 4062, 3, 626, 313, 0, 4053, 4054, 
	5, 386, 0, 0, 4054, 4059, 3, 896, 448, 0, 4055, 4056, 5, 384, 0, 0, 4056, 
	4058, 3, 896, 448, 0, 4057, 4055, 1, 0, 0, 0, 4058, 4061, 1, 0, 0, 0, 4059, 
	4057, 1, 0, 0, 0, 4059, 4060, 1, 0, 0, 0, 4060, 4063, 1, 0, 0, 0, 4061, 
	4059, 1, 0, 0, 0, 4062, 4053, 1, 0, 0, 0, 4062, 4063, 1, 0, 0, 0, 4063, 
	4064, 1, 0, 0, 0, 4064, 4065, 5, 387, 0, 0, 4065, 667, 1, 0, 0, 0, 4066, 
	4068, 5, 288, 0, 0, 4067, 4069, 5, 422, 0, 0, 4068, 4067, 1, 0, 0, 0, 4068, 
	4069, 1, 0, 0, 0, 4069, 4076, 1, 0, 0, 0, 4070, 4072, 3, 670, 335, 0, 4071, 
	4070, 1, 0, 0, 0, 4071, 4072, 1, 0, 0, 0, 4072, 4073, 1, 0, 0, 0, 4073, 
	4077, 3, 672, 336, 0, 4074, 4075, 5, 336, 0, 0, 4075, 4077, 3, 674, 337, 
	0, 4076, 4071, 1, 0, 0, 0, 4076, 4074, 1, 0, 0, 0, 4077, 4080, 1, 0, 0, 
	0, 4078, 4080, 3, 678, 339, 0, 4079, 4066, 1, 0, 0, 0, 4079, 4078, 1, 0, 
	0, 0, 4080, 669, 1, 0, 0, 0, 4081, 4082, 7, 21, 0, 0, 4082, 671, 1, 0, 
	0, 0, 4083, 4088, 3, 676, 338, 0, 4084, 4085, 5, 384, 0, 0, 4085, 4087, 
	3, 676, 338, 0, 4086, 4084, 1, 0, 0, 0, 4087, 4090, 1, 0, 0, 0, 4088, 4086, 
	1, 0, 0, 0, 4088, 4089, 1, 0, 0, 0, 4089, 673, 1, 0, 0, 0, 4090, 4088, 
	1, 0, 0, 0, 4091, 4092, 5, 386, 0, 0, 4092, 4093, 3, 682, 341, 0, 4093, 
	4094, 5, 387, 0, 0, 4094, 4095, 3, 230, 115, 0, 4095, 4096, 3, 234, 117, 
	0, 4096, 4097, 5, 359, 0, 0, 4097, 4110, 5, 412, 0, 0, 4098, 4108, 5, 17, 
	0, 0, 4099, 4102, 5, 386, 0, 0, 4100, 4103, 3, 604, 302, 0, 4101, 4103, 
	3, 266, 133, 0, 4102, 4100, 1, 0, 0, 0, 4102, 4101, 1, 0, 0, 0, 4103, 4104, 
	1, 0, 0, 0, 4104, 4105, 5, 387, 0, 0, 4105, 4109, 1, 0, 0, 0, 4106, 4109, 
	3, 604, 302, 0, 4107, 4109, 3, 266, 133, 0, 4108, 4099, 1, 0, 0, 0, 4108, 
	4106, 1, 0, 0, 0, 4108, 4107, 1, 0, 0, 0, 4109, 4111, 1, 0, 0, 0, 4110, 
	4098, 1, 0, 0, 0, 4110, 4111, 1, 0, 0, 0, 4111, 4112, 1, 0, 0, 0, 4112, 
	4113, 3, 230, 115, 0, 4113, 4114, 3, 232, 116, 0, 4114, 675, 1, 0, 0, 0, 
	4115, 4136, 3, 596, 298, 0, 4116, 4133, 3, 796, 398, 0, 4117, 4119, 5, 
	17, 0, 0, 4118, 4117, 1, 0, 0, 0, 4118, 4119, 1, 0, 0, 0, 4119, 4120, 1, 
	0, 0, 0, 4120, 4134, 3, 896, 448, 0, 4121, 4122, 5, 17, 0, 0, 4122, 4123, 
	5, 386, 0, 0, 4123, 4128, 3, 896, 448, 0, 4124, 4125, 5, 384, 0, 0, 4125, 
	4127, 3, 896, 448, 0, 4126, 4124, 1, 0, 0, 0, 4127, 4130, 1, 0, 0, 0, 4128, 
	4126, 1, 0, 0, 0, 4128, 4129, 1, 0, 0, 0, 4129, 4131, 1, 0, 0, 0, 4130, 
	4128, 1, 0, 0, 0, 4131, 4132, 5, 387, 0, 0, 4132, 4134, 1, 0, 0, 0, 4133, 
	4118, 1, 0, 0, 0, 4133, 4121, 1, 0, 0, 0, 4133, 4134, 1, 0, 0, 0, 4134, 
	4136, 1, 0, 0, 0, 4135, 4115, 1, 0, 0, 0, 4135, 4116, 1, 0, 0, 0, 4136, 
	677, 1, 0, 0, 0, 4137, 4138, 7, 29, 0, 0, 4138, 4139, 3, 682, 341, 0, 4139, 
	4140, 3, 230, 115, 0, 4140, 4141, 3, 234, 117, 0, 4141, 4142, 5, 359, 0, 
	0, 4142, 4155, 5, 412, 0, 0, 4143, 4153, 5, 17, 0, 0, 4144, 4147, 5, 386, 
	0, 0, 4145, 4148, 3, 604, 302, 0, 4146, 4148, 3, 266, 133, 0, 4147, 4145, 
	1, 0, 0, 0, 4147, 4146, 1, 0, 0, 0, 4148, 4149, 1, 0, 0, 0, 4149, 4150, 
	5, 387, 0, 0, 4150, 4154, 1, 0, 0, 0, 4151, 4154, 3, 604, 302, 0, 4152, 
	4154, 3, 266, 133, 0, 4153, 4144, 1, 0, 0, 0, 4153, 4151, 1, 0, 0, 0, 4153, 
	4152, 1, 0, 0, 0, 4154, 4156, 1, 0, 0, 0, 4155, 4143, 1, 0, 0, 0, 4155, 
	4156, 1, 0, 0, 0, 4156, 4157, 1, 0, 0, 0, 4157, 4158, 3, 230, 115, 0, 4158, 
	4159, 3, 232, 116, 0, 4159, 679, 1, 0, 0, 0, 4160, 4163, 3, 596, 298, 0, 
	4161, 4163, 3, 796, 398, 0, 4162, 4160, 1, 0, 0, 0, 4162, 4161, 1, 0, 0, 
	0, 4163, 681, 1, 0, 0, 0, 4164, 4169, 3, 680, 340, 0, 4165, 4166, 5, 384, 
	0, 0, 4166, 4168, 3, 680, 340, 0, 4167, 4165, 1, 0, 0, 0, 4168, 4171, 1, 
	0, 0, 0, 4169, 4167, 1, 0, 0, 0, 4169, 4170, 1, 0, 0, 0, 4170, 683, 1, 
	0, 0, 0, 4171, 4169, 1, 0, 0, 0, 4172, 4173, 5, 374, 0, 0, 4173, 4178, 
	3, 686, 343, 0, 4174, 4175, 5, 384, 0, 0, 4175, 4177, 3, 686, 343, 0, 4176, 
	4174, 1, 0, 0, 0, 4177, 4180, 1, 0, 0, 0, 4178, 4176, 1, 0, 0, 0, 4178, 
	4179, 1, 0, 0, 0, 4179, 685, 1, 0, 0, 0, 4180, 4178, 1, 0, 0, 0, 4181, 
	4182, 3, 896, 448, 0, 4182, 4183, 5, 17, 0, 0, 4183, 4184, 3, 688, 344, 
	0, 4184, 687, 1, 0, 0, 0, 4185, 4198, 3, 896, 448, 0, 4186, 4188, 5, 386, 
	0, 0, 4187, 4189, 3, 896, 448, 0, 4188, 4187, 1, 0, 0, 0, 4188, 4189, 1, 
	0, 0, 0, 4189, 4191, 1, 0, 0, 0, 4190, 4192, 3, 646, 323, 0, 4191, 4190, 
	1, 0, 0, 0, 4191, 4192, 1, 0, 0, 0, 4192, 4194, 1, 0, 0, 0, 4193, 4195, 
	3, 690, 345, 0, 4194, 4193, 1, 0, 0, 0, 4194, 4195, 1, 0, 0, 0, 4195, 4196, 
	1, 0, 0, 0, 4196, 4198, 5, 387, 0, 0, 4197, 4185, 1, 0, 0, 0, 4197, 4186, 
	1, 0, 0, 0, 4198, 689, 1, 0, 0, 0, 4199, 4202, 3, 692, 346, 0, 4200, 4202, 
	3, 694, 347, 0, 4201, 4199, 1, 0, 0, 0, 4201, 4200, 1, 0, 0, 0, 4202, 691, 
	1, 0, 0, 0, 4203, 4210, 5, 282, 0, 0, 4204, 4211, 3, 696, 348, 0, 4205, 
	4206, 5, 25, 0, 0, 4206, 4207, 3, 698, 349, 0, 4207, 4208, 5, 11, 0, 0, 
	4208, 4209, 3, 698, 349, 0, 4209, 4211, 1, 0, 0, 0, 4210, 4204, 1, 0, 0, 
	0, 4210, 4205, 1, 0, 0, 0, 4211, 693, 1, 0, 0, 0, 4212, 4219, 5, 250, 0, 
	0, 4213, 4220, 3, 696, 348, 0, 4214, 4215, 5, 25, 0, 0, 4215, 4216, 3, 
	698, 349, 0, 4216, 4217, 5, 11, 0, 0, 4217, 4218, 3, 698, 349, 0, 4218, 
	4220, 1, 0, 0, 0, 4219, 4213, 1, 0, 0, 0, 4219, 4214, 1, 0, 0, 0, 4220, 
	695, 1, 0, 0, 0, 4221, 4222, 5, 343, 0, 0, 4222, 4228, 5, 237, 0, 0, 4223, 
	4224, 5, 62, 0, 0, 4224, 4228, 5, 281, 0, 0, 4225, 4226, 5, 417, 0, 0, 
	4226, 4228, 5, 237, 0, 0, 4227, 4221, 1, 0, 0, 0, 4227, 4223, 1, 0, 0, 
	0, 4227, 4225, 1, 0, 0, 0, 4228, 697, 1, 0, 0, 0, 4229, 4230, 7, 30, 0, 
	0, 4230, 4234, 7, 31, 0, 0, 4231, 4232, 5, 62, 0, 0, 4232, 4234, 5, 281, 
	0, 0, 4233, 4229, 1, 0, 0, 0, 4233, 4231, 1, 0, 0, 0, 4234, 699, 1, 0, 
	0, 0, 4235, 4236, 5, 139, 0, 0, 4236, 4237, 5, 32, 0, 0, 4237, 4238, 3, 
	702, 351, 0, 4238, 701, 1, 0, 0, 0, 4239, 4243, 3, 706, 353, 0, 4240, 4243, 
	3, 708, 354, 0, 4241, 4243, 3, 704, 352, 0, 4242, 4239, 1, 0, 0, 0, 4242, 
	4240, 1, 0, 0, 0, 4242, 4241, 1, 0, 0, 0, 4243, 703, 1, 0, 0, 0, 4244, 
	4245, 5, 386, 0, 0, 4245, 4246, 5, 387, 0, 0, 4246, 705, 1, 0, 0, 0, 4247, 
	4250, 5, 280, 0, 0, 4248, 4250, 5, 61, 0, 0, 4249, 4247, 1, 0, 0, 0, 4249, 
	4248, 1, 0, 0, 0, 4250, 4251, 1, 0, 0, 0, 4251, 4252, 5, 386, 0, 0, 4252, 
	4257, 3, 796, 398, 0, 4253, 4254, 5, 384, 0, 0, 4254, 4256, 3, 796, 398, 
	0, 4255, 4253, 1, 0, 0, 0, 4256, 4259, 1, 0, 0, 0, 4257, 4255, 1, 0, 0, 
	0, 4257, 4258, 1, 0, 0, 0, 4258, 4260, 1, 0, 0, 0, 4259, 4257, 1, 0, 0, 
	0, 4260, 4261, 5, 387, 0, 0, 4261, 707, 1, 0, 0, 0, 4262, 4267, 3, 724, 
	362, 0, 4263, 4264, 5, 375, 0, 0, 4264, 4268, 5, 280, 0, 0, 4265, 4266, 
	5, 375, 0, 0, 4266, 4268, 5, 61, 0, 0, 4267, 4263, 1, 0, 0, 0, 4267, 4265, 
	1, 0, 0, 0, 4267, 4268, 1, 0, 0, 0, 4268, 4282, 1, 0, 0, 0, 4269, 4270, 
	5, 140, 0, 0, 4270, 4271, 5, 294, 0, 0, 4271, 4272, 5, 386, 0, 0, 4272, 
	4277, 3, 710, 355, 0, 4273, 4274, 5, 384, 0, 0, 4274, 4276, 3, 710, 355, 
	0, 4275, 4273, 1, 0, 0, 0, 4276, 4279, 1, 0, 0, 0, 4277, 4275, 1, 0, 0, 
	0, 4277, 4278, 1, 0, 0, 0, 4278, 4280, 1, 0, 0, 0, 4279, 4277, 1, 0, 0, 
	0, 4280, 4281, 5, 387, 0, 0, 4281, 4283, 1, 0, 0, 0, 4282, 4269, 1, 0, 
	0, 0, 4282, 4283, 1, 0, 0, 0, 4283, 709, 1, 0, 0, 0, 4284, 4287, 3, 712, 
	356, 0, 4285, 4287, 3, 714, 357, 0, 4286, 4284, 1, 0, 0, 0, 4286, 4285, 
	1, 0, 0, 0, 4287, 711, 1, 0, 0, 0, 4288, 4290, 5, 386, 0, 0, 4289, 4291, 
	3, 796, 398, 0, 4290, 4289, 1, 0, 0, 0, 4290, 4291, 1, 0, 0, 0, 4291, 4296, 
	1, 0, 0, 0, 4292, 4293, 5, 384, 0, 0, 4293, 4295, 3, 796, 398, 0, 4294, 
	4292, 1, 0, 0, 0, 4295, 4298, 1, 0, 0, 0, 4296, 4294, 1, 0, 0, 0, 4296, 
	4297, 1, 0, 0, 0, 4297, 4299, 1, 0, 0, 0, 4298, 4296, 1, 0, 0, 0, 4299, 
	4300, 5, 387, 0, 0, 4300, 713, 1, 0, 0, 0, 4301, 4302, 3, 796, 398, 0, 
	4302, 715, 1, 0, 0, 0, 4303, 4304, 5, 141, 0, 0, 4304, 4305, 3, 720, 360, 
	0, 4305, 717, 1, 0, 0, 0, 4306, 4307, 5, 246, 0, 0, 4307, 4308, 3, 796, 
	398, 0, 4308, 719, 1, 0, 0, 0, 4309, 4310, 3, 796, 398, 0, 4310, 721, 1, 
	0, 0, 0, 4311, 4312, 5, 386, 0, 0, 4312, 4313, 3, 724, 362, 0, 4313, 4314, 
	5, 387, 0, 0, 4314, 723, 1, 0, 0, 0, 4315, 4317, 3, 728, 364, 0, 4316, 
	4318, 3, 726, 363, 0, 4317, 4316, 1, 0, 0, 0, 4317, 4318, 1, 0, 0, 0, 4318, 
	725, 1, 0, 0, 0, 4319, 4320, 5, 384, 0, 0, 4320, 4322, 3, 728, 364, 0, 
	4321, 4319, 1, 0, 0, 0, 4322, 4323, 1, 0, 0, 0, 4323, 4321, 1, 0, 0, 0, 
	4323, 4324, 1, 0, 0, 0, 4324, 727, 1, 0, 0, 0, 4325, 4328, 3, 600, 300, 
	0, 4326, 4328, 3, 796, 398, 0, 4327, 4325, 1, 0, 0, 0, 4327, 4326, 1, 0, 
	0, 0, 4328, 729, 1, 0, 0, 0, 4329, 4331, 3, 796, 398, 0, 4330, 4332, 5, 
	17, 0, 0, 4331, 4330, 1, 0, 0, 0, 4331, 4332, 1, 0, 0, 0, 4332, 4334, 1, 
	0, 0, 0, 4333, 4335, 3, 896, 448, 0, 4334, 4333, 1, 0, 0, 0, 4334, 4335, 
	1, 0, 0, 0, 4335, 4340, 1, 0, 0, 0, 4336, 4337, 5, 384, 0, 0, 4337, 4339, 
	3, 732, 366, 0, 4338, 4336, 1, 0, 0, 0, 4339, 4342, 1, 0, 0, 0, 4340, 4338, 
	1, 0, 0, 0, 4340, 4341, 1, 0, 0, 0, 4341, 731, 1, 0, 0, 0, 4342, 4340, 
	1, 0, 0, 0, 4343, 4345, 3, 796, 398, 0, 4344, 4346, 5, 17, 0, 0, 4345, 
	4344, 1, 0, 0, 0, 4345, 4346, 1, 0, 0, 0, 4346, 4348, 1, 0, 0, 0, 4347, 
	4349, 3, 896, 448, 0, 4348, 4347, 1, 0, 0, 0, 4348, 4349, 1, 0, 0, 0, 4349, 
	733, 1, 0, 0, 0, 4350, 4353, 3, 722, 361, 0, 4351, 4353, 3, 724, 362, 0, 
	4352, 4350, 1, 0, 0, 0, 4352, 4351, 1, 0, 0, 0, 4353, 735, 1, 0, 0, 0, 
	4354, 4355, 5, 386, 0, 0, 4355, 4360, 3, 330, 165, 0, 4356, 4357, 5, 384, 
	0, 0, 4357, 4359, 3, 330, 165, 0, 4358, 4356, 1, 0, 0, 0, 4359, 4362, 1, 
	0, 0, 0, 4360, 4358, 1, 0, 0, 0, 4360, 4361, 1, 0, 0, 0, 4361, 4363, 1, 
	0, 0, 0, 4362, 4360, 1, 0, 0, 0, 4363, 4364, 5, 387, 0, 0, 4364, 737, 1, 
	0, 0, 0, 4365, 4370, 3, 330, 165, 0, 4366, 4367, 5, 384, 0, 0, 4367, 4369, 
	3, 330, 165, 0, 4368, 4366, 1, 0, 0, 0, 4369, 4372, 1, 0, 0, 0, 4370, 4368, 
	1, 0, 0, 0, 4370, 4371, 1, 0, 0, 0, 4371, 739, 1, 0, 0, 0, 4372, 4370, 
	1, 0, 0, 0, 4373, 4374, 5, 219, 0, 0, 4374, 4375, 5, 32, 0, 0, 4375, 4380, 
	3, 330, 165, 0, 4376, 4377, 5, 384, 0, 0, 4377, 4379, 3, 330, 165, 0, 4378, 
	4376, 1, 0, 0, 0, 4379, 4382, 1, 0, 0, 0, 4380, 4378, 1, 0, 0, 0, 4380, 
	4381, 1, 0, 0, 0, 4381, 741, 1, 0, 0, 0, 4382, 4380, 1, 0, 0, 0, 4383, 
	4384, 5, 41, 0, 0, 4384, 4385, 5, 32, 0, 0, 4385, 4386, 3, 734, 367, 0, 
	4386, 743, 1, 0, 0, 0, 4387, 4388, 5, 227, 0, 0, 4388, 4389, 5, 32, 0, 
	0, 4389, 4390, 3, 734, 367, 0, 4390, 745, 1, 0, 0, 0, 4391, 4392, 5, 93, 
	0, 0, 4392, 4393, 5, 32, 0, 0, 4393, 4394, 3, 734, 367, 0, 4394, 747, 1, 
	0, 0, 0, 4395, 4396, 5, 303, 0, 0, 4396, 4399, 5, 32, 0, 0, 4397, 4400, 
	3, 736, 368, 0, 4398, 4400, 3, 738, 369, 0, 4399, 4397, 1, 0, 0, 0, 4399, 
	4398, 1, 0, 0, 0, 4400, 749, 1, 0, 0, 0, 4401, 4402, 5, 338, 0, 0, 4402, 
	4406, 5, 386, 0, 0, 4403, 4407, 5, 172, 0, 0, 4404, 4407, 5, 332, 0, 0, 
	4405, 4407, 5, 29, 0, 0, 4406, 4403, 1, 0, 0, 0, 4406, 4404, 1, 0, 0, 0, 
	4406, 4405, 1, 0, 0, 0, 4406, 4407, 1, 0, 0, 0, 4407, 4409, 1, 0, 0, 0, 
	4408, 4410, 3, 680, 340, 0, 4409, 4408, 1, 0, 0, 0, 4409, 4410, 1, 0, 0, 
	0, 4410, 4411, 1, 0, 0, 0, 4411, 4412, 5, 134, 0, 0, 4412, 4413, 3, 680, 
	340, 0, 4413, 4414, 5, 387, 0, 0, 4414, 751, 1, 0, 0, 0, 4415, 4456, 3, 
	750, 375, 0, 4416, 4417, 3, 756, 378, 0, 4417, 4432, 5, 386, 0, 0, 4418, 
	4433, 5, 402, 0, 0, 4419, 4421, 3, 670, 335, 0, 4420, 4419, 1, 0, 0, 0, 
	4420, 4421, 1, 0, 0, 0, 4421, 4430, 1, 0, 0, 0, 4422, 4427, 3, 680, 340, 
	0, 4423, 4424, 5, 384, 0, 0, 4424, 4426, 3, 680, 340, 0, 4425, 4423, 1, 
	0, 0, 0, 4426, 4429, 1, 0, 0, 0, 4427, 4425, 1, 0, 0, 0, 4427, 4428, 1, 
	0, 0, 0, 4428, 4431, 1, 0, 0, 0, 4429, 4427, 1, 0, 0, 0, 4430, 4422, 1, 
	0, 0, 0, 4430, 4431, 1, 0, 0, 0, 4431, 4433, 1, 0, 0, 0, 4432, 4418, 1, 
	0, 0, 0, 4432, 4420, 1, 0, 0, 0, 4433, 4453, 1, 0, 0, 0, 4434, 4435, 5, 
	387, 0, 0, 4435, 4436, 5, 376, 0, 0, 4436, 4437, 5, 139, 0, 0, 4437, 4438, 
	5, 386, 0, 0, 4438, 4439, 3, 740, 370, 0, 4439, 4440, 5, 387, 0, 0, 4440, 
	4454, 1, 0, 0, 0, 4441, 4443, 5, 387, 0, 0, 4442, 4444, 3, 754, 377, 0, 
	4443, 4442, 1, 0, 0, 0, 4443, 4444, 1, 0, 0, 0, 4444, 4445, 1, 0, 0, 0, 
	4445, 4446, 5, 224, 0, 0, 4446, 4454, 3, 688, 344, 0, 4447, 4448, 3, 754, 
	377, 0, 4448, 4449, 5, 387, 0, 0, 4449, 4450, 5, 224, 0, 0, 4450, 4451, 
	3, 688, 344, 0, 4451, 4454, 1, 0, 0, 0, 4452, 4454, 5, 387, 0, 0, 4453, 
	4434, 1, 0, 0, 0, 4453, 4441, 1, 0, 0, 0, 4453, 4447, 1, 0, 0, 0, 4453, 
	4452, 1, 0, 0, 0, 4454, 4456, 1, 0, 0, 0, 4455, 4415, 1, 0, 0, 0, 4455, 
	4416, 1, 0, 0, 0, 4456, 753, 1, 0, 0, 0, 4457, 4458, 5, 271, 0, 0, 4458, 
	4462, 5, 210, 0, 0, 4459, 4460, 5, 146, 0, 0, 4460, 4462, 5, 210, 0, 0, 
	4461, 4457, 1, 0, 0, 0, 4461, 4459, 1, 0, 0, 0, 4462, 755, 1, 0, 0, 0, 
	4463, 4466, 3, 898, 449, 0, 4464, 4466, 3, 904, 452, 0, 4465, 4463, 1, 
	0, 0, 0, 4465, 4464, 1, 0, 0, 0, 4466, 757, 1, 0, 0, 0, 4467, 4468, 5, 
	36, 0, 0, 4468, 4469, 5, 386, 0, 0, 4469, 4470, 3, 796, 398, 0, 4470, 4471, 
	5, 17, 0, 0, 4471, 4474, 3, 370, 185, 0, 4472, 4473, 5, 132, 0, 0, 4473, 
	4475, 5, 412, 0, 0, 4474, 4472, 1, 0, 0, 0, 4474, 4475, 1, 0, 0, 0, 4475, 
	4476, 1, 0, 0, 0, 4476, 4477, 5, 387, 0, 0, 4477, 759, 1, 0, 0, 0, 4478, 
	4479, 5, 35, 0, 0, 4479, 4485, 3, 796, 398, 0, 4480, 4481, 5, 371, 0, 0, 
	4481, 4482, 3, 796, 398, 0, 4482, 4483, 5, 324, 0, 0, 4483, 4484, 3, 796, 
	398, 0, 4484, 4486, 1, 0, 0, 0, 4485, 4480, 1, 0, 0, 0, 4486, 4487, 1, 
	0, 0, 0, 4487, 4485, 1, 0, 0, 0, 4487, 4488, 1, 0, 0, 0, 4488, 4491, 1, 
	0, 0, 0, 4489, 4490, 5, 101, 0, 0, 4490, 4492, 3, 796, 398, 0, 4491, 4489, 
	1, 0, 0, 0, 4491, 4492, 1, 0, 0, 0, 4492, 4493, 1, 0, 0, 0, 4493, 4494, 
	5, 103, 0, 0, 4494, 761, 1, 0, 0, 0, 4495, 4501, 5, 35, 0, 0, 4496, 4497, 
	5, 371, 0, 0, 4497, 4498, 3, 796, 398, 0, 4498, 4499, 5, 324, 0, 0, 4499, 
	4500, 3, 796, 398, 0, 4500, 4502, 1, 0, 0, 0, 4501, 4496, 1, 0, 0, 0, 4502, 
	4503, 1, 0, 0, 0, 4503, 4501, 1, 0, 0, 0, 4503, 4504, 1, 0, 0, 0, 4504, 
	4507, 1, 0, 0, 0, 4505, 4506, 5, 101, 0, 0, 4506, 4508, 3, 796, 398, 0, 
	4507, 4505, 1, 0, 0, 0, 4507, 4508, 1, 0, 0, 0, 4508, 4509, 1, 0, 0, 0, 
	4509, 4510, 5, 103, 0, 0, 4510, 763, 1, 0, 0, 0, 4511, 4512, 5, 127, 0, 
	0, 4512, 4513, 5, 386, 0, 0, 4513, 4516, 3, 796, 398, 0, 4514, 4515, 5, 
	330, 0, 0, 4515, 4517, 3, 766, 383, 0, 4516, 4514, 1, 0, 0, 0, 4516, 4517, 
	1, 0, 0, 0, 4517, 4518, 1, 0, 0, 0, 4518, 4519, 5, 387, 0, 0, 4519, 765, 
	1, 0, 0, 0, 4520, 4521, 7, 32, 0, 0, 4521, 767, 1, 0, 0, 0, 4522, 4523, 
	5, 119, 0, 0, 4523, 4524, 5, 386, 0, 0, 4524, 4525, 3, 770, 385, 0, 4525, 
	4526, 5, 134, 0, 0, 4526, 4527, 3, 796, 398, 0, 4527, 4528, 5, 387, 0, 
	0, 4528, 769, 1, 0, 0, 0, 4529, 4530, 7, 33, 0, 0, 4530, 771, 1, 0, 0, 
	0, 4531, 4545, 3, 790, 395, 0, 4532, 4545, 5, 417, 0, 0, 4533, 4545, 3, 
	782, 391, 0, 4534, 4545, 3, 784, 392, 0, 4535, 4545, 3, 786, 393, 0, 4536, 
	4545, 5, 412, 0, 0, 4537, 4545, 3, 778, 389, 0, 4538, 4545, 5, 414, 0, 
	0, 4539, 4545, 5, 415, 0, 0, 4540, 4545, 3, 780, 390, 0, 4541, 4545, 3, 
	874, 437, 0, 4542, 4545, 5, 209, 0, 0, 4543, 4545, 3, 774, 387, 0, 4544, 
	4531, 1, 0, 0, 0, 4544, 4532, 1, 0, 0, 0, 4544, 4533, 1, 0, 0, 0, 4544, 
	4534, 1, 0, 0, 0, 4544, 4535, 1, 0, 0, 0, 4544, 4536, 1, 0, 0, 0, 4544, 
	4537, 1, 0, 0, 0, 4544, 4538, 1, 0, 0, 0, 4544, 4539, 1, 0, 0, 0, 4544, 
	4540, 1, 0, 0, 0, 4544, 4541, 1, 0, 0, 0, 4544, 4542, 1, 0, 0, 0, 4544, 
	4543, 1, 0, 0, 0, 4545, 773, 1, 0, 0, 0, 4546, 4547, 3, 776, 388, 0, 4547, 
	775, 1, 0, 0, 0, 4548, 4549, 5, 410, 0, 0, 4549, 777, 1, 0, 0, 0, 4550, 
	4552, 5, 412, 0, 0, 4551, 4553, 5, 412, 0, 0, 4552, 4551, 1, 0, 0, 0, 4553, 
	4554, 1, 0, 0, 0, 4554, 4552, 1, 0, 0, 0, 4554, 4555, 1, 0, 0, 0, 4555, 
	779, 1, 0, 0, 0, 4556, 4557, 5, 419, 0, 0, 4557, 4558, 5, 413, 0, 0, 4558, 
	781, 1, 0, 0, 0, 4559, 4560, 5, 71, 0, 0, 4560, 4563, 5, 412, 0, 0, 4561, 
	4563, 5, 63, 0, 0, 4562, 4559, 1, 0, 0, 0, 4562, 4561, 1, 0, 0, 0, 4563, 
	783, 1, 0, 0, 0, 4564, 4565, 5, 326, 0, 0, 4565, 4568, 5, 412, 0, 0, 4566, 
	4568, 5, 64, 0, 0, 4567, 4564, 1, 0, 0, 0, 4567, 4566, 1, 0, 0, 0, 4568, 
	785, 1, 0, 0, 0, 4569, 4570, 5, 327, 0, 0, 4570, 4571, 5, 412, 0, 0, 4571, 
	787, 1, 0, 0, 0, 4572, 4573, 7, 25, 0, 0, 4573, 789, 1, 0, 0, 0, 4574, 
	4575, 3, 788, 394, 0, 4575, 4576, 3, 794, 397, 0, 4576, 791, 1, 0, 0, 0, 
	4577, 4578, 5, 386, 0, 0, 4578, 4579, 3, 788, 394, 0, 4579, 4580, 5, 387, 
	0, 0, 4580, 4581, 3, 794, 397, 0, 4581, 4593, 1, 0, 0, 0, 4582, 4588, 5, 
	158, 0, 0, 4583, 4589, 3, 788, 394, 0, 4584, 4585, 5, 386, 0, 0, 4585, 
	4586, 3, 796, 398, 0, 4586, 4587, 5, 387, 0, 0, 4587, 4589, 1, 0, 0, 0, 
	4588, 4583, 1, 0, 0, 0, 4588, 4584, 1, 0, 0, 0, 4589, 4590, 1, 0, 0, 0, 
	4590, 4591, 3, 794, 397, 0, 4591, 4593, 1, 0, 0, 0, 4592, 4577, 1, 0, 0, 
	0, 4592, 4582, 1, 0, 0, 0, 4593, 793, 1, 0, 0, 0, 4594, 4595, 5, 380, 0, 
	0, 4595, 4596, 5, 330, 0, 0, 4596, 4607, 5, 199, 0, 0, 4597, 4598, 5, 73, 
	0, 0, 4598, 4599, 5, 330, 0, 0, 4599, 4607, 5, 287, 0, 0, 4600, 4607, 5, 
	380, 0, 0, 4601, 4607, 5, 199, 0, 0, 4602, 4607, 5, 73, 0, 0, 4603, 4607, 
	5, 143, 0, 0, 4604, 4607, 5, 198, 0, 0, 4605, 4607, 5, 287, 0, 0, 4606, 
	4594, 1, 0, 0, 0, 4606, 4597, 1, 0, 0, 0, 4606, 4600, 1, 0, 0, 0, 4606, 
	4601, 1, 0, 0, 0, 4606, 4602, 1, 0, 0, 0, 4606, 4603, 1, 0, 0, 0, 4606, 
	4604, 1, 0, 0, 0, 4606, 4605, 1, 0, 0, 0, 4607, 795, 1, 0, 0, 0, 4608, 
	4609, 3, 872, 436, 0, 4609, 797, 1, 0, 0, 0, 4610, 4622, 3, 772, 386, 0, 
	4611, 4622, 3, 792, 396, 0, 4612, 4622, 3, 758, 379, 0, 4613, 4622, 3, 
	768, 384, 0, 4614, 4622, 3, 764, 382, 0, 4615, 4622, 3, 760, 380, 0, 4616, 
	4622, 3, 762, 381, 0, 4617, 4622, 3, 834, 417, 0, 4618, 4622, 3, 752, 376, 
	0, 4619, 4622, 3, 598, 299, 0, 4620, 4622, 3, 722, 361, 0, 4621, 4610, 
	1, 0, 0, 0, 4621, 4611, 1, 0, 0, 0, 4621, 4612, 1, 0, 0, 0, 4621, 4613, 
	1, 0, 0, 0, 4621, 4614, 1, 0, 0, 0, 4621, 4615, 1, 0, 0, 0, 4621, 4616, 
	1, 0, 0, 0, 4621, 4617, 1, 0, 0, 0, 4621, 4618, 1, 0, 0, 0, 4621, 4619, 
	1, 0, 0, 0, 4621, 4620, 1, 0, 0, 0, 4622, 799, 1, 0, 0, 0, 4623, 4632, 
	3, 798, 399, 0, 4624, 4625, 5, 388, 0, 0, 4625, 4626, 3, 796, 398, 0, 4626, 
	4627, 5, 389, 0, 0, 4627, 4631, 1, 0, 0, 0, 4628, 4629, 5, 382, 0, 0, 4629, 
	4631, 3, 896, 448, 0, 4630, 4624, 1, 0, 0, 0, 4630, 4628, 1, 0, 0, 0, 4631, 
	4634, 1, 0, 0, 0, 4632, 4630, 1, 0, 0, 0, 4632, 4633, 1, 0, 0, 0, 4633, 
	801, 1, 0, 0, 0, 4634, 4632, 1, 0, 0, 0, 4635, 4636, 7, 34, 0, 0, 4636, 
	803, 1, 0, 0, 0, 4637, 4639, 3, 802, 401, 0, 4638, 4637, 1, 0, 0, 0, 4639, 
	4642, 1, 0, 0, 0, 4640, 4638, 1, 0, 0, 0, 4640, 4641, 1, 0, 0, 0, 4641, 
	4643, 1, 0, 0, 0, 4642, 4640, 1, 0, 0, 0, 4643, 4644, 3, 800, 400, 0, 4644, 
	805, 1, 0, 0, 0, 4645, 4646, 5, 409, 0, 0, 4646, 807, 1, 0, 0, 0, 4647, 
	4653, 3, 804, 402, 0, 4648, 4649, 3, 806, 403, 0, 4649, 4650, 3, 804, 402, 
	0, 4650, 4652, 1, 0, 0, 0, 4651, 4648, 1, 0, 0, 0, 4652, 4655, 1, 0, 0, 
	0, 4653, 4651, 1, 0, 0, 0, 4653, 4654, 1, 0, 0, 0, 4654, 809, 1, 0, 0, 
	0, 4655, 4653, 1, 0, 0, 0, 4656, 4657, 7, 35, 0, 0, 4657, 811, 1, 0, 0, 
	0, 4658, 4664, 3, 808, 404, 0, 4659, 4660, 3, 810, 405, 0, 4660, 4661, 
	3, 808, 404, 0, 4661, 4663, 1, 0, 0, 0, 4662, 4659, 1, 0, 0, 0, 4663, 4666, 
	1, 0, 0, 0, 4664, 4662, 1, 0, 0, 0, 4664, 4665, 1, 0, 0, 0, 4665, 813, 
	1, 0, 0, 0, 4666, 4664, 1, 0, 0, 0, 4667, 4668, 7, 36, 0, 0, 4668, 815, 
	1, 0, 0, 0, 4669, 4675, 3, 812, 406, 0, 4670, 4671, 3, 814, 407, 0, 4671, 
	4672, 3, 812, 406, 0, 4672, 4674, 1, 0, 0, 0, 4673, 4670, 1, 0, 0, 0, 4674, 
	4677, 1, 0, 0, 0, 4675, 4673, 1, 0, 0, 0, 4675, 4676, 1, 0, 0, 0, 4676, 
	817, 1, 0, 0, 0, 4677, 4675, 1, 0, 0, 0, 4678, 4679, 5, 408, 0, 0, 4679, 
	819, 1, 0, 0, 0, 4680, 4686, 3, 816, 408, 0, 4681, 4682, 3, 818, 409, 0, 
	4682, 4683, 3, 816, 408, 0, 4683, 4685, 1, 0, 0, 0, 4684, 4681, 1, 0, 0, 
	0, 4685, 4688, 1, 0, 0, 0, 4686, 4684, 1, 0, 0, 0, 4686, 4687, 1, 0, 0, 
	0, 4687, 821, 1, 0, 0, 0, 4688, 4686, 1, 0, 0, 0, 4689, 4690, 5, 405, 0, 
	0, 4690, 823, 1, 0, 0, 0, 4691, 4697, 3, 820, 410, 0, 4692, 4693, 3, 822, 
	411, 0, 4693, 4694, 3, 820, 410, 0, 4694, 4696, 1, 0, 0, 0, 4695, 4692, 
	1, 0, 0, 0, 4696, 4699, 1, 0, 0, 0, 4697, 4695, 1, 0, 0, 0, 4697, 4698, 
	1, 0, 0, 0, 4698, 825, 1, 0, 0, 0, 4699, 4697, 1, 0, 0, 0, 4700, 4701, 
	5, 407, 0, 0, 4701, 827, 1, 0, 0, 0, 4702, 4708, 3, 824, 412, 0, 4703, 
	4704, 3, 826, 413, 0, 4704, 4705, 3, 824, 412, 0, 4705, 4707, 1, 0, 0, 
	0, 4706, 4703, 1, 0, 0, 0, 4707, 4710, 1, 0, 0, 0, 4708, 4706, 1, 0, 0, 
	0, 4708, 4709, 1, 0, 0, 0, 4709, 829, 1, 0, 0, 0, 4710, 4708, 1, 0, 0, 
	0, 4711, 4712, 7, 37, 0, 0, 4712, 831, 1, 0, 0, 0, 4713, 4719, 3, 830, 
	415, 0, 4714, 4719, 5, 395, 0, 0, 4715, 4719, 5, 396, 0, 0, 4716, 4719, 
	5, 397, 0, 0, 4717, 4719, 5, 398, 0, 0, 4718, 4713, 1, 0, 0, 0, 4718, 4714, 
	1, 0, 0, 0, 4718, 4715, 1, 0, 0, 0, 4718, 4716, 1, 0, 0, 0, 4718, 4717, 
	1, 0, 0, 0, 4719, 833, 1, 0, 0, 0, 4720, 4721, 5, 386, 0, 0, 4721, 4722, 
	3, 398, 199, 0, 4722, 4723, 5, 387, 0, 0, 4723, 835, 1, 0, 0, 0, 4724, 
	4728, 3, 838, 419, 0, 4725, 4726, 5, 112, 0, 0, 4726, 4728, 3, 834, 417, 
	0, 4727, 4724, 1, 0, 0, 0, 4727, 4725, 1, 0, 0, 0, 4728, 837, 1, 0, 0, 
	0, 4729, 4731, 3, 828, 414, 0, 4730, 4732, 3, 840, 420, 0, 4731, 4730, 
	1, 0, 0, 0, 4731, 4732, 1, 0, 0, 0, 4732, 839, 1, 0, 0, 0, 4733, 4734, 
	3, 832, 416, 0, 4734, 4735, 3, 828, 414, 0, 4735, 4740, 1, 0, 0, 0, 4736, 
	4740, 3, 842, 421, 0, 4737, 4738, 5, 206, 0, 0, 4738, 4740, 3, 850, 425, 
	0, 4739, 4733, 1, 0, 0, 0, 4739, 4736, 1, 0, 0, 0, 4739, 4737, 1, 0, 0, 
	0, 4740, 841, 1, 0, 0, 0, 4741, 4742, 5, 148, 0, 0, 4742, 4753, 3, 848, 
	424, 0, 4743, 4744, 5, 25, 0, 0, 4744, 4745, 3, 828, 414, 0, 4745, 4746, 
	5, 11, 0, 0, 4746, 4747, 3, 828, 414, 0, 4747, 4753, 1, 0, 0, 0, 4748, 
	4749, 5, 176, 0, 0, 4749, 4750, 7, 38, 0, 0, 4750, 4753, 3, 722, 361, 0, 
	4751, 4753, 3, 844, 422, 0, 4752, 4741, 1, 0, 0, 0, 4752, 4743, 1, 0, 0, 
	0, 4752, 4748, 1, 0, 0, 0, 4752, 4751, 1, 0, 0, 0, 4753, 843, 1, 0, 0, 
	0, 4754, 4755, 3, 890, 445, 0, 4755, 4756, 3, 846, 423, 0, 4756, 4757, 
	3, 834, 417, 0, 4757, 845, 1, 0, 0, 0, 4758, 4759, 7, 39, 0, 0, 4759, 847, 
	1, 0, 0, 0, 4760, 4763, 3, 834, 417, 0, 4761, 4763, 3, 722, 361, 0, 4762, 
	4760, 1, 0, 0, 0, 4762, 4761, 1, 0, 0, 0, 4763, 849, 1, 0, 0, 0, 4764, 
	4765, 3, 830, 415, 0, 4765, 4766, 3, 828, 414, 0, 4766, 4769, 1, 0, 0, 
	0, 4767, 4769, 3, 842, 421, 0, 4768, 4764, 1, 0, 0, 0, 4768, 4767, 1, 0, 
	0, 0, 4769, 851, 1, 0, 0, 0, 4770, 4771, 5, 160, 0, 0, 4771, 4772, 5, 92, 
	0, 0, 4772, 4773, 5, 134, 0, 0, 4773, 853, 1, 0, 0, 0, 4774, 4782, 5, 392, 
	0, 0, 4775, 4782, 5, 393, 0, 0, 4776, 4782, 5, 394, 0, 0, 4777, 4778, 5, 
	160, 0, 0, 4778, 4779, 5, 206, 0, 0, 4779, 4780, 5, 92, 0, 0, 4780, 4782, 
	5, 134, 0, 0, 4781, 4774, 1, 0, 0, 0, 4781, 4775, 1, 0, 0, 0, 4781, 4776, 
	1, 0, 0, 0, 4781, 4777, 1, 0, 0, 0, 4782, 855, 1, 0, 0, 0, 4783, 4792, 
	3, 836, 418, 0, 4784, 4785, 3, 854, 427, 0, 4785, 4786, 3, 836, 418, 0, 
	4786, 4791, 1, 0, 0, 0, 4787, 4788, 3, 852, 426, 0, 4788, 4789, 3, 836, 
	418, 0, 4789, 4791, 1, 0, 0, 0, 4790, 4784, 1, 0, 0, 0, 4790, 4787, 1, 
	0, 0, 0, 4791, 4794, 1, 0, 0, 0, 4792, 4790, 1, 0, 0, 0, 4792, 4793, 1, 
	0, 0, 0, 4793, 857, 1, 0, 0, 0, 4794, 4792, 1, 0, 0, 0, 4795, 4808, 5, 
	209, 0, 0, 4796, 4808, 5, 339, 0, 0, 4797, 4808, 5, 120, 0, 0, 4798, 4808, 
	5, 349, 0, 0, 4799, 4800, 5, 206, 0, 0, 4800, 4808, 5, 209, 0, 0, 4801, 
	4802, 5, 206, 0, 0, 4802, 4808, 5, 339, 0, 0, 4803, 4804, 5, 206, 0, 0, 
	4804, 4808, 5, 120, 0, 0, 4805, 4806, 5, 206, 0, 0, 4806, 4808, 5, 349, 
	0, 0, 4807, 4795, 1, 0, 0, 0, 4807, 4796, 1, 0, 0, 0, 4807, 4797, 1, 0, 
	0, 0, 4807, 4798, 1, 0, 0, 0, 4807, 4799, 1, 0, 0, 0, 4807, 4801, 1, 0, 
	0, 0, 4807, 4803, 1, 0, 0, 0, 4807, 4805, 1, 0, 0, 0, 4808, 859, 1, 0, 
	0, 0, 4809, 4812, 3, 856, 428, 0, 4810, 4811, 5, 160, 0, 0, 4811, 4813, 
	3, 858, 429, 0, 4812, 4810, 1, 0, 0, 0, 4812, 4813, 1, 0, 0, 0, 4813, 861, 
	1, 0, 0, 0, 4814, 4815, 5, 206, 0, 0, 4815, 863, 1, 0, 0, 0, 4816, 4818, 
	3, 862, 431, 0, 4817, 4816, 1, 0, 0, 0, 4818, 4821, 1, 0, 0, 0, 4819, 4817, 
	1, 0, 0, 0, 4819, 4820, 1, 0, 0, 0, 4820, 4822, 1, 0, 0, 0, 4821, 4819, 
	1, 0, 0, 0, 4822, 4823, 3, 860, 430, 0, 4823, 865, 1, 0, 0, 0, 4824, 4825, 
	5, 11, 0, 0, 4825, 867, 1, 0, 0, 0, 4826, 4832, 3, 864, 432, 0, 4827, 4828, 
	3, 866, 433, 0, 4828, 4829, 3, 864, 432, 0, 4829, 4831, 1, 0, 0, 0, 4830, 
	4827, 1, 0, 0, 0, 4831, 4834, 1, 0, 0, 0, 4832, 4830, 1, 0, 0, 0, 4832, 
	4833, 1, 0, 0, 0, 4833, 869, 1, 0, 0, 0, 4834, 4832, 1, 0, 0, 0, 4835, 
	4836, 5, 218, 0, 0, 4836, 871, 1, 0, 0, 0, 4837, 4843, 3, 868, 434, 0, 
	4838, 4839, 3, 870, 435, 0, 4839, 4840, 3, 868, 434, 0, 4840, 4842, 1, 
	0, 0, 0, 4841, 4838, 1, 0, 0, 0, 4842, 4845, 1, 0, 0, 0, 4843, 4841, 1, 
	0, 0, 0, 4843, 4844, 1, 0, 0, 0, 4844, 873, 1, 0, 0, 0, 4845, 4843, 1, 
	0, 0, 0, 4846, 4847, 7, 40, 0, 0, 4847, 875, 1, 0, 0, 0, 4848, 4849, 7, 
	40, 0, 0, 4849, 877, 1, 0, 0, 0, 4850, 4852, 3, 640, 320, 0, 4851, 4853, 
	3, 880, 440, 0, 4852, 4851, 1, 0, 0, 0, 4852, 4853, 1, 0, 0, 0, 4853, 879, 
	1, 0, 0, 0, 4854, 4855, 5, 227, 0, 0, 4855, 4856, 5, 386, 0, 0, 4856, 4861, 
	3, 882, 441, 0, 4857, 4858, 5, 384, 0, 0, 4858, 4860, 3, 882, 441, 0, 4859, 
	4857, 1, 0, 0, 0, 4860, 4863, 1, 0, 0, 0, 4861, 4859, 1, 0, 0, 0, 4861, 
	4862, 1, 0, 0, 0, 4862, 4864, 1, 0, 0, 0, 4863, 4861, 1, 0, 0, 0, 4864, 
	4865, 5, 387, 0, 0, 4865, 881, 1, 0, 0, 0, 4866, 4869, 3, 896, 448, 0, 
	4867, 4868, 5, 392, 0, 0, 4868, 4870, 3, 772, 386, 0, 4869, 4867, 1, 0, 
	0, 0, 4869, 4870, 1, 0, 0, 0, 4870, 883, 1, 0, 0, 0, 4871, 4872, 5, 386, 
	0, 0, 4872, 4877, 3, 886, 443, 0, 4873, 4874, 5, 384, 0, 0, 4874, 4876, 
	3, 886, 443, 0, 4875, 4873, 1, 0, 0, 0, 4876, 4879, 1, 0, 0, 0, 4877, 4875, 
	1, 0, 0, 0, 4877, 4878, 1, 0, 0, 0, 4878, 4880, 1, 0, 0, 0, 4879, 4877, 
	1, 0, 0, 0, 4880, 4881, 5, 387, 0, 0, 4881, 885, 1, 0, 0, 0, 4882, 4883, 
	3, 896, 448, 0, 4883, 4884, 3, 888, 444, 0, 4884, 4885, 3, 772, 386, 0, 
	4885, 887, 1, 0, 0, 0, 4886, 4889, 5, 176, 0, 0, 4887, 4889, 3, 890, 445, 
	0, 4888, 4886, 1, 0, 0, 0, 4888, 4887, 1, 0, 0, 0, 4889, 889, 1, 0, 0, 
	0, 4890, 4891, 7, 41, 0, 0, 4891, 891, 1, 0, 0, 0, 4892, 4893, 7, 42, 0, 
	0, 4893, 893, 1, 0, 0, 0, 4894, 4898, 3, 892, 446, 0, 4895, 4898, 5, 412, 
	0, 0, 4896, 4898, 3, 898, 449, 0, 4897, 4894, 1, 0, 0, 0, 4897, 4895, 1, 
	0, 0, 0, 4897, 4896, 1, 0, 0, 0, 4898, 895, 1, 0, 0, 0, 4899, 4902, 5, 
	418, 0, 0, 4900, 4902, 3, 902, 451, 0, 4901, 4899, 1, 0, 0, 0, 4901, 4900, 
	1, 0, 0, 0, 4902, 897, 1, 0, 0, 0, 4903, 4906, 3, 896, 448, 0, 4904, 4905, 
	5, 382, 0, 0, 4905, 4907, 3, 896, 448, 0, 4906, 4904, 1, 0, 0, 0, 4906, 
	4907, 1, 0, 0, 0, 4907, 899, 1, 0, 0, 0, 4908, 4909, 3, 896, 448, 0, 4909, 
	901, 1, 0, 0, 0, 4910, 4911, 7, 43, 0, 0, 4911, 903, 1, 0, 0, 0, 4912, 
	4913, 7, 44, 0, 0, 4913, 905, 1, 0, 0, 0, 4914, 4915, 3, 908, 454, 0, 4915, 
	4916, 5, 0, 0, 1, 4916, 907, 1, 0, 0, 0, 4917, 4922, 3, 910, 455, 0, 4918, 
	4919, 5, 384, 0, 0, 4919, 4921, 3, 910, 455, 0, 4920, 4918, 1, 0, 0, 0, 
	4921, 4924, 1, 0, 0, 0, 4922, 4920, 1, 0, 0, 0, 4922, 4923, 1, 0, 0, 0, 
	4923, 909, 1, 0, 0, 0, 4924, 4922, 1, 0, 0, 0, 4925, 4930, 3, 912, 456, 
	0, 4926, 4927, 5, 386, 0, 0, 4927, 4928, 3, 914, 457, 0, 4928, 4929, 5, 
	387, 0, 0, 4929, 4931, 1, 0, 0, 0, 4930, 4926, 1, 0, 0, 0, 4930, 4931, 
	1, 0, 0, 0, 4931, 911, 1, 0, 0, 0, 4932, 4933, 7, 45, 0, 0, 4933, 913, 
	1, 0, 0, 0, 4934, 4939, 3, 916, 458, 0, 4935, 4936, 5, 384, 0, 0, 4936, 
	4938, 3, 916, 458, 0, 4937, 4935, 1, 0, 0, 0, 4938, 4941, 1, 0, 0, 0, 4939, 
	4937, 1, 0, 0, 0, 4939, 4940, 1, 0, 0, 0, 4940, 915, 1, 0, 0, 0, 4941, 
	4939, 1, 0, 0, 0, 4942, 4943, 7, 46, 0, 0, 4943, 917, 1, 0, 0, 0, 4944, 
	4945, 5, 239, 0, 0, 4945, 4946, 3, 896, 448, 0, 4946, 4947, 5, 134, 0, 
	0, 4947, 4948, 3, 382, 191, 0, 4948, 919, 1, 0, 0, 0, 4949, 4950, 5, 110, 
	0, 0, 4950, 4951, 3, 896, 448, 0, 4951, 4952, 5, 359, 0, 0, 4952, 4953, 
	3, 922, 461, 0, 4953, 921, 1, 0, 0, 0, 4954, 4959, 3, 772, 386, 0, 4955, 
	4956, 5, 384, 0, 0, 4956, 4958, 3, 772, 386, 0, 4957, 4955, 1, 0, 0, 0, 
	4958, 4961, 1, 0, 0, 0, 4959, 4957, 1, 0, 0, 0, 4959, 4960, 1, 0, 0, 0, 
	4960, 923, 1, 0, 0, 0, 4961, 4959, 1, 0, 0, 0, 4962, 4977, 3, 934, 467, 
	0, 4963, 4977, 3, 946, 473, 0, 4964, 4977, 3, 952, 476, 0, 4965, 4977, 
	3, 948, 474, 0, 4966, 4977, 3, 950, 475, 0, 4967, 4977, 3, 974, 487, 0, 
	4968, 4977, 3, 976, 488, 0, 4969, 4977, 3, 978, 489, 0, 4970, 4977, 3, 
	984, 492, 0, 4971, 4977, 3, 986, 493, 0, 4972, 4977, 3, 988, 494, 0, 4973, 
	4977, 3, 990, 495, 0, 4974, 4977, 3, 992, 496, 0, 4975, 4977, 3, 994, 497, 
	0, 4976, 4962, 1, 0, 0, 0, 4976, 4963, 1, 0, 0, 0, 4976, 4964, 1, 0, 0, 
	0, 4976, 4965, 1, 0, 0, 0, 4976, 4966, 1, 0, 0, 0, 4976, 4967, 1, 0, 0, 
	0, 4976, 4968, 1, 0, 0, 0, 4976, 4969, 1, 0, 0, 0, 4976, 4970, 1, 0, 0, 
	0, 4976, 4971, 1, 0, 0, 0, 4976, 4972, 1, 0, 0, 0, 4976, 4973, 1, 0, 0, 
	0, 4976, 4974, 1, 0, 0, 0, 4976, 4975, 1, 0, 0, 0, 4977, 925, 1, 0, 0, 
	0, 4978, 4979, 5, 249, 0, 0, 4979, 4980, 5, 392, 0, 0, 4980, 4986, 5, 417, 
	0, 0, 4981, 4982, 5, 80, 0, 0, 4982, 4983, 5, 236, 0, 0, 4983, 4984, 5, 
	392, 0, 0, 4984, 4986, 3, 954, 477, 0, 4985, 4978, 1, 0, 0, 0, 4985, 4981, 
	1, 0, 0, 0, 4986, 927, 1, 0, 0, 0, 4987, 4992, 3, 926, 463, 0, 4988, 4989, 
	5, 384, 0, 0, 4989, 4991, 3, 926, 463, 0, 4990, 4988, 1, 0, 0, 0, 4991, 
	4994, 1, 0, 0, 0, 4992, 4990, 1, 0, 0, 0, 4992, 4993, 1, 0, 0, 0, 4993, 
	929, 1, 0, 0, 0, 4994, 4992, 1, 0, 0, 0, 4995, 4999, 5, 249, 0, 0, 4996, 
	4997, 5, 80, 0, 0, 4997, 4999, 5, 236, 0, 0, 4998, 4995, 1, 0, 0, 0, 4998, 
	4996, 1, 0, 0, 0, 4999, 931, 1, 0, 0, 0, 5000, 5005, 3, 930, 465, 0, 5001, 
	5002, 5, 384, 0, 0, 5002, 5004, 3, 930, 465, 0, 5003, 5001, 1, 0, 0, 0, 
	5004, 5007, 1, 0, 0, 0, 5005, 5003, 1, 0, 0, 0, 5005, 5006, 1, 0, 0, 0, 
	5006, 933, 1, 0, 0, 0, 5007, 5005, 1, 0, 0, 0, 5008, 5009, 5, 58, 0, 0, 
	5009, 5010, 5, 270, 0, 0, 5010, 5012, 5, 233, 0, 0, 5011, 5013, 3, 40, 
	20, 0, 5012, 5011, 1, 0, 0, 0, 5012, 5013, 1, 0, 0, 0, 5013, 5023, 1, 0, 
	0, 0, 5014, 5015, 3, 896, 448, 0, 5015, 5016, 5, 176, 0, 0, 5016, 5017, 
	3, 896, 448, 0, 5017, 5024, 1, 0, 0, 0, 5018, 5021, 3, 896, 448, 0, 5019, 
	5020, 5, 375, 0, 0, 5020, 5022, 3, 928, 464, 0, 5021, 5019, 1, 0, 0, 0, 
	5021, 5022, 1, 0, 0, 0, 5022, 5024, 1, 0, 0, 0, 5023, 5014, 1, 0, 0, 0, 
	5023, 5018, 1, 0, 0, 0, 5024, 935, 1, 0, 0, 0, 5025, 5026, 5, 375, 0, 0, 
	5026, 5027, 5, 268, 0, 0, 5027, 937, 1, 0, 0, 0, 5028, 5030, 5, 2, 0, 0, 
	5029, 5031, 3, 936, 468, 0, 5030, 5029, 1, 0, 0, 0, 5030, 5031, 1, 0, 0, 
	0, 5031, 939, 1, 0, 0, 0, 5032, 5033, 5, 102, 0, 0, 5033, 941, 1, 0, 0, 
	0, 5034, 5035, 5, 91, 0, 0, 5035, 943, 1, 0, 0, 0, 5036, 5037, 5, 351, 
	0, 0, 5037, 945, 1, 0, 0, 0, 5038, 5039, 5, 9, 0, 0, 5039, 5040, 5, 270, 
	0, 0, 5040, 5041, 5, 233, 0, 0, 5041, 5059, 3, 896, 448, 0, 5042, 5060, 
	5, 362, 0, 0, 5043, 5060, 5, 91, 0, 0, 5044, 5045, 5, 293, 0, 0, 5045, 
	5060, 3, 928, 464, 0, 5046, 5047, 5, 352, 0, 0, 5047, 5060, 3, 932, 466, 
	0, 5048, 5049, 5, 264, 0, 0, 5049, 5050, 5, 330, 0, 0, 5050, 5060, 3, 896, 
	448, 0, 5051, 5053, 3, 938, 469, 0, 5052, 5054, 3, 940, 470, 0, 5053, 5052, 
	1, 0, 0, 0, 5053, 5054, 1, 0, 0, 0, 5054, 5060, 1, 0, 0, 0, 5055, 5057, 
	3, 940, 470, 0, 5056, 5058, 3, 938, 469, 0, 5057, 5056, 1, 0, 0, 0, 5057, 
	5058, 1, 0, 0, 0, 5058, 5060, 1, 0, 0, 0, 5059, 5042, 1, 0, 0, 0, 5059, 
	5043, 1, 0, 0, 0, 5059, 5044, 1, 0, 0, 0, 5059, 5046, 1, 0, 0, 0, 5059, 
	5048, 1, 0, 0, 0, 5059, 5051, 1, 0, 0, 0, 5059, 5055, 1, 0, 0, 0, 5060, 
	947, 1, 0, 0, 0, 5061, 5062, 7, 14, 0, 0, 5062, 5063, 5, 378, 0, 0, 5063, 
	5064, 5, 189, 0, 0, 5064, 949, 1, 0, 0, 0, 5065, 5077, 5, 268, 0, 0, 5066, 
	5067, 5, 3, 0, 0, 5067, 5068, 5, 270, 0, 0, 5068, 5069, 5, 233, 0, 0, 5069, 
	5070, 5, 375, 0, 0, 5070, 5078, 3, 896, 448, 0, 5071, 5072, 5, 270, 0, 
	0, 5072, 5073, 5, 233, 0, 0, 5073, 5074, 3, 896, 448, 0, 5074, 5075, 5, 
	375, 0, 0, 5075, 5076, 3, 896, 448, 0, 5076, 5078, 1, 0, 0, 0, 5077, 5066, 
	1, 0, 0, 0, 5077, 5071, 1, 0, 0, 0, 5078, 951, 1, 0, 0, 0, 5079, 5080, 
	5, 98, 0, 0, 5080, 5081, 5, 270, 0, 0, 5081, 5083, 5, 233, 0, 0, 5082, 
	5084, 3, 36, 18, 0, 5083, 5082, 1, 0, 0, 0, 5083, 5084, 1, 0, 0, 0, 5084, 
	5085, 1, 0, 0, 0, 5085, 5086, 3, 896, 448, 0, 5086, 953, 1, 0, 0, 0, 5087, 
	5092, 3, 896, 448, 0, 5088, 5089, 5, 382, 0, 0, 5089, 5091, 3, 896, 448, 
	0, 5090, 5088, 1, 0, 0, 0, 5091, 5094, 1, 0, 0, 0, 5092, 5090, 1, 0, 0, 
	0, 5092, 5093, 1, 0, 0, 0, 5093, 955, 1, 0, 0, 0, 5094, 5092, 1, 0, 0, 
	0, 5095, 5096, 3, 964, 482, 0, 5096, 957, 1, 0, 0, 0, 5097, 5098, 3, 956, 
	478, 0, 5098, 5099, 5, 0, 0, 1, 5099, 959, 1, 0, 0, 0, 5100, 5105, 3, 962, 
	481, 0, 5101, 5102, 5, 218, 0, 0, 5102, 5104, 3, 962, 481, 0, 5103, 5101, 
	1, 0, 0, 0, 5104, 5107, 1, 0, 0, 0, 5105, 5103, 1, 0, 0, 0, 5105, 5106, 
	1, 0, 0, 0, 5106, 961, 1, 0, 0, 0, 5107, 5105, 1, 0, 0, 0, 5108, 5113, 
	3, 964, 482, 0, 5109, 5110, 5, 11, 0, 0, 5110, 5112, 3, 964, 482, 0, 5111, 
	5109, 1, 0, 0, 0, 5112, 5115, 1, 0, 0, 0, 5113, 5111, 1, 0, 0, 0, 5113, 
	5114, 1, 0, 0, 0, 5114, 963, 1, 0, 0, 0, 5115, 5113, 1, 0, 0, 0, 5116, 
	5117, 3, 896, 448, 0, 5117, 5118, 3, 968, 484, 0, 5118, 5119, 3, 966, 483, 
	0, 5119, 965, 1, 0, 0, 0, 5120, 5121, 7, 25, 0, 0, 5121, 967, 1, 0, 0, 
	0, 5122, 5123, 5, 398, 0, 0, 5123, 969, 1, 0, 0, 0, 5124, 5129, 5, 169, 
	0, 0, 5125, 5126, 5, 201, 0, 0, 5126, 5127, 5, 330, 0, 0, 5127, 5129, 3, 
	954, 477, 0, 5128, 5124, 1, 0, 0, 0, 5128, 5125, 1, 0, 0, 0, 5129, 971, 
	1, 0, 0, 0, 5130, 5131, 3, 970, 485, 0, 5131, 5132, 5, 0, 0, 1, 5132, 973, 
	1, 0, 0, 0, 5133, 5134, 5, 58, 0, 0, 5134, 5135, 5, 337, 0, 0, 5135, 5136, 
	3, 896, 448, 0, 5136, 5137, 5, 382, 0, 0, 5137, 5138, 3, 896, 448, 0, 5138, 
	5139, 5, 371, 0, 0, 5139, 5140, 3, 956, 478, 0, 5140, 5141, 5, 95, 0, 0, 
	5141, 5142, 3, 970, 485, 0, 5142, 975, 1, 0, 0, 0, 5143, 5144, 5, 9, 0, 
	0, 5144, 5145, 5, 337, 0, 0, 5145, 5146, 3, 896, 448, 0, 5146, 5147, 5, 
	382, 0, 0, 5147, 5164, 3, 896, 448, 0, 5148, 5149, 5, 371, 0, 0, 5149, 
	5150, 3, 956, 478, 0, 5150, 5151, 5, 95, 0, 0, 5151, 5152, 3, 970, 485, 
	0, 5152, 5165, 1, 0, 0, 0, 5153, 5154, 5, 4, 0, 0, 5154, 5158, 5, 330, 
	0, 0, 5155, 5156, 5, 98, 0, 0, 5156, 5158, 5, 134, 0, 0, 5157, 5153, 1, 
	0, 0, 0, 5157, 5155, 1, 0, 0, 0, 5158, 5162, 1, 0, 0, 0, 5159, 5160, 5, 
	236, 0, 0, 5160, 5163, 3, 954, 477, 0, 5161, 5163, 5, 351, 0, 0, 5162, 
	5159, 1, 0, 0, 0, 5162, 5161, 1, 0, 0, 0, 5163, 5165, 1, 0, 0, 0, 5164, 
	5148, 1, 0, 0, 0, 5164, 5157, 1, 0, 0, 0, 5165, 977, 1, 0, 0, 0, 5166, 
	5167, 5, 98, 0, 0, 5167, 5168, 5, 337, 0, 0, 5168, 5169, 3, 896, 448, 0, 
	5169, 5170, 5, 382, 0, 0, 5170, 5171, 3, 896, 448, 0, 5171, 979, 1, 0, 
	0, 0, 5172, 5173, 5, 8, 0, 0, 5173, 5174, 5, 392, 0, 0, 5174, 5185, 5, 
	417, 0, 0, 5175, 5176, 5, 249, 0, 0, 5176, 5177, 5, 392, 0, 0, 5177, 5185, 
	5, 417, 0, 0, 5178, 5179, 5, 284, 0, 0, 5179, 5180, 5, 392, 0, 0, 5180, 
	5185, 5, 412, 0, 0, 5181, 5182, 5, 230, 0, 0, 5182, 5183, 5, 392, 0, 0, 
	5183, 5185, 3, 954, 477, 0, 5184, 5172, 1, 0, 0, 0, 5184, 5175, 1, 0, 0, 
	0, 5184, 5178, 1, 0, 0, 0, 5184, 5181, 1, 0, 0, 0, 5185, 981, 1, 0, 0, 
	0, 5186, 5191, 3, 980, 490, 0, 5187, 5188, 5, 384, 0, 0, 5188, 5190, 3, 
	980, 490, 0, 5189, 5187, 1, 0, 0, 0, 5190, 5193, 1, 0, 0, 0, 5191, 5189, 
	1, 0, 0, 0, 5191, 5192, 1, 0, 0, 0, 5192, 983, 1, 0, 0, 0, 5193, 5191, 
	1, 0, 0, 0, 5194, 5195, 5, 58, 0, 0, 5195, 5196, 5, 236, 0, 0, 5196, 5197, 
	3, 896, 448, 0, 5197, 5198, 5, 382, 0, 0, 5198, 5199, 3, 954, 477, 0, 5199, 
	5200, 5, 375, 0, 0, 5200, 5201, 3, 982, 491, 0, 5201, 985, 1, 0, 0, 0, 
	5202, 5203, 5, 9, 0, 0, 5203, 5204, 5, 236, 0, 0, 5204, 5205, 3, 896, 448, 
	0, 5205, 5206, 5, 382, 0, 0, 5206, 5214, 3, 954, 477, 0, 5207, 5208, 5, 
	293, 0, 0, 5208, 5215, 3, 982, 491, 0, 5209, 5210, 5, 352, 0, 0, 5210, 
	5215, 5, 284, 0, 0, 5211, 5212, 7, 47, 0, 0, 5212, 5213, 5, 337, 0, 0, 
	5213, 5215, 3, 896, 448, 0, 5214, 5207, 1, 0, 0, 0, 5214, 5209, 1, 0, 0, 
	0, 5214, 5211, 1, 0, 0, 0, 5215, 987, 1, 0, 0, 0, 5216, 5217, 5, 98, 0, 
	0, 5217, 5218, 5, 236, 0, 0, 5218, 5219, 3, 896, 448, 0, 5219, 5220, 5, 
	382, 0, 0, 5220, 5221, 3, 954, 477, 0, 5221, 989, 1, 0, 0, 0, 5222, 5223, 
	5, 58, 0, 0, 5223, 5224, 7, 48, 0, 0, 5224, 5225, 5, 192, 0, 0, 5225, 5226, 
	5, 412, 0, 0, 5226, 5227, 5, 148, 0, 0, 5227, 5231, 3, 896, 448, 0, 5228, 
	5229, 5, 330, 0, 0, 5229, 5232, 3, 954, 477, 0, 5230, 5232, 3, 944, 472, 
	0, 5231, 5228, 1, 0, 0, 0, 5231, 5230, 1, 0, 0, 0, 5232, 5236, 1, 0, 0, 
	0, 5233, 5234, 5, 375, 0, 0, 5234, 5235, 5, 219, 0, 0, 5235, 5237, 5, 417, 
	0, 0, 5236, 5233, 1, 0, 0, 0, 5236, 5237, 1, 0, 0, 0, 5237, 991, 1, 0, 
	0, 0, 5238, 5239, 5, 9, 0, 0, 5239, 5240, 7, 48, 0, 0, 5240, 5241, 5, 192, 
	0, 0, 5241, 5242, 5, 412, 0, 0, 5242, 5243, 5, 148, 0, 0, 5243, 5247, 3, 
	896, 448, 0, 5244, 5245, 5, 330, 0, 0, 5245, 5248, 3, 954, 477, 0, 5246, 
	5248, 3, 944, 472, 0, 5247, 5244, 1, 0, 0, 0, 5247, 5246, 1, 0, 0, 0, 5248, 
	5252, 1, 0, 0, 0, 5249, 5250, 5, 375, 0, 0, 5250, 5251, 5, 219, 0, 0, 5251, 
	5253, 5, 417, 0, 0, 5252, 5249, 1, 0, 0, 0, 5252, 5253, 1, 0, 0, 0, 5253, 
	993, 1, 0, 0, 0, 5254, 5255, 5, 98, 0, 0, 5255, 5256, 7, 48, 0, 0, 5256, 
	5257, 5, 192, 0, 0, 5257, 5258, 5, 412, 0, 0, 5258, 5259, 5, 148, 0, 0, 
	5259, 5260, 3, 896, 448, 0, 5260, 995, 1, 0, 0, 0, 613, 998, 1006, 1012, 
	1019, 1029, 1032, 1036, 1056, 1061, 1066, 1072, 1076, 1089, 1093, 1097, 
	1102, 1109, 1113, 1118, 1125, 1129, 1140, 1146, 1153, 1200, 1229, 1233, 
	1236, 1239, 1244, 1250, 1254, 1260, 1262, 1279, 1291, 1295, 1302, 1310, 
	1313, 1318, 1322, 1325, 1335, 1343, 1347, 1350, 1354, 1358, 1361, 1366, 
	1372, 1377, 1382, 1386, 1397, 1399, 1403, 1413, 1417, 1423, 1426, 1433, 
	1438, 1446, 1451, 1455, 1463, 1468, 1474, 1480, 1483, 1486, 1489, 1498, 
	1506, 1511, 1519, 1526, 1529, 1532, 1534, 1542, 1545, 1548, 1551, 1554, 
	1557, 1560, 1563, 1566, 1569, 1572, 1574, 1586, 1590, 1600, 1606, 1621, 
	1638, 1643, 1647, 1651, 1658, 1665, 1671, 1675, 1678, 1685, 1708, 1713, 
	1717, 1725, 1734, 1738, 1744, 1750, 1757, 1760, 1766, 1773, 1781, 1790, 
	1799, 1819, 1826, 1828, 1835, 1845, 1853, 1857, 1861, 1874, 1883, 1889, 
	1893, 1900, 1903, 1906, 1909, 1921, 1927, 1953, 1961, 1965, 1968, 1971, 
	1974, 1977, 1980, 1983, 1986, 1995, 2005, 2008, 2028, 2034, 2040, 2043, 
	2045, 2052, 2059, 2063, 2073, 2078, 2087, 2095, 2103, 2121, 2134, 2155, 
	2159, 2174, 2180, 2183, 2186, 2189, 2192, 2196, 2210, 2218, 2221, 2236, 
	2270, 2278, 2283, 2291, 2296, 2301, 2311, 2319, 2327, 2335, 2346, 2350, 
	2358, 2367, 2370, 2379, 2385, 2389, 2395, 2399, 2411, 2420, 2431, 2435, 
	2442, 2454, 2461, 2470, 2473, 2480, 2486, 2492, 2495, 2501, 2505, 2509, 
	2514, 2518, 2522, 2526, 2534, 2538, 2542, 2546, 2550, 2558, 2562, 2566, 
	2574, 2579, 2584, 2588, 2592, 2599, 2608, 2616, 2627, 2645, 2648, 2654, 
	2680, 2683, 2689, 2697, 2705, 2718, 2725, 2731, 2735, 2738, 2741, 2744, 
	2747, 2750, 2757, 2761, 2764, 2767, 2770, 2773, 2776, 2783, 2786, 2793, 
	2796, 2799, 2802, 2805, 2808, 2811, 2814, 2817, 2820, 2823, 2827, 2830, 
	2833, 2836, 2839, 2842, 2845, 2848, 2851, 2854, 2857, 2859, 2865, 2869, 
	2876, 2878, 2881, 2886, 2889, 2893, 2898, 2904, 2910, 2918, 2926, 2933, 
	2939, 2948, 2951, 2955, 2968, 2972, 2983, 2990, 2994, 2999, 3002, 3012, 
	3014, 3018, 3025, 3030, 3050, 3057, 3080, 3094, 3115, 3131, 3144, 3148, 
	3152, 3159, 3187, 3194, 3199, 3204, 3212, 3218, 3222, 3225, 3228, 3234, 
	3241, 3251, 3255, 3260, 3264, 3270, 3277, 3284, 3292, 3301, 3305, 3308, 
	3316, 3319, 3327, 3330, 3338, 3342, 3347, 3351, 3360, 3376, 3391, 3393, 
	3409, 3416, 3433, 3436, 3439, 3445, 3468, 3482, 3485, 3490, 3516, 3520, 
	3523, 3526, 3530, 3535, 3538, 3541, 3544, 3547, 3553, 3556, 3559, 3562, 
	3565, 3568, 3571, 3574, 3577, 3581, 3583, 3589, 3594, 3597, 3600, 3603, 
	3609, 3612, 3615, 3618, 3621, 3624, 3627, 3630, 3633, 3637, 3639, 3641, 
	3646, 3652, 3657, 3675, 3684, 3695, 3703, 3715, 3718, 3724, 3731, 3738, 
	3745, 3752, 3761, 3765, 3772, 3777, 3781, 3797, 3801, 3803, 3806, 3819, 
	3822, 3825, 3837, 3840, 3847, 3856, 3861, 3863, 3865, 3882, 3885, 3894, 
	3900, 3904, 3907, 3910, 3913, 3916, 3928, 3932, 3935, 3938, 3945, 3948, 
	3953, 3961, 3967, 3972, 3976, 3981, 3988, 4002, 4005, 4009, 4026, 4034, 
	4037, 4050, 4059, 4062, 4068, 4071, 4076, 4079, 4088, 4102, 4108, 4110, 
	4118, 4128, 4133, 4135, 4147, 4153, 4155, 4162, 4169, 4178, 4188, 4191, 
	4194, 4197, 4201, 4210, 4219, 4227, 4233, 4242, 4249, 4257, 4267, 4277, 
	4282, 4286, 4290, 4296, 4317, 4323, 4327, 4331, 4334, 4340, 4345, 4348, 
	4352, 4360, 4370, 4380, 4399, 4406, 4409, 4420, 4427, 4430, 4432, 4443, 
	4453, 4455, 4461, 4465, 4474, 4487, 4491, 4503, 4507, 4516, 4544, 4554, 
	4562, 4567, 4588, 4592, 4606, 4621, 4630, 4632, 4640, 4653, 4664, 4675, 
	4686, 4697, 4708, 4718, 4727, 4731, 4739, 4752, 4762, 4768, 4781, 4790, 
	4792, 4807, 4812, 4819, 4832, 4843, 4852, 4861, 4869, 4877, 4888, 4897, 
	4901, 4906, 4922, 4930, 4939, 4959, 4976, 4985, 4992, 4998, 5005, 5012, 
	5021, 5023, 5030, 5053, 5057, 5059, 5077, 5083, 5092, 5105, 5113, 5128, 
	5157, 5162, 5164, 5184, 5191, 5214, 5231, 5236, 5247, 5252,
}
  deserializer := antlr.NewATNDeserializer(nil)
  staticData.atn = deserializer.Deserialize(staticData.serializedATN)
  atn := staticData.atn
  staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
  decisionToDFA := staticData.decisionToDFA
  for index, state := range atn.DecisionToState {
    decisionToDFA[index] = antlr.NewDFA(state, index)
  }
}

// HiveParserInit initializes any static state used to implement HiveParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewHiveParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func HiveParserInit() {
  staticData := &HiveParserParserStaticData
  staticData.once.Do(hiveparserParserInit)
}

// NewHiveParser produces a new parser instance for the optional input antlr.TokenStream.
func NewHiveParser(input antlr.TokenStream) *HiveParser {
	HiveParserInit()
	this := new(HiveParser)
	this.BaseParser = antlr.NewBaseParser(input)
  staticData := &HiveParserParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "HiveParser.g4"

	return this
}


// HiveParser tokens.
const (
	HiveParserEOF = antlr.TokenEOF
	HiveParserKW_ABORT = 1
	HiveParserKW_ACTIVATE = 2
	HiveParserKW_ACTIVE = 3
	HiveParserKW_ADD = 4
	HiveParserKW_ADMIN = 5
	HiveParserKW_AFTER = 6
	HiveParserKW_ALL = 7
	HiveParserKW_ALLOC_FRACTION = 8
	HiveParserKW_ALTER = 9
	HiveParserKW_ANALYZE = 10
	HiveParserKW_AND = 11
	HiveParserKW_ANTI = 12
	HiveParserKW_ANY = 13
	HiveParserKW_APPLICATION = 14
	HiveParserKW_ARCHIVE = 15
	HiveParserKW_ARRAY = 16
	HiveParserKW_AS = 17
	HiveParserKW_ASC = 18
	HiveParserKW_AST = 19
	HiveParserKW_AT = 20
	HiveParserKW_AUTHORIZATION = 21
	HiveParserKW_AUTOCOMMIT = 22
	HiveParserKW_BATCH = 23
	HiveParserKW_BEFORE = 24
	HiveParserKW_BETWEEN = 25
	HiveParserKW_BIGINT = 26
	HiveParserKW_BINARY = 27
	HiveParserKW_BOOLEAN = 28
	HiveParserKW_BOTH = 29
	HiveParserKW_BUCKET = 30
	HiveParserKW_BUCKETS = 31
	HiveParserKW_BY = 32
	HiveParserKW_CACHE = 33
	HiveParserKW_CASCADE = 34
	HiveParserKW_CASE = 35
	HiveParserKW_CAST = 36
	HiveParserKW_CBO = 37
	HiveParserKW_CHANGE = 38
	HiveParserKW_CHAR = 39
	HiveParserKW_CHECK = 40
	HiveParserKW_CLUSTER = 41
	HiveParserKW_CLUSTERED = 42
	HiveParserKW_CLUSTERSTATUS = 43
	HiveParserKW_COLLECTION = 44
	HiveParserKW_COLUMN = 45
	HiveParserKW_COLUMNS = 46
	HiveParserKW_COMMENT = 47
	HiveParserKW_COMMIT = 48
	HiveParserKW_COMPACT = 49
	HiveParserKW_COMPACTIONS = 50
	HiveParserKW_COMPACT_ID = 51
	HiveParserKW_COMPUTE = 52
	HiveParserKW_CONCATENATE = 53
	HiveParserKW_CONF = 54
	HiveParserKW_CONSTRAINT = 55
	HiveParserKW_CONTINUE = 56
	HiveParserKW_COST = 57
	HiveParserKW_CREATE = 58
	HiveParserKW_CRON = 59
	HiveParserKW_CROSS = 60
	HiveParserKW_CUBE = 61
	HiveParserKW_CURRENT = 62
	HiveParserKW_CURRENT_DATE = 63
	HiveParserKW_CURRENT_TIMESTAMP = 64
	HiveParserKW_CURSOR = 65
	HiveParserKW_DATA = 66
	HiveParserKW_DATABASE = 67
	HiveParserKW_DATABASES = 68
	HiveParserKW_DATACONNECTOR = 69
	HiveParserKW_DATACONNECTORS = 70
	HiveParserKW_DATE = 71
	HiveParserKW_DATETIME = 72
	HiveParserKW_DAY = 73
	HiveParserKW_DAYOFWEEK = 74
	HiveParserKW_DBPROPERTIES = 75
	HiveParserKW_DCPROPERTIES = 76
	HiveParserKW_DDL = 77
	HiveParserKW_DEBUG = 78
	HiveParserKW_DECIMAL = 79
	HiveParserKW_DEFAULT = 80
	HiveParserKW_DEFERRED = 81
	HiveParserKW_DEFINED = 82
	HiveParserKW_DELETE = 83
	HiveParserKW_DELIMITED = 84
	HiveParserKW_DEPENDENCY = 85
	HiveParserKW_DESC = 86
	HiveParserKW_DESCRIBE = 87
	HiveParserKW_DETAIL = 88
	HiveParserKW_DIRECTORIES = 89
	HiveParserKW_DIRECTORY = 90
	HiveParserKW_DISABLE = 91
	HiveParserKW_DISTINCT = 92
	HiveParserKW_DISTRIBUTE = 93
	HiveParserKW_DISTRIBUTED = 94
	HiveParserKW_DO = 95
	HiveParserKW_DOUBLE = 96
	HiveParserKW_DOW = 97
	HiveParserKW_DROP = 98
	HiveParserKW_DUMP = 99
	HiveParserKW_ELEM_TYPE = 100
	HiveParserKW_ELSE = 101
	HiveParserKW_ENABLE = 102
	HiveParserKW_END = 103
	HiveParserKW_ENFORCED = 104
	HiveParserKW_ESCAPED = 105
	HiveParserKW_EVERY = 106
	HiveParserKW_EXCEPT = 107
	HiveParserKW_EXCHANGE = 108
	HiveParserKW_EXCLUSIVE = 109
	HiveParserKW_EXECUTE = 110
	HiveParserKW_EXECUTED = 111
	HiveParserKW_EXISTS = 112
	HiveParserKW_EXPIRE_SNAPSHOTS = 113
	HiveParserKW_EXPLAIN = 114
	HiveParserKW_EXPORT = 115
	HiveParserKW_EXPRESSION = 116
	HiveParserKW_EXTENDED = 117
	HiveParserKW_EXTERNAL = 118
	HiveParserKW_EXTRACT = 119
	HiveParserKW_FALSE = 120
	HiveParserKW_FETCH = 121
	HiveParserKW_FIELDS = 122
	HiveParserKW_FILE = 123
	HiveParserKW_FILEFORMAT = 124
	HiveParserKW_FIRST = 125
	HiveParserKW_FLOAT = 126
	HiveParserKW_FLOOR = 127
	HiveParserKW_FOLLOWING = 128
	HiveParserKW_FOR = 129
	HiveParserKW_FORCE = 130
	HiveParserKW_FOREIGN = 131
	HiveParserKW_FORMAT = 132
	HiveParserKW_FORMATTED = 133
	HiveParserKW_FROM = 134
	HiveParserKW_FULL = 135
	HiveParserKW_FUNCTION = 136
	HiveParserKW_FUNCTIONS = 137
	HiveParserKW_GRANT = 138
	HiveParserKW_GROUP = 139
	HiveParserKW_GROUPING = 140
	HiveParserKW_HAVING = 141
	HiveParserKW_HOLD_DDLTIME = 142
	HiveParserKW_HOUR = 143
	HiveParserKW_IDXPROPERTIES = 144
	HiveParserKW_IF = 145
	HiveParserKW_IGNORE = 146
	HiveParserKW_IMPORT = 147
	HiveParserKW_IN = 148
	HiveParserKW_INDEX = 149
	HiveParserKW_INDEXES = 150
	HiveParserKW_INNER = 151
	HiveParserKW_INPATH = 152
	HiveParserKW_INPUTDRIVER = 153
	HiveParserKW_INPUTFORMAT = 154
	HiveParserKW_INSERT = 155
	HiveParserKW_INT = 156
	HiveParserKW_INTERSECT = 157
	HiveParserKW_INTERVAL = 158
	HiveParserKW_INTO = 159
	HiveParserKW_IS = 160
	HiveParserKW_ISOLATION = 161
	HiveParserKW_ITEMS = 162
	HiveParserKW_JAR = 163
	HiveParserKW_JOIN = 164
	HiveParserKW_JOINCOST = 165
	HiveParserKW_KEY = 166
	HiveParserKW_KEYS = 167
	HiveParserKW_KEY_TYPE = 168
	HiveParserKW_KILL = 169
	HiveParserKW_LAST = 170
	HiveParserKW_LATERAL = 171
	HiveParserKW_LEADING = 172
	HiveParserKW_LEFT = 173
	HiveParserKW_LESS = 174
	HiveParserKW_LEVEL = 175
	HiveParserKW_LIKE = 176
	HiveParserKW_LIMIT = 177
	HiveParserKW_LINES = 178
	HiveParserKW_LOAD = 179
	HiveParserKW_LOCAL = 180
	HiveParserKW_LOCATION = 181
	HiveParserKW_LOCK = 182
	HiveParserKW_LOCKS = 183
	HiveParserKW_LOGICAL = 184
	HiveParserKW_LONG = 185
	HiveParserKW_MACRO = 186
	HiveParserKW_MANAGED = 187
	HiveParserKW_MANAGEDLOCATION = 188
	HiveParserKW_MANAGEMENT = 189
	HiveParserKW_MAP = 190
	HiveParserKW_MAPJOIN = 191
	HiveParserKW_MAPPING = 192
	HiveParserKW_MATCHED = 193
	HiveParserKW_MATERIALIZED = 194
	HiveParserKW_MERGE = 195
	HiveParserKW_METADATA = 196
	HiveParserKW_MINUS = 197
	HiveParserKW_MINUTE = 198
	HiveParserKW_MONTH = 199
	HiveParserKW_MORE = 200
	HiveParserKW_MOVE = 201
	HiveParserKW_MSCK = 202
	HiveParserKW_NONE = 203
	HiveParserKW_NORELY = 204
	HiveParserKW_NOSCAN = 205
	HiveParserKW_NOT = 206
	HiveParserKW_NOVALIDATE = 207
	HiveParserKW_NO_DROP = 208
	HiveParserKW_NULL = 209
	HiveParserKW_NULLS = 210
	HiveParserKW_OF = 211
	HiveParserKW_OFFLINE = 212
	HiveParserKW_OFFSET = 213
	HiveParserKW_ON = 214
	HiveParserKW_ONLY = 215
	HiveParserKW_OPERATOR = 216
	HiveParserKW_OPTION = 217
	HiveParserKW_OR = 218
	HiveParserKW_ORDER = 219
	HiveParserKW_OUT = 220
	HiveParserKW_OUTER = 221
	HiveParserKW_OUTPUTDRIVER = 222
	HiveParserKW_OUTPUTFORMAT = 223
	HiveParserKW_OVER = 224
	HiveParserKW_OVERWRITE = 225
	HiveParserKW_OWNER = 226
	HiveParserKW_PARTITION = 227
	HiveParserKW_PARTITIONED = 228
	HiveParserKW_PARTITIONS = 229
	HiveParserKW_PATH = 230
	HiveParserKW_PERCENT = 231
	HiveParserKW_PKFK_JOIN = 232
	HiveParserKW_PLAN = 233
	HiveParserKW_PLANS = 234
	HiveParserKW_PLUS = 235
	HiveParserKW_POOL = 236
	HiveParserKW_PRECEDING = 237
	HiveParserKW_PRECISION = 238
	HiveParserKW_PREPARE = 239
	HiveParserKW_PRESERVE = 240
	HiveParserKW_PRIMARY = 241
	HiveParserKW_PRINCIPALS = 242
	HiveParserKW_PROCEDURE = 243
	HiveParserKW_PROTECTION = 244
	HiveParserKW_PURGE = 245
	HiveParserKW_QUALIFY = 246
	HiveParserKW_QUARTER = 247
	HiveParserKW_QUERY = 248
	HiveParserKW_QUERY_PARALLELISM = 249
	HiveParserKW_RANGE = 250
	HiveParserKW_READ = 251
	HiveParserKW_READONLY = 252
	HiveParserKW_READS = 253
	HiveParserKW_REAL = 254
	HiveParserKW_REBUILD = 255
	HiveParserKW_RECORDREADER = 256
	HiveParserKW_RECORDWRITER = 257
	HiveParserKW_REDUCE = 258
	HiveParserKW_REFERENCES = 259
	HiveParserKW_REGEXP = 260
	HiveParserKW_RELOAD = 261
	HiveParserKW_RELY = 262
	HiveParserKW_REMOTE = 263
	HiveParserKW_RENAME = 264
	HiveParserKW_REOPTIMIZATION = 265
	HiveParserKW_REPAIR = 266
	HiveParserKW_REPL = 267
	HiveParserKW_REPLACE = 268
	HiveParserKW_REPLICATION = 269
	HiveParserKW_RESOURCE = 270
	HiveParserKW_RESPECT = 271
	HiveParserKW_RESTRICT = 272
	HiveParserKW_REVOKE = 273
	HiveParserKW_REWRITE = 274
	HiveParserKW_RIGHT = 275
	HiveParserKW_RLIKE = 276
	HiveParserKW_ROLE = 277
	HiveParserKW_ROLES = 278
	HiveParserKW_ROLLBACK = 279
	HiveParserKW_ROLLUP = 280
	HiveParserKW_ROW = 281
	HiveParserKW_ROWS = 282
	HiveParserKW_SCHEDULED = 283
	HiveParserKW_SCHEDULING_POLICY = 284
	HiveParserKW_SCHEMA = 285
	HiveParserKW_SCHEMAS = 286
	HiveParserKW_SECOND = 287
	HiveParserKW_SELECT = 288
	HiveParserKW_SEMI = 289
	HiveParserKW_SERDE = 290
	HiveParserKW_SERDEPROPERTIES = 291
	HiveParserKW_SERVER = 292
	HiveParserKW_SET = 293
	HiveParserKW_SETS = 294
	HiveParserKW_SET_CURRENT_SNAPSHOT = 295
	HiveParserKW_SHARED = 296
	HiveParserKW_SHOW = 297
	HiveParserKW_SHOW_DATABASE = 298
	HiveParserKW_SKEWED = 299
	HiveParserKW_SMALLINT = 300
	HiveParserKW_SNAPSHOT = 301
	HiveParserKW_SOME = 302
	HiveParserKW_SORT = 303
	HiveParserKW_SORTED = 304
	HiveParserKW_SPEC = 305
	HiveParserKW_SSL = 306
	HiveParserKW_START = 307
	HiveParserKW_STATISTICS = 308
	HiveParserKW_STATUS = 309
	HiveParserKW_STORED = 310
	HiveParserKW_STREAMTABLE = 311
	HiveParserKW_STRING = 312
	HiveParserKW_STRUCT = 313
	HiveParserKW_SUMMARY = 314
	HiveParserKW_SYNC = 315
	HiveParserKW_SYSTEM_TIME = 316
	HiveParserKW_SYSTEM_VERSION = 317
	HiveParserKW_TABLE = 318
	HiveParserKW_TABLES = 319
	HiveParserKW_TABLESAMPLE = 320
	HiveParserKW_TBLPROPERTIES = 321
	HiveParserKW_TEMPORARY = 322
	HiveParserKW_TERMINATED = 323
	HiveParserKW_THEN = 324
	HiveParserKW_TIME = 325
	HiveParserKW_TIMESTAMP = 326
	HiveParserKW_TIMESTAMPLOCALTZ = 327
	HiveParserKW_TIMESTAMPTZ = 328
	HiveParserKW_TINYINT = 329
	HiveParserKW_TO = 330
	HiveParserKW_TOUCH = 331
	HiveParserKW_TRAILING = 332
	HiveParserKW_TRANSACTION = 333
	HiveParserKW_TRANSACTIONAL = 334
	HiveParserKW_TRANSACTIONS = 335
	HiveParserKW_TRANSFORM = 336
	HiveParserKW_TRIGGER = 337
	HiveParserKW_TRIM = 338
	HiveParserKW_TRUE = 339
	HiveParserKW_TRUNCATE = 340
	HiveParserKW_TYPE = 341
	HiveParserKW_UNARCHIVE = 342
	HiveParserKW_UNBOUNDED = 343
	HiveParserKW_UNDO = 344
	HiveParserKW_UNION = 345
	HiveParserKW_UNIONTYPE = 346
	HiveParserKW_UNIQUE = 347
	HiveParserKW_UNIQUEJOIN = 348
	HiveParserKW_UNKNOWN = 349
	HiveParserKW_UNLOCK = 350
	HiveParserKW_UNMANAGED = 351
	HiveParserKW_UNSET = 352
	HiveParserKW_UNSIGNED = 353
	HiveParserKW_UPDATE = 354
	HiveParserKW_URI = 355
	HiveParserKW_URL = 356
	HiveParserKW_USE = 357
	HiveParserKW_USER = 358
	HiveParserKW_USING = 359
	HiveParserKW_UTC = 360
	HiveParserKW_UTCTIMESTAMP = 361
	HiveParserKW_VALIDATE = 362
	HiveParserKW_VALUES = 363
	HiveParserKW_VALUE_TYPE = 364
	HiveParserKW_VARCHAR = 365
	HiveParserKW_VECTORIZATION = 366
	HiveParserKW_VIEW = 367
	HiveParserKW_VIEWS = 368
	HiveParserKW_WAIT = 369
	HiveParserKW_WEEK = 370
	HiveParserKW_WHEN = 371
	HiveParserKW_WHERE = 372
	HiveParserKW_WHILE = 373
	HiveParserKW_WINDOW = 374
	HiveParserKW_WITH = 375
	HiveParserKW_WITHIN = 376
	HiveParserKW_WORK = 377
	HiveParserKW_WORKLOAD = 378
	HiveParserKW_WRITE = 379
	HiveParserKW_YEAR = 380
	HiveParserKW_ZONE = 381
	HiveParserDOT = 382
	HiveParserCOLON = 383
	HiveParserCOMMA = 384
	HiveParserSEMICOLON = 385
	HiveParserLPAREN = 386
	HiveParserRPAREN = 387
	HiveParserLSQUARE = 388
	HiveParserRSQUARE = 389
	HiveParserLCURLY = 390
	HiveParserRCURLY = 391
	HiveParserEQUAL = 392
	HiveParserEQUAL_NS = 393
	HiveParserNOTEQUAL = 394
	HiveParserLESSTHANOREQUALTO = 395
	HiveParserLESSTHAN = 396
	HiveParserGREATERTHANOREQUALTO = 397
	HiveParserGREATERTHAN = 398
	HiveParserDIVIDE = 399
	HiveParserPLUS = 400
	HiveParserMINUS = 401
	HiveParserSTAR = 402
	HiveParserMOD = 403
	HiveParserDIV = 404
	HiveParserAMPERSAND = 405
	HiveParserTILDE = 406
	HiveParserBITWISEOR = 407
	HiveParserCONCATENATE = 408
	HiveParserBITWISEXOR = 409
	HiveParserQUESTION = 410
	HiveParserDOLLAR = 411
	HiveParserStringLiteral = 412
	HiveParserCharSetLiteral = 413
	HiveParserIntegralLiteral = 414
	HiveParserNumberLiteral = 415
	HiveParserByteLengthLiteral = 416
	HiveParserNumber = 417
	HiveParserIdentifier = 418
	HiveParserCharSetName = 419
	HiveParserWHITE_SPACE = 420
	HiveParserLINE_COMMENT = 421
	HiveParserQUERY_HINT = 422
	HiveParserSHOW_HINT = 423
	HiveParserHIDDEN_HINT = 424
)

// HiveParser rules.
const (
	HiveParserRULE_statement = 0
	HiveParserRULE_explainStatement = 1
	HiveParserRULE_explainOption = 2
	HiveParserRULE_vectorizationOnly = 3
	HiveParserRULE_vectorizatonDetail = 4
	HiveParserRULE_execStatement = 5
	HiveParserRULE_loadStatement = 6
	HiveParserRULE_replicationClause = 7
	HiveParserRULE_exportStatement = 8
	HiveParserRULE_importStatement = 9
	HiveParserRULE_replDumpStatement = 10
	HiveParserRULE_replDbPolicy = 11
	HiveParserRULE_replLoadStatement = 12
	HiveParserRULE_replConfigs = 13
	HiveParserRULE_replConfigsList = 14
	HiveParserRULE_replTableLevelPolicy = 15
	HiveParserRULE_replStatusStatement = 16
	HiveParserRULE_ddlStatement = 17
	HiveParserRULE_ifExists = 18
	HiveParserRULE_restrictOrCascade = 19
	HiveParserRULE_ifNotExists = 20
	HiveParserRULE_force = 21
	HiveParserRULE_rewriteEnabled = 22
	HiveParserRULE_rewriteDisabled = 23
	HiveParserRULE_storedAsDirs = 24
	HiveParserRULE_orReplace = 25
	HiveParserRULE_createDatabaseStatement = 26
	HiveParserRULE_dbLocation = 27
	HiveParserRULE_dbManagedLocation = 28
	HiveParserRULE_dbProperties = 29
	HiveParserRULE_dbPropertiesList = 30
	HiveParserRULE_dbConnectorName = 31
	HiveParserRULE_switchDatabaseStatement = 32
	HiveParserRULE_dropDatabaseStatement = 33
	HiveParserRULE_databaseComment = 34
	HiveParserRULE_truncateTableStatement = 35
	HiveParserRULE_dropTableStatement = 36
	HiveParserRULE_inputFileFormat = 37
	HiveParserRULE_tabTypeExpr = 38
	HiveParserRULE_partTypeExpr = 39
	HiveParserRULE_tabPartColTypeExpr = 40
	HiveParserRULE_descStatement = 41
	HiveParserRULE_analyzeStatement = 42
	HiveParserRULE_from_in = 43
	HiveParserRULE_db_schema = 44
	HiveParserRULE_showStatement = 45
	HiveParserRULE_showTablesFilterExpr = 46
	HiveParserRULE_lockStatement = 47
	HiveParserRULE_lockDatabase = 48
	HiveParserRULE_lockMode = 49
	HiveParserRULE_unlockStatement = 50
	HiveParserRULE_unlockDatabase = 51
	HiveParserRULE_createRoleStatement = 52
	HiveParserRULE_dropRoleStatement = 53
	HiveParserRULE_grantPrivileges = 54
	HiveParserRULE_revokePrivileges = 55
	HiveParserRULE_grantRole = 56
	HiveParserRULE_revokeRole = 57
	HiveParserRULE_showRoleGrants = 58
	HiveParserRULE_showRoles = 59
	HiveParserRULE_showCurrentRole = 60
	HiveParserRULE_setRole = 61
	HiveParserRULE_showGrants = 62
	HiveParserRULE_showRolePrincipals = 63
	HiveParserRULE_privilegeIncludeColObject = 64
	HiveParserRULE_privilegeObject = 65
	HiveParserRULE_privObject = 66
	HiveParserRULE_privObjectCols = 67
	HiveParserRULE_privilegeList = 68
	HiveParserRULE_privlegeDef = 69
	HiveParserRULE_privilegeType = 70
	HiveParserRULE_principalSpecification = 71
	HiveParserRULE_principalName = 72
	HiveParserRULE_withGrantOption = 73
	HiveParserRULE_grantOptionFor = 74
	HiveParserRULE_adminOptionFor = 75
	HiveParserRULE_withAdminOption = 76
	HiveParserRULE_metastoreCheck = 77
	HiveParserRULE_resourceList = 78
	HiveParserRULE_resource = 79
	HiveParserRULE_resourceType = 80
	HiveParserRULE_createFunctionStatement = 81
	HiveParserRULE_dropFunctionStatement = 82
	HiveParserRULE_reloadFunctionsStatement = 83
	HiveParserRULE_createMacroStatement = 84
	HiveParserRULE_dropMacroStatement = 85
	HiveParserRULE_createViewStatement = 86
	HiveParserRULE_viewPartition = 87
	HiveParserRULE_viewOrganization = 88
	HiveParserRULE_viewClusterSpec = 89
	HiveParserRULE_viewComplexSpec = 90
	HiveParserRULE_viewDistSpec = 91
	HiveParserRULE_viewSortSpec = 92
	HiveParserRULE_dropViewStatement = 93
	HiveParserRULE_createMaterializedViewStatement = 94
	HiveParserRULE_dropMaterializedViewStatement = 95
	HiveParserRULE_createScheduledQueryStatement = 96
	HiveParserRULE_dropScheduledQueryStatement = 97
	HiveParserRULE_alterScheduledQueryStatement = 98
	HiveParserRULE_alterScheduledQueryChange = 99
	HiveParserRULE_scheduleSpec = 100
	HiveParserRULE_executedAsSpec = 101
	HiveParserRULE_definedAsSpec = 102
	HiveParserRULE_showFunctionIdentifier = 103
	HiveParserRULE_showStmtIdentifier = 104
	HiveParserRULE_tableComment = 105
	HiveParserRULE_createTablePartitionSpec = 106
	HiveParserRULE_createTablePartitionColumnTypeSpec = 107
	HiveParserRULE_createTablePartitionColumnSpec = 108
	HiveParserRULE_partitionTransformSpec = 109
	HiveParserRULE_columnNameTransformConstraint = 110
	HiveParserRULE_partitionTransformType = 111
	HiveParserRULE_tableBuckets = 112
	HiveParserRULE_tableImplBuckets = 113
	HiveParserRULE_tableSkewed = 114
	HiveParserRULE_rowFormat = 115
	HiveParserRULE_recordReader = 116
	HiveParserRULE_recordWriter = 117
	HiveParserRULE_rowFormatSerde = 118
	HiveParserRULE_rowFormatDelimited = 119
	HiveParserRULE_tableRowFormat = 120
	HiveParserRULE_tablePropertiesPrefixed = 121
	HiveParserRULE_tableProperties = 122
	HiveParserRULE_tablePropertiesList = 123
	HiveParserRULE_keyValueProperty = 124
	HiveParserRULE_keyProperty = 125
	HiveParserRULE_tableRowFormatFieldIdentifier = 126
	HiveParserRULE_tableRowFormatCollItemsIdentifier = 127
	HiveParserRULE_tableRowFormatMapKeysIdentifier = 128
	HiveParserRULE_tableRowFormatLinesIdentifier = 129
	HiveParserRULE_tableRowNullFormat = 130
	HiveParserRULE_tableFileFormat = 131
	HiveParserRULE_tableLocation = 132
	HiveParserRULE_columnNameTypeList = 133
	HiveParserRULE_columnNameTypeOrConstraintList = 134
	HiveParserRULE_columnNameColonTypeList = 135
	HiveParserRULE_columnNameList = 136
	HiveParserRULE_columnName = 137
	HiveParserRULE_extColumnName = 138
	HiveParserRULE_columnNameOrderList = 139
	HiveParserRULE_columnParenthesesList = 140
	HiveParserRULE_enableValidateSpecification = 141
	HiveParserRULE_enableSpecification = 142
	HiveParserRULE_validateSpecification = 143
	HiveParserRULE_enforcedSpecification = 144
	HiveParserRULE_relySpecification = 145
	HiveParserRULE_createConstraint = 146
	HiveParserRULE_alterConstraintWithName = 147
	HiveParserRULE_tableLevelConstraint = 148
	HiveParserRULE_pkUkConstraint = 149
	HiveParserRULE_checkConstraint = 150
	HiveParserRULE_createForeignKey = 151
	HiveParserRULE_alterForeignKeyWithName = 152
	HiveParserRULE_skewedValueElement = 153
	HiveParserRULE_skewedColumnValuePairList = 154
	HiveParserRULE_skewedColumnValuePair = 155
	HiveParserRULE_skewedColumnValues = 156
	HiveParserRULE_skewedColumnValue = 157
	HiveParserRULE_skewedValueLocationElement = 158
	HiveParserRULE_orderSpecification = 159
	HiveParserRULE_nullOrdering = 160
	HiveParserRULE_columnNameOrder = 161
	HiveParserRULE_columnNameCommentList = 162
	HiveParserRULE_columnNameComment = 163
	HiveParserRULE_orderSpecificationRewrite = 164
	HiveParserRULE_columnRefOrder = 165
	HiveParserRULE_columnNameType = 166
	HiveParserRULE_columnNameTypeOrConstraint = 167
	HiveParserRULE_tableConstraint = 168
	HiveParserRULE_columnNameTypeConstraint = 169
	HiveParserRULE_columnConstraint = 170
	HiveParserRULE_foreignKeyConstraint = 171
	HiveParserRULE_colConstraint = 172
	HiveParserRULE_alterColumnConstraint = 173
	HiveParserRULE_alterForeignKeyConstraint = 174
	HiveParserRULE_alterColConstraint = 175
	HiveParserRULE_columnConstraintType = 176
	HiveParserRULE_defaultVal = 177
	HiveParserRULE_tableConstraintType = 178
	HiveParserRULE_constraintOptsCreate = 179
	HiveParserRULE_constraintOptsAlter = 180
	HiveParserRULE_columnNameColonType = 181
	HiveParserRULE_colType = 182
	HiveParserRULE_colTypeList = 183
	HiveParserRULE_type = 184
	HiveParserRULE_primitiveType = 185
	HiveParserRULE_listType = 186
	HiveParserRULE_structType = 187
	HiveParserRULE_mapType = 188
	HiveParserRULE_unionType = 189
	HiveParserRULE_setOperator = 190
	HiveParserRULE_queryStatementExpression = 191
	HiveParserRULE_queryStatementExpressionBody = 192
	HiveParserRULE_withClause = 193
	HiveParserRULE_cteStatement = 194
	HiveParserRULE_fromStatement = 195
	HiveParserRULE_singleFromStatement = 196
	HiveParserRULE_regularBody = 197
	HiveParserRULE_atomSelectStatement = 198
	HiveParserRULE_selectStatement = 199
	HiveParserRULE_setOpSelectStatement = 200
	HiveParserRULE_selectStatementWithCTE = 201
	HiveParserRULE_body = 202
	HiveParserRULE_insertClause = 203
	HiveParserRULE_destination = 204
	HiveParserRULE_limitClause = 205
	HiveParserRULE_deleteStatement = 206
	HiveParserRULE_columnAssignmentClause = 207
	HiveParserRULE_precedencePlusExpressionOrDefault = 208
	HiveParserRULE_setColumnsClause = 209
	HiveParserRULE_updateStatement = 210
	HiveParserRULE_sqlTransactionStatement = 211
	HiveParserRULE_startTransactionStatement = 212
	HiveParserRULE_transactionMode = 213
	HiveParserRULE_transactionAccessMode = 214
	HiveParserRULE_isolationLevel = 215
	HiveParserRULE_levelOfIsolation = 216
	HiveParserRULE_commitStatement = 217
	HiveParserRULE_rollbackStatement = 218
	HiveParserRULE_setAutoCommitStatement = 219
	HiveParserRULE_abortTransactionStatement = 220
	HiveParserRULE_abortCompactionStatement = 221
	HiveParserRULE_mergeStatement = 222
	HiveParserRULE_whenClauses = 223
	HiveParserRULE_whenNotMatchedClause = 224
	HiveParserRULE_whenMatchedAndClause = 225
	HiveParserRULE_whenMatchedThenClause = 226
	HiveParserRULE_updateOrDelete = 227
	HiveParserRULE_killQueryStatement = 228
	HiveParserRULE_compactionId = 229
	HiveParserRULE_compactionPool = 230
	HiveParserRULE_compactionType = 231
	HiveParserRULE_compactionStatus = 232
	HiveParserRULE_alterStatement = 233
	HiveParserRULE_alterTableStatementSuffix = 234
	HiveParserRULE_alterTblPartitionStatementSuffix = 235
	HiveParserRULE_alterStatementPartitionKeyType = 236
	HiveParserRULE_alterViewStatementSuffix = 237
	HiveParserRULE_alterMaterializedViewStatementSuffix = 238
	HiveParserRULE_alterMaterializedViewSuffixRewrite = 239
	HiveParserRULE_alterMaterializedViewSuffixRebuild = 240
	HiveParserRULE_alterDatabaseStatementSuffix = 241
	HiveParserRULE_alterDatabaseSuffixProperties = 242
	HiveParserRULE_alterDatabaseSuffixSetOwner = 243
	HiveParserRULE_alterDatabaseSuffixSetLocation = 244
	HiveParserRULE_alterDatabaseSuffixSetManagedLocation = 245
	HiveParserRULE_alterStatementSuffixRename = 246
	HiveParserRULE_alterStatementSuffixAddCol = 247
	HiveParserRULE_alterStatementSuffixAddConstraint = 248
	HiveParserRULE_alterStatementSuffixUpdateColumns = 249
	HiveParserRULE_alterStatementSuffixDropConstraint = 250
	HiveParserRULE_alterStatementSuffixRenameCol = 251
	HiveParserRULE_alterStatementSuffixUpdateStatsCol = 252
	HiveParserRULE_alterStatementSuffixUpdateStats = 253
	HiveParserRULE_alterStatementChangeColPosition = 254
	HiveParserRULE_alterStatementSuffixAddPartitions = 255
	HiveParserRULE_alterStatementSuffixAddPartitionsElement = 256
	HiveParserRULE_alterStatementSuffixTouch = 257
	HiveParserRULE_alterStatementSuffixArchive = 258
	HiveParserRULE_alterStatementSuffixUnArchive = 259
	HiveParserRULE_partitionLocation = 260
	HiveParserRULE_alterStatementSuffixDropPartitions = 261
	HiveParserRULE_alterStatementSuffixProperties = 262
	HiveParserRULE_alterViewSuffixProperties = 263
	HiveParserRULE_alterStatementSuffixSerdeProperties = 264
	HiveParserRULE_tablePartitionPrefix = 265
	HiveParserRULE_alterStatementSuffixFileFormat = 266
	HiveParserRULE_alterStatementSuffixClusterbySortby = 267
	HiveParserRULE_alterTblPartitionStatementSuffixSkewedLocation = 268
	HiveParserRULE_skewedLocations = 269
	HiveParserRULE_skewedLocationsList = 270
	HiveParserRULE_skewedLocationMap = 271
	HiveParserRULE_alterStatementSuffixLocation = 272
	HiveParserRULE_alterStatementSuffixSkewedby = 273
	HiveParserRULE_alterStatementSuffixExchangePartition = 274
	HiveParserRULE_alterStatementSuffixRenamePart = 275
	HiveParserRULE_alterStatementSuffixStatsPart = 276
	HiveParserRULE_alterStatementSuffixMergeFiles = 277
	HiveParserRULE_alterStatementSuffixBucketNum = 278
	HiveParserRULE_blocking = 279
	HiveParserRULE_compactPool = 280
	HiveParserRULE_alterStatementSuffixCompact = 281
	HiveParserRULE_alterStatementSuffixSetOwner = 282
	HiveParserRULE_alterStatementSuffixSetPartSpec = 283
	HiveParserRULE_alterStatementSuffixExecute = 284
	HiveParserRULE_fileFormat = 285
	HiveParserRULE_alterDataConnectorStatementSuffix = 286
	HiveParserRULE_alterDataConnectorSuffixProperties = 287
	HiveParserRULE_alterDataConnectorSuffixSetOwner = 288
	HiveParserRULE_alterDataConnectorSuffixSetUrl = 289
	HiveParserRULE_likeTableOrFile = 290
	HiveParserRULE_createTableStatement = 291
	HiveParserRULE_createDataConnectorStatement = 292
	HiveParserRULE_dataConnectorComment = 293
	HiveParserRULE_dataConnectorUrl = 294
	HiveParserRULE_dataConnectorType = 295
	HiveParserRULE_dcProperties = 296
	HiveParserRULE_dropDataConnectorStatement = 297
	HiveParserRULE_tableAllColumns = 298
	HiveParserRULE_tableOrColumn = 299
	HiveParserRULE_defaultValue = 300
	HiveParserRULE_expressionList = 301
	HiveParserRULE_aliasList = 302
	HiveParserRULE_fromClause = 303
	HiveParserRULE_fromSource = 304
	HiveParserRULE_atomjoinSource = 305
	HiveParserRULE_joinSource = 306
	HiveParserRULE_joinSourcePart = 307
	HiveParserRULE_uniqueJoinSource = 308
	HiveParserRULE_uniqueJoinExpr = 309
	HiveParserRULE_uniqueJoinToken = 310
	HiveParserRULE_joinToken = 311
	HiveParserRULE_lateralView = 312
	HiveParserRULE_tableAlias = 313
	HiveParserRULE_tableBucketSample = 314
	HiveParserRULE_splitSample = 315
	HiveParserRULE_tableSample = 316
	HiveParserRULE_tableSource = 317
	HiveParserRULE_asOfClause = 318
	HiveParserRULE_uniqueJoinTableSource = 319
	HiveParserRULE_tableName = 320
	HiveParserRULE_viewName = 321
	HiveParserRULE_subQuerySource = 322
	HiveParserRULE_partitioningSpec = 323
	HiveParserRULE_partitionTableFunctionSource = 324
	HiveParserRULE_partitionedTableFunction = 325
	HiveParserRULE_whereClause = 326
	HiveParserRULE_searchCondition = 327
	HiveParserRULE_valuesSource = 328
	HiveParserRULE_valuesClause = 329
	HiveParserRULE_valuesTableConstructor = 330
	HiveParserRULE_valueRowConstructor = 331
	HiveParserRULE_firstValueRowConstructor = 332
	HiveParserRULE_virtualTableSource = 333
	HiveParserRULE_selectClause = 334
	HiveParserRULE_all_distinct = 335
	HiveParserRULE_selectList = 336
	HiveParserRULE_selectTrfmClause = 337
	HiveParserRULE_selectItem = 338
	HiveParserRULE_trfmClause = 339
	HiveParserRULE_selectExpression = 340
	HiveParserRULE_selectExpressionList = 341
	HiveParserRULE_window_clause = 342
	HiveParserRULE_window_defn = 343
	HiveParserRULE_window_specification = 344
	HiveParserRULE_window_frame = 345
	HiveParserRULE_window_range_expression = 346
	HiveParserRULE_window_value_expression = 347
	HiveParserRULE_window_frame_start_boundary = 348
	HiveParserRULE_window_frame_boundary = 349
	HiveParserRULE_groupByClause = 350
	HiveParserRULE_groupby_expression = 351
	HiveParserRULE_groupByEmpty = 352
	HiveParserRULE_rollupStandard = 353
	HiveParserRULE_rollupOldSyntax = 354
	HiveParserRULE_groupingSetExpression = 355
	HiveParserRULE_groupingSetExpressionMultiple = 356
	HiveParserRULE_groupingExpressionSingle = 357
	HiveParserRULE_havingClause = 358
	HiveParserRULE_qualifyClause = 359
	HiveParserRULE_havingCondition = 360
	HiveParserRULE_expressionsInParenthesis = 361
	HiveParserRULE_expressionsNotInParenthesis = 362
	HiveParserRULE_expressionPart = 363
	HiveParserRULE_expressionOrDefault = 364
	HiveParserRULE_firstExpressionsWithAlias = 365
	HiveParserRULE_expressionWithAlias = 366
	HiveParserRULE_expressions = 367
	HiveParserRULE_columnRefOrderInParenthesis = 368
	HiveParserRULE_columnRefOrderNotInParenthesis = 369
	HiveParserRULE_orderByClause = 370
	HiveParserRULE_clusterByClause = 371
	HiveParserRULE_partitionByClause = 372
	HiveParserRULE_distributeByClause = 373
	HiveParserRULE_sortByClause = 374
	HiveParserRULE_trimFunction = 375
	HiveParserRULE_function_ = 376
	HiveParserRULE_null_treatment = 377
	HiveParserRULE_functionName = 378
	HiveParserRULE_castExpression = 379
	HiveParserRULE_caseExpression = 380
	HiveParserRULE_whenExpression = 381
	HiveParserRULE_floorExpression = 382
	HiveParserRULE_floorDateQualifiers = 383
	HiveParserRULE_extractExpression = 384
	HiveParserRULE_timeQualifiers = 385
	HiveParserRULE_constant = 386
	HiveParserRULE_prepareStmtParam = 387
	HiveParserRULE_parameterIdx = 388
	HiveParserRULE_stringLiteralSequence = 389
	HiveParserRULE_charSetStringLiteral = 390
	HiveParserRULE_dateLiteral = 391
	HiveParserRULE_timestampLiteral = 392
	HiveParserRULE_timestampLocalTZLiteral = 393
	HiveParserRULE_intervalValue = 394
	HiveParserRULE_intervalLiteral = 395
	HiveParserRULE_intervalExpression = 396
	HiveParserRULE_intervalQualifiers = 397
	HiveParserRULE_expression = 398
	HiveParserRULE_atomExpression = 399
	HiveParserRULE_precedenceFieldExpression = 400
	HiveParserRULE_precedenceUnaryOperator = 401
	HiveParserRULE_precedenceUnaryPrefixExpression = 402
	HiveParserRULE_precedenceBitwiseXorOperator = 403
	HiveParserRULE_precedenceBitwiseXorExpression = 404
	HiveParserRULE_precedenceStarOperator = 405
	HiveParserRULE_precedenceStarExpression = 406
	HiveParserRULE_precedencePlusOperator = 407
	HiveParserRULE_precedencePlusExpression = 408
	HiveParserRULE_precedenceConcatenateOperator = 409
	HiveParserRULE_precedenceConcatenateExpression = 410
	HiveParserRULE_precedenceAmpersandOperator = 411
	HiveParserRULE_precedenceAmpersandExpression = 412
	HiveParserRULE_precedenceBitwiseOrOperator = 413
	HiveParserRULE_precedenceBitwiseOrExpression = 414
	HiveParserRULE_precedenceRegexpOperator = 415
	HiveParserRULE_precedenceSimilarOperator = 416
	HiveParserRULE_subQueryExpression = 417
	HiveParserRULE_precedenceSimilarExpression = 418
	HiveParserRULE_precedenceSimilarExpressionMain = 419
	HiveParserRULE_precedenceSimilarExpressionPart = 420
	HiveParserRULE_precedenceSimilarExpressionAtom = 421
	HiveParserRULE_precedenceSimilarExpressionQuantifierPredicate = 422
	HiveParserRULE_quantifierType = 423
	HiveParserRULE_precedenceSimilarExpressionIn = 424
	HiveParserRULE_precedenceSimilarExpressionPartNot = 425
	HiveParserRULE_precedenceDistinctOperator = 426
	HiveParserRULE_precedenceEqualOperator = 427
	HiveParserRULE_precedenceEqualExpression = 428
	HiveParserRULE_isCondition = 429
	HiveParserRULE_precedenceUnarySuffixExpression = 430
	HiveParserRULE_precedenceNotOperator = 431
	HiveParserRULE_precedenceNotExpression = 432
	HiveParserRULE_precedenceAndOperator = 433
	HiveParserRULE_precedenceAndExpression = 434
	HiveParserRULE_precedenceOrOperator = 435
	HiveParserRULE_precedenceOrExpression = 436
	HiveParserRULE_booleanValue = 437
	HiveParserRULE_booleanValueTok = 438
	HiveParserRULE_tableOrPartition = 439
	HiveParserRULE_partitionSpec = 440
	HiveParserRULE_partitionVal = 441
	HiveParserRULE_partitionSelectorSpec = 442
	HiveParserRULE_partitionSelectorVal = 443
	HiveParserRULE_partitionSelectorOperator = 444
	HiveParserRULE_subQuerySelectorOperator = 445
	HiveParserRULE_sysFuncNames = 446
	HiveParserRULE_descFuncNames = 447
	HiveParserRULE_id_ = 448
	HiveParserRULE_functionIdentifier = 449
	HiveParserRULE_principalIdentifier = 450
	HiveParserRULE_nonReserved = 451
	HiveParserRULE_sql11ReservedKeywordsUsedAsFunctionName = 452
	HiveParserRULE_hint = 453
	HiveParserRULE_hintList = 454
	HiveParserRULE_hintItem = 455
	HiveParserRULE_hintName = 456
	HiveParserRULE_hintArgs = 457
	HiveParserRULE_hintArgName = 458
	HiveParserRULE_prepareStatement = 459
	HiveParserRULE_executeStatement = 460
	HiveParserRULE_executeParamList = 461
	HiveParserRULE_resourcePlanDdlStatements = 462
	HiveParserRULE_rpAssign = 463
	HiveParserRULE_rpAssignList = 464
	HiveParserRULE_rpUnassign = 465
	HiveParserRULE_rpUnassignList = 466
	HiveParserRULE_createResourcePlanStatement = 467
	HiveParserRULE_withReplace = 468
	HiveParserRULE_activate = 469
	HiveParserRULE_enable = 470
	HiveParserRULE_disable = 471
	HiveParserRULE_unmanaged = 472
	HiveParserRULE_alterResourcePlanStatement = 473
	HiveParserRULE_globalWmStatement = 474
	HiveParserRULE_replaceResourcePlanStatement = 475
	HiveParserRULE_dropResourcePlanStatement = 476
	HiveParserRULE_poolPath = 477
	HiveParserRULE_triggerExpression = 478
	HiveParserRULE_triggerExpressionStandalone = 479
	HiveParserRULE_triggerOrExpression = 480
	HiveParserRULE_triggerAndExpression = 481
	HiveParserRULE_triggerAtomExpression = 482
	HiveParserRULE_triggerLiteral = 483
	HiveParserRULE_comparisionOperator = 484
	HiveParserRULE_triggerActionExpression = 485
	HiveParserRULE_triggerActionExpressionStandalone = 486
	HiveParserRULE_createTriggerStatement = 487
	HiveParserRULE_alterTriggerStatement = 488
	HiveParserRULE_dropTriggerStatement = 489
	HiveParserRULE_poolAssign = 490
	HiveParserRULE_poolAssignList = 491
	HiveParserRULE_createPoolStatement = 492
	HiveParserRULE_alterPoolStatement = 493
	HiveParserRULE_dropPoolStatement = 494
	HiveParserRULE_createMappingStatement = 495
	HiveParserRULE_alterMappingStatement = 496
	HiveParserRULE_dropMappingStatement = 497
)

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EOF() antlr.TerminalNode
	ExplainStatement() IExplainStatementContext
	ExecStatement() IExecStatementContext

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_statement
	return p
}

func InitEmptyStatementContext(p *StatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_statement
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) EOF() antlr.TerminalNode {
	return s.GetToken(HiveParserEOF, 0)
}

func (s *StatementContext) ExplainStatement() IExplainStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplainStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplainStatementContext)
}

func (s *StatementContext) ExecStatement() IExecStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExecStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExecStatementContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitStatement(s)
	}
}

func (s *StatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, HiveParserRULE_statement)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(998)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserKW_EXPLAIN:
		{
			p.SetState(996)
			p.ExplainStatement()
		}


	case HiveParserKW_ABORT, HiveParserKW_ALTER, HiveParserKW_ANALYZE, HiveParserKW_COMMIT, HiveParserKW_CREATE, HiveParserKW_DELETE, HiveParserKW_DESC, HiveParserKW_DESCRIBE, HiveParserKW_DISABLE, HiveParserKW_DROP, HiveParserKW_ENABLE, HiveParserKW_EXECUTE, HiveParserKW_EXPORT, HiveParserKW_FROM, HiveParserKW_GRANT, HiveParserKW_IMPORT, HiveParserKW_INSERT, HiveParserKW_KILL, HiveParserKW_LOAD, HiveParserKW_LOCK, HiveParserKW_MAP, HiveParserKW_MERGE, HiveParserKW_MSCK, HiveParserKW_PREPARE, HiveParserKW_REDUCE, HiveParserKW_RELOAD, HiveParserKW_REPL, HiveParserKW_REPLACE, HiveParserKW_REVOKE, HiveParserKW_ROLLBACK, HiveParserKW_SELECT, HiveParserKW_SET, HiveParserKW_SHOW, HiveParserKW_START, HiveParserKW_TRUNCATE, HiveParserKW_UNLOCK, HiveParserKW_UPDATE, HiveParserKW_USE, HiveParserKW_VALUES, HiveParserKW_WITH, HiveParserLPAREN:
		{
			p.SetState(997)
			p.ExecStatement()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(1000)
		p.Match(HiveParserEOF)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExplainStatementContext is an interface to support dynamic dispatch.
type IExplainStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_EXPLAIN() antlr.TerminalNode
	ExecStatement() IExecStatementContext
	KW_REWRITE() antlr.TerminalNode
	QueryStatementExpression() IQueryStatementExpressionContext
	AllExplainOption() []IExplainOptionContext
	ExplainOption(i int) IExplainOptionContext

	// IsExplainStatementContext differentiates from other interfaces.
	IsExplainStatementContext()
}

type ExplainStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExplainStatementContext() *ExplainStatementContext {
	var p = new(ExplainStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_explainStatement
	return p
}

func InitEmptyExplainStatementContext(p *ExplainStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_explainStatement
}

func (*ExplainStatementContext) IsExplainStatementContext() {}

func NewExplainStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExplainStatementContext {
	var p = new(ExplainStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_explainStatement

	return p
}

func (s *ExplainStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExplainStatementContext) KW_EXPLAIN() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_EXPLAIN, 0)
}

func (s *ExplainStatementContext) ExecStatement() IExecStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExecStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExecStatementContext)
}

func (s *ExplainStatementContext) KW_REWRITE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_REWRITE, 0)
}

func (s *ExplainStatementContext) QueryStatementExpression() IQueryStatementExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryStatementExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryStatementExpressionContext)
}

func (s *ExplainStatementContext) AllExplainOption() []IExplainOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExplainOptionContext); ok {
			len++
		}
	}

	tst := make([]IExplainOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExplainOptionContext); ok {
			tst[i] = t.(IExplainOptionContext)
			i++
		}
	}

	return tst
}

func (s *ExplainStatementContext) ExplainOption(i int) IExplainOptionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplainOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplainOptionContext)
}

func (s *ExplainStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplainStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ExplainStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterExplainStatement(s)
	}
}

func (s *ExplainStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitExplainStatement(s)
	}
}

func (s *ExplainStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitExplainStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ExplainStatement() (localctx IExplainStatementContext) {
	localctx = NewExplainStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, HiveParserRULE_explainStatement)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1002)
		p.Match(HiveParserKW_EXPLAIN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1012)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserKW_ABORT, HiveParserKW_ALTER, HiveParserKW_ANALYZE, HiveParserKW_AST, HiveParserKW_AUTHORIZATION, HiveParserKW_CBO, HiveParserKW_COMMIT, HiveParserKW_CREATE, HiveParserKW_DDL, HiveParserKW_DEBUG, HiveParserKW_DELETE, HiveParserKW_DEPENDENCY, HiveParserKW_DESC, HiveParserKW_DESCRIBE, HiveParserKW_DISABLE, HiveParserKW_DROP, HiveParserKW_ENABLE, HiveParserKW_EXECUTE, HiveParserKW_EXPORT, HiveParserKW_EXTENDED, HiveParserKW_FORMATTED, HiveParserKW_FROM, HiveParserKW_GRANT, HiveParserKW_IMPORT, HiveParserKW_INSERT, HiveParserKW_KILL, HiveParserKW_LOAD, HiveParserKW_LOCK, HiveParserKW_LOCKS, HiveParserKW_LOGICAL, HiveParserKW_MAP, HiveParserKW_MERGE, HiveParserKW_MSCK, HiveParserKW_PREPARE, HiveParserKW_REDUCE, HiveParserKW_RELOAD, HiveParserKW_REOPTIMIZATION, HiveParserKW_REPL, HiveParserKW_REPLACE, HiveParserKW_REVOKE, HiveParserKW_ROLLBACK, HiveParserKW_SELECT, HiveParserKW_SET, HiveParserKW_SHOW, HiveParserKW_START, HiveParserKW_TRUNCATE, HiveParserKW_UNLOCK, HiveParserKW_UPDATE, HiveParserKW_USE, HiveParserKW_VALUES, HiveParserKW_VECTORIZATION, HiveParserKW_WITH, HiveParserLPAREN:
		p.SetState(1006)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1003)
					p.ExplainOption()
				}


			}
			p.SetState(1008)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		{
			p.SetState(1009)
			p.ExecStatement()
		}


	case HiveParserKW_REWRITE:
		{
			p.SetState(1010)
			p.Match(HiveParserKW_REWRITE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1011)
			p.QueryStatementExpression()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExplainOptionContext is an interface to support dynamic dispatch.
type IExplainOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_EXTENDED() antlr.TerminalNode
	KW_FORMATTED() antlr.TerminalNode
	KW_DEPENDENCY() antlr.TerminalNode
	KW_CBO() antlr.TerminalNode
	KW_COST() antlr.TerminalNode
	KW_JOINCOST() antlr.TerminalNode
	KW_LOGICAL() antlr.TerminalNode
	KW_AUTHORIZATION() antlr.TerminalNode
	KW_ANALYZE() antlr.TerminalNode
	KW_REOPTIMIZATION() antlr.TerminalNode
	KW_LOCKS() antlr.TerminalNode
	KW_AST() antlr.TerminalNode
	KW_VECTORIZATION() antlr.TerminalNode
	VectorizationOnly() IVectorizationOnlyContext
	VectorizatonDetail() IVectorizatonDetailContext
	KW_DEBUG() antlr.TerminalNode
	KW_DDL() antlr.TerminalNode

	// IsExplainOptionContext differentiates from other interfaces.
	IsExplainOptionContext()
}

type ExplainOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExplainOptionContext() *ExplainOptionContext {
	var p = new(ExplainOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_explainOption
	return p
}

func InitEmptyExplainOptionContext(p *ExplainOptionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_explainOption
}

func (*ExplainOptionContext) IsExplainOptionContext() {}

func NewExplainOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExplainOptionContext {
	var p = new(ExplainOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_explainOption

	return p
}

func (s *ExplainOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExplainOptionContext) KW_EXTENDED() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_EXTENDED, 0)
}

func (s *ExplainOptionContext) KW_FORMATTED() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_FORMATTED, 0)
}

func (s *ExplainOptionContext) KW_DEPENDENCY() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DEPENDENCY, 0)
}

func (s *ExplainOptionContext) KW_CBO() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_CBO, 0)
}

func (s *ExplainOptionContext) KW_COST() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_COST, 0)
}

func (s *ExplainOptionContext) KW_JOINCOST() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_JOINCOST, 0)
}

func (s *ExplainOptionContext) KW_LOGICAL() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_LOGICAL, 0)
}

func (s *ExplainOptionContext) KW_AUTHORIZATION() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_AUTHORIZATION, 0)
}

func (s *ExplainOptionContext) KW_ANALYZE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ANALYZE, 0)
}

func (s *ExplainOptionContext) KW_REOPTIMIZATION() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_REOPTIMIZATION, 0)
}

func (s *ExplainOptionContext) KW_LOCKS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_LOCKS, 0)
}

func (s *ExplainOptionContext) KW_AST() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_AST, 0)
}

func (s *ExplainOptionContext) KW_VECTORIZATION() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_VECTORIZATION, 0)
}

func (s *ExplainOptionContext) VectorizationOnly() IVectorizationOnlyContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVectorizationOnlyContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVectorizationOnlyContext)
}

func (s *ExplainOptionContext) VectorizatonDetail() IVectorizatonDetailContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVectorizatonDetailContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVectorizatonDetailContext)
}

func (s *ExplainOptionContext) KW_DEBUG() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DEBUG, 0)
}

func (s *ExplainOptionContext) KW_DDL() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DDL, 0)
}

func (s *ExplainOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplainOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ExplainOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterExplainOption(s)
	}
}

func (s *ExplainOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitExplainOption(s)
	}
}

func (s *ExplainOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitExplainOption(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ExplainOption() (localctx IExplainOptionContext) {
	localctx = NewExplainOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, HiveParserRULE_explainOption)
	var _la int

	p.SetState(1036)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserKW_EXTENDED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1014)
			p.Match(HiveParserKW_EXTENDED)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HiveParserKW_FORMATTED:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1015)
			p.Match(HiveParserKW_FORMATTED)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HiveParserKW_DEPENDENCY:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1016)
			p.Match(HiveParserKW_DEPENDENCY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HiveParserKW_CBO:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1017)
			p.Match(HiveParserKW_CBO)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1019)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_COST || _la == HiveParserKW_JOINCOST {
			{
				p.SetState(1018)
				_la = p.GetTokenStream().LA(1)

				if !(_la == HiveParserKW_COST || _la == HiveParserKW_JOINCOST) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}


	case HiveParserKW_LOGICAL:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1021)
			p.Match(HiveParserKW_LOGICAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HiveParserKW_AUTHORIZATION:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1022)
			p.Match(HiveParserKW_AUTHORIZATION)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HiveParserKW_ANALYZE:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1023)
			p.Match(HiveParserKW_ANALYZE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HiveParserKW_REOPTIMIZATION:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1024)
			p.Match(HiveParserKW_REOPTIMIZATION)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HiveParserKW_LOCKS:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1025)
			p.Match(HiveParserKW_LOCKS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HiveParserKW_AST:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1026)
			p.Match(HiveParserKW_AST)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HiveParserKW_VECTORIZATION:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1027)
			p.Match(HiveParserKW_VECTORIZATION)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1029)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_ONLY {
			{
				p.SetState(1028)
				p.VectorizationOnly()
			}

		}
		p.SetState(1032)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_DETAIL || _la == HiveParserKW_EXPRESSION || _la == HiveParserKW_OPERATOR || _la == HiveParserKW_SUMMARY {
			{
				p.SetState(1031)
				p.VectorizatonDetail()
			}

		}


	case HiveParserKW_DEBUG:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1034)
			p.Match(HiveParserKW_DEBUG)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HiveParserKW_DDL:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1035)
			p.Match(HiveParserKW_DDL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IVectorizationOnlyContext is an interface to support dynamic dispatch.
type IVectorizationOnlyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_ONLY() antlr.TerminalNode

	// IsVectorizationOnlyContext differentiates from other interfaces.
	IsVectorizationOnlyContext()
}

type VectorizationOnlyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVectorizationOnlyContext() *VectorizationOnlyContext {
	var p = new(VectorizationOnlyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_vectorizationOnly
	return p
}

func InitEmptyVectorizationOnlyContext(p *VectorizationOnlyContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_vectorizationOnly
}

func (*VectorizationOnlyContext) IsVectorizationOnlyContext() {}

func NewVectorizationOnlyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VectorizationOnlyContext {
	var p = new(VectorizationOnlyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_vectorizationOnly

	return p
}

func (s *VectorizationOnlyContext) GetParser() antlr.Parser { return s.parser }

func (s *VectorizationOnlyContext) KW_ONLY() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ONLY, 0)
}

func (s *VectorizationOnlyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VectorizationOnlyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *VectorizationOnlyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterVectorizationOnly(s)
	}
}

func (s *VectorizationOnlyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitVectorizationOnly(s)
	}
}

func (s *VectorizationOnlyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitVectorizationOnly(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) VectorizationOnly() (localctx IVectorizationOnlyContext) {
	localctx = NewVectorizationOnlyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, HiveParserRULE_vectorizationOnly)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1038)
		p.Match(HiveParserKW_ONLY)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IVectorizatonDetailContext is an interface to support dynamic dispatch.
type IVectorizatonDetailContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_SUMMARY() antlr.TerminalNode
	KW_OPERATOR() antlr.TerminalNode
	KW_EXPRESSION() antlr.TerminalNode
	KW_DETAIL() antlr.TerminalNode

	// IsVectorizatonDetailContext differentiates from other interfaces.
	IsVectorizatonDetailContext()
}

type VectorizatonDetailContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVectorizatonDetailContext() *VectorizatonDetailContext {
	var p = new(VectorizatonDetailContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_vectorizatonDetail
	return p
}

func InitEmptyVectorizatonDetailContext(p *VectorizatonDetailContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_vectorizatonDetail
}

func (*VectorizatonDetailContext) IsVectorizatonDetailContext() {}

func NewVectorizatonDetailContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VectorizatonDetailContext {
	var p = new(VectorizatonDetailContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_vectorizatonDetail

	return p
}

func (s *VectorizatonDetailContext) GetParser() antlr.Parser { return s.parser }

func (s *VectorizatonDetailContext) KW_SUMMARY() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SUMMARY, 0)
}

func (s *VectorizatonDetailContext) KW_OPERATOR() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_OPERATOR, 0)
}

func (s *VectorizatonDetailContext) KW_EXPRESSION() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_EXPRESSION, 0)
}

func (s *VectorizatonDetailContext) KW_DETAIL() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DETAIL, 0)
}

func (s *VectorizatonDetailContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VectorizatonDetailContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *VectorizatonDetailContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterVectorizatonDetail(s)
	}
}

func (s *VectorizatonDetailContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitVectorizatonDetail(s)
	}
}

func (s *VectorizatonDetailContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitVectorizatonDetail(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) VectorizatonDetail() (localctx IVectorizatonDetailContext) {
	localctx = NewVectorizatonDetailContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, HiveParserRULE_vectorizatonDetail)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1040)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HiveParserKW_DETAIL || _la == HiveParserKW_EXPRESSION || _la == HiveParserKW_OPERATOR || _la == HiveParserKW_SUMMARY) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExecStatementContext is an interface to support dynamic dispatch.
type IExecStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QueryStatementExpression() IQueryStatementExpressionContext
	LoadStatement() ILoadStatementContext
	ExportStatement() IExportStatementContext
	ImportStatement() IImportStatementContext
	ReplDumpStatement() IReplDumpStatementContext
	ReplLoadStatement() IReplLoadStatementContext
	ReplStatusStatement() IReplStatusStatementContext
	DdlStatement() IDdlStatementContext
	DeleteStatement() IDeleteStatementContext
	UpdateStatement() IUpdateStatementContext
	SqlTransactionStatement() ISqlTransactionStatementContext
	MergeStatement() IMergeStatementContext
	PrepareStatement() IPrepareStatementContext
	ExecuteStatement() IExecuteStatementContext

	// IsExecStatementContext differentiates from other interfaces.
	IsExecStatementContext()
}

type ExecStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExecStatementContext() *ExecStatementContext {
	var p = new(ExecStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_execStatement
	return p
}

func InitEmptyExecStatementContext(p *ExecStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_execStatement
}

func (*ExecStatementContext) IsExecStatementContext() {}

func NewExecStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExecStatementContext {
	var p = new(ExecStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_execStatement

	return p
}

func (s *ExecStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExecStatementContext) QueryStatementExpression() IQueryStatementExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryStatementExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryStatementExpressionContext)
}

func (s *ExecStatementContext) LoadStatement() ILoadStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoadStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoadStatementContext)
}

func (s *ExecStatementContext) ExportStatement() IExportStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExportStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExportStatementContext)
}

func (s *ExecStatementContext) ImportStatement() IImportStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportStatementContext)
}

func (s *ExecStatementContext) ReplDumpStatement() IReplDumpStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplDumpStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplDumpStatementContext)
}

func (s *ExecStatementContext) ReplLoadStatement() IReplLoadStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplLoadStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplLoadStatementContext)
}

func (s *ExecStatementContext) ReplStatusStatement() IReplStatusStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplStatusStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplStatusStatementContext)
}

func (s *ExecStatementContext) DdlStatement() IDdlStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDdlStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDdlStatementContext)
}

func (s *ExecStatementContext) DeleteStatement() IDeleteStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeleteStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeleteStatementContext)
}

func (s *ExecStatementContext) UpdateStatement() IUpdateStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdateStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdateStatementContext)
}

func (s *ExecStatementContext) SqlTransactionStatement() ISqlTransactionStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISqlTransactionStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISqlTransactionStatementContext)
}

func (s *ExecStatementContext) MergeStatement() IMergeStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMergeStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMergeStatementContext)
}

func (s *ExecStatementContext) PrepareStatement() IPrepareStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrepareStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrepareStatementContext)
}

func (s *ExecStatementContext) ExecuteStatement() IExecuteStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExecuteStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExecuteStatementContext)
}

func (s *ExecStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExecStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ExecStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterExecStatement(s)
	}
}

func (s *ExecStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitExecStatement(s)
	}
}

func (s *ExecStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitExecStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ExecStatement() (localctx IExecStatementContext) {
	localctx = NewExecStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, HiveParserRULE_execStatement)
	p.SetState(1056)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 7, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1042)
			p.QueryStatementExpression()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1043)
			p.LoadStatement()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1044)
			p.ExportStatement()
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1045)
			p.ImportStatement()
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1046)
			p.ReplDumpStatement()
		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1047)
			p.ReplLoadStatement()
		}


	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1048)
			p.ReplStatusStatement()
		}


	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1049)
			p.DdlStatement()
		}


	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1050)
			p.DeleteStatement()
		}


	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1051)
			p.UpdateStatement()
		}


	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1052)
			p.SqlTransactionStatement()
		}


	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1053)
			p.MergeStatement()
		}


	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1054)
			p.PrepareStatement()
		}


	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1055)
			p.ExecuteStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ILoadStatementContext is an interface to support dynamic dispatch.
type ILoadStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_LOAD() antlr.TerminalNode
	KW_DATA() antlr.TerminalNode
	KW_INPATH() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode
	KW_INTO() antlr.TerminalNode
	KW_TABLE() antlr.TerminalNode
	TableOrPartition() ITableOrPartitionContext
	KW_LOCAL() antlr.TerminalNode
	KW_OVERWRITE() antlr.TerminalNode
	InputFileFormat() IInputFileFormatContext

	// IsLoadStatementContext differentiates from other interfaces.
	IsLoadStatementContext()
}

type LoadStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoadStatementContext() *LoadStatementContext {
	var p = new(LoadStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_loadStatement
	return p
}

func InitEmptyLoadStatementContext(p *LoadStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_loadStatement
}

func (*LoadStatementContext) IsLoadStatementContext() {}

func NewLoadStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LoadStatementContext {
	var p = new(LoadStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_loadStatement

	return p
}

func (s *LoadStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LoadStatementContext) KW_LOAD() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_LOAD, 0)
}

func (s *LoadStatementContext) KW_DATA() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DATA, 0)
}

func (s *LoadStatementContext) KW_INPATH() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_INPATH, 0)
}

func (s *LoadStatementContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(HiveParserStringLiteral, 0)
}

func (s *LoadStatementContext) KW_INTO() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_INTO, 0)
}

func (s *LoadStatementContext) KW_TABLE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TABLE, 0)
}

func (s *LoadStatementContext) TableOrPartition() ITableOrPartitionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableOrPartitionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableOrPartitionContext)
}

func (s *LoadStatementContext) KW_LOCAL() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_LOCAL, 0)
}

func (s *LoadStatementContext) KW_OVERWRITE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_OVERWRITE, 0)
}

func (s *LoadStatementContext) InputFileFormat() IInputFileFormatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInputFileFormatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInputFileFormatContext)
}

func (s *LoadStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoadStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *LoadStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterLoadStatement(s)
	}
}

func (s *LoadStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitLoadStatement(s)
	}
}

func (s *LoadStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitLoadStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) LoadStatement() (localctx ILoadStatementContext) {
	localctx = NewLoadStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, HiveParserRULE_loadStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1058)
		p.Match(HiveParserKW_LOAD)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1059)
		p.Match(HiveParserKW_DATA)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1061)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_LOCAL {
		{
			p.SetState(1060)
			p.Match(HiveParserKW_LOCAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(1063)
		p.Match(HiveParserKW_INPATH)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1064)
		p.Match(HiveParserStringLiteral)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1066)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_OVERWRITE {
		{
			p.SetState(1065)
			p.Match(HiveParserKW_OVERWRITE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(1068)
		p.Match(HiveParserKW_INTO)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1069)
		p.Match(HiveParserKW_TABLE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1070)
		p.TableOrPartition()
	}
	p.SetState(1072)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_INPUTFORMAT {
		{
			p.SetState(1071)
			p.InputFileFormat()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IReplicationClauseContext is an interface to support dynamic dispatch.
type IReplicationClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_FOR() antlr.TerminalNode
	KW_REPLICATION() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	KW_METADATA() antlr.TerminalNode

	// IsReplicationClauseContext differentiates from other interfaces.
	IsReplicationClauseContext()
}

type ReplicationClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReplicationClauseContext() *ReplicationClauseContext {
	var p = new(ReplicationClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_replicationClause
	return p
}

func InitEmptyReplicationClauseContext(p *ReplicationClauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_replicationClause
}

func (*ReplicationClauseContext) IsReplicationClauseContext() {}

func NewReplicationClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReplicationClauseContext {
	var p = new(ReplicationClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_replicationClause

	return p
}

func (s *ReplicationClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReplicationClauseContext) KW_FOR() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_FOR, 0)
}

func (s *ReplicationClauseContext) KW_REPLICATION() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_REPLICATION, 0)
}

func (s *ReplicationClauseContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserLPAREN, 0)
}

func (s *ReplicationClauseContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(HiveParserStringLiteral, 0)
}

func (s *ReplicationClauseContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserRPAREN, 0)
}

func (s *ReplicationClauseContext) KW_METADATA() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_METADATA, 0)
}

func (s *ReplicationClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplicationClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ReplicationClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterReplicationClause(s)
	}
}

func (s *ReplicationClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitReplicationClause(s)
	}
}

func (s *ReplicationClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitReplicationClause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ReplicationClause() (localctx IReplicationClauseContext) {
	localctx = NewReplicationClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, HiveParserRULE_replicationClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1074)
		p.Match(HiveParserKW_FOR)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1076)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_METADATA {
		{
			p.SetState(1075)
			p.Match(HiveParserKW_METADATA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(1078)
		p.Match(HiveParserKW_REPLICATION)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1079)
		p.Match(HiveParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1080)
		p.Match(HiveParserStringLiteral)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1081)
		p.Match(HiveParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExportStatementContext is an interface to support dynamic dispatch.
type IExportStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_EXPORT() antlr.TerminalNode
	KW_TABLE() antlr.TerminalNode
	TableOrPartition() ITableOrPartitionContext
	KW_TO() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode
	ReplicationClause() IReplicationClauseContext

	// IsExportStatementContext differentiates from other interfaces.
	IsExportStatementContext()
}

type ExportStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExportStatementContext() *ExportStatementContext {
	var p = new(ExportStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_exportStatement
	return p
}

func InitEmptyExportStatementContext(p *ExportStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_exportStatement
}

func (*ExportStatementContext) IsExportStatementContext() {}

func NewExportStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExportStatementContext {
	var p = new(ExportStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_exportStatement

	return p
}

func (s *ExportStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExportStatementContext) KW_EXPORT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_EXPORT, 0)
}

func (s *ExportStatementContext) KW_TABLE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TABLE, 0)
}

func (s *ExportStatementContext) TableOrPartition() ITableOrPartitionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableOrPartitionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableOrPartitionContext)
}

func (s *ExportStatementContext) KW_TO() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TO, 0)
}

func (s *ExportStatementContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(HiveParserStringLiteral, 0)
}

func (s *ExportStatementContext) ReplicationClause() IReplicationClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplicationClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplicationClauseContext)
}

func (s *ExportStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExportStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ExportStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterExportStatement(s)
	}
}

func (s *ExportStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitExportStatement(s)
	}
}

func (s *ExportStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitExportStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ExportStatement() (localctx IExportStatementContext) {
	localctx = NewExportStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, HiveParserRULE_exportStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1083)
		p.Match(HiveParserKW_EXPORT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1084)
		p.Match(HiveParserKW_TABLE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1085)
		p.TableOrPartition()
	}
	{
		p.SetState(1086)
		p.Match(HiveParserKW_TO)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1087)
		p.Match(HiveParserStringLiteral)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1089)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_FOR {
		{
			p.SetState(1088)
			p.ReplicationClause()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IImportStatementContext is an interface to support dynamic dispatch.
type IImportStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPath returns the path token.
	GetPath() antlr.Token 


	// SetPath sets the path token.
	SetPath(antlr.Token) 


	// Getter signatures
	KW_IMPORT() antlr.TerminalNode
	KW_FROM() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode
	KW_TABLE() antlr.TerminalNode
	TableOrPartition() ITableOrPartitionContext
	TableLocation() ITableLocationContext
	KW_EXTERNAL() antlr.TerminalNode

	// IsImportStatementContext differentiates from other interfaces.
	IsImportStatementContext()
}

type ImportStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	path antlr.Token
}

func NewEmptyImportStatementContext() *ImportStatementContext {
	var p = new(ImportStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_importStatement
	return p
}

func InitEmptyImportStatementContext(p *ImportStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_importStatement
}

func (*ImportStatementContext) IsImportStatementContext() {}

func NewImportStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportStatementContext {
	var p = new(ImportStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_importStatement

	return p
}

func (s *ImportStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportStatementContext) GetPath() antlr.Token { return s.path }


func (s *ImportStatementContext) SetPath(v antlr.Token) { s.path = v }


func (s *ImportStatementContext) KW_IMPORT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_IMPORT, 0)
}

func (s *ImportStatementContext) KW_FROM() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_FROM, 0)
}

func (s *ImportStatementContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(HiveParserStringLiteral, 0)
}

func (s *ImportStatementContext) KW_TABLE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TABLE, 0)
}

func (s *ImportStatementContext) TableOrPartition() ITableOrPartitionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableOrPartitionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableOrPartitionContext)
}

func (s *ImportStatementContext) TableLocation() ITableLocationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableLocationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableLocationContext)
}

func (s *ImportStatementContext) KW_EXTERNAL() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_EXTERNAL, 0)
}

func (s *ImportStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ImportStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterImportStatement(s)
	}
}

func (s *ImportStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitImportStatement(s)
	}
}

func (s *ImportStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitImportStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ImportStatement() (localctx IImportStatementContext) {
	localctx = NewImportStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, HiveParserRULE_importStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1091)
		p.Match(HiveParserKW_IMPORT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1097)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_EXTERNAL || _la == HiveParserKW_TABLE {
		p.SetState(1093)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_EXTERNAL {
			{
				p.SetState(1092)
				p.Match(HiveParserKW_EXTERNAL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1095)
			p.Match(HiveParserKW_TABLE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1096)
			p.TableOrPartition()
		}

	}
	{
		p.SetState(1099)
		p.Match(HiveParserKW_FROM)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1100)

		var _m = p.Match(HiveParserStringLiteral)

		localctx.(*ImportStatementContext).path = _m
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1102)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_LOCATION {
		{
			p.SetState(1101)
			p.TableLocation()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IReplDumpStatementContext is an interface to support dynamic dispatch.
type IReplDumpStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDbPolicy returns the dbPolicy rule contexts.
	GetDbPolicy() IReplDbPolicyContext

	// GetOldDbPolicy returns the oldDbPolicy rule contexts.
	GetOldDbPolicy() IReplDbPolicyContext

	// GetReplConf returns the replConf rule contexts.
	GetReplConf() IReplConfigsContext


	// SetDbPolicy sets the dbPolicy rule contexts.
	SetDbPolicy(IReplDbPolicyContext)

	// SetOldDbPolicy sets the oldDbPolicy rule contexts.
	SetOldDbPolicy(IReplDbPolicyContext)

	// SetReplConf sets the replConf rule contexts.
	SetReplConf(IReplConfigsContext)


	// Getter signatures
	KW_REPL() antlr.TerminalNode
	KW_DUMP() antlr.TerminalNode
	AllReplDbPolicy() []IReplDbPolicyContext
	ReplDbPolicy(i int) IReplDbPolicyContext
	KW_REPLACE() antlr.TerminalNode
	KW_WITH() antlr.TerminalNode
	ReplConfigs() IReplConfigsContext

	// IsReplDumpStatementContext differentiates from other interfaces.
	IsReplDumpStatementContext()
}

type ReplDumpStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	dbPolicy IReplDbPolicyContext 
	oldDbPolicy IReplDbPolicyContext 
	replConf IReplConfigsContext 
}

func NewEmptyReplDumpStatementContext() *ReplDumpStatementContext {
	var p = new(ReplDumpStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_replDumpStatement
	return p
}

func InitEmptyReplDumpStatementContext(p *ReplDumpStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_replDumpStatement
}

func (*ReplDumpStatementContext) IsReplDumpStatementContext() {}

func NewReplDumpStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReplDumpStatementContext {
	var p = new(ReplDumpStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_replDumpStatement

	return p
}

func (s *ReplDumpStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReplDumpStatementContext) GetDbPolicy() IReplDbPolicyContext { return s.dbPolicy }

func (s *ReplDumpStatementContext) GetOldDbPolicy() IReplDbPolicyContext { return s.oldDbPolicy }

func (s *ReplDumpStatementContext) GetReplConf() IReplConfigsContext { return s.replConf }


func (s *ReplDumpStatementContext) SetDbPolicy(v IReplDbPolicyContext) { s.dbPolicy = v }

func (s *ReplDumpStatementContext) SetOldDbPolicy(v IReplDbPolicyContext) { s.oldDbPolicy = v }

func (s *ReplDumpStatementContext) SetReplConf(v IReplConfigsContext) { s.replConf = v }


func (s *ReplDumpStatementContext) KW_REPL() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_REPL, 0)
}

func (s *ReplDumpStatementContext) KW_DUMP() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DUMP, 0)
}

func (s *ReplDumpStatementContext) AllReplDbPolicy() []IReplDbPolicyContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IReplDbPolicyContext); ok {
			len++
		}
	}

	tst := make([]IReplDbPolicyContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IReplDbPolicyContext); ok {
			tst[i] = t.(IReplDbPolicyContext)
			i++
		}
	}

	return tst
}

func (s *ReplDumpStatementContext) ReplDbPolicy(i int) IReplDbPolicyContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplDbPolicyContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplDbPolicyContext)
}

func (s *ReplDumpStatementContext) KW_REPLACE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_REPLACE, 0)
}

func (s *ReplDumpStatementContext) KW_WITH() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_WITH, 0)
}

func (s *ReplDumpStatementContext) ReplConfigs() IReplConfigsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplConfigsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplConfigsContext)
}

func (s *ReplDumpStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplDumpStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ReplDumpStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterReplDumpStatement(s)
	}
}

func (s *ReplDumpStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitReplDumpStatement(s)
	}
}

func (s *ReplDumpStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitReplDumpStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ReplDumpStatement() (localctx IReplDumpStatementContext) {
	localctx = NewReplDumpStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, HiveParserRULE_replDumpStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1104)
		p.Match(HiveParserKW_REPL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1105)
		p.Match(HiveParserKW_DUMP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1106)

		var _x = p.ReplDbPolicy()


		localctx.(*ReplDumpStatementContext).dbPolicy = _x
	}
	p.SetState(1109)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_REPLACE {
		{
			p.SetState(1107)
			p.Match(HiveParserKW_REPLACE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1108)

			var _x = p.ReplDbPolicy()


			localctx.(*ReplDumpStatementContext).oldDbPolicy = _x
		}

	}
	p.SetState(1113)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_WITH {
		{
			p.SetState(1111)
			p.Match(HiveParserKW_WITH)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1112)

			var _x = p.ReplConfigs()


			localctx.(*ReplDumpStatementContext).replConf = _x
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IReplDbPolicyContext is an interface to support dynamic dispatch.
type IReplDbPolicyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDbName returns the dbName rule contexts.
	GetDbName() IId_Context

	// GetTablePolicy returns the tablePolicy rule contexts.
	GetTablePolicy() IReplTableLevelPolicyContext


	// SetDbName sets the dbName rule contexts.
	SetDbName(IId_Context)

	// SetTablePolicy sets the tablePolicy rule contexts.
	SetTablePolicy(IReplTableLevelPolicyContext)


	// Getter signatures
	Id_() IId_Context
	DOT() antlr.TerminalNode
	ReplTableLevelPolicy() IReplTableLevelPolicyContext

	// IsReplDbPolicyContext differentiates from other interfaces.
	IsReplDbPolicyContext()
}

type ReplDbPolicyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	dbName IId_Context 
	tablePolicy IReplTableLevelPolicyContext 
}

func NewEmptyReplDbPolicyContext() *ReplDbPolicyContext {
	var p = new(ReplDbPolicyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_replDbPolicy
	return p
}

func InitEmptyReplDbPolicyContext(p *ReplDbPolicyContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_replDbPolicy
}

func (*ReplDbPolicyContext) IsReplDbPolicyContext() {}

func NewReplDbPolicyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReplDbPolicyContext {
	var p = new(ReplDbPolicyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_replDbPolicy

	return p
}

func (s *ReplDbPolicyContext) GetParser() antlr.Parser { return s.parser }

func (s *ReplDbPolicyContext) GetDbName() IId_Context { return s.dbName }

func (s *ReplDbPolicyContext) GetTablePolicy() IReplTableLevelPolicyContext { return s.tablePolicy }


func (s *ReplDbPolicyContext) SetDbName(v IId_Context) { s.dbName = v }

func (s *ReplDbPolicyContext) SetTablePolicy(v IReplTableLevelPolicyContext) { s.tablePolicy = v }


func (s *ReplDbPolicyContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *ReplDbPolicyContext) DOT() antlr.TerminalNode {
	return s.GetToken(HiveParserDOT, 0)
}

func (s *ReplDbPolicyContext) ReplTableLevelPolicy() IReplTableLevelPolicyContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplTableLevelPolicyContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplTableLevelPolicyContext)
}

func (s *ReplDbPolicyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplDbPolicyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ReplDbPolicyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterReplDbPolicy(s)
	}
}

func (s *ReplDbPolicyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitReplDbPolicy(s)
	}
}

func (s *ReplDbPolicyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitReplDbPolicy(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ReplDbPolicy() (localctx IReplDbPolicyContext) {
	localctx = NewReplDbPolicyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, HiveParserRULE_replDbPolicy)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1115)

		var _x = p.Id_()


		localctx.(*ReplDbPolicyContext).dbName = _x
	}
	p.SetState(1118)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserDOT {
		{
			p.SetState(1116)
			p.Match(HiveParserDOT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1117)

			var _x = p.ReplTableLevelPolicy()


			localctx.(*ReplDbPolicyContext).tablePolicy = _x
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IReplLoadStatementContext is an interface to support dynamic dispatch.
type IReplLoadStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSourceDbPolicy returns the sourceDbPolicy rule contexts.
	GetSourceDbPolicy() IReplDbPolicyContext

	// GetDbName returns the dbName rule contexts.
	GetDbName() IId_Context

	// GetReplConf returns the replConf rule contexts.
	GetReplConf() IReplConfigsContext


	// SetSourceDbPolicy sets the sourceDbPolicy rule contexts.
	SetSourceDbPolicy(IReplDbPolicyContext)

	// SetDbName sets the dbName rule contexts.
	SetDbName(IId_Context)

	// SetReplConf sets the replConf rule contexts.
	SetReplConf(IReplConfigsContext)


	// Getter signatures
	KW_REPL() antlr.TerminalNode
	KW_LOAD() antlr.TerminalNode
	ReplDbPolicy() IReplDbPolicyContext
	KW_INTO() antlr.TerminalNode
	KW_WITH() antlr.TerminalNode
	Id_() IId_Context
	ReplConfigs() IReplConfigsContext

	// IsReplLoadStatementContext differentiates from other interfaces.
	IsReplLoadStatementContext()
}

type ReplLoadStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	sourceDbPolicy IReplDbPolicyContext 
	dbName IId_Context 
	replConf IReplConfigsContext 
}

func NewEmptyReplLoadStatementContext() *ReplLoadStatementContext {
	var p = new(ReplLoadStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_replLoadStatement
	return p
}

func InitEmptyReplLoadStatementContext(p *ReplLoadStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_replLoadStatement
}

func (*ReplLoadStatementContext) IsReplLoadStatementContext() {}

func NewReplLoadStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReplLoadStatementContext {
	var p = new(ReplLoadStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_replLoadStatement

	return p
}

func (s *ReplLoadStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReplLoadStatementContext) GetSourceDbPolicy() IReplDbPolicyContext { return s.sourceDbPolicy }

func (s *ReplLoadStatementContext) GetDbName() IId_Context { return s.dbName }

func (s *ReplLoadStatementContext) GetReplConf() IReplConfigsContext { return s.replConf }


func (s *ReplLoadStatementContext) SetSourceDbPolicy(v IReplDbPolicyContext) { s.sourceDbPolicy = v }

func (s *ReplLoadStatementContext) SetDbName(v IId_Context) { s.dbName = v }

func (s *ReplLoadStatementContext) SetReplConf(v IReplConfigsContext) { s.replConf = v }


func (s *ReplLoadStatementContext) KW_REPL() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_REPL, 0)
}

func (s *ReplLoadStatementContext) KW_LOAD() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_LOAD, 0)
}

func (s *ReplLoadStatementContext) ReplDbPolicy() IReplDbPolicyContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplDbPolicyContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplDbPolicyContext)
}

func (s *ReplLoadStatementContext) KW_INTO() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_INTO, 0)
}

func (s *ReplLoadStatementContext) KW_WITH() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_WITH, 0)
}

func (s *ReplLoadStatementContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *ReplLoadStatementContext) ReplConfigs() IReplConfigsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplConfigsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplConfigsContext)
}

func (s *ReplLoadStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplLoadStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ReplLoadStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterReplLoadStatement(s)
	}
}

func (s *ReplLoadStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitReplLoadStatement(s)
	}
}

func (s *ReplLoadStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitReplLoadStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ReplLoadStatement() (localctx IReplLoadStatementContext) {
	localctx = NewReplLoadStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, HiveParserRULE_replLoadStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1120)
		p.Match(HiveParserKW_REPL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1121)
		p.Match(HiveParserKW_LOAD)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1122)

		var _x = p.ReplDbPolicy()


		localctx.(*ReplLoadStatementContext).sourceDbPolicy = _x
	}
	p.SetState(1125)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_INTO {
		{
			p.SetState(1123)
			p.Match(HiveParserKW_INTO)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1124)

			var _x = p.Id_()


			localctx.(*ReplLoadStatementContext).dbName = _x
		}

	}
	p.SetState(1129)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_WITH {
		{
			p.SetState(1127)
			p.Match(HiveParserKW_WITH)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1128)

			var _x = p.ReplConfigs()


			localctx.(*ReplLoadStatementContext).replConf = _x
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IReplConfigsContext is an interface to support dynamic dispatch.
type IReplConfigsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	ReplConfigsList() IReplConfigsListContext
	RPAREN() antlr.TerminalNode

	// IsReplConfigsContext differentiates from other interfaces.
	IsReplConfigsContext()
}

type ReplConfigsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReplConfigsContext() *ReplConfigsContext {
	var p = new(ReplConfigsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_replConfigs
	return p
}

func InitEmptyReplConfigsContext(p *ReplConfigsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_replConfigs
}

func (*ReplConfigsContext) IsReplConfigsContext() {}

func NewReplConfigsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReplConfigsContext {
	var p = new(ReplConfigsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_replConfigs

	return p
}

func (s *ReplConfigsContext) GetParser() antlr.Parser { return s.parser }

func (s *ReplConfigsContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserLPAREN, 0)
}

func (s *ReplConfigsContext) ReplConfigsList() IReplConfigsListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplConfigsListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplConfigsListContext)
}

func (s *ReplConfigsContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserRPAREN, 0)
}

func (s *ReplConfigsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplConfigsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ReplConfigsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterReplConfigs(s)
	}
}

func (s *ReplConfigsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitReplConfigs(s)
	}
}

func (s *ReplConfigsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitReplConfigs(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ReplConfigs() (localctx IReplConfigsContext) {
	localctx = NewReplConfigsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, HiveParserRULE_replConfigs)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1131)
		p.Match(HiveParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1132)
		p.ReplConfigsList()
	}
	{
		p.SetState(1133)
		p.Match(HiveParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IReplConfigsListContext is an interface to support dynamic dispatch.
type IReplConfigsListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllKeyValueProperty() []IKeyValuePropertyContext
	KeyValueProperty(i int) IKeyValuePropertyContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsReplConfigsListContext differentiates from other interfaces.
	IsReplConfigsListContext()
}

type ReplConfigsListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReplConfigsListContext() *ReplConfigsListContext {
	var p = new(ReplConfigsListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_replConfigsList
	return p
}

func InitEmptyReplConfigsListContext(p *ReplConfigsListContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_replConfigsList
}

func (*ReplConfigsListContext) IsReplConfigsListContext() {}

func NewReplConfigsListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReplConfigsListContext {
	var p = new(ReplConfigsListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_replConfigsList

	return p
}

func (s *ReplConfigsListContext) GetParser() antlr.Parser { return s.parser }

func (s *ReplConfigsListContext) AllKeyValueProperty() []IKeyValuePropertyContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IKeyValuePropertyContext); ok {
			len++
		}
	}

	tst := make([]IKeyValuePropertyContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IKeyValuePropertyContext); ok {
			tst[i] = t.(IKeyValuePropertyContext)
			i++
		}
	}

	return tst
}

func (s *ReplConfigsListContext) KeyValueProperty(i int) IKeyValuePropertyContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyValuePropertyContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyValuePropertyContext)
}

func (s *ReplConfigsListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(HiveParserCOMMA)
}

func (s *ReplConfigsListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserCOMMA, i)
}

func (s *ReplConfigsListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplConfigsListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ReplConfigsListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterReplConfigsList(s)
	}
}

func (s *ReplConfigsListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitReplConfigsList(s)
	}
}

func (s *ReplConfigsListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitReplConfigsList(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ReplConfigsList() (localctx IReplConfigsListContext) {
	localctx = NewReplConfigsListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, HiveParserRULE_replConfigsList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1135)
		p.KeyValueProperty()
	}
	p.SetState(1140)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HiveParserCOMMA {
		{
			p.SetState(1136)
			p.Match(HiveParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1137)
			p.KeyValueProperty()
		}


		p.SetState(1142)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IReplTableLevelPolicyContext is an interface to support dynamic dispatch.
type IReplTableLevelPolicyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetReplTablesIncludeList returns the replTablesIncludeList token.
	GetReplTablesIncludeList() antlr.Token 

	// GetReplTablesExcludeList returns the replTablesExcludeList token.
	GetReplTablesExcludeList() antlr.Token 


	// SetReplTablesIncludeList sets the replTablesIncludeList token.
	SetReplTablesIncludeList(antlr.Token) 

	// SetReplTablesExcludeList sets the replTablesExcludeList token.
	SetReplTablesExcludeList(antlr.Token) 


	// Getter signatures
	AllStringLiteral() []antlr.TerminalNode
	StringLiteral(i int) antlr.TerminalNode
	DOT() antlr.TerminalNode

	// IsReplTableLevelPolicyContext differentiates from other interfaces.
	IsReplTableLevelPolicyContext()
}

type ReplTableLevelPolicyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	replTablesIncludeList antlr.Token
	replTablesExcludeList antlr.Token
}

func NewEmptyReplTableLevelPolicyContext() *ReplTableLevelPolicyContext {
	var p = new(ReplTableLevelPolicyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_replTableLevelPolicy
	return p
}

func InitEmptyReplTableLevelPolicyContext(p *ReplTableLevelPolicyContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_replTableLevelPolicy
}

func (*ReplTableLevelPolicyContext) IsReplTableLevelPolicyContext() {}

func NewReplTableLevelPolicyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReplTableLevelPolicyContext {
	var p = new(ReplTableLevelPolicyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_replTableLevelPolicy

	return p
}

func (s *ReplTableLevelPolicyContext) GetParser() antlr.Parser { return s.parser }

func (s *ReplTableLevelPolicyContext) GetReplTablesIncludeList() antlr.Token { return s.replTablesIncludeList }

func (s *ReplTableLevelPolicyContext) GetReplTablesExcludeList() antlr.Token { return s.replTablesExcludeList }


func (s *ReplTableLevelPolicyContext) SetReplTablesIncludeList(v antlr.Token) { s.replTablesIncludeList = v }

func (s *ReplTableLevelPolicyContext) SetReplTablesExcludeList(v antlr.Token) { s.replTablesExcludeList = v }


func (s *ReplTableLevelPolicyContext) AllStringLiteral() []antlr.TerminalNode {
	return s.GetTokens(HiveParserStringLiteral)
}

func (s *ReplTableLevelPolicyContext) StringLiteral(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserStringLiteral, i)
}

func (s *ReplTableLevelPolicyContext) DOT() antlr.TerminalNode {
	return s.GetToken(HiveParserDOT, 0)
}

func (s *ReplTableLevelPolicyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplTableLevelPolicyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ReplTableLevelPolicyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterReplTableLevelPolicy(s)
	}
}

func (s *ReplTableLevelPolicyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitReplTableLevelPolicy(s)
	}
}

func (s *ReplTableLevelPolicyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitReplTableLevelPolicy(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ReplTableLevelPolicy() (localctx IReplTableLevelPolicyContext) {
	localctx = NewReplTableLevelPolicyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, HiveParserRULE_replTableLevelPolicy)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1143)

		var _m = p.Match(HiveParserStringLiteral)

		localctx.(*ReplTableLevelPolicyContext).replTablesIncludeList = _m
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1146)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserDOT {
		{
			p.SetState(1144)
			p.Match(HiveParserDOT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1145)

			var _m = p.Match(HiveParserStringLiteral)

			localctx.(*ReplTableLevelPolicyContext).replTablesExcludeList = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IReplStatusStatementContext is an interface to support dynamic dispatch.
type IReplStatusStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDbName returns the dbName rule contexts.
	GetDbName() IId_Context

	// GetReplConf returns the replConf rule contexts.
	GetReplConf() IReplConfigsContext


	// SetDbName sets the dbName rule contexts.
	SetDbName(IId_Context)

	// SetReplConf sets the replConf rule contexts.
	SetReplConf(IReplConfigsContext)


	// Getter signatures
	KW_REPL() antlr.TerminalNode
	KW_STATUS() antlr.TerminalNode
	Id_() IId_Context
	KW_WITH() antlr.TerminalNode
	ReplConfigs() IReplConfigsContext

	// IsReplStatusStatementContext differentiates from other interfaces.
	IsReplStatusStatementContext()
}

type ReplStatusStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	dbName IId_Context 
	replConf IReplConfigsContext 
}

func NewEmptyReplStatusStatementContext() *ReplStatusStatementContext {
	var p = new(ReplStatusStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_replStatusStatement
	return p
}

func InitEmptyReplStatusStatementContext(p *ReplStatusStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_replStatusStatement
}

func (*ReplStatusStatementContext) IsReplStatusStatementContext() {}

func NewReplStatusStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReplStatusStatementContext {
	var p = new(ReplStatusStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_replStatusStatement

	return p
}

func (s *ReplStatusStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReplStatusStatementContext) GetDbName() IId_Context { return s.dbName }

func (s *ReplStatusStatementContext) GetReplConf() IReplConfigsContext { return s.replConf }


func (s *ReplStatusStatementContext) SetDbName(v IId_Context) { s.dbName = v }

func (s *ReplStatusStatementContext) SetReplConf(v IReplConfigsContext) { s.replConf = v }


func (s *ReplStatusStatementContext) KW_REPL() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_REPL, 0)
}

func (s *ReplStatusStatementContext) KW_STATUS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_STATUS, 0)
}

func (s *ReplStatusStatementContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *ReplStatusStatementContext) KW_WITH() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_WITH, 0)
}

func (s *ReplStatusStatementContext) ReplConfigs() IReplConfigsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplConfigsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplConfigsContext)
}

func (s *ReplStatusStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplStatusStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ReplStatusStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterReplStatusStatement(s)
	}
}

func (s *ReplStatusStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitReplStatusStatement(s)
	}
}

func (s *ReplStatusStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitReplStatusStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ReplStatusStatement() (localctx IReplStatusStatementContext) {
	localctx = NewReplStatusStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, HiveParserRULE_replStatusStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1148)
		p.Match(HiveParserKW_REPL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1149)
		p.Match(HiveParserKW_STATUS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1150)

		var _x = p.Id_()


		localctx.(*ReplStatusStatementContext).dbName = _x
	}
	p.SetState(1153)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_WITH {
		{
			p.SetState(1151)
			p.Match(HiveParserKW_WITH)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1152)

			var _x = p.ReplConfigs()


			localctx.(*ReplStatusStatementContext).replConf = _x
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDdlStatementContext is an interface to support dynamic dispatch.
type IDdlStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CreateDatabaseStatement() ICreateDatabaseStatementContext
	SwitchDatabaseStatement() ISwitchDatabaseStatementContext
	DropDatabaseStatement() IDropDatabaseStatementContext
	CreateTableStatement() ICreateTableStatementContext
	DropTableStatement() IDropTableStatementContext
	TruncateTableStatement() ITruncateTableStatementContext
	AlterStatement() IAlterStatementContext
	DescStatement() IDescStatementContext
	ShowStatement() IShowStatementContext
	MetastoreCheck() IMetastoreCheckContext
	CreateViewStatement() ICreateViewStatementContext
	CreateMaterializedViewStatement() ICreateMaterializedViewStatementContext
	CreateScheduledQueryStatement() ICreateScheduledQueryStatementContext
	AlterScheduledQueryStatement() IAlterScheduledQueryStatementContext
	DropScheduledQueryStatement() IDropScheduledQueryStatementContext
	DropViewStatement() IDropViewStatementContext
	DropMaterializedViewStatement() IDropMaterializedViewStatementContext
	CreateFunctionStatement() ICreateFunctionStatementContext
	CreateMacroStatement() ICreateMacroStatementContext
	DropFunctionStatement() IDropFunctionStatementContext
	ReloadFunctionsStatement() IReloadFunctionsStatementContext
	DropMacroStatement() IDropMacroStatementContext
	AnalyzeStatement() IAnalyzeStatementContext
	LockStatement() ILockStatementContext
	UnlockStatement() IUnlockStatementContext
	LockDatabase() ILockDatabaseContext
	UnlockDatabase() IUnlockDatabaseContext
	CreateRoleStatement() ICreateRoleStatementContext
	DropRoleStatement() IDropRoleStatementContext
	GrantPrivileges() IGrantPrivilegesContext
	RevokePrivileges() IRevokePrivilegesContext
	ShowGrants() IShowGrantsContext
	ShowRoleGrants() IShowRoleGrantsContext
	ShowRolePrincipals() IShowRolePrincipalsContext
	ShowRoles() IShowRolesContext
	GrantRole() IGrantRoleContext
	RevokeRole() IRevokeRoleContext
	SetRole() ISetRoleContext
	ShowCurrentRole() IShowCurrentRoleContext
	AbortTransactionStatement() IAbortTransactionStatementContext
	AbortCompactionStatement() IAbortCompactionStatementContext
	KillQueryStatement() IKillQueryStatementContext
	ResourcePlanDdlStatements() IResourcePlanDdlStatementsContext
	CreateDataConnectorStatement() ICreateDataConnectorStatementContext
	DropDataConnectorStatement() IDropDataConnectorStatementContext

	// IsDdlStatementContext differentiates from other interfaces.
	IsDdlStatementContext()
}

type DdlStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDdlStatementContext() *DdlStatementContext {
	var p = new(DdlStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_ddlStatement
	return p
}

func InitEmptyDdlStatementContext(p *DdlStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_ddlStatement
}

func (*DdlStatementContext) IsDdlStatementContext() {}

func NewDdlStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DdlStatementContext {
	var p = new(DdlStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_ddlStatement

	return p
}

func (s *DdlStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DdlStatementContext) CreateDatabaseStatement() ICreateDatabaseStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateDatabaseStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateDatabaseStatementContext)
}

func (s *DdlStatementContext) SwitchDatabaseStatement() ISwitchDatabaseStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISwitchDatabaseStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISwitchDatabaseStatementContext)
}

func (s *DdlStatementContext) DropDatabaseStatement() IDropDatabaseStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropDatabaseStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropDatabaseStatementContext)
}

func (s *DdlStatementContext) CreateTableStatement() ICreateTableStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateTableStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateTableStatementContext)
}

func (s *DdlStatementContext) DropTableStatement() IDropTableStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropTableStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropTableStatementContext)
}

func (s *DdlStatementContext) TruncateTableStatement() ITruncateTableStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITruncateTableStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITruncateTableStatementContext)
}

func (s *DdlStatementContext) AlterStatement() IAlterStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterStatementContext)
}

func (s *DdlStatementContext) DescStatement() IDescStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDescStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDescStatementContext)
}

func (s *DdlStatementContext) ShowStatement() IShowStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowStatementContext)
}

func (s *DdlStatementContext) MetastoreCheck() IMetastoreCheckContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMetastoreCheckContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMetastoreCheckContext)
}

func (s *DdlStatementContext) CreateViewStatement() ICreateViewStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateViewStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateViewStatementContext)
}

func (s *DdlStatementContext) CreateMaterializedViewStatement() ICreateMaterializedViewStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateMaterializedViewStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateMaterializedViewStatementContext)
}

func (s *DdlStatementContext) CreateScheduledQueryStatement() ICreateScheduledQueryStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateScheduledQueryStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateScheduledQueryStatementContext)
}

func (s *DdlStatementContext) AlterScheduledQueryStatement() IAlterScheduledQueryStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterScheduledQueryStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterScheduledQueryStatementContext)
}

func (s *DdlStatementContext) DropScheduledQueryStatement() IDropScheduledQueryStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropScheduledQueryStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropScheduledQueryStatementContext)
}

func (s *DdlStatementContext) DropViewStatement() IDropViewStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropViewStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropViewStatementContext)
}

func (s *DdlStatementContext) DropMaterializedViewStatement() IDropMaterializedViewStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropMaterializedViewStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropMaterializedViewStatementContext)
}

func (s *DdlStatementContext) CreateFunctionStatement() ICreateFunctionStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateFunctionStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateFunctionStatementContext)
}

func (s *DdlStatementContext) CreateMacroStatement() ICreateMacroStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateMacroStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateMacroStatementContext)
}

func (s *DdlStatementContext) DropFunctionStatement() IDropFunctionStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropFunctionStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropFunctionStatementContext)
}

func (s *DdlStatementContext) ReloadFunctionsStatement() IReloadFunctionsStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReloadFunctionsStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReloadFunctionsStatementContext)
}

func (s *DdlStatementContext) DropMacroStatement() IDropMacroStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropMacroStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropMacroStatementContext)
}

func (s *DdlStatementContext) AnalyzeStatement() IAnalyzeStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnalyzeStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnalyzeStatementContext)
}

func (s *DdlStatementContext) LockStatement() ILockStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILockStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILockStatementContext)
}

func (s *DdlStatementContext) UnlockStatement() IUnlockStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnlockStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnlockStatementContext)
}

func (s *DdlStatementContext) LockDatabase() ILockDatabaseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILockDatabaseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILockDatabaseContext)
}

func (s *DdlStatementContext) UnlockDatabase() IUnlockDatabaseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnlockDatabaseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnlockDatabaseContext)
}

func (s *DdlStatementContext) CreateRoleStatement() ICreateRoleStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateRoleStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateRoleStatementContext)
}

func (s *DdlStatementContext) DropRoleStatement() IDropRoleStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropRoleStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropRoleStatementContext)
}

func (s *DdlStatementContext) GrantPrivileges() IGrantPrivilegesContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantPrivilegesContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantPrivilegesContext)
}

func (s *DdlStatementContext) RevokePrivileges() IRevokePrivilegesContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRevokePrivilegesContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRevokePrivilegesContext)
}

func (s *DdlStatementContext) ShowGrants() IShowGrantsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowGrantsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowGrantsContext)
}

func (s *DdlStatementContext) ShowRoleGrants() IShowRoleGrantsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowRoleGrantsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowRoleGrantsContext)
}

func (s *DdlStatementContext) ShowRolePrincipals() IShowRolePrincipalsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowRolePrincipalsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowRolePrincipalsContext)
}

func (s *DdlStatementContext) ShowRoles() IShowRolesContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowRolesContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowRolesContext)
}

func (s *DdlStatementContext) GrantRole() IGrantRoleContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantRoleContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantRoleContext)
}

func (s *DdlStatementContext) RevokeRole() IRevokeRoleContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRevokeRoleContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRevokeRoleContext)
}

func (s *DdlStatementContext) SetRole() ISetRoleContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetRoleContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetRoleContext)
}

func (s *DdlStatementContext) ShowCurrentRole() IShowCurrentRoleContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowCurrentRoleContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowCurrentRoleContext)
}

func (s *DdlStatementContext) AbortTransactionStatement() IAbortTransactionStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAbortTransactionStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAbortTransactionStatementContext)
}

func (s *DdlStatementContext) AbortCompactionStatement() IAbortCompactionStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAbortCompactionStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAbortCompactionStatementContext)
}

func (s *DdlStatementContext) KillQueryStatement() IKillQueryStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKillQueryStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKillQueryStatementContext)
}

func (s *DdlStatementContext) ResourcePlanDdlStatements() IResourcePlanDdlStatementsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResourcePlanDdlStatementsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResourcePlanDdlStatementsContext)
}

func (s *DdlStatementContext) CreateDataConnectorStatement() ICreateDataConnectorStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateDataConnectorStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateDataConnectorStatementContext)
}

func (s *DdlStatementContext) DropDataConnectorStatement() IDropDataConnectorStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropDataConnectorStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropDataConnectorStatementContext)
}

func (s *DdlStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DdlStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DdlStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterDdlStatement(s)
	}
}

func (s *DdlStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitDdlStatement(s)
	}
}

func (s *DdlStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitDdlStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) DdlStatement() (localctx IDdlStatementContext) {
	localctx = NewDdlStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, HiveParserRULE_ddlStatement)
	p.SetState(1200)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 24, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1155)
			p.CreateDatabaseStatement()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1156)
			p.SwitchDatabaseStatement()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1157)
			p.DropDatabaseStatement()
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1158)
			p.CreateTableStatement()
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1159)
			p.DropTableStatement()
		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1160)
			p.TruncateTableStatement()
		}


	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1161)
			p.AlterStatement()
		}


	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1162)
			p.DescStatement()
		}


	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1163)
			p.ShowStatement()
		}


	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1164)
			p.MetastoreCheck()
		}


	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1165)
			p.CreateViewStatement()
		}


	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1166)
			p.CreateMaterializedViewStatement()
		}


	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1167)
			p.CreateScheduledQueryStatement()
		}


	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1168)
			p.AlterScheduledQueryStatement()
		}


	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(1169)
			p.DropScheduledQueryStatement()
		}


	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(1170)
			p.DropViewStatement()
		}


	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(1171)
			p.DropMaterializedViewStatement()
		}


	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(1172)
			p.CreateFunctionStatement()
		}


	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(1173)
			p.CreateMacroStatement()
		}


	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(1174)
			p.DropFunctionStatement()
		}


	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(1175)
			p.ReloadFunctionsStatement()
		}


	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(1176)
			p.DropMacroStatement()
		}


	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(1177)
			p.AnalyzeStatement()
		}


	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(1178)
			p.LockStatement()
		}


	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(1179)
			p.UnlockStatement()
		}


	case 26:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(1180)
			p.LockDatabase()
		}


	case 27:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(1181)
			p.UnlockDatabase()
		}


	case 28:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(1182)
			p.CreateRoleStatement()
		}


	case 29:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(1183)
			p.DropRoleStatement()
		}


	case 30:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(1184)
			p.GrantPrivileges()
		}


	case 31:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(1185)
			p.RevokePrivileges()
		}


	case 32:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(1186)
			p.ShowGrants()
		}


	case 33:
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(1187)
			p.ShowRoleGrants()
		}


	case 34:
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(1188)
			p.ShowRolePrincipals()
		}


	case 35:
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(1189)
			p.ShowRoles()
		}


	case 36:
		p.EnterOuterAlt(localctx, 36)
		{
			p.SetState(1190)
			p.GrantRole()
		}


	case 37:
		p.EnterOuterAlt(localctx, 37)
		{
			p.SetState(1191)
			p.RevokeRole()
		}


	case 38:
		p.EnterOuterAlt(localctx, 38)
		{
			p.SetState(1192)
			p.SetRole()
		}


	case 39:
		p.EnterOuterAlt(localctx, 39)
		{
			p.SetState(1193)
			p.ShowCurrentRole()
		}


	case 40:
		p.EnterOuterAlt(localctx, 40)
		{
			p.SetState(1194)
			p.AbortTransactionStatement()
		}


	case 41:
		p.EnterOuterAlt(localctx, 41)
		{
			p.SetState(1195)
			p.AbortCompactionStatement()
		}


	case 42:
		p.EnterOuterAlt(localctx, 42)
		{
			p.SetState(1196)
			p.KillQueryStatement()
		}


	case 43:
		p.EnterOuterAlt(localctx, 43)
		{
			p.SetState(1197)
			p.ResourcePlanDdlStatements()
		}


	case 44:
		p.EnterOuterAlt(localctx, 44)
		{
			p.SetState(1198)
			p.CreateDataConnectorStatement()
		}


	case 45:
		p.EnterOuterAlt(localctx, 45)
		{
			p.SetState(1199)
			p.DropDataConnectorStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IIfExistsContext is an interface to support dynamic dispatch.
type IIfExistsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_IF() antlr.TerminalNode
	KW_EXISTS() antlr.TerminalNode

	// IsIfExistsContext differentiates from other interfaces.
	IsIfExistsContext()
}

type IfExistsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfExistsContext() *IfExistsContext {
	var p = new(IfExistsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_ifExists
	return p
}

func InitEmptyIfExistsContext(p *IfExistsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_ifExists
}

func (*IfExistsContext) IsIfExistsContext() {}

func NewIfExistsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfExistsContext {
	var p = new(IfExistsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_ifExists

	return p
}

func (s *IfExistsContext) GetParser() antlr.Parser { return s.parser }

func (s *IfExistsContext) KW_IF() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_IF, 0)
}

func (s *IfExistsContext) KW_EXISTS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_EXISTS, 0)
}

func (s *IfExistsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfExistsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *IfExistsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterIfExists(s)
	}
}

func (s *IfExistsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitIfExists(s)
	}
}

func (s *IfExistsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitIfExists(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) IfExists() (localctx IIfExistsContext) {
	localctx = NewIfExistsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, HiveParserRULE_ifExists)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1202)
		p.Match(HiveParserKW_IF)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1203)
		p.Match(HiveParserKW_EXISTS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRestrictOrCascadeContext is an interface to support dynamic dispatch.
type IRestrictOrCascadeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_RESTRICT() antlr.TerminalNode
	KW_CASCADE() antlr.TerminalNode

	// IsRestrictOrCascadeContext differentiates from other interfaces.
	IsRestrictOrCascadeContext()
}

type RestrictOrCascadeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRestrictOrCascadeContext() *RestrictOrCascadeContext {
	var p = new(RestrictOrCascadeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_restrictOrCascade
	return p
}

func InitEmptyRestrictOrCascadeContext(p *RestrictOrCascadeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_restrictOrCascade
}

func (*RestrictOrCascadeContext) IsRestrictOrCascadeContext() {}

func NewRestrictOrCascadeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RestrictOrCascadeContext {
	var p = new(RestrictOrCascadeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_restrictOrCascade

	return p
}

func (s *RestrictOrCascadeContext) GetParser() antlr.Parser { return s.parser }

func (s *RestrictOrCascadeContext) KW_RESTRICT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_RESTRICT, 0)
}

func (s *RestrictOrCascadeContext) KW_CASCADE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_CASCADE, 0)
}

func (s *RestrictOrCascadeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RestrictOrCascadeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *RestrictOrCascadeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterRestrictOrCascade(s)
	}
}

func (s *RestrictOrCascadeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitRestrictOrCascade(s)
	}
}

func (s *RestrictOrCascadeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitRestrictOrCascade(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) RestrictOrCascade() (localctx IRestrictOrCascadeContext) {
	localctx = NewRestrictOrCascadeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, HiveParserRULE_restrictOrCascade)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1205)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HiveParserKW_CASCADE || _la == HiveParserKW_RESTRICT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IIfNotExistsContext is an interface to support dynamic dispatch.
type IIfNotExistsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_IF() antlr.TerminalNode
	KW_NOT() antlr.TerminalNode
	KW_EXISTS() antlr.TerminalNode

	// IsIfNotExistsContext differentiates from other interfaces.
	IsIfNotExistsContext()
}

type IfNotExistsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfNotExistsContext() *IfNotExistsContext {
	var p = new(IfNotExistsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_ifNotExists
	return p
}

func InitEmptyIfNotExistsContext(p *IfNotExistsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_ifNotExists
}

func (*IfNotExistsContext) IsIfNotExistsContext() {}

func NewIfNotExistsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfNotExistsContext {
	var p = new(IfNotExistsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_ifNotExists

	return p
}

func (s *IfNotExistsContext) GetParser() antlr.Parser { return s.parser }

func (s *IfNotExistsContext) KW_IF() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_IF, 0)
}

func (s *IfNotExistsContext) KW_NOT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_NOT, 0)
}

func (s *IfNotExistsContext) KW_EXISTS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_EXISTS, 0)
}

func (s *IfNotExistsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfNotExistsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *IfNotExistsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterIfNotExists(s)
	}
}

func (s *IfNotExistsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitIfNotExists(s)
	}
}

func (s *IfNotExistsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitIfNotExists(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) IfNotExists() (localctx IIfNotExistsContext) {
	localctx = NewIfNotExistsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, HiveParserRULE_ifNotExists)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1207)
		p.Match(HiveParserKW_IF)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1208)
		p.Match(HiveParserKW_NOT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1209)
		p.Match(HiveParserKW_EXISTS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IForceContext is an interface to support dynamic dispatch.
type IForceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_FORCE() antlr.TerminalNode

	// IsForceContext differentiates from other interfaces.
	IsForceContext()
}

type ForceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForceContext() *ForceContext {
	var p = new(ForceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_force
	return p
}

func InitEmptyForceContext(p *ForceContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_force
}

func (*ForceContext) IsForceContext() {}

func NewForceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForceContext {
	var p = new(ForceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_force

	return p
}

func (s *ForceContext) GetParser() antlr.Parser { return s.parser }

func (s *ForceContext) KW_FORCE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_FORCE, 0)
}

func (s *ForceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ForceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterForce(s)
	}
}

func (s *ForceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitForce(s)
	}
}

func (s *ForceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitForce(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) Force() (localctx IForceContext) {
	localctx = NewForceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, HiveParserRULE_force)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1211)
		p.Match(HiveParserKW_FORCE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRewriteEnabledContext is an interface to support dynamic dispatch.
type IRewriteEnabledContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_ENABLE() antlr.TerminalNode
	KW_REWRITE() antlr.TerminalNode

	// IsRewriteEnabledContext differentiates from other interfaces.
	IsRewriteEnabledContext()
}

type RewriteEnabledContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRewriteEnabledContext() *RewriteEnabledContext {
	var p = new(RewriteEnabledContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_rewriteEnabled
	return p
}

func InitEmptyRewriteEnabledContext(p *RewriteEnabledContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_rewriteEnabled
}

func (*RewriteEnabledContext) IsRewriteEnabledContext() {}

func NewRewriteEnabledContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RewriteEnabledContext {
	var p = new(RewriteEnabledContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_rewriteEnabled

	return p
}

func (s *RewriteEnabledContext) GetParser() antlr.Parser { return s.parser }

func (s *RewriteEnabledContext) KW_ENABLE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ENABLE, 0)
}

func (s *RewriteEnabledContext) KW_REWRITE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_REWRITE, 0)
}

func (s *RewriteEnabledContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RewriteEnabledContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *RewriteEnabledContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterRewriteEnabled(s)
	}
}

func (s *RewriteEnabledContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitRewriteEnabled(s)
	}
}

func (s *RewriteEnabledContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitRewriteEnabled(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) RewriteEnabled() (localctx IRewriteEnabledContext) {
	localctx = NewRewriteEnabledContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, HiveParserRULE_rewriteEnabled)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1213)
		p.Match(HiveParserKW_ENABLE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1214)
		p.Match(HiveParserKW_REWRITE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRewriteDisabledContext is an interface to support dynamic dispatch.
type IRewriteDisabledContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_DISABLE() antlr.TerminalNode
	KW_REWRITE() antlr.TerminalNode

	// IsRewriteDisabledContext differentiates from other interfaces.
	IsRewriteDisabledContext()
}

type RewriteDisabledContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRewriteDisabledContext() *RewriteDisabledContext {
	var p = new(RewriteDisabledContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_rewriteDisabled
	return p
}

func InitEmptyRewriteDisabledContext(p *RewriteDisabledContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_rewriteDisabled
}

func (*RewriteDisabledContext) IsRewriteDisabledContext() {}

func NewRewriteDisabledContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RewriteDisabledContext {
	var p = new(RewriteDisabledContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_rewriteDisabled

	return p
}

func (s *RewriteDisabledContext) GetParser() antlr.Parser { return s.parser }

func (s *RewriteDisabledContext) KW_DISABLE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DISABLE, 0)
}

func (s *RewriteDisabledContext) KW_REWRITE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_REWRITE, 0)
}

func (s *RewriteDisabledContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RewriteDisabledContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *RewriteDisabledContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterRewriteDisabled(s)
	}
}

func (s *RewriteDisabledContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitRewriteDisabled(s)
	}
}

func (s *RewriteDisabledContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitRewriteDisabled(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) RewriteDisabled() (localctx IRewriteDisabledContext) {
	localctx = NewRewriteDisabledContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, HiveParserRULE_rewriteDisabled)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1216)
		p.Match(HiveParserKW_DISABLE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1217)
		p.Match(HiveParserKW_REWRITE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IStoredAsDirsContext is an interface to support dynamic dispatch.
type IStoredAsDirsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_STORED() antlr.TerminalNode
	KW_AS() antlr.TerminalNode
	KW_DIRECTORIES() antlr.TerminalNode

	// IsStoredAsDirsContext differentiates from other interfaces.
	IsStoredAsDirsContext()
}

type StoredAsDirsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStoredAsDirsContext() *StoredAsDirsContext {
	var p = new(StoredAsDirsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_storedAsDirs
	return p
}

func InitEmptyStoredAsDirsContext(p *StoredAsDirsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_storedAsDirs
}

func (*StoredAsDirsContext) IsStoredAsDirsContext() {}

func NewStoredAsDirsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StoredAsDirsContext {
	var p = new(StoredAsDirsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_storedAsDirs

	return p
}

func (s *StoredAsDirsContext) GetParser() antlr.Parser { return s.parser }

func (s *StoredAsDirsContext) KW_STORED() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_STORED, 0)
}

func (s *StoredAsDirsContext) KW_AS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_AS, 0)
}

func (s *StoredAsDirsContext) KW_DIRECTORIES() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DIRECTORIES, 0)
}

func (s *StoredAsDirsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StoredAsDirsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *StoredAsDirsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterStoredAsDirs(s)
	}
}

func (s *StoredAsDirsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitStoredAsDirs(s)
	}
}

func (s *StoredAsDirsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitStoredAsDirs(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) StoredAsDirs() (localctx IStoredAsDirsContext) {
	localctx = NewStoredAsDirsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, HiveParserRULE_storedAsDirs)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1219)
		p.Match(HiveParserKW_STORED)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1220)
		p.Match(HiveParserKW_AS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1221)
		p.Match(HiveParserKW_DIRECTORIES)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IOrReplaceContext is an interface to support dynamic dispatch.
type IOrReplaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_OR() antlr.TerminalNode
	KW_REPLACE() antlr.TerminalNode

	// IsOrReplaceContext differentiates from other interfaces.
	IsOrReplaceContext()
}

type OrReplaceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrReplaceContext() *OrReplaceContext {
	var p = new(OrReplaceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_orReplace
	return p
}

func InitEmptyOrReplaceContext(p *OrReplaceContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_orReplace
}

func (*OrReplaceContext) IsOrReplaceContext() {}

func NewOrReplaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrReplaceContext {
	var p = new(OrReplaceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_orReplace

	return p
}

func (s *OrReplaceContext) GetParser() antlr.Parser { return s.parser }

func (s *OrReplaceContext) KW_OR() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_OR, 0)
}

func (s *OrReplaceContext) KW_REPLACE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_REPLACE, 0)
}

func (s *OrReplaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrReplaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OrReplaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterOrReplace(s)
	}
}

func (s *OrReplaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitOrReplace(s)
	}
}

func (s *OrReplaceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitOrReplace(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) OrReplace() (localctx IOrReplaceContext) {
	localctx = NewOrReplaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, HiveParserRULE_orReplace)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1223)
		p.Match(HiveParserKW_OR)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1224)
		p.Match(HiveParserKW_REPLACE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreateDatabaseStatementContext is an interface to support dynamic dispatch.
type ICreateDatabaseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IId_Context

	// GetDbprops returns the dbprops rule contexts.
	GetDbprops() IDbPropertiesContext


	// SetName sets the name rule contexts.
	SetName(IId_Context)

	// SetDbprops sets the dbprops rule contexts.
	SetDbprops(IDbPropertiesContext)


	// Getter signatures
	KW_CREATE() antlr.TerminalNode
	Db_schema() IDb_schemaContext
	Id_() IId_Context
	IfNotExists() IIfNotExistsContext
	DatabaseComment() IDatabaseCommentContext
	DbLocation() IDbLocationContext
	DbManagedLocation() IDbManagedLocationContext
	KW_WITH() antlr.TerminalNode
	KW_DBPROPERTIES() antlr.TerminalNode
	DbProperties() IDbPropertiesContext
	KW_REMOTE() antlr.TerminalNode
	DbConnectorName() IDbConnectorNameContext

	// IsCreateDatabaseStatementContext differentiates from other interfaces.
	IsCreateDatabaseStatementContext()
}

type CreateDatabaseStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name IId_Context 
	dbprops IDbPropertiesContext 
}

func NewEmptyCreateDatabaseStatementContext() *CreateDatabaseStatementContext {
	var p = new(CreateDatabaseStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_createDatabaseStatement
	return p
}

func InitEmptyCreateDatabaseStatementContext(p *CreateDatabaseStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_createDatabaseStatement
}

func (*CreateDatabaseStatementContext) IsCreateDatabaseStatementContext() {}

func NewCreateDatabaseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateDatabaseStatementContext {
	var p = new(CreateDatabaseStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_createDatabaseStatement

	return p
}

func (s *CreateDatabaseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateDatabaseStatementContext) GetName() IId_Context { return s.name }

func (s *CreateDatabaseStatementContext) GetDbprops() IDbPropertiesContext { return s.dbprops }


func (s *CreateDatabaseStatementContext) SetName(v IId_Context) { s.name = v }

func (s *CreateDatabaseStatementContext) SetDbprops(v IDbPropertiesContext) { s.dbprops = v }


func (s *CreateDatabaseStatementContext) KW_CREATE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_CREATE, 0)
}

func (s *CreateDatabaseStatementContext) Db_schema() IDb_schemaContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDb_schemaContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDb_schemaContext)
}

func (s *CreateDatabaseStatementContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *CreateDatabaseStatementContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *CreateDatabaseStatementContext) DatabaseComment() IDatabaseCommentContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatabaseCommentContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatabaseCommentContext)
}

func (s *CreateDatabaseStatementContext) DbLocation() IDbLocationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDbLocationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDbLocationContext)
}

func (s *CreateDatabaseStatementContext) DbManagedLocation() IDbManagedLocationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDbManagedLocationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDbManagedLocationContext)
}

func (s *CreateDatabaseStatementContext) KW_WITH() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_WITH, 0)
}

func (s *CreateDatabaseStatementContext) KW_DBPROPERTIES() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DBPROPERTIES, 0)
}

func (s *CreateDatabaseStatementContext) DbProperties() IDbPropertiesContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDbPropertiesContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDbPropertiesContext)
}

func (s *CreateDatabaseStatementContext) KW_REMOTE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_REMOTE, 0)
}

func (s *CreateDatabaseStatementContext) DbConnectorName() IDbConnectorNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDbConnectorNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDbConnectorNameContext)
}

func (s *CreateDatabaseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateDatabaseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CreateDatabaseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterCreateDatabaseStatement(s)
	}
}

func (s *CreateDatabaseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitCreateDatabaseStatement(s)
	}
}

func (s *CreateDatabaseStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitCreateDatabaseStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) CreateDatabaseStatement() (localctx ICreateDatabaseStatementContext) {
	localctx = NewCreateDatabaseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, HiveParserRULE_createDatabaseStatement)
	var _la int

	p.SetState(1262)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 33, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1226)
			p.Match(HiveParserKW_CREATE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1227)
			p.Db_schema()
		}
		p.SetState(1229)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_IF {
			{
				p.SetState(1228)
				p.IfNotExists()
			}

		}
		{
			p.SetState(1231)

			var _x = p.Id_()


			localctx.(*CreateDatabaseStatementContext).name = _x
		}
		p.SetState(1233)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_COMMENT {
			{
				p.SetState(1232)
				p.DatabaseComment()
			}

		}
		p.SetState(1236)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_LOCATION {
			{
				p.SetState(1235)
				p.DbLocation()
			}

		}
		p.SetState(1239)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_MANAGEDLOCATION {
			{
				p.SetState(1238)
				p.DbManagedLocation()
			}

		}
		p.SetState(1244)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_WITH {
			{
				p.SetState(1241)
				p.Match(HiveParserKW_WITH)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1242)
				p.Match(HiveParserKW_DBPROPERTIES)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1243)

				var _x = p.DbProperties()


				localctx.(*CreateDatabaseStatementContext).dbprops = _x
			}

		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1246)
			p.Match(HiveParserKW_CREATE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1247)
			p.Match(HiveParserKW_REMOTE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1248)
			p.Db_schema()
		}
		p.SetState(1250)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_IF {
			{
				p.SetState(1249)
				p.IfNotExists()
			}

		}
		{
			p.SetState(1252)

			var _x = p.Id_()


			localctx.(*CreateDatabaseStatementContext).name = _x
		}
		p.SetState(1254)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_COMMENT {
			{
				p.SetState(1253)
				p.DatabaseComment()
			}

		}
		{
			p.SetState(1256)
			p.DbConnectorName()
		}
		p.SetState(1260)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_WITH {
			{
				p.SetState(1257)
				p.Match(HiveParserKW_WITH)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1258)
				p.Match(HiveParserKW_DBPROPERTIES)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1259)

				var _x = p.DbProperties()


				localctx.(*CreateDatabaseStatementContext).dbprops = _x
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDbLocationContext is an interface to support dynamic dispatch.
type IDbLocationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLocn returns the locn token.
	GetLocn() antlr.Token 


	// SetLocn sets the locn token.
	SetLocn(antlr.Token) 


	// Getter signatures
	KW_LOCATION() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode

	// IsDbLocationContext differentiates from other interfaces.
	IsDbLocationContext()
}

type DbLocationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	locn antlr.Token
}

func NewEmptyDbLocationContext() *DbLocationContext {
	var p = new(DbLocationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_dbLocation
	return p
}

func InitEmptyDbLocationContext(p *DbLocationContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_dbLocation
}

func (*DbLocationContext) IsDbLocationContext() {}

func NewDbLocationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DbLocationContext {
	var p = new(DbLocationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_dbLocation

	return p
}

func (s *DbLocationContext) GetParser() antlr.Parser { return s.parser }

func (s *DbLocationContext) GetLocn() antlr.Token { return s.locn }


func (s *DbLocationContext) SetLocn(v antlr.Token) { s.locn = v }


func (s *DbLocationContext) KW_LOCATION() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_LOCATION, 0)
}

func (s *DbLocationContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(HiveParserStringLiteral, 0)
}

func (s *DbLocationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DbLocationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DbLocationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterDbLocation(s)
	}
}

func (s *DbLocationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitDbLocation(s)
	}
}

func (s *DbLocationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitDbLocation(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) DbLocation() (localctx IDbLocationContext) {
	localctx = NewDbLocationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, HiveParserRULE_dbLocation)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1264)
		p.Match(HiveParserKW_LOCATION)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1265)

		var _m = p.Match(HiveParserStringLiteral)

		localctx.(*DbLocationContext).locn = _m
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDbManagedLocationContext is an interface to support dynamic dispatch.
type IDbManagedLocationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLocn returns the locn token.
	GetLocn() antlr.Token 


	// SetLocn sets the locn token.
	SetLocn(antlr.Token) 


	// Getter signatures
	KW_MANAGEDLOCATION() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode

	// IsDbManagedLocationContext differentiates from other interfaces.
	IsDbManagedLocationContext()
}

type DbManagedLocationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	locn antlr.Token
}

func NewEmptyDbManagedLocationContext() *DbManagedLocationContext {
	var p = new(DbManagedLocationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_dbManagedLocation
	return p
}

func InitEmptyDbManagedLocationContext(p *DbManagedLocationContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_dbManagedLocation
}

func (*DbManagedLocationContext) IsDbManagedLocationContext() {}

func NewDbManagedLocationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DbManagedLocationContext {
	var p = new(DbManagedLocationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_dbManagedLocation

	return p
}

func (s *DbManagedLocationContext) GetParser() antlr.Parser { return s.parser }

func (s *DbManagedLocationContext) GetLocn() antlr.Token { return s.locn }


func (s *DbManagedLocationContext) SetLocn(v antlr.Token) { s.locn = v }


func (s *DbManagedLocationContext) KW_MANAGEDLOCATION() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_MANAGEDLOCATION, 0)
}

func (s *DbManagedLocationContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(HiveParserStringLiteral, 0)
}

func (s *DbManagedLocationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DbManagedLocationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DbManagedLocationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterDbManagedLocation(s)
	}
}

func (s *DbManagedLocationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitDbManagedLocation(s)
	}
}

func (s *DbManagedLocationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitDbManagedLocation(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) DbManagedLocation() (localctx IDbManagedLocationContext) {
	localctx = NewDbManagedLocationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, HiveParserRULE_dbManagedLocation)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1267)
		p.Match(HiveParserKW_MANAGEDLOCATION)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1268)

		var _m = p.Match(HiveParserStringLiteral)

		localctx.(*DbManagedLocationContext).locn = _m
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDbPropertiesContext is an interface to support dynamic dispatch.
type IDbPropertiesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	DbPropertiesList() IDbPropertiesListContext
	RPAREN() antlr.TerminalNode

	// IsDbPropertiesContext differentiates from other interfaces.
	IsDbPropertiesContext()
}

type DbPropertiesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDbPropertiesContext() *DbPropertiesContext {
	var p = new(DbPropertiesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_dbProperties
	return p
}

func InitEmptyDbPropertiesContext(p *DbPropertiesContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_dbProperties
}

func (*DbPropertiesContext) IsDbPropertiesContext() {}

func NewDbPropertiesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DbPropertiesContext {
	var p = new(DbPropertiesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_dbProperties

	return p
}

func (s *DbPropertiesContext) GetParser() antlr.Parser { return s.parser }

func (s *DbPropertiesContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserLPAREN, 0)
}

func (s *DbPropertiesContext) DbPropertiesList() IDbPropertiesListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDbPropertiesListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDbPropertiesListContext)
}

func (s *DbPropertiesContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserRPAREN, 0)
}

func (s *DbPropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DbPropertiesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DbPropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterDbProperties(s)
	}
}

func (s *DbPropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitDbProperties(s)
	}
}

func (s *DbPropertiesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitDbProperties(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) DbProperties() (localctx IDbPropertiesContext) {
	localctx = NewDbPropertiesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, HiveParserRULE_dbProperties)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1270)
		p.Match(HiveParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1271)
		p.DbPropertiesList()
	}
	{
		p.SetState(1272)
		p.Match(HiveParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDbPropertiesListContext is an interface to support dynamic dispatch.
type IDbPropertiesListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllKeyValueProperty() []IKeyValuePropertyContext
	KeyValueProperty(i int) IKeyValuePropertyContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsDbPropertiesListContext differentiates from other interfaces.
	IsDbPropertiesListContext()
}

type DbPropertiesListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDbPropertiesListContext() *DbPropertiesListContext {
	var p = new(DbPropertiesListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_dbPropertiesList
	return p
}

func InitEmptyDbPropertiesListContext(p *DbPropertiesListContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_dbPropertiesList
}

func (*DbPropertiesListContext) IsDbPropertiesListContext() {}

func NewDbPropertiesListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DbPropertiesListContext {
	var p = new(DbPropertiesListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_dbPropertiesList

	return p
}

func (s *DbPropertiesListContext) GetParser() antlr.Parser { return s.parser }

func (s *DbPropertiesListContext) AllKeyValueProperty() []IKeyValuePropertyContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IKeyValuePropertyContext); ok {
			len++
		}
	}

	tst := make([]IKeyValuePropertyContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IKeyValuePropertyContext); ok {
			tst[i] = t.(IKeyValuePropertyContext)
			i++
		}
	}

	return tst
}

func (s *DbPropertiesListContext) KeyValueProperty(i int) IKeyValuePropertyContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyValuePropertyContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyValuePropertyContext)
}

func (s *DbPropertiesListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(HiveParserCOMMA)
}

func (s *DbPropertiesListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserCOMMA, i)
}

func (s *DbPropertiesListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DbPropertiesListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DbPropertiesListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterDbPropertiesList(s)
	}
}

func (s *DbPropertiesListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitDbPropertiesList(s)
	}
}

func (s *DbPropertiesListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitDbPropertiesList(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) DbPropertiesList() (localctx IDbPropertiesListContext) {
	localctx = NewDbPropertiesListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, HiveParserRULE_dbPropertiesList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1274)
		p.KeyValueProperty()
	}
	p.SetState(1279)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HiveParserCOMMA {
		{
			p.SetState(1275)
			p.Match(HiveParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1276)
			p.KeyValueProperty()
		}


		p.SetState(1281)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDbConnectorNameContext is an interface to support dynamic dispatch.
type IDbConnectorNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDcName returns the dcName rule contexts.
	GetDcName() IId_Context


	// SetDcName sets the dcName rule contexts.
	SetDcName(IId_Context)


	// Getter signatures
	KW_USING() antlr.TerminalNode
	Id_() IId_Context

	// IsDbConnectorNameContext differentiates from other interfaces.
	IsDbConnectorNameContext()
}

type DbConnectorNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	dcName IId_Context 
}

func NewEmptyDbConnectorNameContext() *DbConnectorNameContext {
	var p = new(DbConnectorNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_dbConnectorName
	return p
}

func InitEmptyDbConnectorNameContext(p *DbConnectorNameContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_dbConnectorName
}

func (*DbConnectorNameContext) IsDbConnectorNameContext() {}

func NewDbConnectorNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DbConnectorNameContext {
	var p = new(DbConnectorNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_dbConnectorName

	return p
}

func (s *DbConnectorNameContext) GetParser() antlr.Parser { return s.parser }

func (s *DbConnectorNameContext) GetDcName() IId_Context { return s.dcName }


func (s *DbConnectorNameContext) SetDcName(v IId_Context) { s.dcName = v }


func (s *DbConnectorNameContext) KW_USING() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_USING, 0)
}

func (s *DbConnectorNameContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *DbConnectorNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DbConnectorNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DbConnectorNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterDbConnectorName(s)
	}
}

func (s *DbConnectorNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitDbConnectorName(s)
	}
}

func (s *DbConnectorNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitDbConnectorName(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) DbConnectorName() (localctx IDbConnectorNameContext) {
	localctx = NewDbConnectorNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, HiveParserRULE_dbConnectorName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1282)
		p.Match(HiveParserKW_USING)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1283)

		var _x = p.Id_()


		localctx.(*DbConnectorNameContext).dcName = _x
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISwitchDatabaseStatementContext is an interface to support dynamic dispatch.
type ISwitchDatabaseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_USE() antlr.TerminalNode
	Id_() IId_Context

	// IsSwitchDatabaseStatementContext differentiates from other interfaces.
	IsSwitchDatabaseStatementContext()
}

type SwitchDatabaseStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitchDatabaseStatementContext() *SwitchDatabaseStatementContext {
	var p = new(SwitchDatabaseStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_switchDatabaseStatement
	return p
}

func InitEmptySwitchDatabaseStatementContext(p *SwitchDatabaseStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_switchDatabaseStatement
}

func (*SwitchDatabaseStatementContext) IsSwitchDatabaseStatementContext() {}

func NewSwitchDatabaseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwitchDatabaseStatementContext {
	var p = new(SwitchDatabaseStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_switchDatabaseStatement

	return p
}

func (s *SwitchDatabaseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SwitchDatabaseStatementContext) KW_USE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_USE, 0)
}

func (s *SwitchDatabaseStatementContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *SwitchDatabaseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchDatabaseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SwitchDatabaseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterSwitchDatabaseStatement(s)
	}
}

func (s *SwitchDatabaseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitSwitchDatabaseStatement(s)
	}
}

func (s *SwitchDatabaseStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitSwitchDatabaseStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) SwitchDatabaseStatement() (localctx ISwitchDatabaseStatementContext) {
	localctx = NewSwitchDatabaseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, HiveParserRULE_switchDatabaseStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1285)
		p.Match(HiveParserKW_USE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1286)
		p.Id_()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDropDatabaseStatementContext is an interface to support dynamic dispatch.
type IDropDatabaseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_DROP() antlr.TerminalNode
	Db_schema() IDb_schemaContext
	Id_() IId_Context
	IfExists() IIfExistsContext
	RestrictOrCascade() IRestrictOrCascadeContext

	// IsDropDatabaseStatementContext differentiates from other interfaces.
	IsDropDatabaseStatementContext()
}

type DropDatabaseStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropDatabaseStatementContext() *DropDatabaseStatementContext {
	var p = new(DropDatabaseStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_dropDatabaseStatement
	return p
}

func InitEmptyDropDatabaseStatementContext(p *DropDatabaseStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_dropDatabaseStatement
}

func (*DropDatabaseStatementContext) IsDropDatabaseStatementContext() {}

func NewDropDatabaseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropDatabaseStatementContext {
	var p = new(DropDatabaseStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_dropDatabaseStatement

	return p
}

func (s *DropDatabaseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropDatabaseStatementContext) KW_DROP() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DROP, 0)
}

func (s *DropDatabaseStatementContext) Db_schema() IDb_schemaContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDb_schemaContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDb_schemaContext)
}

func (s *DropDatabaseStatementContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *DropDatabaseStatementContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropDatabaseStatementContext) RestrictOrCascade() IRestrictOrCascadeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRestrictOrCascadeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRestrictOrCascadeContext)
}

func (s *DropDatabaseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropDatabaseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DropDatabaseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterDropDatabaseStatement(s)
	}
}

func (s *DropDatabaseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitDropDatabaseStatement(s)
	}
}

func (s *DropDatabaseStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitDropDatabaseStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) DropDatabaseStatement() (localctx IDropDatabaseStatementContext) {
	localctx = NewDropDatabaseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, HiveParserRULE_dropDatabaseStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1288)
		p.Match(HiveParserKW_DROP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1289)
		p.Db_schema()
	}
	p.SetState(1291)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_IF {
		{
			p.SetState(1290)
			p.IfExists()
		}

	}
	{
		p.SetState(1293)
		p.Id_()
	}
	p.SetState(1295)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_CASCADE || _la == HiveParserKW_RESTRICT {
		{
			p.SetState(1294)
			p.RestrictOrCascade()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDatabaseCommentContext is an interface to support dynamic dispatch.
type IDatabaseCommentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetComment returns the comment token.
	GetComment() antlr.Token 


	// SetComment sets the comment token.
	SetComment(antlr.Token) 


	// Getter signatures
	KW_COMMENT() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode

	// IsDatabaseCommentContext differentiates from other interfaces.
	IsDatabaseCommentContext()
}

type DatabaseCommentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	comment antlr.Token
}

func NewEmptyDatabaseCommentContext() *DatabaseCommentContext {
	var p = new(DatabaseCommentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_databaseComment
	return p
}

func InitEmptyDatabaseCommentContext(p *DatabaseCommentContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_databaseComment
}

func (*DatabaseCommentContext) IsDatabaseCommentContext() {}

func NewDatabaseCommentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DatabaseCommentContext {
	var p = new(DatabaseCommentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_databaseComment

	return p
}

func (s *DatabaseCommentContext) GetParser() antlr.Parser { return s.parser }

func (s *DatabaseCommentContext) GetComment() antlr.Token { return s.comment }


func (s *DatabaseCommentContext) SetComment(v antlr.Token) { s.comment = v }


func (s *DatabaseCommentContext) KW_COMMENT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_COMMENT, 0)
}

func (s *DatabaseCommentContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(HiveParserStringLiteral, 0)
}

func (s *DatabaseCommentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DatabaseCommentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DatabaseCommentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterDatabaseComment(s)
	}
}

func (s *DatabaseCommentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitDatabaseComment(s)
	}
}

func (s *DatabaseCommentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitDatabaseComment(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) DatabaseComment() (localctx IDatabaseCommentContext) {
	localctx = NewDatabaseCommentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, HiveParserRULE_databaseComment)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1297)
		p.Match(HiveParserKW_COMMENT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1298)

		var _m = p.Match(HiveParserStringLiteral)

		localctx.(*DatabaseCommentContext).comment = _m
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITruncateTableStatementContext is an interface to support dynamic dispatch.
type ITruncateTableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_TRUNCATE() antlr.TerminalNode
	TablePartitionPrefix() ITablePartitionPrefixContext
	KW_TABLE() antlr.TerminalNode
	KW_COLUMNS() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	ColumnNameList() IColumnNameListContext
	RPAREN() antlr.TerminalNode
	Force() IForceContext

	// IsTruncateTableStatementContext differentiates from other interfaces.
	IsTruncateTableStatementContext()
}

type TruncateTableStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTruncateTableStatementContext() *TruncateTableStatementContext {
	var p = new(TruncateTableStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_truncateTableStatement
	return p
}

func InitEmptyTruncateTableStatementContext(p *TruncateTableStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_truncateTableStatement
}

func (*TruncateTableStatementContext) IsTruncateTableStatementContext() {}

func NewTruncateTableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TruncateTableStatementContext {
	var p = new(TruncateTableStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_truncateTableStatement

	return p
}

func (s *TruncateTableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TruncateTableStatementContext) KW_TRUNCATE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TRUNCATE, 0)
}

func (s *TruncateTableStatementContext) TablePartitionPrefix() ITablePartitionPrefixContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablePartitionPrefixContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablePartitionPrefixContext)
}

func (s *TruncateTableStatementContext) KW_TABLE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TABLE, 0)
}

func (s *TruncateTableStatementContext) KW_COLUMNS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_COLUMNS, 0)
}

func (s *TruncateTableStatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserLPAREN, 0)
}

func (s *TruncateTableStatementContext) ColumnNameList() IColumnNameListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNameListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNameListContext)
}

func (s *TruncateTableStatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserRPAREN, 0)
}

func (s *TruncateTableStatementContext) Force() IForceContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForceContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForceContext)
}

func (s *TruncateTableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TruncateTableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TruncateTableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterTruncateTableStatement(s)
	}
}

func (s *TruncateTableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitTruncateTableStatement(s)
	}
}

func (s *TruncateTableStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitTruncateTableStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) TruncateTableStatement() (localctx ITruncateTableStatementContext) {
	localctx = NewTruncateTableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, HiveParserRULE_truncateTableStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1300)
		p.Match(HiveParserKW_TRUNCATE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1302)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_TABLE {
		{
			p.SetState(1301)
			p.Match(HiveParserKW_TABLE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(1304)
		p.TablePartitionPrefix()
	}
	p.SetState(1310)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_COLUMNS {
		{
			p.SetState(1305)
			p.Match(HiveParserKW_COLUMNS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1306)
			p.Match(HiveParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1307)
			p.ColumnNameList()
		}
		{
			p.SetState(1308)
			p.Match(HiveParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	p.SetState(1313)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_FORCE {
		{
			p.SetState(1312)
			p.Force()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDropTableStatementContext is an interface to support dynamic dispatch.
type IDropTableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_DROP() antlr.TerminalNode
	KW_TABLE() antlr.TerminalNode
	TableName() ITableNameContext
	IfExists() IIfExistsContext
	KW_PURGE() antlr.TerminalNode
	ReplicationClause() IReplicationClauseContext

	// IsDropTableStatementContext differentiates from other interfaces.
	IsDropTableStatementContext()
}

type DropTableStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropTableStatementContext() *DropTableStatementContext {
	var p = new(DropTableStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_dropTableStatement
	return p
}

func InitEmptyDropTableStatementContext(p *DropTableStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_dropTableStatement
}

func (*DropTableStatementContext) IsDropTableStatementContext() {}

func NewDropTableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropTableStatementContext {
	var p = new(DropTableStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_dropTableStatement

	return p
}

func (s *DropTableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropTableStatementContext) KW_DROP() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DROP, 0)
}

func (s *DropTableStatementContext) KW_TABLE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TABLE, 0)
}

func (s *DropTableStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *DropTableStatementContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropTableStatementContext) KW_PURGE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_PURGE, 0)
}

func (s *DropTableStatementContext) ReplicationClause() IReplicationClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplicationClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplicationClauseContext)
}

func (s *DropTableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropTableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DropTableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterDropTableStatement(s)
	}
}

func (s *DropTableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitDropTableStatement(s)
	}
}

func (s *DropTableStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitDropTableStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) DropTableStatement() (localctx IDropTableStatementContext) {
	localctx = NewDropTableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, HiveParserRULE_dropTableStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1315)
		p.Match(HiveParserKW_DROP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1316)
		p.Match(HiveParserKW_TABLE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1318)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_IF {
		{
			p.SetState(1317)
			p.IfExists()
		}

	}
	{
		p.SetState(1320)
		p.TableName()
	}
	p.SetState(1322)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_PURGE {
		{
			p.SetState(1321)
			p.Match(HiveParserKW_PURGE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	p.SetState(1325)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_FOR {
		{
			p.SetState(1324)
			p.ReplicationClause()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IInputFileFormatContext is an interface to support dynamic dispatch.
type IInputFileFormatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetInFmt returns the inFmt token.
	GetInFmt() antlr.Token 

	// GetSerdeCls returns the serdeCls token.
	GetSerdeCls() antlr.Token 


	// SetInFmt sets the inFmt token.
	SetInFmt(antlr.Token) 

	// SetSerdeCls sets the serdeCls token.
	SetSerdeCls(antlr.Token) 


	// Getter signatures
	KW_INPUTFORMAT() antlr.TerminalNode
	KW_SERDE() antlr.TerminalNode
	AllStringLiteral() []antlr.TerminalNode
	StringLiteral(i int) antlr.TerminalNode

	// IsInputFileFormatContext differentiates from other interfaces.
	IsInputFileFormatContext()
}

type InputFileFormatContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	inFmt antlr.Token
	serdeCls antlr.Token
}

func NewEmptyInputFileFormatContext() *InputFileFormatContext {
	var p = new(InputFileFormatContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_inputFileFormat
	return p
}

func InitEmptyInputFileFormatContext(p *InputFileFormatContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_inputFileFormat
}

func (*InputFileFormatContext) IsInputFileFormatContext() {}

func NewInputFileFormatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InputFileFormatContext {
	var p = new(InputFileFormatContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_inputFileFormat

	return p
}

func (s *InputFileFormatContext) GetParser() antlr.Parser { return s.parser }

func (s *InputFileFormatContext) GetInFmt() antlr.Token { return s.inFmt }

func (s *InputFileFormatContext) GetSerdeCls() antlr.Token { return s.serdeCls }


func (s *InputFileFormatContext) SetInFmt(v antlr.Token) { s.inFmt = v }

func (s *InputFileFormatContext) SetSerdeCls(v antlr.Token) { s.serdeCls = v }


func (s *InputFileFormatContext) KW_INPUTFORMAT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_INPUTFORMAT, 0)
}

func (s *InputFileFormatContext) KW_SERDE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SERDE, 0)
}

func (s *InputFileFormatContext) AllStringLiteral() []antlr.TerminalNode {
	return s.GetTokens(HiveParserStringLiteral)
}

func (s *InputFileFormatContext) StringLiteral(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserStringLiteral, i)
}

func (s *InputFileFormatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InputFileFormatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *InputFileFormatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterInputFileFormat(s)
	}
}

func (s *InputFileFormatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitInputFileFormat(s)
	}
}

func (s *InputFileFormatContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitInputFileFormat(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) InputFileFormat() (localctx IInputFileFormatContext) {
	localctx = NewInputFileFormatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, HiveParserRULE_inputFileFormat)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1327)
		p.Match(HiveParserKW_INPUTFORMAT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1328)

		var _m = p.Match(HiveParserStringLiteral)

		localctx.(*InputFileFormatContext).inFmt = _m
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1329)
		p.Match(HiveParserKW_SERDE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1330)

		var _m = p.Match(HiveParserStringLiteral)

		localctx.(*InputFileFormatContext).serdeCls = _m
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITabTypeExprContext is an interface to support dynamic dispatch.
type ITabTypeExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllId_() []IId_Context
	Id_(i int) IId_Context
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode
	AllKW_ELEM_TYPE() []antlr.TerminalNode
	KW_ELEM_TYPE(i int) antlr.TerminalNode
	AllKW_KEY_TYPE() []antlr.TerminalNode
	KW_KEY_TYPE(i int) antlr.TerminalNode
	AllKW_VALUE_TYPE() []antlr.TerminalNode
	KW_VALUE_TYPE(i int) antlr.TerminalNode

	// IsTabTypeExprContext differentiates from other interfaces.
	IsTabTypeExprContext()
}

type TabTypeExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTabTypeExprContext() *TabTypeExprContext {
	var p = new(TabTypeExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_tabTypeExpr
	return p
}

func InitEmptyTabTypeExprContext(p *TabTypeExprContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_tabTypeExpr
}

func (*TabTypeExprContext) IsTabTypeExprContext() {}

func NewTabTypeExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TabTypeExprContext {
	var p = new(TabTypeExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_tabTypeExpr

	return p
}

func (s *TabTypeExprContext) GetParser() antlr.Parser { return s.parser }

func (s *TabTypeExprContext) AllId_() []IId_Context {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IId_Context); ok {
			len++
		}
	}

	tst := make([]IId_Context, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IId_Context); ok {
			tst[i] = t.(IId_Context)
			i++
		}
	}

	return tst
}

func (s *TabTypeExprContext) Id_(i int) IId_Context {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *TabTypeExprContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(HiveParserDOT)
}

func (s *TabTypeExprContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserDOT, i)
}

func (s *TabTypeExprContext) AllKW_ELEM_TYPE() []antlr.TerminalNode {
	return s.GetTokens(HiveParserKW_ELEM_TYPE)
}

func (s *TabTypeExprContext) KW_ELEM_TYPE(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ELEM_TYPE, i)
}

func (s *TabTypeExprContext) AllKW_KEY_TYPE() []antlr.TerminalNode {
	return s.GetTokens(HiveParserKW_KEY_TYPE)
}

func (s *TabTypeExprContext) KW_KEY_TYPE(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserKW_KEY_TYPE, i)
}

func (s *TabTypeExprContext) AllKW_VALUE_TYPE() []antlr.TerminalNode {
	return s.GetTokens(HiveParserKW_VALUE_TYPE)
}

func (s *TabTypeExprContext) KW_VALUE_TYPE(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserKW_VALUE_TYPE, i)
}

func (s *TabTypeExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TabTypeExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TabTypeExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterTabTypeExpr(s)
	}
}

func (s *TabTypeExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitTabTypeExpr(s)
	}
}

func (s *TabTypeExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitTabTypeExpr(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) TabTypeExpr() (localctx ITabTypeExprContext) {
	localctx = NewTabTypeExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, HiveParserRULE_tabTypeExpr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1332)
		p.Id_()
	}
	p.SetState(1335)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserDOT {
		{
			p.SetState(1333)
			p.Match(HiveParserDOT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1334)
			p.Id_()
		}

	}
	p.SetState(1350)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 46, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1337)
			p.Id_()
		}
		p.SetState(1347)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == HiveParserDOT {
			{
				p.SetState(1338)
				p.Match(HiveParserDOT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			p.SetState(1343)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 44, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(1339)
					p.Match(HiveParserKW_ELEM_TYPE)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}


			case 2:
				{
					p.SetState(1340)
					p.Match(HiveParserKW_KEY_TYPE)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}


			case 3:
				{
					p.SetState(1341)
					p.Match(HiveParserKW_VALUE_TYPE)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}


			case 4:
				{
					p.SetState(1342)
					p.Id_()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}


			p.SetState(1349)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPartTypeExprContext is an interface to support dynamic dispatch.
type IPartTypeExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TabTypeExpr() ITabTypeExprContext
	PartitionSpec() IPartitionSpecContext

	// IsPartTypeExprContext differentiates from other interfaces.
	IsPartTypeExprContext()
}

type PartTypeExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartTypeExprContext() *PartTypeExprContext {
	var p = new(PartTypeExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_partTypeExpr
	return p
}

func InitEmptyPartTypeExprContext(p *PartTypeExprContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_partTypeExpr
}

func (*PartTypeExprContext) IsPartTypeExprContext() {}

func NewPartTypeExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartTypeExprContext {
	var p = new(PartTypeExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_partTypeExpr

	return p
}

func (s *PartTypeExprContext) GetParser() antlr.Parser { return s.parser }

func (s *PartTypeExprContext) TabTypeExpr() ITabTypeExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITabTypeExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITabTypeExprContext)
}

func (s *PartTypeExprContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *PartTypeExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartTypeExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PartTypeExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterPartTypeExpr(s)
	}
}

func (s *PartTypeExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitPartTypeExpr(s)
	}
}

func (s *PartTypeExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitPartTypeExpr(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) PartTypeExpr() (localctx IPartTypeExprContext) {
	localctx = NewPartTypeExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, HiveParserRULE_partTypeExpr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1352)
		p.TabTypeExpr()
	}
	p.SetState(1354)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_PARTITION {
		{
			p.SetState(1353)
			p.PartitionSpec()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITabPartColTypeExprContext is an interface to support dynamic dispatch.
type ITabPartColTypeExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TableName() ITableNameContext
	PartitionSpec() IPartitionSpecContext
	ExtColumnName() IExtColumnNameContext

	// IsTabPartColTypeExprContext differentiates from other interfaces.
	IsTabPartColTypeExprContext()
}

type TabPartColTypeExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTabPartColTypeExprContext() *TabPartColTypeExprContext {
	var p = new(TabPartColTypeExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_tabPartColTypeExpr
	return p
}

func InitEmptyTabPartColTypeExprContext(p *TabPartColTypeExprContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_tabPartColTypeExpr
}

func (*TabPartColTypeExprContext) IsTabPartColTypeExprContext() {}

func NewTabPartColTypeExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TabPartColTypeExprContext {
	var p = new(TabPartColTypeExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_tabPartColTypeExpr

	return p
}

func (s *TabPartColTypeExprContext) GetParser() antlr.Parser { return s.parser }

func (s *TabPartColTypeExprContext) TableName() ITableNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *TabPartColTypeExprContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *TabPartColTypeExprContext) ExtColumnName() IExtColumnNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExtColumnNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExtColumnNameContext)
}

func (s *TabPartColTypeExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TabPartColTypeExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TabPartColTypeExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterTabPartColTypeExpr(s)
	}
}

func (s *TabPartColTypeExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitTabPartColTypeExpr(s)
	}
}

func (s *TabPartColTypeExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitTabPartColTypeExpr(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) TabPartColTypeExpr() (localctx ITabPartColTypeExprContext) {
	localctx = NewTabPartColTypeExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, HiveParserRULE_tabPartColTypeExpr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1356)
		p.TableName()
	}
	p.SetState(1358)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_PARTITION {
		{
			p.SetState(1357)
			p.PartitionSpec()
		}

	}
	p.SetState(1361)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 808078815591695742) != 0) || ((int64((_la - 66)) & ^0x3f) == 0 && ((int64(1) << (_la - 66)) & 1083038567331911621) != 0) || ((int64((_la - 132)) & ^0x3f) == 0 && ((int64(1) << (_la - 132)) & 8916819943869537315) != 0) || ((int64((_la - 196)) & ^0x3f) == 0 && ((int64(1) << (_la - 196)) & 4159991143015340909) != 0) || ((int64((_la - 261)) & ^0x3f) == 0 && ((int64(1) << (_la - 261)) & 8484708576009596927) != 0) || ((int64((_la - 328)) & ^0x3f) == 0 && ((int64(1) << (_la - 328)) & 17776728909112555) != 0) || _la == HiveParserIdentifier {
		{
			p.SetState(1360)
			p.ExtColumnName()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDescStatementContext is an interface to support dynamic dispatch.
type IDescStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDescOptions returns the descOptions token.
	GetDescOptions() antlr.Token 


	// SetDescOptions sets the descOptions token.
	SetDescOptions(antlr.Token) 


	// GetDbName returns the dbName rule contexts.
	GetDbName() IId_Context

	// GetDcName returns the dcName rule contexts.
	GetDcName() IId_Context

	// GetName returns the name rule contexts.
	GetName() IDescFuncNamesContext

	// GetParttype returns the parttype rule contexts.
	GetParttype() ITabPartColTypeExprContext


	// SetDbName sets the dbName rule contexts.
	SetDbName(IId_Context)

	// SetDcName sets the dcName rule contexts.
	SetDcName(IId_Context)

	// SetName sets the name rule contexts.
	SetName(IDescFuncNamesContext)

	// SetParttype sets the parttype rule contexts.
	SetParttype(ITabPartColTypeExprContext)


	// Getter signatures
	KW_DESCRIBE() antlr.TerminalNode
	KW_DESC() antlr.TerminalNode
	Db_schema() IDb_schemaContext
	KW_DATACONNECTOR() antlr.TerminalNode
	KW_FUNCTION() antlr.TerminalNode
	Id_() IId_Context
	DescFuncNames() IDescFuncNamesContext
	TabPartColTypeExpr() ITabPartColTypeExprContext
	KW_EXTENDED() antlr.TerminalNode
	KW_FORMATTED() antlr.TerminalNode

	// IsDescStatementContext differentiates from other interfaces.
	IsDescStatementContext()
}

type DescStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	dbName IId_Context 
	dcName IId_Context 
	name IDescFuncNamesContext 
	descOptions antlr.Token
	parttype ITabPartColTypeExprContext 
}

func NewEmptyDescStatementContext() *DescStatementContext {
	var p = new(DescStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_descStatement
	return p
}

func InitEmptyDescStatementContext(p *DescStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_descStatement
}

func (*DescStatementContext) IsDescStatementContext() {}

func NewDescStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DescStatementContext {
	var p = new(DescStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_descStatement

	return p
}

func (s *DescStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DescStatementContext) GetDescOptions() antlr.Token { return s.descOptions }


func (s *DescStatementContext) SetDescOptions(v antlr.Token) { s.descOptions = v }


func (s *DescStatementContext) GetDbName() IId_Context { return s.dbName }

func (s *DescStatementContext) GetDcName() IId_Context { return s.dcName }

func (s *DescStatementContext) GetName() IDescFuncNamesContext { return s.name }

func (s *DescStatementContext) GetParttype() ITabPartColTypeExprContext { return s.parttype }


func (s *DescStatementContext) SetDbName(v IId_Context) { s.dbName = v }

func (s *DescStatementContext) SetDcName(v IId_Context) { s.dcName = v }

func (s *DescStatementContext) SetName(v IDescFuncNamesContext) { s.name = v }

func (s *DescStatementContext) SetParttype(v ITabPartColTypeExprContext) { s.parttype = v }


func (s *DescStatementContext) KW_DESCRIBE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DESCRIBE, 0)
}

func (s *DescStatementContext) KW_DESC() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DESC, 0)
}

func (s *DescStatementContext) Db_schema() IDb_schemaContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDb_schemaContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDb_schemaContext)
}

func (s *DescStatementContext) KW_DATACONNECTOR() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DATACONNECTOR, 0)
}

func (s *DescStatementContext) KW_FUNCTION() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_FUNCTION, 0)
}

func (s *DescStatementContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *DescStatementContext) DescFuncNames() IDescFuncNamesContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDescFuncNamesContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDescFuncNamesContext)
}

func (s *DescStatementContext) TabPartColTypeExpr() ITabPartColTypeExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITabPartColTypeExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITabPartColTypeExprContext)
}

func (s *DescStatementContext) KW_EXTENDED() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_EXTENDED, 0)
}

func (s *DescStatementContext) KW_FORMATTED() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_FORMATTED, 0)
}

func (s *DescStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DescStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterDescStatement(s)
	}
}

func (s *DescStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitDescStatement(s)
	}
}

func (s *DescStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitDescStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) DescStatement() (localctx IDescStatementContext) {
	localctx = NewDescStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, HiveParserRULE_descStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1363)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HiveParserKW_DESC || _la == HiveParserKW_DESCRIBE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1386)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 54, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1364)
			p.Db_schema()
		}
		p.SetState(1366)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_EXTENDED {
			{
				p.SetState(1365)
				p.Match(HiveParserKW_EXTENDED)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1368)

			var _x = p.Id_()


			localctx.(*DescStatementContext).dbName = _x
		}


	case 2:
		{
			p.SetState(1370)
			p.Match(HiveParserKW_DATACONNECTOR)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1372)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_EXTENDED {
			{
				p.SetState(1371)
				p.Match(HiveParserKW_EXTENDED)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1374)

			var _x = p.Id_()


			localctx.(*DescStatementContext).dcName = _x
		}


	case 3:
		{
			p.SetState(1375)
			p.Match(HiveParserKW_FUNCTION)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1377)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_EXTENDED {
			{
				p.SetState(1376)
				p.Match(HiveParserKW_EXTENDED)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1379)

			var _x = p.DescFuncNames()


			localctx.(*DescStatementContext).name = _x
		}


	case 4:
		p.SetState(1382)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case HiveParserKW_FORMATTED:
			{
				p.SetState(1380)

				var _m = p.Match(HiveParserKW_FORMATTED)

				localctx.(*DescStatementContext).descOptions = _m
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


		case HiveParserKW_EXTENDED:
			{
				p.SetState(1381)

				var _m = p.Match(HiveParserKW_EXTENDED)

				localctx.(*DescStatementContext).descOptions = _m
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}



		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(1384)

			var _x = p.TabPartColTypeExpr()


			localctx.(*DescStatementContext).parttype = _x
		}


	case 5:
		{
			p.SetState(1385)

			var _x = p.TabPartColTypeExpr()


			localctx.(*DescStatementContext).parttype = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAnalyzeStatementContext is an interface to support dynamic dispatch.
type IAnalyzeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetNoscan returns the noscan token.
	GetNoscan() antlr.Token 


	// SetNoscan sets the noscan token.
	SetNoscan(antlr.Token) 


	// GetParttype returns the parttype rule contexts.
	GetParttype() ITableOrPartitionContext

	// GetStatsColumnName returns the statsColumnName rule contexts.
	GetStatsColumnName() IColumnNameListContext


	// SetParttype sets the parttype rule contexts.
	SetParttype(ITableOrPartitionContext)

	// SetStatsColumnName sets the statsColumnName rule contexts.
	SetStatsColumnName(IColumnNameListContext)


	// Getter signatures
	KW_ANALYZE() antlr.TerminalNode
	KW_TABLE() antlr.TerminalNode
	TableOrPartition() ITableOrPartitionContext
	KW_COMPUTE() antlr.TerminalNode
	KW_STATISTICS() antlr.TerminalNode
	KW_CACHE() antlr.TerminalNode
	KW_METADATA() antlr.TerminalNode
	KW_FOR() antlr.TerminalNode
	KW_COLUMNS() antlr.TerminalNode
	KW_NOSCAN() antlr.TerminalNode
	ColumnNameList() IColumnNameListContext

	// IsAnalyzeStatementContext differentiates from other interfaces.
	IsAnalyzeStatementContext()
}

type AnalyzeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	parttype ITableOrPartitionContext 
	noscan antlr.Token
	statsColumnName IColumnNameListContext 
}

func NewEmptyAnalyzeStatementContext() *AnalyzeStatementContext {
	var p = new(AnalyzeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_analyzeStatement
	return p
}

func InitEmptyAnalyzeStatementContext(p *AnalyzeStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_analyzeStatement
}

func (*AnalyzeStatementContext) IsAnalyzeStatementContext() {}

func NewAnalyzeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnalyzeStatementContext {
	var p = new(AnalyzeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_analyzeStatement

	return p
}

func (s *AnalyzeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AnalyzeStatementContext) GetNoscan() antlr.Token { return s.noscan }


func (s *AnalyzeStatementContext) SetNoscan(v antlr.Token) { s.noscan = v }


func (s *AnalyzeStatementContext) GetParttype() ITableOrPartitionContext { return s.parttype }

func (s *AnalyzeStatementContext) GetStatsColumnName() IColumnNameListContext { return s.statsColumnName }


func (s *AnalyzeStatementContext) SetParttype(v ITableOrPartitionContext) { s.parttype = v }

func (s *AnalyzeStatementContext) SetStatsColumnName(v IColumnNameListContext) { s.statsColumnName = v }


func (s *AnalyzeStatementContext) KW_ANALYZE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ANALYZE, 0)
}

func (s *AnalyzeStatementContext) KW_TABLE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TABLE, 0)
}

func (s *AnalyzeStatementContext) TableOrPartition() ITableOrPartitionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableOrPartitionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableOrPartitionContext)
}

func (s *AnalyzeStatementContext) KW_COMPUTE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_COMPUTE, 0)
}

func (s *AnalyzeStatementContext) KW_STATISTICS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_STATISTICS, 0)
}

func (s *AnalyzeStatementContext) KW_CACHE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_CACHE, 0)
}

func (s *AnalyzeStatementContext) KW_METADATA() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_METADATA, 0)
}

func (s *AnalyzeStatementContext) KW_FOR() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_FOR, 0)
}

func (s *AnalyzeStatementContext) KW_COLUMNS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_COLUMNS, 0)
}

func (s *AnalyzeStatementContext) KW_NOSCAN() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_NOSCAN, 0)
}

func (s *AnalyzeStatementContext) ColumnNameList() IColumnNameListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNameListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNameListContext)
}

func (s *AnalyzeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnalyzeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AnalyzeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterAnalyzeStatement(s)
	}
}

func (s *AnalyzeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitAnalyzeStatement(s)
	}
}

func (s *AnalyzeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitAnalyzeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) AnalyzeStatement() (localctx IAnalyzeStatementContext) {
	localctx = NewAnalyzeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, HiveParserRULE_analyzeStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1388)
		p.Match(HiveParserKW_ANALYZE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1389)
		p.Match(HiveParserKW_TABLE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1390)

		var _x = p.TableOrPartition()


		localctx.(*AnalyzeStatementContext).parttype = _x
	}
	p.SetState(1403)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserKW_COMPUTE:
		{
			p.SetState(1391)
			p.Match(HiveParserKW_COMPUTE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1392)
			p.Match(HiveParserKW_STATISTICS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1399)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case HiveParserKW_NOSCAN:
			{
				p.SetState(1393)

				var _m = p.Match(HiveParserKW_NOSCAN)

				localctx.(*AnalyzeStatementContext).noscan = _m
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


		case HiveParserKW_FOR:
			{
				p.SetState(1394)
				p.Match(HiveParserKW_FOR)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1395)
				p.Match(HiveParserKW_COLUMNS)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			p.SetState(1397)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 808078815591695742) != 0) || ((int64((_la - 66)) & ^0x3f) == 0 && ((int64(1) << (_la - 66)) & 1083038567331911621) != 0) || ((int64((_la - 132)) & ^0x3f) == 0 && ((int64(1) << (_la - 132)) & 8916819943869537315) != 0) || ((int64((_la - 196)) & ^0x3f) == 0 && ((int64(1) << (_la - 196)) & 4159991143015340909) != 0) || ((int64((_la - 261)) & ^0x3f) == 0 && ((int64(1) << (_la - 261)) & 8484708576009596927) != 0) || ((int64((_la - 328)) & ^0x3f) == 0 && ((int64(1) << (_la - 328)) & 17776728909112555) != 0) || _la == HiveParserIdentifier {
				{
					p.SetState(1396)

					var _x = p.ColumnNameList()


					localctx.(*AnalyzeStatementContext).statsColumnName = _x
				}

			}


		case HiveParserEOF:



		default:
		}


	case HiveParserKW_CACHE:
		{
			p.SetState(1401)
			p.Match(HiveParserKW_CACHE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1402)
			p.Match(HiveParserKW_METADATA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFrom_inContext is an interface to support dynamic dispatch.
type IFrom_inContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_FROM() antlr.TerminalNode
	KW_IN() antlr.TerminalNode

	// IsFrom_inContext differentiates from other interfaces.
	IsFrom_inContext()
}

type From_inContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrom_inContext() *From_inContext {
	var p = new(From_inContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_from_in
	return p
}

func InitEmptyFrom_inContext(p *From_inContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_from_in
}

func (*From_inContext) IsFrom_inContext() {}

func NewFrom_inContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *From_inContext {
	var p = new(From_inContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_from_in

	return p
}

func (s *From_inContext) GetParser() antlr.Parser { return s.parser }

func (s *From_inContext) KW_FROM() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_FROM, 0)
}

func (s *From_inContext) KW_IN() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_IN, 0)
}

func (s *From_inContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *From_inContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *From_inContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterFrom_in(s)
	}
}

func (s *From_inContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitFrom_in(s)
	}
}

func (s *From_inContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitFrom_in(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) From_in() (localctx IFrom_inContext) {
	localctx = NewFrom_inContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, HiveParserRULE_from_in)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1405)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HiveParserKW_FROM || _la == HiveParserKW_IN) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDb_schemaContext is an interface to support dynamic dispatch.
type IDb_schemaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_DATABASE() antlr.TerminalNode
	KW_SCHEMA() antlr.TerminalNode

	// IsDb_schemaContext differentiates from other interfaces.
	IsDb_schemaContext()
}

type Db_schemaContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDb_schemaContext() *Db_schemaContext {
	var p = new(Db_schemaContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_db_schema
	return p
}

func InitEmptyDb_schemaContext(p *Db_schemaContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_db_schema
}

func (*Db_schemaContext) IsDb_schemaContext() {}

func NewDb_schemaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Db_schemaContext {
	var p = new(Db_schemaContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_db_schema

	return p
}

func (s *Db_schemaContext) GetParser() antlr.Parser { return s.parser }

func (s *Db_schemaContext) KW_DATABASE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DATABASE, 0)
}

func (s *Db_schemaContext) KW_SCHEMA() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SCHEMA, 0)
}

func (s *Db_schemaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Db_schemaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Db_schemaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterDb_schema(s)
	}
}

func (s *Db_schemaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitDb_schema(s)
	}
}

func (s *Db_schemaContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitDb_schema(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) Db_schema() (localctx IDb_schemaContext) {
	localctx = NewDb_schemaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, HiveParserRULE_db_schema)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1407)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HiveParserKW_DATABASE || _la == HiveParserKW_SCHEMA) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IShowStatementContext is an interface to support dynamic dispatch.
type IShowStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetIsExtended returns the isExtended token.
	GetIsExtended() antlr.Token 

	// GetPrptyName returns the prptyName token.
	GetPrptyName() antlr.Token 


	// SetIsExtended sets the isExtended token.
	SetIsExtended(antlr.Token) 

	// SetPrptyName sets the prptyName token.
	SetPrptyName(antlr.Token) 


	// GetDb_name returns the db_name rule contexts.
	GetDb_name() IId_Context

	// GetFilter returns the filter rule contexts.
	GetFilter() IShowTablesFilterExprContext

	// GetTabName returns the tabName rule contexts.
	GetTabName() ITableNameContext

	// GetDbName returns the dbName rule contexts.
	GetDbName() IId_Context

	// GetParttype returns the parttype rule contexts.
	GetParttype() IPartTypeExprContext

	// GetRp_name returns the rp_name rule contexts.
	GetRp_name() IId_Context


	// SetDb_name sets the db_name rule contexts.
	SetDb_name(IId_Context)

	// SetFilter sets the filter rule contexts.
	SetFilter(IShowTablesFilterExprContext)

	// SetTabName sets the tabName rule contexts.
	SetTabName(ITableNameContext)

	// SetDbName sets the dbName rule contexts.
	SetDbName(IId_Context)

	// SetParttype sets the parttype rule contexts.
	SetParttype(IPartTypeExprContext)

	// SetRp_name sets the rp_name rule contexts.
	SetRp_name(IId_Context)


	// Getter signatures
	KW_SHOW() antlr.TerminalNode
	KW_DATABASES() antlr.TerminalNode
	KW_SCHEMAS() antlr.TerminalNode
	KW_LIKE() antlr.TerminalNode
	ShowStmtIdentifier() IShowStmtIdentifierContext
	KW_TABLES() antlr.TerminalNode
	AllFrom_in() []IFrom_inContext
	From_in(i int) IFrom_inContext
	KW_EXTENDED() antlr.TerminalNode
	Id_() IId_Context
	ShowTablesFilterExpr() IShowTablesFilterExprContext
	KW_VIEWS() antlr.TerminalNode
	KW_MATERIALIZED() antlr.TerminalNode
	KW_COLUMNS() antlr.TerminalNode
	TableName() ITableNameContext
	KW_SORTED() antlr.TerminalNode
	KW_FUNCTIONS() antlr.TerminalNode
	ShowFunctionIdentifier() IShowFunctionIdentifierContext
	KW_PARTITIONS() antlr.TerminalNode
	PartitionSpec() IPartitionSpecContext
	WhereClause() IWhereClauseContext
	OrderByClause() IOrderByClauseContext
	LimitClause() ILimitClauseContext
	KW_CREATE() antlr.TerminalNode
	Db_schema() IDb_schemaContext
	KW_TABLE() antlr.TerminalNode
	KW_TBLPROPERTIES() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode
	KW_LOCKS() antlr.TerminalNode
	PartTypeExpr() IPartTypeExprContext
	KW_COMPACTIONS() antlr.TerminalNode
	CompactionId() ICompactionIdContext
	CompactionPool() ICompactionPoolContext
	CompactionType() ICompactionTypeContext
	CompactionStatus() ICompactionStatusContext
	KW_TRANSACTIONS() antlr.TerminalNode
	KW_CONF() antlr.TerminalNode
	KW_RESOURCE() antlr.TerminalNode
	KW_PLAN() antlr.TerminalNode
	KW_PLANS() antlr.TerminalNode
	KW_DATACONNECTORS() antlr.TerminalNode

	// IsShowStatementContext differentiates from other interfaces.
	IsShowStatementContext()
}

type ShowStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	isExtended antlr.Token
	db_name IId_Context 
	filter IShowTablesFilterExprContext 
	tabName ITableNameContext 
	prptyName antlr.Token
	dbName IId_Context 
	parttype IPartTypeExprContext 
	rp_name IId_Context 
}

func NewEmptyShowStatementContext() *ShowStatementContext {
	var p = new(ShowStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_showStatement
	return p
}

func InitEmptyShowStatementContext(p *ShowStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_showStatement
}

func (*ShowStatementContext) IsShowStatementContext() {}

func NewShowStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowStatementContext {
	var p = new(ShowStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_showStatement

	return p
}

func (s *ShowStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowStatementContext) GetIsExtended() antlr.Token { return s.isExtended }

func (s *ShowStatementContext) GetPrptyName() antlr.Token { return s.prptyName }


func (s *ShowStatementContext) SetIsExtended(v antlr.Token) { s.isExtended = v }

func (s *ShowStatementContext) SetPrptyName(v antlr.Token) { s.prptyName = v }


func (s *ShowStatementContext) GetDb_name() IId_Context { return s.db_name }

func (s *ShowStatementContext) GetFilter() IShowTablesFilterExprContext { return s.filter }

func (s *ShowStatementContext) GetTabName() ITableNameContext { return s.tabName }

func (s *ShowStatementContext) GetDbName() IId_Context { return s.dbName }

func (s *ShowStatementContext) GetParttype() IPartTypeExprContext { return s.parttype }

func (s *ShowStatementContext) GetRp_name() IId_Context { return s.rp_name }


func (s *ShowStatementContext) SetDb_name(v IId_Context) { s.db_name = v }

func (s *ShowStatementContext) SetFilter(v IShowTablesFilterExprContext) { s.filter = v }

func (s *ShowStatementContext) SetTabName(v ITableNameContext) { s.tabName = v }

func (s *ShowStatementContext) SetDbName(v IId_Context) { s.dbName = v }

func (s *ShowStatementContext) SetParttype(v IPartTypeExprContext) { s.parttype = v }

func (s *ShowStatementContext) SetRp_name(v IId_Context) { s.rp_name = v }


func (s *ShowStatementContext) KW_SHOW() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SHOW, 0)
}

func (s *ShowStatementContext) KW_DATABASES() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DATABASES, 0)
}

func (s *ShowStatementContext) KW_SCHEMAS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SCHEMAS, 0)
}

func (s *ShowStatementContext) KW_LIKE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_LIKE, 0)
}

func (s *ShowStatementContext) ShowStmtIdentifier() IShowStmtIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowStmtIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowStmtIdentifierContext)
}

func (s *ShowStatementContext) KW_TABLES() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TABLES, 0)
}

func (s *ShowStatementContext) AllFrom_in() []IFrom_inContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFrom_inContext); ok {
			len++
		}
	}

	tst := make([]IFrom_inContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFrom_inContext); ok {
			tst[i] = t.(IFrom_inContext)
			i++
		}
	}

	return tst
}

func (s *ShowStatementContext) From_in(i int) IFrom_inContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrom_inContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrom_inContext)
}

func (s *ShowStatementContext) KW_EXTENDED() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_EXTENDED, 0)
}

func (s *ShowStatementContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *ShowStatementContext) ShowTablesFilterExpr() IShowTablesFilterExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowTablesFilterExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowTablesFilterExprContext)
}

func (s *ShowStatementContext) KW_VIEWS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_VIEWS, 0)
}

func (s *ShowStatementContext) KW_MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_MATERIALIZED, 0)
}

func (s *ShowStatementContext) KW_COLUMNS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_COLUMNS, 0)
}

func (s *ShowStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *ShowStatementContext) KW_SORTED() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SORTED, 0)
}

func (s *ShowStatementContext) KW_FUNCTIONS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_FUNCTIONS, 0)
}

func (s *ShowStatementContext) ShowFunctionIdentifier() IShowFunctionIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowFunctionIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowFunctionIdentifierContext)
}

func (s *ShowStatementContext) KW_PARTITIONS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_PARTITIONS, 0)
}

func (s *ShowStatementContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *ShowStatementContext) WhereClause() IWhereClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *ShowStatementContext) OrderByClause() IOrderByClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByClauseContext)
}

func (s *ShowStatementContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *ShowStatementContext) KW_CREATE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_CREATE, 0)
}

func (s *ShowStatementContext) Db_schema() IDb_schemaContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDb_schemaContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDb_schemaContext)
}

func (s *ShowStatementContext) KW_TABLE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TABLE, 0)
}

func (s *ShowStatementContext) KW_TBLPROPERTIES() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TBLPROPERTIES, 0)
}

func (s *ShowStatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserLPAREN, 0)
}

func (s *ShowStatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserRPAREN, 0)
}

func (s *ShowStatementContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(HiveParserStringLiteral, 0)
}

func (s *ShowStatementContext) KW_LOCKS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_LOCKS, 0)
}

func (s *ShowStatementContext) PartTypeExpr() IPartTypeExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartTypeExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartTypeExprContext)
}

func (s *ShowStatementContext) KW_COMPACTIONS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_COMPACTIONS, 0)
}

func (s *ShowStatementContext) CompactionId() ICompactionIdContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompactionIdContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompactionIdContext)
}

func (s *ShowStatementContext) CompactionPool() ICompactionPoolContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompactionPoolContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompactionPoolContext)
}

func (s *ShowStatementContext) CompactionType() ICompactionTypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompactionTypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompactionTypeContext)
}

func (s *ShowStatementContext) CompactionStatus() ICompactionStatusContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompactionStatusContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompactionStatusContext)
}

func (s *ShowStatementContext) KW_TRANSACTIONS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TRANSACTIONS, 0)
}

func (s *ShowStatementContext) KW_CONF() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_CONF, 0)
}

func (s *ShowStatementContext) KW_RESOURCE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_RESOURCE, 0)
}

func (s *ShowStatementContext) KW_PLAN() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_PLAN, 0)
}

func (s *ShowStatementContext) KW_PLANS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_PLANS, 0)
}

func (s *ShowStatementContext) KW_DATACONNECTORS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DATACONNECTORS, 0)
}

func (s *ShowStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ShowStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterShowStatement(s)
	}
}

func (s *ShowStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitShowStatement(s)
	}
}

func (s *ShowStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitShowStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ShowStatement() (localctx IShowStatementContext) {
	localctx = NewShowStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, HiveParserRULE_showStatement)
	var _la int

	p.SetState(1590)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 95, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1409)
			p.Match(HiveParserKW_SHOW)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1410)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HiveParserKW_DATABASES || _la == HiveParserKW_SCHEMAS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1413)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_LIKE {
			{
				p.SetState(1411)
				p.Match(HiveParserKW_LIKE)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1412)
				p.ShowStmtIdentifier()
			}

		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1415)
			p.Match(HiveParserKW_SHOW)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1417)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_EXTENDED {
			{
				p.SetState(1416)

				var _m = p.Match(HiveParserKW_EXTENDED)

				localctx.(*ShowStatementContext).isExtended = _m
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1419)
			p.Match(HiveParserKW_TABLES)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1423)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_FROM || _la == HiveParserKW_IN {
			{
				p.SetState(1420)
				p.From_in()
			}
			{
				p.SetState(1421)

				var _x = p.Id_()


				localctx.(*ShowStatementContext).db_name = _x
			}

		}
		p.SetState(1426)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 808078815591695742) != 0) || ((int64((_la - 66)) & ^0x3f) == 0 && ((int64(1) << (_la - 66)) & 1083038567331911621) != 0) || ((int64((_la - 132)) & ^0x3f) == 0 && ((int64(1) << (_la - 132)) & 8916837536055581731) != 0) || ((int64((_la - 196)) & ^0x3f) == 0 && ((int64(1) << (_la - 196)) & 4159991143015340909) != 0) || ((int64((_la - 261)) & ^0x3f) == 0 && ((int64(1) << (_la - 261)) & 8484708576009596927) != 0) || ((int64((_la - 328)) & ^0x3f) == 0 && ((int64(1) << (_la - 328)) & 17794321095156971) != 0) || _la == HiveParserStringLiteral || _la == HiveParserIdentifier {
			{
				p.SetState(1425)

				var _x = p.ShowTablesFilterExpr()


				localctx.(*ShowStatementContext).filter = _x
			}

		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1428)
			p.Match(HiveParserKW_SHOW)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1429)
			p.Match(HiveParserKW_VIEWS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1433)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_FROM || _la == HiveParserKW_IN {
			{
				p.SetState(1430)
				p.From_in()
			}
			{
				p.SetState(1431)

				var _x = p.Id_()


				localctx.(*ShowStatementContext).db_name = _x
			}

		}
		p.SetState(1438)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case HiveParserKW_LIKE:
			{
				p.SetState(1435)
				p.Match(HiveParserKW_LIKE)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1436)
				p.ShowStmtIdentifier()
			}


		case HiveParserKW_ABORT, HiveParserKW_ACTIVATE, HiveParserKW_ACTIVE, HiveParserKW_ADD, HiveParserKW_ADMIN, HiveParserKW_AFTER, HiveParserKW_ALLOC_FRACTION, HiveParserKW_ANALYZE, HiveParserKW_ARCHIVE, HiveParserKW_ASC, HiveParserKW_AST, HiveParserKW_AT, HiveParserKW_AUTOCOMMIT, HiveParserKW_BATCH, HiveParserKW_BEFORE, HiveParserKW_BUCKET, HiveParserKW_BUCKETS, HiveParserKW_CACHE, HiveParserKW_CASCADE, HiveParserKW_CBO, HiveParserKW_CHANGE, HiveParserKW_CHECK, HiveParserKW_CLUSTER, HiveParserKW_CLUSTERED, HiveParserKW_CLUSTERSTATUS, HiveParserKW_COLLECTION, HiveParserKW_COLUMNS, HiveParserKW_COMMENT, HiveParserKW_COMPACT, HiveParserKW_COMPACTIONS, HiveParserKW_COMPUTE, HiveParserKW_CONCATENATE, HiveParserKW_CONTINUE, HiveParserKW_COST, HiveParserKW_CRON, HiveParserKW_DATA, HiveParserKW_DATABASES, HiveParserKW_DATETIME, HiveParserKW_DAY, HiveParserKW_DAYOFWEEK, HiveParserKW_DBPROPERTIES, HiveParserKW_DCPROPERTIES, HiveParserKW_DEBUG, HiveParserKW_DEFAULT, HiveParserKW_DEFERRED, HiveParserKW_DEFINED, HiveParserKW_DELIMITED, HiveParserKW_DEPENDENCY, HiveParserKW_DESC, HiveParserKW_DETAIL, HiveParserKW_DIRECTORIES, HiveParserKW_DIRECTORY, HiveParserKW_DISABLE, HiveParserKW_DISTRIBUTE, HiveParserKW_DISTRIBUTED, HiveParserKW_DO, HiveParserKW_DOW, HiveParserKW_DUMP, HiveParserKW_ELEM_TYPE, HiveParserKW_ENABLE, HiveParserKW_ENFORCED, HiveParserKW_ESCAPED, HiveParserKW_EVERY, HiveParserKW_EXCLUSIVE, HiveParserKW_EXECUTE, HiveParserKW_EXECUTED, HiveParserKW_EXPIRE_SNAPSHOTS, HiveParserKW_EXPLAIN, HiveParserKW_EXPORT, HiveParserKW_EXPRESSION, HiveParserKW_FIELDS, HiveParserKW_FILE, HiveParserKW_FILEFORMAT, HiveParserKW_FIRST, HiveParserKW_FORMAT, HiveParserKW_FORMATTED, HiveParserKW_FUNCTIONS, HiveParserKW_HOLD_DDLTIME, HiveParserKW_HOUR, HiveParserKW_IDXPROPERTIES, HiveParserKW_IGNORE, HiveParserKW_INDEX, HiveParserKW_INDEXES, HiveParserKW_INPATH, HiveParserKW_INPUTDRIVER, HiveParserKW_INPUTFORMAT, HiveParserKW_ISOLATION, HiveParserKW_ITEMS, HiveParserKW_JAR, HiveParserKW_JOINCOST, HiveParserKW_KEY, HiveParserKW_KEYS, HiveParserKW_KEY_TYPE, HiveParserKW_KILL, HiveParserKW_LAST, HiveParserKW_LEVEL, HiveParserKW_LIMIT, HiveParserKW_LINES, HiveParserKW_LOAD, HiveParserKW_LOCATION, HiveParserKW_LOCK, HiveParserKW_LOCKS, HiveParserKW_LOGICAL, HiveParserKW_LONG, HiveParserKW_MANAGED, HiveParserKW_MANAGEDLOCATION, HiveParserKW_MANAGEMENT, HiveParserKW_MAPJOIN, HiveParserKW_MAPPING, HiveParserKW_MATCHED, HiveParserKW_MATERIALIZED, HiveParserKW_METADATA, HiveParserKW_MINUTE, HiveParserKW_MONTH, HiveParserKW_MOVE, HiveParserKW_MSCK, HiveParserKW_NORELY, HiveParserKW_NOSCAN, HiveParserKW_NOVALIDATE, HiveParserKW_NO_DROP, HiveParserKW_NULLS, HiveParserKW_OFFLINE, HiveParserKW_OFFSET, HiveParserKW_OPERATOR, HiveParserKW_OPTION, HiveParserKW_OUTPUTDRIVER, HiveParserKW_OUTPUTFORMAT, HiveParserKW_OVERWRITE, HiveParserKW_OWNER, HiveParserKW_PARTITIONED, HiveParserKW_PARTITIONS, HiveParserKW_PATH, HiveParserKW_PLAN, HiveParserKW_PLANS, HiveParserKW_PLUS, HiveParserKW_POOL, HiveParserKW_PRINCIPALS, HiveParserKW_PROTECTION, HiveParserKW_PURGE, HiveParserKW_QUARTER, HiveParserKW_QUERY, HiveParserKW_QUERY_PARALLELISM, HiveParserKW_READ, HiveParserKW_READONLY, HiveParserKW_REBUILD, HiveParserKW_RECORDREADER, HiveParserKW_RECORDWRITER, HiveParserKW_RELOAD, HiveParserKW_RELY, HiveParserKW_REMOTE, HiveParserKW_RENAME, HiveParserKW_REOPTIMIZATION, HiveParserKW_REPAIR, HiveParserKW_REPL, HiveParserKW_REPLACE, HiveParserKW_REPLICATION, HiveParserKW_RESOURCE, HiveParserKW_RESPECT, HiveParserKW_RESTRICT, HiveParserKW_REWRITE, HiveParserKW_ROLE, HiveParserKW_ROLES, HiveParserKW_SCHEDULED, HiveParserKW_SCHEDULING_POLICY, HiveParserKW_SCHEMA, HiveParserKW_SCHEMAS, HiveParserKW_SECOND, HiveParserKW_SEMI, HiveParserKW_SERDE, HiveParserKW_SERDEPROPERTIES, HiveParserKW_SERVER, HiveParserKW_SETS, HiveParserKW_SET_CURRENT_SNAPSHOT, HiveParserKW_SHARED, HiveParserKW_SHOW, HiveParserKW_SHOW_DATABASE, HiveParserKW_SKEWED, HiveParserKW_SNAPSHOT, HiveParserKW_SORT, HiveParserKW_SORTED, HiveParserKW_SPEC, HiveParserKW_SSL, HiveParserKW_STATISTICS, HiveParserKW_STATUS, HiveParserKW_STORED, HiveParserKW_STREAMTABLE, HiveParserKW_STRING, HiveParserKW_STRUCT, HiveParserKW_SUMMARY, HiveParserKW_SYSTEM_TIME, HiveParserKW_SYSTEM_VERSION, HiveParserKW_TABLES, HiveParserKW_TBLPROPERTIES, HiveParserKW_TEMPORARY, HiveParserKW_TERMINATED, HiveParserKW_TIMESTAMPTZ, HiveParserKW_TINYINT, HiveParserKW_TOUCH, HiveParserKW_TRANSACTION, HiveParserKW_TRANSACTIONAL, HiveParserKW_TRANSACTIONS, HiveParserKW_TRIM, HiveParserKW_TYPE, HiveParserKW_UNARCHIVE, HiveParserKW_UNDO, HiveParserKW_UNIONTYPE, HiveParserKW_UNKNOWN, HiveParserKW_UNLOCK, HiveParserKW_UNMANAGED, HiveParserKW_UNSET, HiveParserKW_UNSIGNED, HiveParserKW_URI, HiveParserKW_URL, HiveParserKW_USE, HiveParserKW_UTC, HiveParserKW_UTCTIMESTAMP, HiveParserKW_VALIDATE, HiveParserKW_VALUE_TYPE, HiveParserKW_VECTORIZATION, HiveParserKW_VIEW, HiveParserKW_VIEWS, HiveParserKW_WAIT, HiveParserKW_WEEK, HiveParserKW_WHILE, HiveParserKW_WITHIN, HiveParserKW_WORK, HiveParserKW_WORKLOAD, HiveParserKW_WRITE, HiveParserKW_YEAR, HiveParserKW_ZONE, HiveParserStringLiteral, HiveParserIdentifier:
			{
				p.SetState(1437)
				p.ShowStmtIdentifier()
			}


		case HiveParserEOF:



		default:
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1440)
			p.Match(HiveParserKW_SHOW)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1441)
			p.Match(HiveParserKW_MATERIALIZED)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1442)
			p.Match(HiveParserKW_VIEWS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1446)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_FROM || _la == HiveParserKW_IN {
			{
				p.SetState(1443)
				p.From_in()
			}
			{
				p.SetState(1444)

				var _x = p.Id_()


				localctx.(*ShowStatementContext).db_name = _x
			}

		}
		p.SetState(1451)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case HiveParserKW_LIKE:
			{
				p.SetState(1448)
				p.Match(HiveParserKW_LIKE)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1449)
				p.ShowStmtIdentifier()
			}


		case HiveParserKW_ABORT, HiveParserKW_ACTIVATE, HiveParserKW_ACTIVE, HiveParserKW_ADD, HiveParserKW_ADMIN, HiveParserKW_AFTER, HiveParserKW_ALLOC_FRACTION, HiveParserKW_ANALYZE, HiveParserKW_ARCHIVE, HiveParserKW_ASC, HiveParserKW_AST, HiveParserKW_AT, HiveParserKW_AUTOCOMMIT, HiveParserKW_BATCH, HiveParserKW_BEFORE, HiveParserKW_BUCKET, HiveParserKW_BUCKETS, HiveParserKW_CACHE, HiveParserKW_CASCADE, HiveParserKW_CBO, HiveParserKW_CHANGE, HiveParserKW_CHECK, HiveParserKW_CLUSTER, HiveParserKW_CLUSTERED, HiveParserKW_CLUSTERSTATUS, HiveParserKW_COLLECTION, HiveParserKW_COLUMNS, HiveParserKW_COMMENT, HiveParserKW_COMPACT, HiveParserKW_COMPACTIONS, HiveParserKW_COMPUTE, HiveParserKW_CONCATENATE, HiveParserKW_CONTINUE, HiveParserKW_COST, HiveParserKW_CRON, HiveParserKW_DATA, HiveParserKW_DATABASES, HiveParserKW_DATETIME, HiveParserKW_DAY, HiveParserKW_DAYOFWEEK, HiveParserKW_DBPROPERTIES, HiveParserKW_DCPROPERTIES, HiveParserKW_DEBUG, HiveParserKW_DEFAULT, HiveParserKW_DEFERRED, HiveParserKW_DEFINED, HiveParserKW_DELIMITED, HiveParserKW_DEPENDENCY, HiveParserKW_DESC, HiveParserKW_DETAIL, HiveParserKW_DIRECTORIES, HiveParserKW_DIRECTORY, HiveParserKW_DISABLE, HiveParserKW_DISTRIBUTE, HiveParserKW_DISTRIBUTED, HiveParserKW_DO, HiveParserKW_DOW, HiveParserKW_DUMP, HiveParserKW_ELEM_TYPE, HiveParserKW_ENABLE, HiveParserKW_ENFORCED, HiveParserKW_ESCAPED, HiveParserKW_EVERY, HiveParserKW_EXCLUSIVE, HiveParserKW_EXECUTE, HiveParserKW_EXECUTED, HiveParserKW_EXPIRE_SNAPSHOTS, HiveParserKW_EXPLAIN, HiveParserKW_EXPORT, HiveParserKW_EXPRESSION, HiveParserKW_FIELDS, HiveParserKW_FILE, HiveParserKW_FILEFORMAT, HiveParserKW_FIRST, HiveParserKW_FORMAT, HiveParserKW_FORMATTED, HiveParserKW_FUNCTIONS, HiveParserKW_HOLD_DDLTIME, HiveParserKW_HOUR, HiveParserKW_IDXPROPERTIES, HiveParserKW_IGNORE, HiveParserKW_INDEX, HiveParserKW_INDEXES, HiveParserKW_INPATH, HiveParserKW_INPUTDRIVER, HiveParserKW_INPUTFORMAT, HiveParserKW_ISOLATION, HiveParserKW_ITEMS, HiveParserKW_JAR, HiveParserKW_JOINCOST, HiveParserKW_KEY, HiveParserKW_KEYS, HiveParserKW_KEY_TYPE, HiveParserKW_KILL, HiveParserKW_LAST, HiveParserKW_LEVEL, HiveParserKW_LIMIT, HiveParserKW_LINES, HiveParserKW_LOAD, HiveParserKW_LOCATION, HiveParserKW_LOCK, HiveParserKW_LOCKS, HiveParserKW_LOGICAL, HiveParserKW_LONG, HiveParserKW_MANAGED, HiveParserKW_MANAGEDLOCATION, HiveParserKW_MANAGEMENT, HiveParserKW_MAPJOIN, HiveParserKW_MAPPING, HiveParserKW_MATCHED, HiveParserKW_MATERIALIZED, HiveParserKW_METADATA, HiveParserKW_MINUTE, HiveParserKW_MONTH, HiveParserKW_MOVE, HiveParserKW_MSCK, HiveParserKW_NORELY, HiveParserKW_NOSCAN, HiveParserKW_NOVALIDATE, HiveParserKW_NO_DROP, HiveParserKW_NULLS, HiveParserKW_OFFLINE, HiveParserKW_OFFSET, HiveParserKW_OPERATOR, HiveParserKW_OPTION, HiveParserKW_OUTPUTDRIVER, HiveParserKW_OUTPUTFORMAT, HiveParserKW_OVERWRITE, HiveParserKW_OWNER, HiveParserKW_PARTITIONED, HiveParserKW_PARTITIONS, HiveParserKW_PATH, HiveParserKW_PLAN, HiveParserKW_PLANS, HiveParserKW_PLUS, HiveParserKW_POOL, HiveParserKW_PRINCIPALS, HiveParserKW_PROTECTION, HiveParserKW_PURGE, HiveParserKW_QUARTER, HiveParserKW_QUERY, HiveParserKW_QUERY_PARALLELISM, HiveParserKW_READ, HiveParserKW_READONLY, HiveParserKW_REBUILD, HiveParserKW_RECORDREADER, HiveParserKW_RECORDWRITER, HiveParserKW_RELOAD, HiveParserKW_RELY, HiveParserKW_REMOTE, HiveParserKW_RENAME, HiveParserKW_REOPTIMIZATION, HiveParserKW_REPAIR, HiveParserKW_REPL, HiveParserKW_REPLACE, HiveParserKW_REPLICATION, HiveParserKW_RESOURCE, HiveParserKW_RESPECT, HiveParserKW_RESTRICT, HiveParserKW_REWRITE, HiveParserKW_ROLE, HiveParserKW_ROLES, HiveParserKW_SCHEDULED, HiveParserKW_SCHEDULING_POLICY, HiveParserKW_SCHEMA, HiveParserKW_SCHEMAS, HiveParserKW_SECOND, HiveParserKW_SEMI, HiveParserKW_SERDE, HiveParserKW_SERDEPROPERTIES, HiveParserKW_SERVER, HiveParserKW_SETS, HiveParserKW_SET_CURRENT_SNAPSHOT, HiveParserKW_SHARED, HiveParserKW_SHOW, HiveParserKW_SHOW_DATABASE, HiveParserKW_SKEWED, HiveParserKW_SNAPSHOT, HiveParserKW_SORT, HiveParserKW_SORTED, HiveParserKW_SPEC, HiveParserKW_SSL, HiveParserKW_STATISTICS, HiveParserKW_STATUS, HiveParserKW_STORED, HiveParserKW_STREAMTABLE, HiveParserKW_STRING, HiveParserKW_STRUCT, HiveParserKW_SUMMARY, HiveParserKW_SYSTEM_TIME, HiveParserKW_SYSTEM_VERSION, HiveParserKW_TABLES, HiveParserKW_TBLPROPERTIES, HiveParserKW_TEMPORARY, HiveParserKW_TERMINATED, HiveParserKW_TIMESTAMPTZ, HiveParserKW_TINYINT, HiveParserKW_TOUCH, HiveParserKW_TRANSACTION, HiveParserKW_TRANSACTIONAL, HiveParserKW_TRANSACTIONS, HiveParserKW_TRIM, HiveParserKW_TYPE, HiveParserKW_UNARCHIVE, HiveParserKW_UNDO, HiveParserKW_UNIONTYPE, HiveParserKW_UNKNOWN, HiveParserKW_UNLOCK, HiveParserKW_UNMANAGED, HiveParserKW_UNSET, HiveParserKW_UNSIGNED, HiveParserKW_URI, HiveParserKW_URL, HiveParserKW_USE, HiveParserKW_UTC, HiveParserKW_UTCTIMESTAMP, HiveParserKW_VALIDATE, HiveParserKW_VALUE_TYPE, HiveParserKW_VECTORIZATION, HiveParserKW_VIEW, HiveParserKW_VIEWS, HiveParserKW_WAIT, HiveParserKW_WEEK, HiveParserKW_WHILE, HiveParserKW_WITHIN, HiveParserKW_WORK, HiveParserKW_WORKLOAD, HiveParserKW_WRITE, HiveParserKW_YEAR, HiveParserKW_ZONE, HiveParserStringLiteral, HiveParserIdentifier:
			{
				p.SetState(1450)
				p.ShowStmtIdentifier()
			}


		case HiveParserEOF:



		default:
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1453)
			p.Match(HiveParserKW_SHOW)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1455)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_SORTED {
			{
				p.SetState(1454)
				p.Match(HiveParserKW_SORTED)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1457)
			p.Match(HiveParserKW_COLUMNS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1458)
			p.From_in()
		}
		{
			p.SetState(1459)
			p.TableName()
		}
		p.SetState(1463)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_FROM || _la == HiveParserKW_IN {
			{
				p.SetState(1460)
				p.From_in()
			}
			{
				p.SetState(1461)

				var _x = p.Id_()


				localctx.(*ShowStatementContext).db_name = _x
			}

		}
		p.SetState(1468)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case HiveParserKW_LIKE:
			{
				p.SetState(1465)
				p.Match(HiveParserKW_LIKE)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1466)
				p.ShowStmtIdentifier()
			}


		case HiveParserKW_ABORT, HiveParserKW_ACTIVATE, HiveParserKW_ACTIVE, HiveParserKW_ADD, HiveParserKW_ADMIN, HiveParserKW_AFTER, HiveParserKW_ALLOC_FRACTION, HiveParserKW_ANALYZE, HiveParserKW_ARCHIVE, HiveParserKW_ASC, HiveParserKW_AST, HiveParserKW_AT, HiveParserKW_AUTOCOMMIT, HiveParserKW_BATCH, HiveParserKW_BEFORE, HiveParserKW_BUCKET, HiveParserKW_BUCKETS, HiveParserKW_CACHE, HiveParserKW_CASCADE, HiveParserKW_CBO, HiveParserKW_CHANGE, HiveParserKW_CHECK, HiveParserKW_CLUSTER, HiveParserKW_CLUSTERED, HiveParserKW_CLUSTERSTATUS, HiveParserKW_COLLECTION, HiveParserKW_COLUMNS, HiveParserKW_COMMENT, HiveParserKW_COMPACT, HiveParserKW_COMPACTIONS, HiveParserKW_COMPUTE, HiveParserKW_CONCATENATE, HiveParserKW_CONTINUE, HiveParserKW_COST, HiveParserKW_CRON, HiveParserKW_DATA, HiveParserKW_DATABASES, HiveParserKW_DATETIME, HiveParserKW_DAY, HiveParserKW_DAYOFWEEK, HiveParserKW_DBPROPERTIES, HiveParserKW_DCPROPERTIES, HiveParserKW_DEBUG, HiveParserKW_DEFAULT, HiveParserKW_DEFERRED, HiveParserKW_DEFINED, HiveParserKW_DELIMITED, HiveParserKW_DEPENDENCY, HiveParserKW_DESC, HiveParserKW_DETAIL, HiveParserKW_DIRECTORIES, HiveParserKW_DIRECTORY, HiveParserKW_DISABLE, HiveParserKW_DISTRIBUTE, HiveParserKW_DISTRIBUTED, HiveParserKW_DO, HiveParserKW_DOW, HiveParserKW_DUMP, HiveParserKW_ELEM_TYPE, HiveParserKW_ENABLE, HiveParserKW_ENFORCED, HiveParserKW_ESCAPED, HiveParserKW_EVERY, HiveParserKW_EXCLUSIVE, HiveParserKW_EXECUTE, HiveParserKW_EXECUTED, HiveParserKW_EXPIRE_SNAPSHOTS, HiveParserKW_EXPLAIN, HiveParserKW_EXPORT, HiveParserKW_EXPRESSION, HiveParserKW_FIELDS, HiveParserKW_FILE, HiveParserKW_FILEFORMAT, HiveParserKW_FIRST, HiveParserKW_FORMAT, HiveParserKW_FORMATTED, HiveParserKW_FUNCTIONS, HiveParserKW_HOLD_DDLTIME, HiveParserKW_HOUR, HiveParserKW_IDXPROPERTIES, HiveParserKW_IGNORE, HiveParserKW_INDEX, HiveParserKW_INDEXES, HiveParserKW_INPATH, HiveParserKW_INPUTDRIVER, HiveParserKW_INPUTFORMAT, HiveParserKW_ISOLATION, HiveParserKW_ITEMS, HiveParserKW_JAR, HiveParserKW_JOINCOST, HiveParserKW_KEY, HiveParserKW_KEYS, HiveParserKW_KEY_TYPE, HiveParserKW_KILL, HiveParserKW_LAST, HiveParserKW_LEVEL, HiveParserKW_LIMIT, HiveParserKW_LINES, HiveParserKW_LOAD, HiveParserKW_LOCATION, HiveParserKW_LOCK, HiveParserKW_LOCKS, HiveParserKW_LOGICAL, HiveParserKW_LONG, HiveParserKW_MANAGED, HiveParserKW_MANAGEDLOCATION, HiveParserKW_MANAGEMENT, HiveParserKW_MAPJOIN, HiveParserKW_MAPPING, HiveParserKW_MATCHED, HiveParserKW_MATERIALIZED, HiveParserKW_METADATA, HiveParserKW_MINUTE, HiveParserKW_MONTH, HiveParserKW_MOVE, HiveParserKW_MSCK, HiveParserKW_NORELY, HiveParserKW_NOSCAN, HiveParserKW_NOVALIDATE, HiveParserKW_NO_DROP, HiveParserKW_NULLS, HiveParserKW_OFFLINE, HiveParserKW_OFFSET, HiveParserKW_OPERATOR, HiveParserKW_OPTION, HiveParserKW_OUTPUTDRIVER, HiveParserKW_OUTPUTFORMAT, HiveParserKW_OVERWRITE, HiveParserKW_OWNER, HiveParserKW_PARTITIONED, HiveParserKW_PARTITIONS, HiveParserKW_PATH, HiveParserKW_PLAN, HiveParserKW_PLANS, HiveParserKW_PLUS, HiveParserKW_POOL, HiveParserKW_PRINCIPALS, HiveParserKW_PROTECTION, HiveParserKW_PURGE, HiveParserKW_QUARTER, HiveParserKW_QUERY, HiveParserKW_QUERY_PARALLELISM, HiveParserKW_READ, HiveParserKW_READONLY, HiveParserKW_REBUILD, HiveParserKW_RECORDREADER, HiveParserKW_RECORDWRITER, HiveParserKW_RELOAD, HiveParserKW_RELY, HiveParserKW_REMOTE, HiveParserKW_RENAME, HiveParserKW_REOPTIMIZATION, HiveParserKW_REPAIR, HiveParserKW_REPL, HiveParserKW_REPLACE, HiveParserKW_REPLICATION, HiveParserKW_RESOURCE, HiveParserKW_RESPECT, HiveParserKW_RESTRICT, HiveParserKW_REWRITE, HiveParserKW_ROLE, HiveParserKW_ROLES, HiveParserKW_SCHEDULED, HiveParserKW_SCHEDULING_POLICY, HiveParserKW_SCHEMA, HiveParserKW_SCHEMAS, HiveParserKW_SECOND, HiveParserKW_SEMI, HiveParserKW_SERDE, HiveParserKW_SERDEPROPERTIES, HiveParserKW_SERVER, HiveParserKW_SETS, HiveParserKW_SET_CURRENT_SNAPSHOT, HiveParserKW_SHARED, HiveParserKW_SHOW, HiveParserKW_SHOW_DATABASE, HiveParserKW_SKEWED, HiveParserKW_SNAPSHOT, HiveParserKW_SORT, HiveParserKW_SORTED, HiveParserKW_SPEC, HiveParserKW_SSL, HiveParserKW_STATISTICS, HiveParserKW_STATUS, HiveParserKW_STORED, HiveParserKW_STREAMTABLE, HiveParserKW_STRING, HiveParserKW_STRUCT, HiveParserKW_SUMMARY, HiveParserKW_SYSTEM_TIME, HiveParserKW_SYSTEM_VERSION, HiveParserKW_TABLES, HiveParserKW_TBLPROPERTIES, HiveParserKW_TEMPORARY, HiveParserKW_TERMINATED, HiveParserKW_TIMESTAMPTZ, HiveParserKW_TINYINT, HiveParserKW_TOUCH, HiveParserKW_TRANSACTION, HiveParserKW_TRANSACTIONAL, HiveParserKW_TRANSACTIONS, HiveParserKW_TRIM, HiveParserKW_TYPE, HiveParserKW_UNARCHIVE, HiveParserKW_UNDO, HiveParserKW_UNIONTYPE, HiveParserKW_UNKNOWN, HiveParserKW_UNLOCK, HiveParserKW_UNMANAGED, HiveParserKW_UNSET, HiveParserKW_UNSIGNED, HiveParserKW_URI, HiveParserKW_URL, HiveParserKW_USE, HiveParserKW_UTC, HiveParserKW_UTCTIMESTAMP, HiveParserKW_VALIDATE, HiveParserKW_VALUE_TYPE, HiveParserKW_VECTORIZATION, HiveParserKW_VIEW, HiveParserKW_VIEWS, HiveParserKW_WAIT, HiveParserKW_WEEK, HiveParserKW_WHILE, HiveParserKW_WITHIN, HiveParserKW_WORK, HiveParserKW_WORKLOAD, HiveParserKW_WRITE, HiveParserKW_YEAR, HiveParserKW_ZONE, HiveParserStringLiteral, HiveParserIdentifier:
			{
				p.SetState(1467)
				p.ShowStmtIdentifier()
			}


		case HiveParserEOF:



		default:
		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1470)
			p.Match(HiveParserKW_SHOW)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1471)
			p.Match(HiveParserKW_FUNCTIONS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1474)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_LIKE {
			{
				p.SetState(1472)
				p.Match(HiveParserKW_LIKE)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1473)
				p.ShowFunctionIdentifier()
			}

		}


	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1476)
			p.Match(HiveParserKW_SHOW)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1477)
			p.Match(HiveParserKW_PARTITIONS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1478)

			var _x = p.TableName()


			localctx.(*ShowStatementContext).tabName = _x
		}
		p.SetState(1480)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_PARTITION {
			{
				p.SetState(1479)
				p.PartitionSpec()
			}

		}
		p.SetState(1483)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_WHERE {
			{
				p.SetState(1482)
				p.WhereClause()
			}

		}
		p.SetState(1486)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_ORDER {
			{
				p.SetState(1485)
				p.OrderByClause()
			}

		}
		p.SetState(1489)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_LIMIT {
			{
				p.SetState(1488)
				p.LimitClause()
			}

		}


	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1491)
			p.Match(HiveParserKW_SHOW)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1492)
			p.Match(HiveParserKW_CREATE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1498)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case HiveParserKW_DATABASE, HiveParserKW_SCHEMA:
			{
				p.SetState(1493)
				p.Db_schema()
			}
			{
				p.SetState(1494)

				var _x = p.Id_()


				localctx.(*ShowStatementContext).db_name = _x
			}


		case HiveParserKW_TABLE:
			{
				p.SetState(1496)
				p.Match(HiveParserKW_TABLE)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1497)

				var _x = p.TableName()


				localctx.(*ShowStatementContext).tabName = _x
			}



		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}


	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1500)
			p.Match(HiveParserKW_SHOW)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1501)
			p.Match(HiveParserKW_TABLE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1502)
			p.Match(HiveParserKW_EXTENDED)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1506)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_FROM || _la == HiveParserKW_IN {
			{
				p.SetState(1503)
				p.From_in()
			}
			{
				p.SetState(1504)

				var _x = p.Id_()


				localctx.(*ShowStatementContext).db_name = _x
			}

		}
		{
			p.SetState(1508)
			p.Match(HiveParserKW_LIKE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1509)
			p.ShowStmtIdentifier()
		}
		p.SetState(1511)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_PARTITION {
			{
				p.SetState(1510)
				p.PartitionSpec()
			}

		}


	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1513)
			p.Match(HiveParserKW_SHOW)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1514)
			p.Match(HiveParserKW_TBLPROPERTIES)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1515)
			p.TableName()
		}
		p.SetState(1519)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserLPAREN {
			{
				p.SetState(1516)
				p.Match(HiveParserLPAREN)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1517)

				var _m = p.Match(HiveParserStringLiteral)

				localctx.(*ShowStatementContext).prptyName = _m
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1518)
				p.Match(HiveParserRPAREN)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}


	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1521)
			p.Match(HiveParserKW_SHOW)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1522)
			p.Match(HiveParserKW_LOCKS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1534)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 81, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1523)
				p.Db_schema()
			}
			{
				p.SetState(1524)

				var _x = p.Id_()


				localctx.(*ShowStatementContext).dbName = _x
			}
			p.SetState(1526)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == HiveParserKW_EXTENDED {
				{
					p.SetState(1525)

					var _m = p.Match(HiveParserKW_EXTENDED)

					localctx.(*ShowStatementContext).isExtended = _m
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}

			}


		case 2:
			p.SetState(1529)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 808078815591695742) != 0) || ((int64((_la - 66)) & ^0x3f) == 0 && ((int64(1) << (_la - 66)) & 1083038567331911621) != 0) || ((int64((_la - 132)) & ^0x3f) == 0 && ((int64(1) << (_la - 132)) & 8916819943869537315) != 0) || ((int64((_la - 196)) & ^0x3f) == 0 && ((int64(1) << (_la - 196)) & 4159991143015340909) != 0) || ((int64((_la - 261)) & ^0x3f) == 0 && ((int64(1) << (_la - 261)) & 8484708576009596927) != 0) || ((int64((_la - 328)) & ^0x3f) == 0 && ((int64(1) << (_la - 328)) & 17776728909112555) != 0) || _la == HiveParserIdentifier {
				{
					p.SetState(1528)

					var _x = p.PartTypeExpr()


					localctx.(*ShowStatementContext).parttype = _x
				}

			}
			p.SetState(1532)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == HiveParserKW_EXTENDED {
				{
					p.SetState(1531)

					var _m = p.Match(HiveParserKW_EXTENDED)

					localctx.(*ShowStatementContext).isExtended = _m
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}

			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}


	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1536)
			p.Match(HiveParserKW_SHOW)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1537)
			p.Match(HiveParserKW_COMPACTIONS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1574)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 93, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1538)
				p.CompactionId()
			}


		case 2:
			{
				p.SetState(1539)
				p.Db_schema()
			}
			{
				p.SetState(1540)

				var _x = p.Id_()


				localctx.(*ShowStatementContext).dbName = _x
			}
			p.SetState(1542)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == HiveParserKW_POOL {
				{
					p.SetState(1541)
					p.CompactionPool()
				}

			}
			p.SetState(1545)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == HiveParserKW_TYPE {
				{
					p.SetState(1544)
					p.CompactionType()
				}

			}
			p.SetState(1548)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == HiveParserKW_STATUS {
				{
					p.SetState(1547)
					p.CompactionStatus()
				}

			}
			p.SetState(1551)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == HiveParserKW_ORDER {
				{
					p.SetState(1550)
					p.OrderByClause()
				}

			}
			p.SetState(1554)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == HiveParserKW_LIMIT {
				{
					p.SetState(1553)
					p.LimitClause()
				}

			}


		case 3:
			p.SetState(1557)
			p.GetErrorHandler().Sync(p)


			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 87, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(1556)

					var _x = p.PartTypeExpr()


					localctx.(*ShowStatementContext).parttype = _x
				}

				} else if p.HasError() { // JIM
					goto errorExit
			}
			p.SetState(1560)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == HiveParserKW_POOL {
				{
					p.SetState(1559)
					p.CompactionPool()
				}

			}
			p.SetState(1563)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == HiveParserKW_TYPE {
				{
					p.SetState(1562)
					p.CompactionType()
				}

			}
			p.SetState(1566)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == HiveParserKW_STATUS {
				{
					p.SetState(1565)
					p.CompactionStatus()
				}

			}
			p.SetState(1569)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == HiveParserKW_ORDER {
				{
					p.SetState(1568)
					p.OrderByClause()
				}

			}
			p.SetState(1572)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == HiveParserKW_LIMIT {
				{
					p.SetState(1571)
					p.LimitClause()
				}

			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}


	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1576)
			p.Match(HiveParserKW_SHOW)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1577)
			p.Match(HiveParserKW_TRANSACTIONS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1578)
			p.Match(HiveParserKW_SHOW)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1579)
			p.Match(HiveParserKW_CONF)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1580)
			p.Match(HiveParserStringLiteral)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(1581)
			p.Match(HiveParserKW_SHOW)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1582)
			p.Match(HiveParserKW_RESOURCE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1586)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case HiveParserKW_PLAN:
			{
				p.SetState(1583)
				p.Match(HiveParserKW_PLAN)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1584)

				var _x = p.Id_()


				localctx.(*ShowStatementContext).rp_name = _x
			}


		case HiveParserKW_PLANS:
			{
				p.SetState(1585)
				p.Match(HiveParserKW_PLANS)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}



		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}


	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(1588)
			p.Match(HiveParserKW_SHOW)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1589)
			p.Match(HiveParserKW_DATACONNECTORS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IShowTablesFilterExprContext is an interface to support dynamic dispatch.
type IShowTablesFilterExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_WHERE() antlr.TerminalNode
	Id_() IId_Context
	EQUAL() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode
	KW_LIKE() antlr.TerminalNode
	ShowStmtIdentifier() IShowStmtIdentifierContext

	// IsShowTablesFilterExprContext differentiates from other interfaces.
	IsShowTablesFilterExprContext()
}

type ShowTablesFilterExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowTablesFilterExprContext() *ShowTablesFilterExprContext {
	var p = new(ShowTablesFilterExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_showTablesFilterExpr
	return p
}

func InitEmptyShowTablesFilterExprContext(p *ShowTablesFilterExprContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_showTablesFilterExpr
}

func (*ShowTablesFilterExprContext) IsShowTablesFilterExprContext() {}

func NewShowTablesFilterExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowTablesFilterExprContext {
	var p = new(ShowTablesFilterExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_showTablesFilterExpr

	return p
}

func (s *ShowTablesFilterExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowTablesFilterExprContext) KW_WHERE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_WHERE, 0)
}

func (s *ShowTablesFilterExprContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *ShowTablesFilterExprContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(HiveParserEQUAL, 0)
}

func (s *ShowTablesFilterExprContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(HiveParserStringLiteral, 0)
}

func (s *ShowTablesFilterExprContext) KW_LIKE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_LIKE, 0)
}

func (s *ShowTablesFilterExprContext) ShowStmtIdentifier() IShowStmtIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowStmtIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowStmtIdentifierContext)
}

func (s *ShowTablesFilterExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTablesFilterExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ShowTablesFilterExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterShowTablesFilterExpr(s)
	}
}

func (s *ShowTablesFilterExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitShowTablesFilterExpr(s)
	}
}

func (s *ShowTablesFilterExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitShowTablesFilterExpr(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ShowTablesFilterExpr() (localctx IShowTablesFilterExprContext) {
	localctx = NewShowTablesFilterExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, HiveParserRULE_showTablesFilterExpr)
	p.SetState(1600)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserKW_WHERE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1592)
			p.Match(HiveParserKW_WHERE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1593)
			p.Id_()
		}
		{
			p.SetState(1594)
			p.Match(HiveParserEQUAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1595)
			p.Match(HiveParserStringLiteral)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HiveParserKW_LIKE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1597)
			p.Match(HiveParserKW_LIKE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1598)
			p.ShowStmtIdentifier()
		}


	case HiveParserKW_ABORT, HiveParserKW_ACTIVATE, HiveParserKW_ACTIVE, HiveParserKW_ADD, HiveParserKW_ADMIN, HiveParserKW_AFTER, HiveParserKW_ALLOC_FRACTION, HiveParserKW_ANALYZE, HiveParserKW_ARCHIVE, HiveParserKW_ASC, HiveParserKW_AST, HiveParserKW_AT, HiveParserKW_AUTOCOMMIT, HiveParserKW_BATCH, HiveParserKW_BEFORE, HiveParserKW_BUCKET, HiveParserKW_BUCKETS, HiveParserKW_CACHE, HiveParserKW_CASCADE, HiveParserKW_CBO, HiveParserKW_CHANGE, HiveParserKW_CHECK, HiveParserKW_CLUSTER, HiveParserKW_CLUSTERED, HiveParserKW_CLUSTERSTATUS, HiveParserKW_COLLECTION, HiveParserKW_COLUMNS, HiveParserKW_COMMENT, HiveParserKW_COMPACT, HiveParserKW_COMPACTIONS, HiveParserKW_COMPUTE, HiveParserKW_CONCATENATE, HiveParserKW_CONTINUE, HiveParserKW_COST, HiveParserKW_CRON, HiveParserKW_DATA, HiveParserKW_DATABASES, HiveParserKW_DATETIME, HiveParserKW_DAY, HiveParserKW_DAYOFWEEK, HiveParserKW_DBPROPERTIES, HiveParserKW_DCPROPERTIES, HiveParserKW_DEBUG, HiveParserKW_DEFAULT, HiveParserKW_DEFERRED, HiveParserKW_DEFINED, HiveParserKW_DELIMITED, HiveParserKW_DEPENDENCY, HiveParserKW_DESC, HiveParserKW_DETAIL, HiveParserKW_DIRECTORIES, HiveParserKW_DIRECTORY, HiveParserKW_DISABLE, HiveParserKW_DISTRIBUTE, HiveParserKW_DISTRIBUTED, HiveParserKW_DO, HiveParserKW_DOW, HiveParserKW_DUMP, HiveParserKW_ELEM_TYPE, HiveParserKW_ENABLE, HiveParserKW_ENFORCED, HiveParserKW_ESCAPED, HiveParserKW_EVERY, HiveParserKW_EXCLUSIVE, HiveParserKW_EXECUTE, HiveParserKW_EXECUTED, HiveParserKW_EXPIRE_SNAPSHOTS, HiveParserKW_EXPLAIN, HiveParserKW_EXPORT, HiveParserKW_EXPRESSION, HiveParserKW_FIELDS, HiveParserKW_FILE, HiveParserKW_FILEFORMAT, HiveParserKW_FIRST, HiveParserKW_FORMAT, HiveParserKW_FORMATTED, HiveParserKW_FUNCTIONS, HiveParserKW_HOLD_DDLTIME, HiveParserKW_HOUR, HiveParserKW_IDXPROPERTIES, HiveParserKW_IGNORE, HiveParserKW_INDEX, HiveParserKW_INDEXES, HiveParserKW_INPATH, HiveParserKW_INPUTDRIVER, HiveParserKW_INPUTFORMAT, HiveParserKW_ISOLATION, HiveParserKW_ITEMS, HiveParserKW_JAR, HiveParserKW_JOINCOST, HiveParserKW_KEY, HiveParserKW_KEYS, HiveParserKW_KEY_TYPE, HiveParserKW_KILL, HiveParserKW_LAST, HiveParserKW_LEVEL, HiveParserKW_LIMIT, HiveParserKW_LINES, HiveParserKW_LOAD, HiveParserKW_LOCATION, HiveParserKW_LOCK, HiveParserKW_LOCKS, HiveParserKW_LOGICAL, HiveParserKW_LONG, HiveParserKW_MANAGED, HiveParserKW_MANAGEDLOCATION, HiveParserKW_MANAGEMENT, HiveParserKW_MAPJOIN, HiveParserKW_MAPPING, HiveParserKW_MATCHED, HiveParserKW_MATERIALIZED, HiveParserKW_METADATA, HiveParserKW_MINUTE, HiveParserKW_MONTH, HiveParserKW_MOVE, HiveParserKW_MSCK, HiveParserKW_NORELY, HiveParserKW_NOSCAN, HiveParserKW_NOVALIDATE, HiveParserKW_NO_DROP, HiveParserKW_NULLS, HiveParserKW_OFFLINE, HiveParserKW_OFFSET, HiveParserKW_OPERATOR, HiveParserKW_OPTION, HiveParserKW_OUTPUTDRIVER, HiveParserKW_OUTPUTFORMAT, HiveParserKW_OVERWRITE, HiveParserKW_OWNER, HiveParserKW_PARTITIONED, HiveParserKW_PARTITIONS, HiveParserKW_PATH, HiveParserKW_PLAN, HiveParserKW_PLANS, HiveParserKW_PLUS, HiveParserKW_POOL, HiveParserKW_PRINCIPALS, HiveParserKW_PROTECTION, HiveParserKW_PURGE, HiveParserKW_QUARTER, HiveParserKW_QUERY, HiveParserKW_QUERY_PARALLELISM, HiveParserKW_READ, HiveParserKW_READONLY, HiveParserKW_REBUILD, HiveParserKW_RECORDREADER, HiveParserKW_RECORDWRITER, HiveParserKW_RELOAD, HiveParserKW_RELY, HiveParserKW_REMOTE, HiveParserKW_RENAME, HiveParserKW_REOPTIMIZATION, HiveParserKW_REPAIR, HiveParserKW_REPL, HiveParserKW_REPLACE, HiveParserKW_REPLICATION, HiveParserKW_RESOURCE, HiveParserKW_RESPECT, HiveParserKW_RESTRICT, HiveParserKW_REWRITE, HiveParserKW_ROLE, HiveParserKW_ROLES, HiveParserKW_SCHEDULED, HiveParserKW_SCHEDULING_POLICY, HiveParserKW_SCHEMA, HiveParserKW_SCHEMAS, HiveParserKW_SECOND, HiveParserKW_SEMI, HiveParserKW_SERDE, HiveParserKW_SERDEPROPERTIES, HiveParserKW_SERVER, HiveParserKW_SETS, HiveParserKW_SET_CURRENT_SNAPSHOT, HiveParserKW_SHARED, HiveParserKW_SHOW, HiveParserKW_SHOW_DATABASE, HiveParserKW_SKEWED, HiveParserKW_SNAPSHOT, HiveParserKW_SORT, HiveParserKW_SORTED, HiveParserKW_SPEC, HiveParserKW_SSL, HiveParserKW_STATISTICS, HiveParserKW_STATUS, HiveParserKW_STORED, HiveParserKW_STREAMTABLE, HiveParserKW_STRING, HiveParserKW_STRUCT, HiveParserKW_SUMMARY, HiveParserKW_SYSTEM_TIME, HiveParserKW_SYSTEM_VERSION, HiveParserKW_TABLES, HiveParserKW_TBLPROPERTIES, HiveParserKW_TEMPORARY, HiveParserKW_TERMINATED, HiveParserKW_TIMESTAMPTZ, HiveParserKW_TINYINT, HiveParserKW_TOUCH, HiveParserKW_TRANSACTION, HiveParserKW_TRANSACTIONAL, HiveParserKW_TRANSACTIONS, HiveParserKW_TRIM, HiveParserKW_TYPE, HiveParserKW_UNARCHIVE, HiveParserKW_UNDO, HiveParserKW_UNIONTYPE, HiveParserKW_UNKNOWN, HiveParserKW_UNLOCK, HiveParserKW_UNMANAGED, HiveParserKW_UNSET, HiveParserKW_UNSIGNED, HiveParserKW_URI, HiveParserKW_URL, HiveParserKW_USE, HiveParserKW_UTC, HiveParserKW_UTCTIMESTAMP, HiveParserKW_VALIDATE, HiveParserKW_VALUE_TYPE, HiveParserKW_VECTORIZATION, HiveParserKW_VIEW, HiveParserKW_VIEWS, HiveParserKW_WAIT, HiveParserKW_WEEK, HiveParserKW_WHILE, HiveParserKW_WITHIN, HiveParserKW_WORK, HiveParserKW_WORKLOAD, HiveParserKW_WRITE, HiveParserKW_YEAR, HiveParserKW_ZONE, HiveParserStringLiteral, HiveParserIdentifier:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1599)
			p.ShowStmtIdentifier()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ILockStatementContext is an interface to support dynamic dispatch.
type ILockStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_LOCK() antlr.TerminalNode
	KW_TABLE() antlr.TerminalNode
	TableName() ITableNameContext
	LockMode() ILockModeContext
	PartitionSpec() IPartitionSpecContext

	// IsLockStatementContext differentiates from other interfaces.
	IsLockStatementContext()
}

type LockStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLockStatementContext() *LockStatementContext {
	var p = new(LockStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_lockStatement
	return p
}

func InitEmptyLockStatementContext(p *LockStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_lockStatement
}

func (*LockStatementContext) IsLockStatementContext() {}

func NewLockStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LockStatementContext {
	var p = new(LockStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_lockStatement

	return p
}

func (s *LockStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LockStatementContext) KW_LOCK() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_LOCK, 0)
}

func (s *LockStatementContext) KW_TABLE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TABLE, 0)
}

func (s *LockStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *LockStatementContext) LockMode() ILockModeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILockModeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILockModeContext)
}

func (s *LockStatementContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *LockStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LockStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *LockStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterLockStatement(s)
	}
}

func (s *LockStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitLockStatement(s)
	}
}

func (s *LockStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitLockStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) LockStatement() (localctx ILockStatementContext) {
	localctx = NewLockStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, HiveParserRULE_lockStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1602)
		p.Match(HiveParserKW_LOCK)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1603)
		p.Match(HiveParserKW_TABLE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1604)
		p.TableName()
	}
	p.SetState(1606)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_PARTITION {
		{
			p.SetState(1605)
			p.PartitionSpec()
		}

	}
	{
		p.SetState(1608)
		p.LockMode()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ILockDatabaseContext is an interface to support dynamic dispatch.
type ILockDatabaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDbName returns the dbName rule contexts.
	GetDbName() IId_Context


	// SetDbName sets the dbName rule contexts.
	SetDbName(IId_Context)


	// Getter signatures
	KW_LOCK() antlr.TerminalNode
	Db_schema() IDb_schemaContext
	LockMode() ILockModeContext
	Id_() IId_Context

	// IsLockDatabaseContext differentiates from other interfaces.
	IsLockDatabaseContext()
}

type LockDatabaseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	dbName IId_Context 
}

func NewEmptyLockDatabaseContext() *LockDatabaseContext {
	var p = new(LockDatabaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_lockDatabase
	return p
}

func InitEmptyLockDatabaseContext(p *LockDatabaseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_lockDatabase
}

func (*LockDatabaseContext) IsLockDatabaseContext() {}

func NewLockDatabaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LockDatabaseContext {
	var p = new(LockDatabaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_lockDatabase

	return p
}

func (s *LockDatabaseContext) GetParser() antlr.Parser { return s.parser }

func (s *LockDatabaseContext) GetDbName() IId_Context { return s.dbName }


func (s *LockDatabaseContext) SetDbName(v IId_Context) { s.dbName = v }


func (s *LockDatabaseContext) KW_LOCK() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_LOCK, 0)
}

func (s *LockDatabaseContext) Db_schema() IDb_schemaContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDb_schemaContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDb_schemaContext)
}

func (s *LockDatabaseContext) LockMode() ILockModeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILockModeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILockModeContext)
}

func (s *LockDatabaseContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *LockDatabaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LockDatabaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *LockDatabaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterLockDatabase(s)
	}
}

func (s *LockDatabaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitLockDatabase(s)
	}
}

func (s *LockDatabaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitLockDatabase(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) LockDatabase() (localctx ILockDatabaseContext) {
	localctx = NewLockDatabaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, HiveParserRULE_lockDatabase)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1610)
		p.Match(HiveParserKW_LOCK)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1611)
		p.Db_schema()
	}
	{
		p.SetState(1612)

		var _x = p.Id_()


		localctx.(*LockDatabaseContext).dbName = _x
	}
	{
		p.SetState(1613)
		p.LockMode()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ILockModeContext is an interface to support dynamic dispatch.
type ILockModeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_SHARED() antlr.TerminalNode
	KW_EXCLUSIVE() antlr.TerminalNode

	// IsLockModeContext differentiates from other interfaces.
	IsLockModeContext()
}

type LockModeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLockModeContext() *LockModeContext {
	var p = new(LockModeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_lockMode
	return p
}

func InitEmptyLockModeContext(p *LockModeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_lockMode
}

func (*LockModeContext) IsLockModeContext() {}

func NewLockModeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LockModeContext {
	var p = new(LockModeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_lockMode

	return p
}

func (s *LockModeContext) GetParser() antlr.Parser { return s.parser }

func (s *LockModeContext) KW_SHARED() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SHARED, 0)
}

func (s *LockModeContext) KW_EXCLUSIVE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_EXCLUSIVE, 0)
}

func (s *LockModeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LockModeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *LockModeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterLockMode(s)
	}
}

func (s *LockModeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitLockMode(s)
	}
}

func (s *LockModeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitLockMode(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) LockMode() (localctx ILockModeContext) {
	localctx = NewLockModeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, HiveParserRULE_lockMode)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1615)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HiveParserKW_EXCLUSIVE || _la == HiveParserKW_SHARED) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IUnlockStatementContext is an interface to support dynamic dispatch.
type IUnlockStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_UNLOCK() antlr.TerminalNode
	KW_TABLE() antlr.TerminalNode
	TableName() ITableNameContext
	PartitionSpec() IPartitionSpecContext

	// IsUnlockStatementContext differentiates from other interfaces.
	IsUnlockStatementContext()
}

type UnlockStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnlockStatementContext() *UnlockStatementContext {
	var p = new(UnlockStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_unlockStatement
	return p
}

func InitEmptyUnlockStatementContext(p *UnlockStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_unlockStatement
}

func (*UnlockStatementContext) IsUnlockStatementContext() {}

func NewUnlockStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnlockStatementContext {
	var p = new(UnlockStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_unlockStatement

	return p
}

func (s *UnlockStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UnlockStatementContext) KW_UNLOCK() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_UNLOCK, 0)
}

func (s *UnlockStatementContext) KW_TABLE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TABLE, 0)
}

func (s *UnlockStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *UnlockStatementContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *UnlockStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnlockStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *UnlockStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterUnlockStatement(s)
	}
}

func (s *UnlockStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitUnlockStatement(s)
	}
}

func (s *UnlockStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitUnlockStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) UnlockStatement() (localctx IUnlockStatementContext) {
	localctx = NewUnlockStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, HiveParserRULE_unlockStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1617)
		p.Match(HiveParserKW_UNLOCK)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1618)
		p.Match(HiveParserKW_TABLE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1619)
		p.TableName()
	}
	p.SetState(1621)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_PARTITION {
		{
			p.SetState(1620)
			p.PartitionSpec()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IUnlockDatabaseContext is an interface to support dynamic dispatch.
type IUnlockDatabaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDbName returns the dbName rule contexts.
	GetDbName() IId_Context


	// SetDbName sets the dbName rule contexts.
	SetDbName(IId_Context)


	// Getter signatures
	KW_UNLOCK() antlr.TerminalNode
	Db_schema() IDb_schemaContext
	Id_() IId_Context

	// IsUnlockDatabaseContext differentiates from other interfaces.
	IsUnlockDatabaseContext()
}

type UnlockDatabaseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	dbName IId_Context 
}

func NewEmptyUnlockDatabaseContext() *UnlockDatabaseContext {
	var p = new(UnlockDatabaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_unlockDatabase
	return p
}

func InitEmptyUnlockDatabaseContext(p *UnlockDatabaseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_unlockDatabase
}

func (*UnlockDatabaseContext) IsUnlockDatabaseContext() {}

func NewUnlockDatabaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnlockDatabaseContext {
	var p = new(UnlockDatabaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_unlockDatabase

	return p
}

func (s *UnlockDatabaseContext) GetParser() antlr.Parser { return s.parser }

func (s *UnlockDatabaseContext) GetDbName() IId_Context { return s.dbName }


func (s *UnlockDatabaseContext) SetDbName(v IId_Context) { s.dbName = v }


func (s *UnlockDatabaseContext) KW_UNLOCK() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_UNLOCK, 0)
}

func (s *UnlockDatabaseContext) Db_schema() IDb_schemaContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDb_schemaContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDb_schemaContext)
}

func (s *UnlockDatabaseContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *UnlockDatabaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnlockDatabaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *UnlockDatabaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterUnlockDatabase(s)
	}
}

func (s *UnlockDatabaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitUnlockDatabase(s)
	}
}

func (s *UnlockDatabaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitUnlockDatabase(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) UnlockDatabase() (localctx IUnlockDatabaseContext) {
	localctx = NewUnlockDatabaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, HiveParserRULE_unlockDatabase)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1623)
		p.Match(HiveParserKW_UNLOCK)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1624)
		p.Db_schema()
	}
	{
		p.SetState(1625)

		var _x = p.Id_()


		localctx.(*UnlockDatabaseContext).dbName = _x
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreateRoleStatementContext is an interface to support dynamic dispatch.
type ICreateRoleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRoleName returns the roleName rule contexts.
	GetRoleName() IId_Context


	// SetRoleName sets the roleName rule contexts.
	SetRoleName(IId_Context)


	// Getter signatures
	KW_CREATE() antlr.TerminalNode
	KW_ROLE() antlr.TerminalNode
	Id_() IId_Context

	// IsCreateRoleStatementContext differentiates from other interfaces.
	IsCreateRoleStatementContext()
}

type CreateRoleStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	roleName IId_Context 
}

func NewEmptyCreateRoleStatementContext() *CreateRoleStatementContext {
	var p = new(CreateRoleStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_createRoleStatement
	return p
}

func InitEmptyCreateRoleStatementContext(p *CreateRoleStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_createRoleStatement
}

func (*CreateRoleStatementContext) IsCreateRoleStatementContext() {}

func NewCreateRoleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateRoleStatementContext {
	var p = new(CreateRoleStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_createRoleStatement

	return p
}

func (s *CreateRoleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateRoleStatementContext) GetRoleName() IId_Context { return s.roleName }


func (s *CreateRoleStatementContext) SetRoleName(v IId_Context) { s.roleName = v }


func (s *CreateRoleStatementContext) KW_CREATE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_CREATE, 0)
}

func (s *CreateRoleStatementContext) KW_ROLE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ROLE, 0)
}

func (s *CreateRoleStatementContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *CreateRoleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateRoleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CreateRoleStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterCreateRoleStatement(s)
	}
}

func (s *CreateRoleStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitCreateRoleStatement(s)
	}
}

func (s *CreateRoleStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitCreateRoleStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) CreateRoleStatement() (localctx ICreateRoleStatementContext) {
	localctx = NewCreateRoleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, HiveParserRULE_createRoleStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1627)
		p.Match(HiveParserKW_CREATE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1628)
		p.Match(HiveParserKW_ROLE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1629)

		var _x = p.Id_()


		localctx.(*CreateRoleStatementContext).roleName = _x
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDropRoleStatementContext is an interface to support dynamic dispatch.
type IDropRoleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRoleName returns the roleName rule contexts.
	GetRoleName() IId_Context


	// SetRoleName sets the roleName rule contexts.
	SetRoleName(IId_Context)


	// Getter signatures
	KW_DROP() antlr.TerminalNode
	KW_ROLE() antlr.TerminalNode
	Id_() IId_Context

	// IsDropRoleStatementContext differentiates from other interfaces.
	IsDropRoleStatementContext()
}

type DropRoleStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	roleName IId_Context 
}

func NewEmptyDropRoleStatementContext() *DropRoleStatementContext {
	var p = new(DropRoleStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_dropRoleStatement
	return p
}

func InitEmptyDropRoleStatementContext(p *DropRoleStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_dropRoleStatement
}

func (*DropRoleStatementContext) IsDropRoleStatementContext() {}

func NewDropRoleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropRoleStatementContext {
	var p = new(DropRoleStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_dropRoleStatement

	return p
}

func (s *DropRoleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropRoleStatementContext) GetRoleName() IId_Context { return s.roleName }


func (s *DropRoleStatementContext) SetRoleName(v IId_Context) { s.roleName = v }


func (s *DropRoleStatementContext) KW_DROP() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DROP, 0)
}

func (s *DropRoleStatementContext) KW_ROLE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ROLE, 0)
}

func (s *DropRoleStatementContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *DropRoleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropRoleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DropRoleStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterDropRoleStatement(s)
	}
}

func (s *DropRoleStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitDropRoleStatement(s)
	}
}

func (s *DropRoleStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitDropRoleStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) DropRoleStatement() (localctx IDropRoleStatementContext) {
	localctx = NewDropRoleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, HiveParserRULE_dropRoleStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1631)
		p.Match(HiveParserKW_DROP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1632)
		p.Match(HiveParserKW_ROLE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1633)

		var _x = p.Id_()


		localctx.(*DropRoleStatementContext).roleName = _x
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IGrantPrivilegesContext is an interface to support dynamic dispatch.
type IGrantPrivilegesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPrivList returns the privList rule contexts.
	GetPrivList() IPrivilegeListContext


	// SetPrivList sets the privList rule contexts.
	SetPrivList(IPrivilegeListContext)


	// Getter signatures
	KW_GRANT() antlr.TerminalNode
	KW_TO() antlr.TerminalNode
	PrincipalSpecification() IPrincipalSpecificationContext
	PrivilegeList() IPrivilegeListContext
	PrivilegeObject() IPrivilegeObjectContext
	WithGrantOption() IWithGrantOptionContext

	// IsGrantPrivilegesContext differentiates from other interfaces.
	IsGrantPrivilegesContext()
}

type GrantPrivilegesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	privList IPrivilegeListContext 
}

func NewEmptyGrantPrivilegesContext() *GrantPrivilegesContext {
	var p = new(GrantPrivilegesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_grantPrivileges
	return p
}

func InitEmptyGrantPrivilegesContext(p *GrantPrivilegesContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_grantPrivileges
}

func (*GrantPrivilegesContext) IsGrantPrivilegesContext() {}

func NewGrantPrivilegesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GrantPrivilegesContext {
	var p = new(GrantPrivilegesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_grantPrivileges

	return p
}

func (s *GrantPrivilegesContext) GetParser() antlr.Parser { return s.parser }

func (s *GrantPrivilegesContext) GetPrivList() IPrivilegeListContext { return s.privList }


func (s *GrantPrivilegesContext) SetPrivList(v IPrivilegeListContext) { s.privList = v }


func (s *GrantPrivilegesContext) KW_GRANT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_GRANT, 0)
}

func (s *GrantPrivilegesContext) KW_TO() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TO, 0)
}

func (s *GrantPrivilegesContext) PrincipalSpecification() IPrincipalSpecificationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrincipalSpecificationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrincipalSpecificationContext)
}

func (s *GrantPrivilegesContext) PrivilegeList() IPrivilegeListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeListContext)
}

func (s *GrantPrivilegesContext) PrivilegeObject() IPrivilegeObjectContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeObjectContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeObjectContext)
}

func (s *GrantPrivilegesContext) WithGrantOption() IWithGrantOptionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithGrantOptionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithGrantOptionContext)
}

func (s *GrantPrivilegesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantPrivilegesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *GrantPrivilegesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterGrantPrivileges(s)
	}
}

func (s *GrantPrivilegesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitGrantPrivileges(s)
	}
}

func (s *GrantPrivilegesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitGrantPrivileges(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) GrantPrivileges() (localctx IGrantPrivilegesContext) {
	localctx = NewGrantPrivilegesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, HiveParserRULE_grantPrivileges)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1635)
		p.Match(HiveParserKW_GRANT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1636)

		var _x = p.PrivilegeList()


		localctx.(*GrantPrivilegesContext).privList = _x
	}
	p.SetState(1638)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_ON {
		{
			p.SetState(1637)
			p.PrivilegeObject()
		}

	}
	{
		p.SetState(1640)
		p.Match(HiveParserKW_TO)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1641)
		p.PrincipalSpecification()
	}
	p.SetState(1643)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_WITH {
		{
			p.SetState(1642)
			p.WithGrantOption()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRevokePrivilegesContext is an interface to support dynamic dispatch.
type IRevokePrivilegesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_REVOKE() antlr.TerminalNode
	PrivilegeList() IPrivilegeListContext
	KW_FROM() antlr.TerminalNode
	PrincipalSpecification() IPrincipalSpecificationContext
	GrantOptionFor() IGrantOptionForContext
	PrivilegeObject() IPrivilegeObjectContext

	// IsRevokePrivilegesContext differentiates from other interfaces.
	IsRevokePrivilegesContext()
}

type RevokePrivilegesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRevokePrivilegesContext() *RevokePrivilegesContext {
	var p = new(RevokePrivilegesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_revokePrivileges
	return p
}

func InitEmptyRevokePrivilegesContext(p *RevokePrivilegesContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_revokePrivileges
}

func (*RevokePrivilegesContext) IsRevokePrivilegesContext() {}

func NewRevokePrivilegesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RevokePrivilegesContext {
	var p = new(RevokePrivilegesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_revokePrivileges

	return p
}

func (s *RevokePrivilegesContext) GetParser() antlr.Parser { return s.parser }

func (s *RevokePrivilegesContext) KW_REVOKE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_REVOKE, 0)
}

func (s *RevokePrivilegesContext) PrivilegeList() IPrivilegeListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeListContext)
}

func (s *RevokePrivilegesContext) KW_FROM() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_FROM, 0)
}

func (s *RevokePrivilegesContext) PrincipalSpecification() IPrincipalSpecificationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrincipalSpecificationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrincipalSpecificationContext)
}

func (s *RevokePrivilegesContext) GrantOptionFor() IGrantOptionForContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantOptionForContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantOptionForContext)
}

func (s *RevokePrivilegesContext) PrivilegeObject() IPrivilegeObjectContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeObjectContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeObjectContext)
}

func (s *RevokePrivilegesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokePrivilegesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *RevokePrivilegesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterRevokePrivileges(s)
	}
}

func (s *RevokePrivilegesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitRevokePrivileges(s)
	}
}

func (s *RevokePrivilegesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitRevokePrivileges(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) RevokePrivileges() (localctx IRevokePrivilegesContext) {
	localctx = NewRevokePrivilegesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, HiveParserRULE_revokePrivileges)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1645)
		p.Match(HiveParserKW_REVOKE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1647)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_GRANT {
		{
			p.SetState(1646)
			p.GrantOptionFor()
		}

	}
	{
		p.SetState(1649)
		p.PrivilegeList()
	}
	p.SetState(1651)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_ON {
		{
			p.SetState(1650)
			p.PrivilegeObject()
		}

	}
	{
		p.SetState(1653)
		p.Match(HiveParserKW_FROM)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1654)
		p.PrincipalSpecification()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IGrantRoleContext is an interface to support dynamic dispatch.
type IGrantRoleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_GRANT() antlr.TerminalNode
	AllId_() []IId_Context
	Id_(i int) IId_Context
	KW_TO() antlr.TerminalNode
	PrincipalSpecification() IPrincipalSpecificationContext
	KW_ROLE() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	WithAdminOption() IWithAdminOptionContext

	// IsGrantRoleContext differentiates from other interfaces.
	IsGrantRoleContext()
}

type GrantRoleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGrantRoleContext() *GrantRoleContext {
	var p = new(GrantRoleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_grantRole
	return p
}

func InitEmptyGrantRoleContext(p *GrantRoleContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_grantRole
}

func (*GrantRoleContext) IsGrantRoleContext() {}

func NewGrantRoleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GrantRoleContext {
	var p = new(GrantRoleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_grantRole

	return p
}

func (s *GrantRoleContext) GetParser() antlr.Parser { return s.parser }

func (s *GrantRoleContext) KW_GRANT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_GRANT, 0)
}

func (s *GrantRoleContext) AllId_() []IId_Context {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IId_Context); ok {
			len++
		}
	}

	tst := make([]IId_Context, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IId_Context); ok {
			tst[i] = t.(IId_Context)
			i++
		}
	}

	return tst
}

func (s *GrantRoleContext) Id_(i int) IId_Context {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *GrantRoleContext) KW_TO() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TO, 0)
}

func (s *GrantRoleContext) PrincipalSpecification() IPrincipalSpecificationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrincipalSpecificationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrincipalSpecificationContext)
}

func (s *GrantRoleContext) KW_ROLE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ROLE, 0)
}

func (s *GrantRoleContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(HiveParserCOMMA)
}

func (s *GrantRoleContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserCOMMA, i)
}

func (s *GrantRoleContext) WithAdminOption() IWithAdminOptionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithAdminOptionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithAdminOptionContext)
}

func (s *GrantRoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantRoleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *GrantRoleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterGrantRole(s)
	}
}

func (s *GrantRoleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitGrantRole(s)
	}
}

func (s *GrantRoleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitGrantRole(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) GrantRole() (localctx IGrantRoleContext) {
	localctx = NewGrantRoleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, HiveParserRULE_grantRole)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1656)
		p.Match(HiveParserKW_GRANT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1658)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 103, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1657)
			p.Match(HiveParserKW_ROLE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(1660)
		p.Id_()
	}
	p.SetState(1665)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HiveParserCOMMA {
		{
			p.SetState(1661)
			p.Match(HiveParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1662)
			p.Id_()
		}


		p.SetState(1667)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1668)
		p.Match(HiveParserKW_TO)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1669)
		p.PrincipalSpecification()
	}
	p.SetState(1671)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_WITH {
		{
			p.SetState(1670)
			p.WithAdminOption()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRevokeRoleContext is an interface to support dynamic dispatch.
type IRevokeRoleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_REVOKE() antlr.TerminalNode
	AllId_() []IId_Context
	Id_(i int) IId_Context
	KW_FROM() antlr.TerminalNode
	PrincipalSpecification() IPrincipalSpecificationContext
	AdminOptionFor() IAdminOptionForContext
	KW_ROLE() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsRevokeRoleContext differentiates from other interfaces.
	IsRevokeRoleContext()
}

type RevokeRoleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRevokeRoleContext() *RevokeRoleContext {
	var p = new(RevokeRoleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_revokeRole
	return p
}

func InitEmptyRevokeRoleContext(p *RevokeRoleContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_revokeRole
}

func (*RevokeRoleContext) IsRevokeRoleContext() {}

func NewRevokeRoleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RevokeRoleContext {
	var p = new(RevokeRoleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_revokeRole

	return p
}

func (s *RevokeRoleContext) GetParser() antlr.Parser { return s.parser }

func (s *RevokeRoleContext) KW_REVOKE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_REVOKE, 0)
}

func (s *RevokeRoleContext) AllId_() []IId_Context {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IId_Context); ok {
			len++
		}
	}

	tst := make([]IId_Context, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IId_Context); ok {
			tst[i] = t.(IId_Context)
			i++
		}
	}

	return tst
}

func (s *RevokeRoleContext) Id_(i int) IId_Context {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *RevokeRoleContext) KW_FROM() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_FROM, 0)
}

func (s *RevokeRoleContext) PrincipalSpecification() IPrincipalSpecificationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrincipalSpecificationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrincipalSpecificationContext)
}

func (s *RevokeRoleContext) AdminOptionFor() IAdminOptionForContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdminOptionForContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdminOptionForContext)
}

func (s *RevokeRoleContext) KW_ROLE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ROLE, 0)
}

func (s *RevokeRoleContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(HiveParserCOMMA)
}

func (s *RevokeRoleContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserCOMMA, i)
}

func (s *RevokeRoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokeRoleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *RevokeRoleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterRevokeRole(s)
	}
}

func (s *RevokeRoleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitRevokeRole(s)
	}
}

func (s *RevokeRoleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitRevokeRole(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) RevokeRole() (localctx IRevokeRoleContext) {
	localctx = NewRevokeRoleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, HiveParserRULE_revokeRole)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1673)
		p.Match(HiveParserKW_REVOKE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1675)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 106, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1674)
			p.AdminOptionFor()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	p.SetState(1678)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 107, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1677)
			p.Match(HiveParserKW_ROLE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(1680)
		p.Id_()
	}
	p.SetState(1685)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HiveParserCOMMA {
		{
			p.SetState(1681)
			p.Match(HiveParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1682)
			p.Id_()
		}


		p.SetState(1687)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1688)
		p.Match(HiveParserKW_FROM)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1689)
		p.PrincipalSpecification()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IShowRoleGrantsContext is an interface to support dynamic dispatch.
type IShowRoleGrantsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_SHOW() antlr.TerminalNode
	KW_ROLE() antlr.TerminalNode
	KW_GRANT() antlr.TerminalNode
	PrincipalName() IPrincipalNameContext

	// IsShowRoleGrantsContext differentiates from other interfaces.
	IsShowRoleGrantsContext()
}

type ShowRoleGrantsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowRoleGrantsContext() *ShowRoleGrantsContext {
	var p = new(ShowRoleGrantsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_showRoleGrants
	return p
}

func InitEmptyShowRoleGrantsContext(p *ShowRoleGrantsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_showRoleGrants
}

func (*ShowRoleGrantsContext) IsShowRoleGrantsContext() {}

func NewShowRoleGrantsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowRoleGrantsContext {
	var p = new(ShowRoleGrantsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_showRoleGrants

	return p
}

func (s *ShowRoleGrantsContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowRoleGrantsContext) KW_SHOW() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SHOW, 0)
}

func (s *ShowRoleGrantsContext) KW_ROLE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ROLE, 0)
}

func (s *ShowRoleGrantsContext) KW_GRANT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_GRANT, 0)
}

func (s *ShowRoleGrantsContext) PrincipalName() IPrincipalNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrincipalNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrincipalNameContext)
}

func (s *ShowRoleGrantsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowRoleGrantsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ShowRoleGrantsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterShowRoleGrants(s)
	}
}

func (s *ShowRoleGrantsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitShowRoleGrants(s)
	}
}

func (s *ShowRoleGrantsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitShowRoleGrants(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ShowRoleGrants() (localctx IShowRoleGrantsContext) {
	localctx = NewShowRoleGrantsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, HiveParserRULE_showRoleGrants)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1691)
		p.Match(HiveParserKW_SHOW)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1692)
		p.Match(HiveParserKW_ROLE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1693)
		p.Match(HiveParserKW_GRANT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1694)
		p.PrincipalName()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IShowRolesContext is an interface to support dynamic dispatch.
type IShowRolesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_SHOW() antlr.TerminalNode
	KW_ROLES() antlr.TerminalNode

	// IsShowRolesContext differentiates from other interfaces.
	IsShowRolesContext()
}

type ShowRolesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowRolesContext() *ShowRolesContext {
	var p = new(ShowRolesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_showRoles
	return p
}

func InitEmptyShowRolesContext(p *ShowRolesContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_showRoles
}

func (*ShowRolesContext) IsShowRolesContext() {}

func NewShowRolesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowRolesContext {
	var p = new(ShowRolesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_showRoles

	return p
}

func (s *ShowRolesContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowRolesContext) KW_SHOW() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SHOW, 0)
}

func (s *ShowRolesContext) KW_ROLES() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ROLES, 0)
}

func (s *ShowRolesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowRolesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ShowRolesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterShowRoles(s)
	}
}

func (s *ShowRolesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitShowRoles(s)
	}
}

func (s *ShowRolesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitShowRoles(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ShowRoles() (localctx IShowRolesContext) {
	localctx = NewShowRolesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, HiveParserRULE_showRoles)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1696)
		p.Match(HiveParserKW_SHOW)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1697)
		p.Match(HiveParserKW_ROLES)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IShowCurrentRoleContext is an interface to support dynamic dispatch.
type IShowCurrentRoleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_SHOW() antlr.TerminalNode
	KW_CURRENT() antlr.TerminalNode
	KW_ROLES() antlr.TerminalNode

	// IsShowCurrentRoleContext differentiates from other interfaces.
	IsShowCurrentRoleContext()
}

type ShowCurrentRoleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowCurrentRoleContext() *ShowCurrentRoleContext {
	var p = new(ShowCurrentRoleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_showCurrentRole
	return p
}

func InitEmptyShowCurrentRoleContext(p *ShowCurrentRoleContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_showCurrentRole
}

func (*ShowCurrentRoleContext) IsShowCurrentRoleContext() {}

func NewShowCurrentRoleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowCurrentRoleContext {
	var p = new(ShowCurrentRoleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_showCurrentRole

	return p
}

func (s *ShowCurrentRoleContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowCurrentRoleContext) KW_SHOW() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SHOW, 0)
}

func (s *ShowCurrentRoleContext) KW_CURRENT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_CURRENT, 0)
}

func (s *ShowCurrentRoleContext) KW_ROLES() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ROLES, 0)
}

func (s *ShowCurrentRoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCurrentRoleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ShowCurrentRoleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterShowCurrentRole(s)
	}
}

func (s *ShowCurrentRoleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitShowCurrentRole(s)
	}
}

func (s *ShowCurrentRoleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitShowCurrentRole(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ShowCurrentRole() (localctx IShowCurrentRoleContext) {
	localctx = NewShowCurrentRoleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, HiveParserRULE_showCurrentRole)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1699)
		p.Match(HiveParserKW_SHOW)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1700)
		p.Match(HiveParserKW_CURRENT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1701)
		p.Match(HiveParserKW_ROLES)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISetRoleContext is an interface to support dynamic dispatch.
type ISetRoleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetAll returns the all token.
	GetAll() antlr.Token 

	// GetNone returns the none token.
	GetNone() antlr.Token 


	// SetAll sets the all token.
	SetAll(antlr.Token) 

	// SetNone sets the none token.
	SetNone(antlr.Token) 


	// Getter signatures
	KW_SET() antlr.TerminalNode
	KW_ROLE() antlr.TerminalNode
	Id_() IId_Context
	KW_ALL() antlr.TerminalNode
	KW_NONE() antlr.TerminalNode

	// IsSetRoleContext differentiates from other interfaces.
	IsSetRoleContext()
}

type SetRoleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	all antlr.Token
	none antlr.Token
}

func NewEmptySetRoleContext() *SetRoleContext {
	var p = new(SetRoleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_setRole
	return p
}

func InitEmptySetRoleContext(p *SetRoleContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_setRole
}

func (*SetRoleContext) IsSetRoleContext() {}

func NewSetRoleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetRoleContext {
	var p = new(SetRoleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_setRole

	return p
}

func (s *SetRoleContext) GetParser() antlr.Parser { return s.parser }

func (s *SetRoleContext) GetAll() antlr.Token { return s.all }

func (s *SetRoleContext) GetNone() antlr.Token { return s.none }


func (s *SetRoleContext) SetAll(v antlr.Token) { s.all = v }

func (s *SetRoleContext) SetNone(v antlr.Token) { s.none = v }


func (s *SetRoleContext) KW_SET() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SET, 0)
}

func (s *SetRoleContext) KW_ROLE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ROLE, 0)
}

func (s *SetRoleContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *SetRoleContext) KW_ALL() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ALL, 0)
}

func (s *SetRoleContext) KW_NONE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_NONE, 0)
}

func (s *SetRoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetRoleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SetRoleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterSetRole(s)
	}
}

func (s *SetRoleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitSetRole(s)
	}
}

func (s *SetRoleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitSetRole(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) SetRole() (localctx ISetRoleContext) {
	localctx = NewSetRoleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, HiveParserRULE_setRole)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1703)
		p.Match(HiveParserKW_SET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1704)
		p.Match(HiveParserKW_ROLE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1708)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserKW_ALL:
		{
			p.SetState(1705)

			var _m = p.Match(HiveParserKW_ALL)

			localctx.(*SetRoleContext).all = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HiveParserKW_NONE:
		{
			p.SetState(1706)

			var _m = p.Match(HiveParserKW_NONE)

			localctx.(*SetRoleContext).none = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HiveParserKW_ABORT, HiveParserKW_ACTIVATE, HiveParserKW_ACTIVE, HiveParserKW_ADD, HiveParserKW_ADMIN, HiveParserKW_AFTER, HiveParserKW_ALLOC_FRACTION, HiveParserKW_ANALYZE, HiveParserKW_ARCHIVE, HiveParserKW_ASC, HiveParserKW_AST, HiveParserKW_AT, HiveParserKW_AUTOCOMMIT, HiveParserKW_BATCH, HiveParserKW_BEFORE, HiveParserKW_BUCKET, HiveParserKW_BUCKETS, HiveParserKW_CACHE, HiveParserKW_CASCADE, HiveParserKW_CBO, HiveParserKW_CHANGE, HiveParserKW_CHECK, HiveParserKW_CLUSTER, HiveParserKW_CLUSTERED, HiveParserKW_CLUSTERSTATUS, HiveParserKW_COLLECTION, HiveParserKW_COLUMNS, HiveParserKW_COMMENT, HiveParserKW_COMPACT, HiveParserKW_COMPACTIONS, HiveParserKW_COMPUTE, HiveParserKW_CONCATENATE, HiveParserKW_CONTINUE, HiveParserKW_COST, HiveParserKW_CRON, HiveParserKW_DATA, HiveParserKW_DATABASES, HiveParserKW_DATETIME, HiveParserKW_DAY, HiveParserKW_DAYOFWEEK, HiveParserKW_DBPROPERTIES, HiveParserKW_DCPROPERTIES, HiveParserKW_DEBUG, HiveParserKW_DEFAULT, HiveParserKW_DEFERRED, HiveParserKW_DEFINED, HiveParserKW_DELIMITED, HiveParserKW_DEPENDENCY, HiveParserKW_DESC, HiveParserKW_DETAIL, HiveParserKW_DIRECTORIES, HiveParserKW_DIRECTORY, HiveParserKW_DISABLE, HiveParserKW_DISTRIBUTE, HiveParserKW_DISTRIBUTED, HiveParserKW_DO, HiveParserKW_DOW, HiveParserKW_DUMP, HiveParserKW_ELEM_TYPE, HiveParserKW_ENABLE, HiveParserKW_ENFORCED, HiveParserKW_ESCAPED, HiveParserKW_EVERY, HiveParserKW_EXCLUSIVE, HiveParserKW_EXECUTE, HiveParserKW_EXECUTED, HiveParserKW_EXPIRE_SNAPSHOTS, HiveParserKW_EXPLAIN, HiveParserKW_EXPORT, HiveParserKW_EXPRESSION, HiveParserKW_FIELDS, HiveParserKW_FILE, HiveParserKW_FILEFORMAT, HiveParserKW_FIRST, HiveParserKW_FORMAT, HiveParserKW_FORMATTED, HiveParserKW_FUNCTIONS, HiveParserKW_HOLD_DDLTIME, HiveParserKW_HOUR, HiveParserKW_IDXPROPERTIES, HiveParserKW_IGNORE, HiveParserKW_INDEX, HiveParserKW_INDEXES, HiveParserKW_INPATH, HiveParserKW_INPUTDRIVER, HiveParserKW_INPUTFORMAT, HiveParserKW_ISOLATION, HiveParserKW_ITEMS, HiveParserKW_JAR, HiveParserKW_JOINCOST, HiveParserKW_KEY, HiveParserKW_KEYS, HiveParserKW_KEY_TYPE, HiveParserKW_KILL, HiveParserKW_LAST, HiveParserKW_LEVEL, HiveParserKW_LIMIT, HiveParserKW_LINES, HiveParserKW_LOAD, HiveParserKW_LOCATION, HiveParserKW_LOCK, HiveParserKW_LOCKS, HiveParserKW_LOGICAL, HiveParserKW_LONG, HiveParserKW_MANAGED, HiveParserKW_MANAGEDLOCATION, HiveParserKW_MANAGEMENT, HiveParserKW_MAPJOIN, HiveParserKW_MAPPING, HiveParserKW_MATCHED, HiveParserKW_MATERIALIZED, HiveParserKW_METADATA, HiveParserKW_MINUTE, HiveParserKW_MONTH, HiveParserKW_MOVE, HiveParserKW_MSCK, HiveParserKW_NORELY, HiveParserKW_NOSCAN, HiveParserKW_NOVALIDATE, HiveParserKW_NO_DROP, HiveParserKW_NULLS, HiveParserKW_OFFLINE, HiveParserKW_OFFSET, HiveParserKW_OPERATOR, HiveParserKW_OPTION, HiveParserKW_OUTPUTDRIVER, HiveParserKW_OUTPUTFORMAT, HiveParserKW_OVERWRITE, HiveParserKW_OWNER, HiveParserKW_PARTITIONED, HiveParserKW_PARTITIONS, HiveParserKW_PATH, HiveParserKW_PLAN, HiveParserKW_PLANS, HiveParserKW_PLUS, HiveParserKW_POOL, HiveParserKW_PRINCIPALS, HiveParserKW_PROTECTION, HiveParserKW_PURGE, HiveParserKW_QUARTER, HiveParserKW_QUERY, HiveParserKW_QUERY_PARALLELISM, HiveParserKW_READ, HiveParserKW_READONLY, HiveParserKW_REBUILD, HiveParserKW_RECORDREADER, HiveParserKW_RECORDWRITER, HiveParserKW_RELOAD, HiveParserKW_RELY, HiveParserKW_REMOTE, HiveParserKW_RENAME, HiveParserKW_REOPTIMIZATION, HiveParserKW_REPAIR, HiveParserKW_REPL, HiveParserKW_REPLACE, HiveParserKW_REPLICATION, HiveParserKW_RESOURCE, HiveParserKW_RESPECT, HiveParserKW_RESTRICT, HiveParserKW_REWRITE, HiveParserKW_ROLE, HiveParserKW_ROLES, HiveParserKW_SCHEDULED, HiveParserKW_SCHEDULING_POLICY, HiveParserKW_SCHEMA, HiveParserKW_SCHEMAS, HiveParserKW_SECOND, HiveParserKW_SEMI, HiveParserKW_SERDE, HiveParserKW_SERDEPROPERTIES, HiveParserKW_SERVER, HiveParserKW_SETS, HiveParserKW_SET_CURRENT_SNAPSHOT, HiveParserKW_SHARED, HiveParserKW_SHOW, HiveParserKW_SHOW_DATABASE, HiveParserKW_SKEWED, HiveParserKW_SNAPSHOT, HiveParserKW_SORT, HiveParserKW_SORTED, HiveParserKW_SPEC, HiveParserKW_SSL, HiveParserKW_STATISTICS, HiveParserKW_STATUS, HiveParserKW_STORED, HiveParserKW_STREAMTABLE, HiveParserKW_STRING, HiveParserKW_STRUCT, HiveParserKW_SUMMARY, HiveParserKW_SYSTEM_TIME, HiveParserKW_SYSTEM_VERSION, HiveParserKW_TABLES, HiveParserKW_TBLPROPERTIES, HiveParserKW_TEMPORARY, HiveParserKW_TERMINATED, HiveParserKW_TIMESTAMPTZ, HiveParserKW_TINYINT, HiveParserKW_TOUCH, HiveParserKW_TRANSACTION, HiveParserKW_TRANSACTIONAL, HiveParserKW_TRANSACTIONS, HiveParserKW_TRIM, HiveParserKW_TYPE, HiveParserKW_UNARCHIVE, HiveParserKW_UNDO, HiveParserKW_UNIONTYPE, HiveParserKW_UNKNOWN, HiveParserKW_UNLOCK, HiveParserKW_UNMANAGED, HiveParserKW_UNSET, HiveParserKW_UNSIGNED, HiveParserKW_URI, HiveParserKW_URL, HiveParserKW_USE, HiveParserKW_UTC, HiveParserKW_UTCTIMESTAMP, HiveParserKW_VALIDATE, HiveParserKW_VALUE_TYPE, HiveParserKW_VECTORIZATION, HiveParserKW_VIEW, HiveParserKW_VIEWS, HiveParserKW_WAIT, HiveParserKW_WEEK, HiveParserKW_WHILE, HiveParserKW_WITHIN, HiveParserKW_WORK, HiveParserKW_WORKLOAD, HiveParserKW_WRITE, HiveParserKW_YEAR, HiveParserKW_ZONE, HiveParserIdentifier:
		{
			p.SetState(1707)
			p.Id_()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IShowGrantsContext is an interface to support dynamic dispatch.
type IShowGrantsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_SHOW() antlr.TerminalNode
	KW_GRANT() antlr.TerminalNode
	PrincipalName() IPrincipalNameContext
	KW_ON() antlr.TerminalNode
	PrivilegeIncludeColObject() IPrivilegeIncludeColObjectContext

	// IsShowGrantsContext differentiates from other interfaces.
	IsShowGrantsContext()
}

type ShowGrantsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowGrantsContext() *ShowGrantsContext {
	var p = new(ShowGrantsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_showGrants
	return p
}

func InitEmptyShowGrantsContext(p *ShowGrantsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_showGrants
}

func (*ShowGrantsContext) IsShowGrantsContext() {}

func NewShowGrantsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowGrantsContext {
	var p = new(ShowGrantsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_showGrants

	return p
}

func (s *ShowGrantsContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowGrantsContext) KW_SHOW() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SHOW, 0)
}

func (s *ShowGrantsContext) KW_GRANT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_GRANT, 0)
}

func (s *ShowGrantsContext) PrincipalName() IPrincipalNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrincipalNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrincipalNameContext)
}

func (s *ShowGrantsContext) KW_ON() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ON, 0)
}

func (s *ShowGrantsContext) PrivilegeIncludeColObject() IPrivilegeIncludeColObjectContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeIncludeColObjectContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeIncludeColObjectContext)
}

func (s *ShowGrantsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowGrantsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ShowGrantsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterShowGrants(s)
	}
}

func (s *ShowGrantsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitShowGrants(s)
	}
}

func (s *ShowGrantsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitShowGrants(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ShowGrants() (localctx IShowGrantsContext) {
	localctx = NewShowGrantsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, HiveParserRULE_showGrants)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1710)
		p.Match(HiveParserKW_SHOW)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1711)
		p.Match(HiveParserKW_GRANT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1713)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_GROUP || _la == HiveParserKW_ROLE || _la == HiveParserKW_USER {
		{
			p.SetState(1712)
			p.PrincipalName()
		}

	}
	p.SetState(1717)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_ON {
		{
			p.SetState(1715)
			p.Match(HiveParserKW_ON)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1716)
			p.PrivilegeIncludeColObject()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IShowRolePrincipalsContext is an interface to support dynamic dispatch.
type IShowRolePrincipalsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRoleName returns the roleName rule contexts.
	GetRoleName() IId_Context


	// SetRoleName sets the roleName rule contexts.
	SetRoleName(IId_Context)


	// Getter signatures
	KW_SHOW() antlr.TerminalNode
	KW_PRINCIPALS() antlr.TerminalNode
	Id_() IId_Context

	// IsShowRolePrincipalsContext differentiates from other interfaces.
	IsShowRolePrincipalsContext()
}

type ShowRolePrincipalsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	roleName IId_Context 
}

func NewEmptyShowRolePrincipalsContext() *ShowRolePrincipalsContext {
	var p = new(ShowRolePrincipalsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_showRolePrincipals
	return p
}

func InitEmptyShowRolePrincipalsContext(p *ShowRolePrincipalsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_showRolePrincipals
}

func (*ShowRolePrincipalsContext) IsShowRolePrincipalsContext() {}

func NewShowRolePrincipalsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowRolePrincipalsContext {
	var p = new(ShowRolePrincipalsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_showRolePrincipals

	return p
}

func (s *ShowRolePrincipalsContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowRolePrincipalsContext) GetRoleName() IId_Context { return s.roleName }


func (s *ShowRolePrincipalsContext) SetRoleName(v IId_Context) { s.roleName = v }


func (s *ShowRolePrincipalsContext) KW_SHOW() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SHOW, 0)
}

func (s *ShowRolePrincipalsContext) KW_PRINCIPALS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_PRINCIPALS, 0)
}

func (s *ShowRolePrincipalsContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *ShowRolePrincipalsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowRolePrincipalsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ShowRolePrincipalsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterShowRolePrincipals(s)
	}
}

func (s *ShowRolePrincipalsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitShowRolePrincipals(s)
	}
}

func (s *ShowRolePrincipalsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitShowRolePrincipals(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ShowRolePrincipals() (localctx IShowRolePrincipalsContext) {
	localctx = NewShowRolePrincipalsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, HiveParserRULE_showRolePrincipals)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1719)
		p.Match(HiveParserKW_SHOW)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1720)
		p.Match(HiveParserKW_PRINCIPALS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1721)

		var _x = p.Id_()


		localctx.(*ShowRolePrincipalsContext).roleName = _x
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPrivilegeIncludeColObjectContext is an interface to support dynamic dispatch.
type IPrivilegeIncludeColObjectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_ALL() antlr.TerminalNode
	PrivObjectCols() IPrivObjectColsContext

	// IsPrivilegeIncludeColObjectContext differentiates from other interfaces.
	IsPrivilegeIncludeColObjectContext()
}

type PrivilegeIncludeColObjectContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivilegeIncludeColObjectContext() *PrivilegeIncludeColObjectContext {
	var p = new(PrivilegeIncludeColObjectContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_privilegeIncludeColObject
	return p
}

func InitEmptyPrivilegeIncludeColObjectContext(p *PrivilegeIncludeColObjectContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_privilegeIncludeColObject
}

func (*PrivilegeIncludeColObjectContext) IsPrivilegeIncludeColObjectContext() {}

func NewPrivilegeIncludeColObjectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivilegeIncludeColObjectContext {
	var p = new(PrivilegeIncludeColObjectContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_privilegeIncludeColObject

	return p
}

func (s *PrivilegeIncludeColObjectContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivilegeIncludeColObjectContext) KW_ALL() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ALL, 0)
}

func (s *PrivilegeIncludeColObjectContext) PrivObjectCols() IPrivObjectColsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivObjectColsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivObjectColsContext)
}

func (s *PrivilegeIncludeColObjectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivilegeIncludeColObjectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PrivilegeIncludeColObjectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterPrivilegeIncludeColObject(s)
	}
}

func (s *PrivilegeIncludeColObjectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitPrivilegeIncludeColObject(s)
	}
}

func (s *PrivilegeIncludeColObjectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitPrivilegeIncludeColObject(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) PrivilegeIncludeColObject() (localctx IPrivilegeIncludeColObjectContext) {
	localctx = NewPrivilegeIncludeColObjectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, HiveParserRULE_privilegeIncludeColObject)
	p.SetState(1725)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserKW_ALL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1723)
			p.Match(HiveParserKW_ALL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HiveParserKW_ABORT, HiveParserKW_ACTIVATE, HiveParserKW_ACTIVE, HiveParserKW_ADD, HiveParserKW_ADMIN, HiveParserKW_AFTER, HiveParserKW_ALLOC_FRACTION, HiveParserKW_ANALYZE, HiveParserKW_ARCHIVE, HiveParserKW_ASC, HiveParserKW_AST, HiveParserKW_AT, HiveParserKW_AUTOCOMMIT, HiveParserKW_BATCH, HiveParserKW_BEFORE, HiveParserKW_BUCKET, HiveParserKW_BUCKETS, HiveParserKW_CACHE, HiveParserKW_CASCADE, HiveParserKW_CBO, HiveParserKW_CHANGE, HiveParserKW_CHECK, HiveParserKW_CLUSTER, HiveParserKW_CLUSTERED, HiveParserKW_CLUSTERSTATUS, HiveParserKW_COLLECTION, HiveParserKW_COLUMNS, HiveParserKW_COMMENT, HiveParserKW_COMPACT, HiveParserKW_COMPACTIONS, HiveParserKW_COMPUTE, HiveParserKW_CONCATENATE, HiveParserKW_CONTINUE, HiveParserKW_COST, HiveParserKW_CRON, HiveParserKW_DATA, HiveParserKW_DATABASE, HiveParserKW_DATABASES, HiveParserKW_DATETIME, HiveParserKW_DAY, HiveParserKW_DAYOFWEEK, HiveParserKW_DBPROPERTIES, HiveParserKW_DCPROPERTIES, HiveParserKW_DEBUG, HiveParserKW_DEFAULT, HiveParserKW_DEFERRED, HiveParserKW_DEFINED, HiveParserKW_DELIMITED, HiveParserKW_DEPENDENCY, HiveParserKW_DESC, HiveParserKW_DETAIL, HiveParserKW_DIRECTORIES, HiveParserKW_DIRECTORY, HiveParserKW_DISABLE, HiveParserKW_DISTRIBUTE, HiveParserKW_DISTRIBUTED, HiveParserKW_DO, HiveParserKW_DOW, HiveParserKW_DUMP, HiveParserKW_ELEM_TYPE, HiveParserKW_ENABLE, HiveParserKW_ENFORCED, HiveParserKW_ESCAPED, HiveParserKW_EVERY, HiveParserKW_EXCLUSIVE, HiveParserKW_EXECUTE, HiveParserKW_EXECUTED, HiveParserKW_EXPIRE_SNAPSHOTS, HiveParserKW_EXPLAIN, HiveParserKW_EXPORT, HiveParserKW_EXPRESSION, HiveParserKW_FIELDS, HiveParserKW_FILE, HiveParserKW_FILEFORMAT, HiveParserKW_FIRST, HiveParserKW_FORMAT, HiveParserKW_FORMATTED, HiveParserKW_FUNCTIONS, HiveParserKW_HOLD_DDLTIME, HiveParserKW_HOUR, HiveParserKW_IDXPROPERTIES, HiveParserKW_IGNORE, HiveParserKW_INDEX, HiveParserKW_INDEXES, HiveParserKW_INPATH, HiveParserKW_INPUTDRIVER, HiveParserKW_INPUTFORMAT, HiveParserKW_ISOLATION, HiveParserKW_ITEMS, HiveParserKW_JAR, HiveParserKW_JOINCOST, HiveParserKW_KEY, HiveParserKW_KEYS, HiveParserKW_KEY_TYPE, HiveParserKW_KILL, HiveParserKW_LAST, HiveParserKW_LEVEL, HiveParserKW_LIMIT, HiveParserKW_LINES, HiveParserKW_LOAD, HiveParserKW_LOCATION, HiveParserKW_LOCK, HiveParserKW_LOCKS, HiveParserKW_LOGICAL, HiveParserKW_LONG, HiveParserKW_MANAGED, HiveParserKW_MANAGEDLOCATION, HiveParserKW_MANAGEMENT, HiveParserKW_MAPJOIN, HiveParserKW_MAPPING, HiveParserKW_MATCHED, HiveParserKW_MATERIALIZED, HiveParserKW_METADATA, HiveParserKW_MINUTE, HiveParserKW_MONTH, HiveParserKW_MOVE, HiveParserKW_MSCK, HiveParserKW_NORELY, HiveParserKW_NOSCAN, HiveParserKW_NOVALIDATE, HiveParserKW_NO_DROP, HiveParserKW_NULLS, HiveParserKW_OFFLINE, HiveParserKW_OFFSET, HiveParserKW_OPERATOR, HiveParserKW_OPTION, HiveParserKW_OUTPUTDRIVER, HiveParserKW_OUTPUTFORMAT, HiveParserKW_OVERWRITE, HiveParserKW_OWNER, HiveParserKW_PARTITIONED, HiveParserKW_PARTITIONS, HiveParserKW_PATH, HiveParserKW_PLAN, HiveParserKW_PLANS, HiveParserKW_PLUS, HiveParserKW_POOL, HiveParserKW_PRINCIPALS, HiveParserKW_PROTECTION, HiveParserKW_PURGE, HiveParserKW_QUARTER, HiveParserKW_QUERY, HiveParserKW_QUERY_PARALLELISM, HiveParserKW_READ, HiveParserKW_READONLY, HiveParserKW_REBUILD, HiveParserKW_RECORDREADER, HiveParserKW_RECORDWRITER, HiveParserKW_RELOAD, HiveParserKW_RELY, HiveParserKW_REMOTE, HiveParserKW_RENAME, HiveParserKW_REOPTIMIZATION, HiveParserKW_REPAIR, HiveParserKW_REPL, HiveParserKW_REPLACE, HiveParserKW_REPLICATION, HiveParserKW_RESOURCE, HiveParserKW_RESPECT, HiveParserKW_RESTRICT, HiveParserKW_REWRITE, HiveParserKW_ROLE, HiveParserKW_ROLES, HiveParserKW_SCHEDULED, HiveParserKW_SCHEDULING_POLICY, HiveParserKW_SCHEMA, HiveParserKW_SCHEMAS, HiveParserKW_SECOND, HiveParserKW_SEMI, HiveParserKW_SERDE, HiveParserKW_SERDEPROPERTIES, HiveParserKW_SERVER, HiveParserKW_SETS, HiveParserKW_SET_CURRENT_SNAPSHOT, HiveParserKW_SHARED, HiveParserKW_SHOW, HiveParserKW_SHOW_DATABASE, HiveParserKW_SKEWED, HiveParserKW_SNAPSHOT, HiveParserKW_SORT, HiveParserKW_SORTED, HiveParserKW_SPEC, HiveParserKW_SSL, HiveParserKW_STATISTICS, HiveParserKW_STATUS, HiveParserKW_STORED, HiveParserKW_STREAMTABLE, HiveParserKW_STRING, HiveParserKW_STRUCT, HiveParserKW_SUMMARY, HiveParserKW_SYSTEM_TIME, HiveParserKW_SYSTEM_VERSION, HiveParserKW_TABLE, HiveParserKW_TABLES, HiveParserKW_TBLPROPERTIES, HiveParserKW_TEMPORARY, HiveParserKW_TERMINATED, HiveParserKW_TIMESTAMPTZ, HiveParserKW_TINYINT, HiveParserKW_TOUCH, HiveParserKW_TRANSACTION, HiveParserKW_TRANSACTIONAL, HiveParserKW_TRANSACTIONS, HiveParserKW_TRIM, HiveParserKW_TYPE, HiveParserKW_UNARCHIVE, HiveParserKW_UNDO, HiveParserKW_UNIONTYPE, HiveParserKW_UNKNOWN, HiveParserKW_UNLOCK, HiveParserKW_UNMANAGED, HiveParserKW_UNSET, HiveParserKW_UNSIGNED, HiveParserKW_URI, HiveParserKW_URL, HiveParserKW_USE, HiveParserKW_UTC, HiveParserKW_UTCTIMESTAMP, HiveParserKW_VALIDATE, HiveParserKW_VALUE_TYPE, HiveParserKW_VECTORIZATION, HiveParserKW_VIEW, HiveParserKW_VIEWS, HiveParserKW_WAIT, HiveParserKW_WEEK, HiveParserKW_WHILE, HiveParserKW_WITHIN, HiveParserKW_WORK, HiveParserKW_WORKLOAD, HiveParserKW_WRITE, HiveParserKW_YEAR, HiveParserKW_ZONE, HiveParserIdentifier:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1724)
			p.PrivObjectCols()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPrivilegeObjectContext is an interface to support dynamic dispatch.
type IPrivilegeObjectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_ON() antlr.TerminalNode
	PrivObject() IPrivObjectContext

	// IsPrivilegeObjectContext differentiates from other interfaces.
	IsPrivilegeObjectContext()
}

type PrivilegeObjectContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivilegeObjectContext() *PrivilegeObjectContext {
	var p = new(PrivilegeObjectContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_privilegeObject
	return p
}

func InitEmptyPrivilegeObjectContext(p *PrivilegeObjectContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_privilegeObject
}

func (*PrivilegeObjectContext) IsPrivilegeObjectContext() {}

func NewPrivilegeObjectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivilegeObjectContext {
	var p = new(PrivilegeObjectContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_privilegeObject

	return p
}

func (s *PrivilegeObjectContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivilegeObjectContext) KW_ON() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ON, 0)
}

func (s *PrivilegeObjectContext) PrivObject() IPrivObjectContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivObjectContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivObjectContext)
}

func (s *PrivilegeObjectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivilegeObjectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PrivilegeObjectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterPrivilegeObject(s)
	}
}

func (s *PrivilegeObjectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitPrivilegeObject(s)
	}
}

func (s *PrivilegeObjectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitPrivilegeObject(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) PrivilegeObject() (localctx IPrivilegeObjectContext) {
	localctx = NewPrivilegeObjectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, HiveParserRULE_privilegeObject)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1727)
		p.Match(HiveParserKW_ON)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1728)
		p.PrivObject()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPrivObjectContext is an interface to support dynamic dispatch.
type IPrivObjectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPath returns the path token.
	GetPath() antlr.Token 


	// SetPath sets the path token.
	SetPath(antlr.Token) 


	// Getter signatures
	Db_schema() IDb_schemaContext
	Id_() IId_Context
	TableName() ITableNameContext
	KW_TABLE() antlr.TerminalNode
	PartitionSpec() IPartitionSpecContext
	KW_URI() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode
	KW_SERVER() antlr.TerminalNode

	// IsPrivObjectContext differentiates from other interfaces.
	IsPrivObjectContext()
}

type PrivObjectContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	path antlr.Token
}

func NewEmptyPrivObjectContext() *PrivObjectContext {
	var p = new(PrivObjectContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_privObject
	return p
}

func InitEmptyPrivObjectContext(p *PrivObjectContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_privObject
}

func (*PrivObjectContext) IsPrivObjectContext() {}

func NewPrivObjectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivObjectContext {
	var p = new(PrivObjectContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_privObject

	return p
}

func (s *PrivObjectContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivObjectContext) GetPath() antlr.Token { return s.path }


func (s *PrivObjectContext) SetPath(v antlr.Token) { s.path = v }


func (s *PrivObjectContext) Db_schema() IDb_schemaContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDb_schemaContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDb_schemaContext)
}

func (s *PrivObjectContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *PrivObjectContext) TableName() ITableNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *PrivObjectContext) KW_TABLE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TABLE, 0)
}

func (s *PrivObjectContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *PrivObjectContext) KW_URI() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_URI, 0)
}

func (s *PrivObjectContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(HiveParserStringLiteral, 0)
}

func (s *PrivObjectContext) KW_SERVER() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SERVER, 0)
}

func (s *PrivObjectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivObjectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PrivObjectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterPrivObject(s)
	}
}

func (s *PrivObjectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitPrivObject(s)
	}
}

func (s *PrivObjectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitPrivObject(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) PrivObject() (localctx IPrivObjectContext) {
	localctx = NewPrivObjectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, HiveParserRULE_privObject)
	var _la int

	p.SetState(1744)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 115, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1730)
			p.Db_schema()
		}
		{
			p.SetState(1731)
			p.Id_()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1734)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_TABLE {
			{
				p.SetState(1733)
				p.Match(HiveParserKW_TABLE)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1736)
			p.TableName()
		}
		p.SetState(1738)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_PARTITION {
			{
				p.SetState(1737)
				p.PartitionSpec()
			}

		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1740)
			p.Match(HiveParserKW_URI)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1741)

			var _m = p.Match(HiveParserStringLiteral)

			localctx.(*PrivObjectContext).path = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1742)
			p.Match(HiveParserKW_SERVER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1743)
			p.Id_()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPrivObjectColsContext is an interface to support dynamic dispatch.
type IPrivObjectColsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPath returns the path token.
	GetPath() antlr.Token 


	// SetPath sets the path token.
	SetPath(antlr.Token) 


	// GetCols returns the cols rule contexts.
	GetCols() IColumnNameListContext


	// SetCols sets the cols rule contexts.
	SetCols(IColumnNameListContext)


	// Getter signatures
	Db_schema() IDb_schemaContext
	Id_() IId_Context
	TableName() ITableNameContext
	KW_TABLE() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	PartitionSpec() IPartitionSpecContext
	ColumnNameList() IColumnNameListContext
	KW_URI() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode
	KW_SERVER() antlr.TerminalNode

	// IsPrivObjectColsContext differentiates from other interfaces.
	IsPrivObjectColsContext()
}

type PrivObjectColsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	cols IColumnNameListContext 
	path antlr.Token
}

func NewEmptyPrivObjectColsContext() *PrivObjectColsContext {
	var p = new(PrivObjectColsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_privObjectCols
	return p
}

func InitEmptyPrivObjectColsContext(p *PrivObjectColsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_privObjectCols
}

func (*PrivObjectColsContext) IsPrivObjectColsContext() {}

func NewPrivObjectColsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivObjectColsContext {
	var p = new(PrivObjectColsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_privObjectCols

	return p
}

func (s *PrivObjectColsContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivObjectColsContext) GetPath() antlr.Token { return s.path }


func (s *PrivObjectColsContext) SetPath(v antlr.Token) { s.path = v }


func (s *PrivObjectColsContext) GetCols() IColumnNameListContext { return s.cols }


func (s *PrivObjectColsContext) SetCols(v IColumnNameListContext) { s.cols = v }


func (s *PrivObjectColsContext) Db_schema() IDb_schemaContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDb_schemaContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDb_schemaContext)
}

func (s *PrivObjectColsContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *PrivObjectColsContext) TableName() ITableNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *PrivObjectColsContext) KW_TABLE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TABLE, 0)
}

func (s *PrivObjectColsContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserLPAREN, 0)
}

func (s *PrivObjectColsContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserRPAREN, 0)
}

func (s *PrivObjectColsContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *PrivObjectColsContext) ColumnNameList() IColumnNameListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNameListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNameListContext)
}

func (s *PrivObjectColsContext) KW_URI() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_URI, 0)
}

func (s *PrivObjectColsContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(HiveParserStringLiteral, 0)
}

func (s *PrivObjectColsContext) KW_SERVER() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SERVER, 0)
}

func (s *PrivObjectColsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivObjectColsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PrivObjectColsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterPrivObjectCols(s)
	}
}

func (s *PrivObjectColsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitPrivObjectCols(s)
	}
}

func (s *PrivObjectColsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitPrivObjectCols(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) PrivObjectCols() (localctx IPrivObjectColsContext) {
	localctx = NewPrivObjectColsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, HiveParserRULE_privObjectCols)
	var _la int

	p.SetState(1766)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 119, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1746)
			p.Db_schema()
		}
		{
			p.SetState(1747)
			p.Id_()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1750)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_TABLE {
			{
				p.SetState(1749)
				p.Match(HiveParserKW_TABLE)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1752)
			p.TableName()
		}
		p.SetState(1757)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserLPAREN {
			{
				p.SetState(1753)
				p.Match(HiveParserLPAREN)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1754)

				var _x = p.ColumnNameList()


				localctx.(*PrivObjectColsContext).cols = _x
			}
			{
				p.SetState(1755)
				p.Match(HiveParserRPAREN)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		p.SetState(1760)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_PARTITION {
			{
				p.SetState(1759)
				p.PartitionSpec()
			}

		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1762)
			p.Match(HiveParserKW_URI)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1763)

			var _m = p.Match(HiveParserStringLiteral)

			localctx.(*PrivObjectColsContext).path = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1764)
			p.Match(HiveParserKW_SERVER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1765)
			p.Id_()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPrivilegeListContext is an interface to support dynamic dispatch.
type IPrivilegeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPrivlegeDef() []IPrivlegeDefContext
	PrivlegeDef(i int) IPrivlegeDefContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPrivilegeListContext differentiates from other interfaces.
	IsPrivilegeListContext()
}

type PrivilegeListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivilegeListContext() *PrivilegeListContext {
	var p = new(PrivilegeListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_privilegeList
	return p
}

func InitEmptyPrivilegeListContext(p *PrivilegeListContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_privilegeList
}

func (*PrivilegeListContext) IsPrivilegeListContext() {}

func NewPrivilegeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivilegeListContext {
	var p = new(PrivilegeListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_privilegeList

	return p
}

func (s *PrivilegeListContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivilegeListContext) AllPrivlegeDef() []IPrivlegeDefContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrivlegeDefContext); ok {
			len++
		}
	}

	tst := make([]IPrivlegeDefContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrivlegeDefContext); ok {
			tst[i] = t.(IPrivlegeDefContext)
			i++
		}
	}

	return tst
}

func (s *PrivilegeListContext) PrivlegeDef(i int) IPrivlegeDefContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivlegeDefContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivlegeDefContext)
}

func (s *PrivilegeListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(HiveParserCOMMA)
}

func (s *PrivilegeListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserCOMMA, i)
}

func (s *PrivilegeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivilegeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PrivilegeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterPrivilegeList(s)
	}
}

func (s *PrivilegeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitPrivilegeList(s)
	}
}

func (s *PrivilegeListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitPrivilegeList(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) PrivilegeList() (localctx IPrivilegeListContext) {
	localctx = NewPrivilegeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, HiveParserRULE_privilegeList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1768)
		p.PrivlegeDef()
	}
	p.SetState(1773)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HiveParserCOMMA {
		{
			p.SetState(1769)
			p.Match(HiveParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1770)
			p.PrivlegeDef()
		}


		p.SetState(1775)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPrivlegeDefContext is an interface to support dynamic dispatch.
type IPrivlegeDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCols returns the cols rule contexts.
	GetCols() IColumnNameListContext


	// SetCols sets the cols rule contexts.
	SetCols(IColumnNameListContext)


	// Getter signatures
	PrivilegeType() IPrivilegeTypeContext
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	ColumnNameList() IColumnNameListContext

	// IsPrivlegeDefContext differentiates from other interfaces.
	IsPrivlegeDefContext()
}

type PrivlegeDefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	cols IColumnNameListContext 
}

func NewEmptyPrivlegeDefContext() *PrivlegeDefContext {
	var p = new(PrivlegeDefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_privlegeDef
	return p
}

func InitEmptyPrivlegeDefContext(p *PrivlegeDefContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_privlegeDef
}

func (*PrivlegeDefContext) IsPrivlegeDefContext() {}

func NewPrivlegeDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivlegeDefContext {
	var p = new(PrivlegeDefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_privlegeDef

	return p
}

func (s *PrivlegeDefContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivlegeDefContext) GetCols() IColumnNameListContext { return s.cols }


func (s *PrivlegeDefContext) SetCols(v IColumnNameListContext) { s.cols = v }


func (s *PrivlegeDefContext) PrivilegeType() IPrivilegeTypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeTypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeTypeContext)
}

func (s *PrivlegeDefContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserLPAREN, 0)
}

func (s *PrivlegeDefContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserRPAREN, 0)
}

func (s *PrivlegeDefContext) ColumnNameList() IColumnNameListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNameListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNameListContext)
}

func (s *PrivlegeDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivlegeDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PrivlegeDefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterPrivlegeDef(s)
	}
}

func (s *PrivlegeDefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitPrivlegeDef(s)
	}
}

func (s *PrivlegeDefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitPrivlegeDef(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) PrivlegeDef() (localctx IPrivlegeDefContext) {
	localctx = NewPrivlegeDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, HiveParserRULE_privlegeDef)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1776)
		p.PrivilegeType()
	}
	p.SetState(1781)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserLPAREN {
		{
			p.SetState(1777)
			p.Match(HiveParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1778)

			var _x = p.ColumnNameList()


			localctx.(*PrivlegeDefContext).cols = _x
		}
		{
			p.SetState(1779)
			p.Match(HiveParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPrivilegeTypeContext is an interface to support dynamic dispatch.
type IPrivilegeTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_ALL() antlr.TerminalNode
	KW_ALTER() antlr.TerminalNode
	KW_UPDATE() antlr.TerminalNode
	KW_CREATE() antlr.TerminalNode
	KW_DROP() antlr.TerminalNode
	KW_LOCK() antlr.TerminalNode
	KW_SELECT() antlr.TerminalNode
	KW_SHOW_DATABASE() antlr.TerminalNode
	KW_INSERT() antlr.TerminalNode
	KW_DELETE() antlr.TerminalNode

	// IsPrivilegeTypeContext differentiates from other interfaces.
	IsPrivilegeTypeContext()
}

type PrivilegeTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivilegeTypeContext() *PrivilegeTypeContext {
	var p = new(PrivilegeTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_privilegeType
	return p
}

func InitEmptyPrivilegeTypeContext(p *PrivilegeTypeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_privilegeType
}

func (*PrivilegeTypeContext) IsPrivilegeTypeContext() {}

func NewPrivilegeTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivilegeTypeContext {
	var p = new(PrivilegeTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_privilegeType

	return p
}

func (s *PrivilegeTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivilegeTypeContext) KW_ALL() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ALL, 0)
}

func (s *PrivilegeTypeContext) KW_ALTER() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ALTER, 0)
}

func (s *PrivilegeTypeContext) KW_UPDATE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_UPDATE, 0)
}

func (s *PrivilegeTypeContext) KW_CREATE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_CREATE, 0)
}

func (s *PrivilegeTypeContext) KW_DROP() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DROP, 0)
}

func (s *PrivilegeTypeContext) KW_LOCK() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_LOCK, 0)
}

func (s *PrivilegeTypeContext) KW_SELECT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SELECT, 0)
}

func (s *PrivilegeTypeContext) KW_SHOW_DATABASE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SHOW_DATABASE, 0)
}

func (s *PrivilegeTypeContext) KW_INSERT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_INSERT, 0)
}

func (s *PrivilegeTypeContext) KW_DELETE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DELETE, 0)
}

func (s *PrivilegeTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivilegeTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PrivilegeTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterPrivilegeType(s)
	}
}

func (s *PrivilegeTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitPrivilegeType(s)
	}
}

func (s *PrivilegeTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitPrivilegeType(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) PrivilegeType() (localctx IPrivilegeTypeContext) {
	localctx = NewPrivilegeTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, HiveParserRULE_privilegeType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1783)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 288230376151712384) != 0) || _la == HiveParserKW_DELETE || _la == HiveParserKW_DROP || _la == HiveParserKW_INSERT || _la == HiveParserKW_LOCK || _la == HiveParserKW_SELECT || _la == HiveParserKW_SHOW_DATABASE || _la == HiveParserKW_UPDATE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPrincipalSpecificationContext is an interface to support dynamic dispatch.
type IPrincipalSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPrincipalName() []IPrincipalNameContext
	PrincipalName(i int) IPrincipalNameContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPrincipalSpecificationContext differentiates from other interfaces.
	IsPrincipalSpecificationContext()
}

type PrincipalSpecificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrincipalSpecificationContext() *PrincipalSpecificationContext {
	var p = new(PrincipalSpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_principalSpecification
	return p
}

func InitEmptyPrincipalSpecificationContext(p *PrincipalSpecificationContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_principalSpecification
}

func (*PrincipalSpecificationContext) IsPrincipalSpecificationContext() {}

func NewPrincipalSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrincipalSpecificationContext {
	var p = new(PrincipalSpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_principalSpecification

	return p
}

func (s *PrincipalSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *PrincipalSpecificationContext) AllPrincipalName() []IPrincipalNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrincipalNameContext); ok {
			len++
		}
	}

	tst := make([]IPrincipalNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrincipalNameContext); ok {
			tst[i] = t.(IPrincipalNameContext)
			i++
		}
	}

	return tst
}

func (s *PrincipalSpecificationContext) PrincipalName(i int) IPrincipalNameContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrincipalNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrincipalNameContext)
}

func (s *PrincipalSpecificationContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(HiveParserCOMMA)
}

func (s *PrincipalSpecificationContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserCOMMA, i)
}

func (s *PrincipalSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrincipalSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PrincipalSpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterPrincipalSpecification(s)
	}
}

func (s *PrincipalSpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitPrincipalSpecification(s)
	}
}

func (s *PrincipalSpecificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitPrincipalSpecification(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) PrincipalSpecification() (localctx IPrincipalSpecificationContext) {
	localctx = NewPrincipalSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, HiveParserRULE_principalSpecification)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1785)
		p.PrincipalName()
	}
	p.SetState(1790)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HiveParserCOMMA {
		{
			p.SetState(1786)
			p.Match(HiveParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1787)
			p.PrincipalName()
		}


		p.SetState(1792)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPrincipalNameContext is an interface to support dynamic dispatch.
type IPrincipalNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_USER() antlr.TerminalNode
	PrincipalIdentifier() IPrincipalIdentifierContext
	KW_GROUP() antlr.TerminalNode
	KW_ROLE() antlr.TerminalNode
	Id_() IId_Context

	// IsPrincipalNameContext differentiates from other interfaces.
	IsPrincipalNameContext()
}

type PrincipalNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrincipalNameContext() *PrincipalNameContext {
	var p = new(PrincipalNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_principalName
	return p
}

func InitEmptyPrincipalNameContext(p *PrincipalNameContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_principalName
}

func (*PrincipalNameContext) IsPrincipalNameContext() {}

func NewPrincipalNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrincipalNameContext {
	var p = new(PrincipalNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_principalName

	return p
}

func (s *PrincipalNameContext) GetParser() antlr.Parser { return s.parser }

func (s *PrincipalNameContext) KW_USER() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_USER, 0)
}

func (s *PrincipalNameContext) PrincipalIdentifier() IPrincipalIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrincipalIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrincipalIdentifierContext)
}

func (s *PrincipalNameContext) KW_GROUP() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_GROUP, 0)
}

func (s *PrincipalNameContext) KW_ROLE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ROLE, 0)
}

func (s *PrincipalNameContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *PrincipalNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrincipalNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PrincipalNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterPrincipalName(s)
	}
}

func (s *PrincipalNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitPrincipalName(s)
	}
}

func (s *PrincipalNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitPrincipalName(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) PrincipalName() (localctx IPrincipalNameContext) {
	localctx = NewPrincipalNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, HiveParserRULE_principalName)
	p.SetState(1799)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserKW_USER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1793)
			p.Match(HiveParserKW_USER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1794)
			p.PrincipalIdentifier()
		}


	case HiveParserKW_GROUP:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1795)
			p.Match(HiveParserKW_GROUP)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1796)
			p.PrincipalIdentifier()
		}


	case HiveParserKW_ROLE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1797)
			p.Match(HiveParserKW_ROLE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1798)
			p.Id_()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IWithGrantOptionContext is an interface to support dynamic dispatch.
type IWithGrantOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_WITH() antlr.TerminalNode
	KW_GRANT() antlr.TerminalNode
	KW_OPTION() antlr.TerminalNode

	// IsWithGrantOptionContext differentiates from other interfaces.
	IsWithGrantOptionContext()
}

type WithGrantOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithGrantOptionContext() *WithGrantOptionContext {
	var p = new(WithGrantOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_withGrantOption
	return p
}

func InitEmptyWithGrantOptionContext(p *WithGrantOptionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_withGrantOption
}

func (*WithGrantOptionContext) IsWithGrantOptionContext() {}

func NewWithGrantOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithGrantOptionContext {
	var p = new(WithGrantOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_withGrantOption

	return p
}

func (s *WithGrantOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *WithGrantOptionContext) KW_WITH() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_WITH, 0)
}

func (s *WithGrantOptionContext) KW_GRANT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_GRANT, 0)
}

func (s *WithGrantOptionContext) KW_OPTION() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_OPTION, 0)
}

func (s *WithGrantOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithGrantOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *WithGrantOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterWithGrantOption(s)
	}
}

func (s *WithGrantOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitWithGrantOption(s)
	}
}

func (s *WithGrantOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitWithGrantOption(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) WithGrantOption() (localctx IWithGrantOptionContext) {
	localctx = NewWithGrantOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, HiveParserRULE_withGrantOption)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1801)
		p.Match(HiveParserKW_WITH)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1802)
		p.Match(HiveParserKW_GRANT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1803)
		p.Match(HiveParserKW_OPTION)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IGrantOptionForContext is an interface to support dynamic dispatch.
type IGrantOptionForContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_GRANT() antlr.TerminalNode
	KW_OPTION() antlr.TerminalNode
	KW_FOR() antlr.TerminalNode

	// IsGrantOptionForContext differentiates from other interfaces.
	IsGrantOptionForContext()
}

type GrantOptionForContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGrantOptionForContext() *GrantOptionForContext {
	var p = new(GrantOptionForContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_grantOptionFor
	return p
}

func InitEmptyGrantOptionForContext(p *GrantOptionForContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_grantOptionFor
}

func (*GrantOptionForContext) IsGrantOptionForContext() {}

func NewGrantOptionForContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GrantOptionForContext {
	var p = new(GrantOptionForContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_grantOptionFor

	return p
}

func (s *GrantOptionForContext) GetParser() antlr.Parser { return s.parser }

func (s *GrantOptionForContext) KW_GRANT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_GRANT, 0)
}

func (s *GrantOptionForContext) KW_OPTION() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_OPTION, 0)
}

func (s *GrantOptionForContext) KW_FOR() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_FOR, 0)
}

func (s *GrantOptionForContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantOptionForContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *GrantOptionForContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterGrantOptionFor(s)
	}
}

func (s *GrantOptionForContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitGrantOptionFor(s)
	}
}

func (s *GrantOptionForContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitGrantOptionFor(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) GrantOptionFor() (localctx IGrantOptionForContext) {
	localctx = NewGrantOptionForContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, HiveParserRULE_grantOptionFor)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1805)
		p.Match(HiveParserKW_GRANT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1806)
		p.Match(HiveParserKW_OPTION)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1807)
		p.Match(HiveParserKW_FOR)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAdminOptionForContext is an interface to support dynamic dispatch.
type IAdminOptionForContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_ADMIN() antlr.TerminalNode
	KW_OPTION() antlr.TerminalNode
	KW_FOR() antlr.TerminalNode

	// IsAdminOptionForContext differentiates from other interfaces.
	IsAdminOptionForContext()
}

type AdminOptionForContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdminOptionForContext() *AdminOptionForContext {
	var p = new(AdminOptionForContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_adminOptionFor
	return p
}

func InitEmptyAdminOptionForContext(p *AdminOptionForContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_adminOptionFor
}

func (*AdminOptionForContext) IsAdminOptionForContext() {}

func NewAdminOptionForContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdminOptionForContext {
	var p = new(AdminOptionForContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_adminOptionFor

	return p
}

func (s *AdminOptionForContext) GetParser() antlr.Parser { return s.parser }

func (s *AdminOptionForContext) KW_ADMIN() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ADMIN, 0)
}

func (s *AdminOptionForContext) KW_OPTION() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_OPTION, 0)
}

func (s *AdminOptionForContext) KW_FOR() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_FOR, 0)
}

func (s *AdminOptionForContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminOptionForContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AdminOptionForContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterAdminOptionFor(s)
	}
}

func (s *AdminOptionForContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitAdminOptionFor(s)
	}
}

func (s *AdminOptionForContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitAdminOptionFor(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) AdminOptionFor() (localctx IAdminOptionForContext) {
	localctx = NewAdminOptionForContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, HiveParserRULE_adminOptionFor)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1809)
		p.Match(HiveParserKW_ADMIN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1810)
		p.Match(HiveParserKW_OPTION)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1811)
		p.Match(HiveParserKW_FOR)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IWithAdminOptionContext is an interface to support dynamic dispatch.
type IWithAdminOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_WITH() antlr.TerminalNode
	KW_ADMIN() antlr.TerminalNode
	KW_OPTION() antlr.TerminalNode

	// IsWithAdminOptionContext differentiates from other interfaces.
	IsWithAdminOptionContext()
}

type WithAdminOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithAdminOptionContext() *WithAdminOptionContext {
	var p = new(WithAdminOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_withAdminOption
	return p
}

func InitEmptyWithAdminOptionContext(p *WithAdminOptionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_withAdminOption
}

func (*WithAdminOptionContext) IsWithAdminOptionContext() {}

func NewWithAdminOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithAdminOptionContext {
	var p = new(WithAdminOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_withAdminOption

	return p
}

func (s *WithAdminOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *WithAdminOptionContext) KW_WITH() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_WITH, 0)
}

func (s *WithAdminOptionContext) KW_ADMIN() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ADMIN, 0)
}

func (s *WithAdminOptionContext) KW_OPTION() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_OPTION, 0)
}

func (s *WithAdminOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithAdminOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *WithAdminOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterWithAdminOption(s)
	}
}

func (s *WithAdminOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitWithAdminOption(s)
	}
}

func (s *WithAdminOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitWithAdminOption(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) WithAdminOption() (localctx IWithAdminOptionContext) {
	localctx = NewWithAdminOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, HiveParserRULE_withAdminOption)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1813)
		p.Match(HiveParserKW_WITH)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1814)
		p.Match(HiveParserKW_ADMIN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1815)
		p.Match(HiveParserKW_OPTION)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IMetastoreCheckContext is an interface to support dynamic dispatch.
type IMetastoreCheckContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRepair returns the repair token.
	GetRepair() antlr.Token 

	// GetOpt returns the opt token.
	GetOpt() antlr.Token 

	// GetParts returns the parts token.
	GetParts() antlr.Token 


	// SetRepair sets the repair token.
	SetRepair(antlr.Token) 

	// SetOpt sets the opt token.
	SetOpt(antlr.Token) 

	// SetParts sets the parts token.
	SetParts(antlr.Token) 


	// Getter signatures
	KW_MSCK() antlr.TerminalNode
	KW_TABLE() antlr.TerminalNode
	TableName() ITableNameContext
	KW_REPAIR() antlr.TerminalNode
	KW_PARTITIONS() antlr.TerminalNode
	KW_ADD() antlr.TerminalNode
	KW_DROP() antlr.TerminalNode
	KW_SYNC() antlr.TerminalNode
	PartitionSelectorSpec() IPartitionSelectorSpecContext

	// IsMetastoreCheckContext differentiates from other interfaces.
	IsMetastoreCheckContext()
}

type MetastoreCheckContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	repair antlr.Token
	opt antlr.Token
	parts antlr.Token
}

func NewEmptyMetastoreCheckContext() *MetastoreCheckContext {
	var p = new(MetastoreCheckContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_metastoreCheck
	return p
}

func InitEmptyMetastoreCheckContext(p *MetastoreCheckContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_metastoreCheck
}

func (*MetastoreCheckContext) IsMetastoreCheckContext() {}

func NewMetastoreCheckContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MetastoreCheckContext {
	var p = new(MetastoreCheckContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_metastoreCheck

	return p
}

func (s *MetastoreCheckContext) GetParser() antlr.Parser { return s.parser }

func (s *MetastoreCheckContext) GetRepair() antlr.Token { return s.repair }

func (s *MetastoreCheckContext) GetOpt() antlr.Token { return s.opt }

func (s *MetastoreCheckContext) GetParts() antlr.Token { return s.parts }


func (s *MetastoreCheckContext) SetRepair(v antlr.Token) { s.repair = v }

func (s *MetastoreCheckContext) SetOpt(v antlr.Token) { s.opt = v }

func (s *MetastoreCheckContext) SetParts(v antlr.Token) { s.parts = v }


func (s *MetastoreCheckContext) KW_MSCK() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_MSCK, 0)
}

func (s *MetastoreCheckContext) KW_TABLE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TABLE, 0)
}

func (s *MetastoreCheckContext) TableName() ITableNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *MetastoreCheckContext) KW_REPAIR() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_REPAIR, 0)
}

func (s *MetastoreCheckContext) KW_PARTITIONS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_PARTITIONS, 0)
}

func (s *MetastoreCheckContext) KW_ADD() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ADD, 0)
}

func (s *MetastoreCheckContext) KW_DROP() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DROP, 0)
}

func (s *MetastoreCheckContext) KW_SYNC() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SYNC, 0)
}

func (s *MetastoreCheckContext) PartitionSelectorSpec() IPartitionSelectorSpecContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSelectorSpecContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSelectorSpecContext)
}

func (s *MetastoreCheckContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MetastoreCheckContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *MetastoreCheckContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterMetastoreCheck(s)
	}
}

func (s *MetastoreCheckContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitMetastoreCheck(s)
	}
}

func (s *MetastoreCheckContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitMetastoreCheck(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) MetastoreCheck() (localctx IMetastoreCheckContext) {
	localctx = NewMetastoreCheckContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, HiveParserRULE_metastoreCheck)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1817)
		p.Match(HiveParserKW_MSCK)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1819)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_REPAIR {
		{
			p.SetState(1818)

			var _m = p.Match(HiveParserKW_REPAIR)

			localctx.(*MetastoreCheckContext).repair = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}

	{
		p.SetState(1821)
		p.Match(HiveParserKW_TABLE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1822)
		p.TableName()
	}
	p.SetState(1828)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_ADD || _la == HiveParserKW_DROP || _la == HiveParserKW_SYNC {
		{
			p.SetState(1823)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*MetastoreCheckContext).opt = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == HiveParserKW_ADD || _la == HiveParserKW_DROP || _la == HiveParserKW_SYNC) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*MetastoreCheckContext).opt = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1824)

			var _m = p.Match(HiveParserKW_PARTITIONS)

			localctx.(*MetastoreCheckContext).parts = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1826)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserLPAREN {
			{
				p.SetState(1825)
				p.PartitionSelectorSpec()
			}

		}

	}




errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IResourceListContext is an interface to support dynamic dispatch.
type IResourceListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllResource() []IResourceContext
	Resource(i int) IResourceContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsResourceListContext differentiates from other interfaces.
	IsResourceListContext()
}

type ResourceListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResourceListContext() *ResourceListContext {
	var p = new(ResourceListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_resourceList
	return p
}

func InitEmptyResourceListContext(p *ResourceListContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_resourceList
}

func (*ResourceListContext) IsResourceListContext() {}

func NewResourceListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResourceListContext {
	var p = new(ResourceListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_resourceList

	return p
}

func (s *ResourceListContext) GetParser() antlr.Parser { return s.parser }

func (s *ResourceListContext) AllResource() []IResourceContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IResourceContext); ok {
			len++
		}
	}

	tst := make([]IResourceContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IResourceContext); ok {
			tst[i] = t.(IResourceContext)
			i++
		}
	}

	return tst
}

func (s *ResourceListContext) Resource(i int) IResourceContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResourceContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResourceContext)
}

func (s *ResourceListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(HiveParserCOMMA)
}

func (s *ResourceListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserCOMMA, i)
}

func (s *ResourceListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResourceListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ResourceListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterResourceList(s)
	}
}

func (s *ResourceListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitResourceList(s)
	}
}

func (s *ResourceListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitResourceList(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ResourceList() (localctx IResourceListContext) {
	localctx = NewResourceListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, HiveParserRULE_resourceList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1830)
		p.Resource()
	}
	p.SetState(1835)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HiveParserCOMMA {
		{
			p.SetState(1831)
			p.Match(HiveParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1832)
			p.Resource()
		}


		p.SetState(1837)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IResourceContext is an interface to support dynamic dispatch.
type IResourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetResPath returns the resPath token.
	GetResPath() antlr.Token 


	// SetResPath sets the resPath token.
	SetResPath(antlr.Token) 


	// GetResType returns the resType rule contexts.
	GetResType() IResourceTypeContext


	// SetResType sets the resType rule contexts.
	SetResType(IResourceTypeContext)


	// Getter signatures
	ResourceType() IResourceTypeContext
	StringLiteral() antlr.TerminalNode

	// IsResourceContext differentiates from other interfaces.
	IsResourceContext()
}

type ResourceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	resType IResourceTypeContext 
	resPath antlr.Token
}

func NewEmptyResourceContext() *ResourceContext {
	var p = new(ResourceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_resource
	return p
}

func InitEmptyResourceContext(p *ResourceContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_resource
}

func (*ResourceContext) IsResourceContext() {}

func NewResourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResourceContext {
	var p = new(ResourceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_resource

	return p
}

func (s *ResourceContext) GetParser() antlr.Parser { return s.parser }

func (s *ResourceContext) GetResPath() antlr.Token { return s.resPath }


func (s *ResourceContext) SetResPath(v antlr.Token) { s.resPath = v }


func (s *ResourceContext) GetResType() IResourceTypeContext { return s.resType }


func (s *ResourceContext) SetResType(v IResourceTypeContext) { s.resType = v }


func (s *ResourceContext) ResourceType() IResourceTypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResourceTypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResourceTypeContext)
}

func (s *ResourceContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(HiveParserStringLiteral, 0)
}

func (s *ResourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ResourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterResource(s)
	}
}

func (s *ResourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitResource(s)
	}
}

func (s *ResourceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitResource(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) Resource() (localctx IResourceContext) {
	localctx = NewResourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, HiveParserRULE_resource)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1838)

		var _x = p.ResourceType()


		localctx.(*ResourceContext).resType = _x
	}
	{
		p.SetState(1839)

		var _m = p.Match(HiveParserStringLiteral)

		localctx.(*ResourceContext).resPath = _m
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IResourceTypeContext is an interface to support dynamic dispatch.
type IResourceTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_JAR() antlr.TerminalNode
	KW_FILE() antlr.TerminalNode
	KW_ARCHIVE() antlr.TerminalNode

	// IsResourceTypeContext differentiates from other interfaces.
	IsResourceTypeContext()
}

type ResourceTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResourceTypeContext() *ResourceTypeContext {
	var p = new(ResourceTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_resourceType
	return p
}

func InitEmptyResourceTypeContext(p *ResourceTypeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_resourceType
}

func (*ResourceTypeContext) IsResourceTypeContext() {}

func NewResourceTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResourceTypeContext {
	var p = new(ResourceTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_resourceType

	return p
}

func (s *ResourceTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ResourceTypeContext) KW_JAR() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_JAR, 0)
}

func (s *ResourceTypeContext) KW_FILE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_FILE, 0)
}

func (s *ResourceTypeContext) KW_ARCHIVE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ARCHIVE, 0)
}

func (s *ResourceTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResourceTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ResourceTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterResourceType(s)
	}
}

func (s *ResourceTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitResourceType(s)
	}
}

func (s *ResourceTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitResourceType(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ResourceType() (localctx IResourceTypeContext) {
	localctx = NewResourceTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, HiveParserRULE_resourceType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1841)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HiveParserKW_ARCHIVE || _la == HiveParserKW_FILE || _la == HiveParserKW_JAR) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreateFunctionStatementContext is an interface to support dynamic dispatch.
type ICreateFunctionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTemp returns the temp token.
	GetTemp() antlr.Token 


	// SetTemp sets the temp token.
	SetTemp(antlr.Token) 


	// GetRList returns the rList rule contexts.
	GetRList() IResourceListContext


	// SetRList sets the rList rule contexts.
	SetRList(IResourceListContext)


	// Getter signatures
	KW_CREATE() antlr.TerminalNode
	KW_FUNCTION() antlr.TerminalNode
	FunctionIdentifier() IFunctionIdentifierContext
	KW_AS() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode
	KW_USING() antlr.TerminalNode
	KW_TEMPORARY() antlr.TerminalNode
	ResourceList() IResourceListContext

	// IsCreateFunctionStatementContext differentiates from other interfaces.
	IsCreateFunctionStatementContext()
}

type CreateFunctionStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	temp antlr.Token
	rList IResourceListContext 
}

func NewEmptyCreateFunctionStatementContext() *CreateFunctionStatementContext {
	var p = new(CreateFunctionStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_createFunctionStatement
	return p
}

func InitEmptyCreateFunctionStatementContext(p *CreateFunctionStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_createFunctionStatement
}

func (*CreateFunctionStatementContext) IsCreateFunctionStatementContext() {}

func NewCreateFunctionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateFunctionStatementContext {
	var p = new(CreateFunctionStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_createFunctionStatement

	return p
}

func (s *CreateFunctionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateFunctionStatementContext) GetTemp() antlr.Token { return s.temp }


func (s *CreateFunctionStatementContext) SetTemp(v antlr.Token) { s.temp = v }


func (s *CreateFunctionStatementContext) GetRList() IResourceListContext { return s.rList }


func (s *CreateFunctionStatementContext) SetRList(v IResourceListContext) { s.rList = v }


func (s *CreateFunctionStatementContext) KW_CREATE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_CREATE, 0)
}

func (s *CreateFunctionStatementContext) KW_FUNCTION() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_FUNCTION, 0)
}

func (s *CreateFunctionStatementContext) FunctionIdentifier() IFunctionIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionIdentifierContext)
}

func (s *CreateFunctionStatementContext) KW_AS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_AS, 0)
}

func (s *CreateFunctionStatementContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(HiveParserStringLiteral, 0)
}

func (s *CreateFunctionStatementContext) KW_USING() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_USING, 0)
}

func (s *CreateFunctionStatementContext) KW_TEMPORARY() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TEMPORARY, 0)
}

func (s *CreateFunctionStatementContext) ResourceList() IResourceListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResourceListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResourceListContext)
}

func (s *CreateFunctionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateFunctionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CreateFunctionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterCreateFunctionStatement(s)
	}
}

func (s *CreateFunctionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitCreateFunctionStatement(s)
	}
}

func (s *CreateFunctionStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitCreateFunctionStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) CreateFunctionStatement() (localctx ICreateFunctionStatementContext) {
	localctx = NewCreateFunctionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, HiveParserRULE_createFunctionStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1843)
		p.Match(HiveParserKW_CREATE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1845)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_TEMPORARY {
		{
			p.SetState(1844)

			var _m = p.Match(HiveParserKW_TEMPORARY)

			localctx.(*CreateFunctionStatementContext).temp = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(1847)
		p.Match(HiveParserKW_FUNCTION)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1848)
		p.FunctionIdentifier()
	}
	{
		p.SetState(1849)
		p.Match(HiveParserKW_AS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1850)
		p.Match(HiveParserStringLiteral)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1853)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_USING {
		{
			p.SetState(1851)
			p.Match(HiveParserKW_USING)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1852)

			var _x = p.ResourceList()


			localctx.(*CreateFunctionStatementContext).rList = _x
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDropFunctionStatementContext is an interface to support dynamic dispatch.
type IDropFunctionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTemp returns the temp token.
	GetTemp() antlr.Token 


	// SetTemp sets the temp token.
	SetTemp(antlr.Token) 


	// Getter signatures
	KW_DROP() antlr.TerminalNode
	KW_FUNCTION() antlr.TerminalNode
	FunctionIdentifier() IFunctionIdentifierContext
	IfExists() IIfExistsContext
	KW_TEMPORARY() antlr.TerminalNode

	// IsDropFunctionStatementContext differentiates from other interfaces.
	IsDropFunctionStatementContext()
}

type DropFunctionStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	temp antlr.Token
}

func NewEmptyDropFunctionStatementContext() *DropFunctionStatementContext {
	var p = new(DropFunctionStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_dropFunctionStatement
	return p
}

func InitEmptyDropFunctionStatementContext(p *DropFunctionStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_dropFunctionStatement
}

func (*DropFunctionStatementContext) IsDropFunctionStatementContext() {}

func NewDropFunctionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropFunctionStatementContext {
	var p = new(DropFunctionStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_dropFunctionStatement

	return p
}

func (s *DropFunctionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropFunctionStatementContext) GetTemp() antlr.Token { return s.temp }


func (s *DropFunctionStatementContext) SetTemp(v antlr.Token) { s.temp = v }


func (s *DropFunctionStatementContext) KW_DROP() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DROP, 0)
}

func (s *DropFunctionStatementContext) KW_FUNCTION() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_FUNCTION, 0)
}

func (s *DropFunctionStatementContext) FunctionIdentifier() IFunctionIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionIdentifierContext)
}

func (s *DropFunctionStatementContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropFunctionStatementContext) KW_TEMPORARY() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TEMPORARY, 0)
}

func (s *DropFunctionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropFunctionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DropFunctionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterDropFunctionStatement(s)
	}
}

func (s *DropFunctionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitDropFunctionStatement(s)
	}
}

func (s *DropFunctionStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitDropFunctionStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) DropFunctionStatement() (localctx IDropFunctionStatementContext) {
	localctx = NewDropFunctionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, HiveParserRULE_dropFunctionStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1855)
		p.Match(HiveParserKW_DROP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1857)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_TEMPORARY {
		{
			p.SetState(1856)

			var _m = p.Match(HiveParserKW_TEMPORARY)

			localctx.(*DropFunctionStatementContext).temp = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(1859)
		p.Match(HiveParserKW_FUNCTION)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1861)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_IF {
		{
			p.SetState(1860)
			p.IfExists()
		}

	}
	{
		p.SetState(1863)
		p.FunctionIdentifier()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IReloadFunctionsStatementContext is an interface to support dynamic dispatch.
type IReloadFunctionsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_RELOAD() antlr.TerminalNode
	KW_FUNCTIONS() antlr.TerminalNode
	KW_FUNCTION() antlr.TerminalNode

	// IsReloadFunctionsStatementContext differentiates from other interfaces.
	IsReloadFunctionsStatementContext()
}

type ReloadFunctionsStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReloadFunctionsStatementContext() *ReloadFunctionsStatementContext {
	var p = new(ReloadFunctionsStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_reloadFunctionsStatement
	return p
}

func InitEmptyReloadFunctionsStatementContext(p *ReloadFunctionsStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_reloadFunctionsStatement
}

func (*ReloadFunctionsStatementContext) IsReloadFunctionsStatementContext() {}

func NewReloadFunctionsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReloadFunctionsStatementContext {
	var p = new(ReloadFunctionsStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_reloadFunctionsStatement

	return p
}

func (s *ReloadFunctionsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReloadFunctionsStatementContext) KW_RELOAD() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_RELOAD, 0)
}

func (s *ReloadFunctionsStatementContext) KW_FUNCTIONS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_FUNCTIONS, 0)
}

func (s *ReloadFunctionsStatementContext) KW_FUNCTION() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_FUNCTION, 0)
}

func (s *ReloadFunctionsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReloadFunctionsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ReloadFunctionsStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterReloadFunctionsStatement(s)
	}
}

func (s *ReloadFunctionsStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitReloadFunctionsStatement(s)
	}
}

func (s *ReloadFunctionsStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitReloadFunctionsStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ReloadFunctionsStatement() (localctx IReloadFunctionsStatementContext) {
	localctx = NewReloadFunctionsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, HiveParserRULE_reloadFunctionsStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1865)
		p.Match(HiveParserKW_RELOAD)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1866)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HiveParserKW_FUNCTION || _la == HiveParserKW_FUNCTIONS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreateMacroStatementContext is an interface to support dynamic dispatch.
type ICreateMacroStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_CREATE() antlr.TerminalNode
	KW_TEMPORARY() antlr.TerminalNode
	KW_MACRO() antlr.TerminalNode
	Identifier() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	Expression() IExpressionContext
	ColumnNameTypeList() IColumnNameTypeListContext

	// IsCreateMacroStatementContext differentiates from other interfaces.
	IsCreateMacroStatementContext()
}

type CreateMacroStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateMacroStatementContext() *CreateMacroStatementContext {
	var p = new(CreateMacroStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_createMacroStatement
	return p
}

func InitEmptyCreateMacroStatementContext(p *CreateMacroStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_createMacroStatement
}

func (*CreateMacroStatementContext) IsCreateMacroStatementContext() {}

func NewCreateMacroStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateMacroStatementContext {
	var p = new(CreateMacroStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_createMacroStatement

	return p
}

func (s *CreateMacroStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateMacroStatementContext) KW_CREATE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_CREATE, 0)
}

func (s *CreateMacroStatementContext) KW_TEMPORARY() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TEMPORARY, 0)
}

func (s *CreateMacroStatementContext) KW_MACRO() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_MACRO, 0)
}

func (s *CreateMacroStatementContext) Identifier() antlr.TerminalNode {
	return s.GetToken(HiveParserIdentifier, 0)
}

func (s *CreateMacroStatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserLPAREN, 0)
}

func (s *CreateMacroStatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserRPAREN, 0)
}

func (s *CreateMacroStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CreateMacroStatementContext) ColumnNameTypeList() IColumnNameTypeListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNameTypeListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNameTypeListContext)
}

func (s *CreateMacroStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateMacroStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CreateMacroStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterCreateMacroStatement(s)
	}
}

func (s *CreateMacroStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitCreateMacroStatement(s)
	}
}

func (s *CreateMacroStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitCreateMacroStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) CreateMacroStatement() (localctx ICreateMacroStatementContext) {
	localctx = NewCreateMacroStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, HiveParserRULE_createMacroStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1868)
		p.Match(HiveParserKW_CREATE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1869)
		p.Match(HiveParserKW_TEMPORARY)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1870)
		p.Match(HiveParserKW_MACRO)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1871)
		p.Match(HiveParserIdentifier)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1872)
		p.Match(HiveParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1874)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 808078815591695742) != 0) || ((int64((_la - 66)) & ^0x3f) == 0 && ((int64(1) << (_la - 66)) & 1083038567331911621) != 0) || ((int64((_la - 132)) & ^0x3f) == 0 && ((int64(1) << (_la - 132)) & 8916819943869537315) != 0) || ((int64((_la - 196)) & ^0x3f) == 0 && ((int64(1) << (_la - 196)) & 4159991143015340909) != 0) || ((int64((_la - 261)) & ^0x3f) == 0 && ((int64(1) << (_la - 261)) & 8484708576009596927) != 0) || ((int64((_la - 328)) & ^0x3f) == 0 && ((int64(1) << (_la - 328)) & 17776728909112555) != 0) || _la == HiveParserIdentifier {
		{
			p.SetState(1873)
			p.ColumnNameTypeList()
		}

	}
	{
		p.SetState(1876)
		p.Match(HiveParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1877)
		p.Expression()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDropMacroStatementContext is an interface to support dynamic dispatch.
type IDropMacroStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_DROP() antlr.TerminalNode
	KW_TEMPORARY() antlr.TerminalNode
	KW_MACRO() antlr.TerminalNode
	Identifier() antlr.TerminalNode
	IfExists() IIfExistsContext

	// IsDropMacroStatementContext differentiates from other interfaces.
	IsDropMacroStatementContext()
}

type DropMacroStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropMacroStatementContext() *DropMacroStatementContext {
	var p = new(DropMacroStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_dropMacroStatement
	return p
}

func InitEmptyDropMacroStatementContext(p *DropMacroStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_dropMacroStatement
}

func (*DropMacroStatementContext) IsDropMacroStatementContext() {}

func NewDropMacroStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropMacroStatementContext {
	var p = new(DropMacroStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_dropMacroStatement

	return p
}

func (s *DropMacroStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropMacroStatementContext) KW_DROP() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DROP, 0)
}

func (s *DropMacroStatementContext) KW_TEMPORARY() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TEMPORARY, 0)
}

func (s *DropMacroStatementContext) KW_MACRO() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_MACRO, 0)
}

func (s *DropMacroStatementContext) Identifier() antlr.TerminalNode {
	return s.GetToken(HiveParserIdentifier, 0)
}

func (s *DropMacroStatementContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropMacroStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropMacroStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DropMacroStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterDropMacroStatement(s)
	}
}

func (s *DropMacroStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitDropMacroStatement(s)
	}
}

func (s *DropMacroStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitDropMacroStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) DropMacroStatement() (localctx IDropMacroStatementContext) {
	localctx = NewDropMacroStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, HiveParserRULE_dropMacroStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1879)
		p.Match(HiveParserKW_DROP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1880)
		p.Match(HiveParserKW_TEMPORARY)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1881)
		p.Match(HiveParserKW_MACRO)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1883)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_IF {
		{
			p.SetState(1882)
			p.IfExists()
		}

	}
	{
		p.SetState(1885)
		p.Match(HiveParserIdentifier)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreateViewStatementContext is an interface to support dynamic dispatch.
type ICreateViewStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() ITableNameContext


	// SetName sets the name rule contexts.
	SetName(ITableNameContext)


	// Getter signatures
	KW_CREATE() antlr.TerminalNode
	KW_VIEW() antlr.TerminalNode
	KW_AS() antlr.TerminalNode
	SelectStatementWithCTE() ISelectStatementWithCTEContext
	TableName() ITableNameContext
	OrReplace() IOrReplaceContext
	IfNotExists() IIfNotExistsContext
	LPAREN() antlr.TerminalNode
	ColumnNameCommentList() IColumnNameCommentListContext
	RPAREN() antlr.TerminalNode
	TableComment() ITableCommentContext
	ViewPartition() IViewPartitionContext
	TablePropertiesPrefixed() ITablePropertiesPrefixedContext

	// IsCreateViewStatementContext differentiates from other interfaces.
	IsCreateViewStatementContext()
}

type CreateViewStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name ITableNameContext 
}

func NewEmptyCreateViewStatementContext() *CreateViewStatementContext {
	var p = new(CreateViewStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_createViewStatement
	return p
}

func InitEmptyCreateViewStatementContext(p *CreateViewStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_createViewStatement
}

func (*CreateViewStatementContext) IsCreateViewStatementContext() {}

func NewCreateViewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateViewStatementContext {
	var p = new(CreateViewStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_createViewStatement

	return p
}

func (s *CreateViewStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateViewStatementContext) GetName() ITableNameContext { return s.name }


func (s *CreateViewStatementContext) SetName(v ITableNameContext) { s.name = v }


func (s *CreateViewStatementContext) KW_CREATE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_CREATE, 0)
}

func (s *CreateViewStatementContext) KW_VIEW() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_VIEW, 0)
}

func (s *CreateViewStatementContext) KW_AS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_AS, 0)
}

func (s *CreateViewStatementContext) SelectStatementWithCTE() ISelectStatementWithCTEContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementWithCTEContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementWithCTEContext)
}

func (s *CreateViewStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *CreateViewStatementContext) OrReplace() IOrReplaceContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrReplaceContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrReplaceContext)
}

func (s *CreateViewStatementContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *CreateViewStatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserLPAREN, 0)
}

func (s *CreateViewStatementContext) ColumnNameCommentList() IColumnNameCommentListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNameCommentListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNameCommentListContext)
}

func (s *CreateViewStatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserRPAREN, 0)
}

func (s *CreateViewStatementContext) TableComment() ITableCommentContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableCommentContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableCommentContext)
}

func (s *CreateViewStatementContext) ViewPartition() IViewPartitionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IViewPartitionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IViewPartitionContext)
}

func (s *CreateViewStatementContext) TablePropertiesPrefixed() ITablePropertiesPrefixedContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablePropertiesPrefixedContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablePropertiesPrefixedContext)
}

func (s *CreateViewStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateViewStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CreateViewStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterCreateViewStatement(s)
	}
}

func (s *CreateViewStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitCreateViewStatement(s)
	}
}

func (s *CreateViewStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitCreateViewStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) CreateViewStatement() (localctx ICreateViewStatementContext) {
	localctx = NewCreateViewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, HiveParserRULE_createViewStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1887)
		p.Match(HiveParserKW_CREATE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1889)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_OR {
		{
			p.SetState(1888)
			p.OrReplace()
		}

	}
	{
		p.SetState(1891)
		p.Match(HiveParserKW_VIEW)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1893)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_IF {
		{
			p.SetState(1892)
			p.IfNotExists()
		}

	}
	{
		p.SetState(1895)

		var _x = p.TableName()


		localctx.(*CreateViewStatementContext).name = _x
	}
	p.SetState(1900)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserLPAREN {
		{
			p.SetState(1896)
			p.Match(HiveParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1897)
			p.ColumnNameCommentList()
		}
		{
			p.SetState(1898)
			p.Match(HiveParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	p.SetState(1903)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_COMMENT {
		{
			p.SetState(1902)
			p.TableComment()
		}

	}
	p.SetState(1906)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_PARTITIONED {
		{
			p.SetState(1905)
			p.ViewPartition()
		}

	}
	p.SetState(1909)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_TBLPROPERTIES {
		{
			p.SetState(1908)
			p.TablePropertiesPrefixed()
		}

	}
	{
		p.SetState(1911)
		p.Match(HiveParserKW_AS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1912)
		p.SelectStatementWithCTE()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IViewPartitionContext is an interface to support dynamic dispatch.
type IViewPartitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSpec returns the spec rule contexts.
	GetSpec() IPartitionTransformSpecContext


	// SetSpec sets the spec rule contexts.
	SetSpec(IPartitionTransformSpecContext)


	// Getter signatures
	KW_PARTITIONED() antlr.TerminalNode
	KW_ON() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	ColumnNameList() IColumnNameListContext
	KW_SPEC() antlr.TerminalNode
	PartitionTransformSpec() IPartitionTransformSpecContext

	// IsViewPartitionContext differentiates from other interfaces.
	IsViewPartitionContext()
}

type ViewPartitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	spec IPartitionTransformSpecContext 
}

func NewEmptyViewPartitionContext() *ViewPartitionContext {
	var p = new(ViewPartitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_viewPartition
	return p
}

func InitEmptyViewPartitionContext(p *ViewPartitionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_viewPartition
}

func (*ViewPartitionContext) IsViewPartitionContext() {}

func NewViewPartitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ViewPartitionContext {
	var p = new(ViewPartitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_viewPartition

	return p
}

func (s *ViewPartitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ViewPartitionContext) GetSpec() IPartitionTransformSpecContext { return s.spec }


func (s *ViewPartitionContext) SetSpec(v IPartitionTransformSpecContext) { s.spec = v }


func (s *ViewPartitionContext) KW_PARTITIONED() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_PARTITIONED, 0)
}

func (s *ViewPartitionContext) KW_ON() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ON, 0)
}

func (s *ViewPartitionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserRPAREN, 0)
}

func (s *ViewPartitionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserLPAREN, 0)
}

func (s *ViewPartitionContext) ColumnNameList() IColumnNameListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNameListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNameListContext)
}

func (s *ViewPartitionContext) KW_SPEC() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SPEC, 0)
}

func (s *ViewPartitionContext) PartitionTransformSpec() IPartitionTransformSpecContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionTransformSpecContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionTransformSpecContext)
}

func (s *ViewPartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ViewPartitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ViewPartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterViewPartition(s)
	}
}

func (s *ViewPartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitViewPartition(s)
	}
}

func (s *ViewPartitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitViewPartition(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ViewPartition() (localctx IViewPartitionContext) {
	localctx = NewViewPartitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, HiveParserRULE_viewPartition)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1914)
		p.Match(HiveParserKW_PARTITIONED)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1915)
		p.Match(HiveParserKW_ON)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1921)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserLPAREN:
		{
			p.SetState(1916)
			p.Match(HiveParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1917)
			p.ColumnNameList()
		}


	case HiveParserKW_SPEC:
		{
			p.SetState(1918)
			p.Match(HiveParserKW_SPEC)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1919)
			p.Match(HiveParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1920)

			var _x = p.PartitionTransformSpec()


			localctx.(*ViewPartitionContext).spec = _x
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(1923)
		p.Match(HiveParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IViewOrganizationContext is an interface to support dynamic dispatch.
type IViewOrganizationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ViewClusterSpec() IViewClusterSpecContext
	ViewComplexSpec() IViewComplexSpecContext

	// IsViewOrganizationContext differentiates from other interfaces.
	IsViewOrganizationContext()
}

type ViewOrganizationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyViewOrganizationContext() *ViewOrganizationContext {
	var p = new(ViewOrganizationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_viewOrganization
	return p
}

func InitEmptyViewOrganizationContext(p *ViewOrganizationContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_viewOrganization
}

func (*ViewOrganizationContext) IsViewOrganizationContext() {}

func NewViewOrganizationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ViewOrganizationContext {
	var p = new(ViewOrganizationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_viewOrganization

	return p
}

func (s *ViewOrganizationContext) GetParser() antlr.Parser { return s.parser }

func (s *ViewOrganizationContext) ViewClusterSpec() IViewClusterSpecContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IViewClusterSpecContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IViewClusterSpecContext)
}

func (s *ViewOrganizationContext) ViewComplexSpec() IViewComplexSpecContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IViewComplexSpecContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IViewComplexSpecContext)
}

func (s *ViewOrganizationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ViewOrganizationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ViewOrganizationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterViewOrganization(s)
	}
}

func (s *ViewOrganizationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitViewOrganization(s)
	}
}

func (s *ViewOrganizationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitViewOrganization(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ViewOrganization() (localctx IViewOrganizationContext) {
	localctx = NewViewOrganizationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, HiveParserRULE_viewOrganization)
	p.SetState(1927)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserKW_CLUSTERED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1925)
			p.ViewClusterSpec()
		}


	case HiveParserKW_DISTRIBUTED:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1926)
			p.ViewComplexSpec()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IViewClusterSpecContext is an interface to support dynamic dispatch.
type IViewClusterSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_CLUSTERED() antlr.TerminalNode
	KW_ON() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	ColumnNameList() IColumnNameListContext
	RPAREN() antlr.TerminalNode

	// IsViewClusterSpecContext differentiates from other interfaces.
	IsViewClusterSpecContext()
}

type ViewClusterSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyViewClusterSpecContext() *ViewClusterSpecContext {
	var p = new(ViewClusterSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_viewClusterSpec
	return p
}

func InitEmptyViewClusterSpecContext(p *ViewClusterSpecContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_viewClusterSpec
}

func (*ViewClusterSpecContext) IsViewClusterSpecContext() {}

func NewViewClusterSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ViewClusterSpecContext {
	var p = new(ViewClusterSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_viewClusterSpec

	return p
}

func (s *ViewClusterSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *ViewClusterSpecContext) KW_CLUSTERED() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_CLUSTERED, 0)
}

func (s *ViewClusterSpecContext) KW_ON() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ON, 0)
}

func (s *ViewClusterSpecContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserLPAREN, 0)
}

func (s *ViewClusterSpecContext) ColumnNameList() IColumnNameListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNameListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNameListContext)
}

func (s *ViewClusterSpecContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserRPAREN, 0)
}

func (s *ViewClusterSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ViewClusterSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ViewClusterSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterViewClusterSpec(s)
	}
}

func (s *ViewClusterSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitViewClusterSpec(s)
	}
}

func (s *ViewClusterSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitViewClusterSpec(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ViewClusterSpec() (localctx IViewClusterSpecContext) {
	localctx = NewViewClusterSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, HiveParserRULE_viewClusterSpec)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1929)
		p.Match(HiveParserKW_CLUSTERED)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1930)
		p.Match(HiveParserKW_ON)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1931)
		p.Match(HiveParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1932)
		p.ColumnNameList()
	}
	{
		p.SetState(1933)
		p.Match(HiveParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IViewComplexSpecContext is an interface to support dynamic dispatch.
type IViewComplexSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ViewDistSpec() IViewDistSpecContext
	ViewSortSpec() IViewSortSpecContext

	// IsViewComplexSpecContext differentiates from other interfaces.
	IsViewComplexSpecContext()
}

type ViewComplexSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyViewComplexSpecContext() *ViewComplexSpecContext {
	var p = new(ViewComplexSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_viewComplexSpec
	return p
}

func InitEmptyViewComplexSpecContext(p *ViewComplexSpecContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_viewComplexSpec
}

func (*ViewComplexSpecContext) IsViewComplexSpecContext() {}

func NewViewComplexSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ViewComplexSpecContext {
	var p = new(ViewComplexSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_viewComplexSpec

	return p
}

func (s *ViewComplexSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *ViewComplexSpecContext) ViewDistSpec() IViewDistSpecContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IViewDistSpecContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IViewDistSpecContext)
}

func (s *ViewComplexSpecContext) ViewSortSpec() IViewSortSpecContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IViewSortSpecContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IViewSortSpecContext)
}

func (s *ViewComplexSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ViewComplexSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ViewComplexSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterViewComplexSpec(s)
	}
}

func (s *ViewComplexSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitViewComplexSpec(s)
	}
}

func (s *ViewComplexSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitViewComplexSpec(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ViewComplexSpec() (localctx IViewComplexSpecContext) {
	localctx = NewViewComplexSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, HiveParserRULE_viewComplexSpec)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1935)
		p.ViewDistSpec()
	}
	{
		p.SetState(1936)
		p.ViewSortSpec()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IViewDistSpecContext is an interface to support dynamic dispatch.
type IViewDistSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetColList returns the colList rule contexts.
	GetColList() IColumnNameListContext


	// SetColList sets the colList rule contexts.
	SetColList(IColumnNameListContext)


	// Getter signatures
	KW_DISTRIBUTED() antlr.TerminalNode
	KW_ON() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	ColumnNameList() IColumnNameListContext

	// IsViewDistSpecContext differentiates from other interfaces.
	IsViewDistSpecContext()
}

type ViewDistSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	colList IColumnNameListContext 
}

func NewEmptyViewDistSpecContext() *ViewDistSpecContext {
	var p = new(ViewDistSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_viewDistSpec
	return p
}

func InitEmptyViewDistSpecContext(p *ViewDistSpecContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_viewDistSpec
}

func (*ViewDistSpecContext) IsViewDistSpecContext() {}

func NewViewDistSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ViewDistSpecContext {
	var p = new(ViewDistSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_viewDistSpec

	return p
}

func (s *ViewDistSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *ViewDistSpecContext) GetColList() IColumnNameListContext { return s.colList }


func (s *ViewDistSpecContext) SetColList(v IColumnNameListContext) { s.colList = v }


func (s *ViewDistSpecContext) KW_DISTRIBUTED() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DISTRIBUTED, 0)
}

func (s *ViewDistSpecContext) KW_ON() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ON, 0)
}

func (s *ViewDistSpecContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserLPAREN, 0)
}

func (s *ViewDistSpecContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserRPAREN, 0)
}

func (s *ViewDistSpecContext) ColumnNameList() IColumnNameListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNameListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNameListContext)
}

func (s *ViewDistSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ViewDistSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ViewDistSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterViewDistSpec(s)
	}
}

func (s *ViewDistSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitViewDistSpec(s)
	}
}

func (s *ViewDistSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitViewDistSpec(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ViewDistSpec() (localctx IViewDistSpecContext) {
	localctx = NewViewDistSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, HiveParserRULE_viewDistSpec)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1938)
		p.Match(HiveParserKW_DISTRIBUTED)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1939)
		p.Match(HiveParserKW_ON)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1940)
		p.Match(HiveParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1941)

		var _x = p.ColumnNameList()


		localctx.(*ViewDistSpecContext).colList = _x
	}
	{
		p.SetState(1942)
		p.Match(HiveParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IViewSortSpecContext is an interface to support dynamic dispatch.
type IViewSortSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetColList returns the colList rule contexts.
	GetColList() IColumnNameListContext


	// SetColList sets the colList rule contexts.
	SetColList(IColumnNameListContext)


	// Getter signatures
	KW_SORTED() antlr.TerminalNode
	KW_ON() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	ColumnNameList() IColumnNameListContext

	// IsViewSortSpecContext differentiates from other interfaces.
	IsViewSortSpecContext()
}

type ViewSortSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	colList IColumnNameListContext 
}

func NewEmptyViewSortSpecContext() *ViewSortSpecContext {
	var p = new(ViewSortSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_viewSortSpec
	return p
}

func InitEmptyViewSortSpecContext(p *ViewSortSpecContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_viewSortSpec
}

func (*ViewSortSpecContext) IsViewSortSpecContext() {}

func NewViewSortSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ViewSortSpecContext {
	var p = new(ViewSortSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_viewSortSpec

	return p
}

func (s *ViewSortSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *ViewSortSpecContext) GetColList() IColumnNameListContext { return s.colList }


func (s *ViewSortSpecContext) SetColList(v IColumnNameListContext) { s.colList = v }


func (s *ViewSortSpecContext) KW_SORTED() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SORTED, 0)
}

func (s *ViewSortSpecContext) KW_ON() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ON, 0)
}

func (s *ViewSortSpecContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserLPAREN, 0)
}

func (s *ViewSortSpecContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserRPAREN, 0)
}

func (s *ViewSortSpecContext) ColumnNameList() IColumnNameListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNameListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNameListContext)
}

func (s *ViewSortSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ViewSortSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ViewSortSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterViewSortSpec(s)
	}
}

func (s *ViewSortSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitViewSortSpec(s)
	}
}

func (s *ViewSortSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitViewSortSpec(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ViewSortSpec() (localctx IViewSortSpecContext) {
	localctx = NewViewSortSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, HiveParserRULE_viewSortSpec)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1944)
		p.Match(HiveParserKW_SORTED)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1945)
		p.Match(HiveParserKW_ON)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1946)
		p.Match(HiveParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1947)

		var _x = p.ColumnNameList()


		localctx.(*ViewSortSpecContext).colList = _x
	}
	{
		p.SetState(1948)
		p.Match(HiveParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDropViewStatementContext is an interface to support dynamic dispatch.
type IDropViewStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_DROP() antlr.TerminalNode
	KW_VIEW() antlr.TerminalNode
	ViewName() IViewNameContext
	IfExists() IIfExistsContext

	// IsDropViewStatementContext differentiates from other interfaces.
	IsDropViewStatementContext()
}

type DropViewStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropViewStatementContext() *DropViewStatementContext {
	var p = new(DropViewStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_dropViewStatement
	return p
}

func InitEmptyDropViewStatementContext(p *DropViewStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_dropViewStatement
}

func (*DropViewStatementContext) IsDropViewStatementContext() {}

func NewDropViewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropViewStatementContext {
	var p = new(DropViewStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_dropViewStatement

	return p
}

func (s *DropViewStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropViewStatementContext) KW_DROP() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DROP, 0)
}

func (s *DropViewStatementContext) KW_VIEW() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_VIEW, 0)
}

func (s *DropViewStatementContext) ViewName() IViewNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IViewNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IViewNameContext)
}

func (s *DropViewStatementContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropViewStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropViewStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DropViewStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterDropViewStatement(s)
	}
}

func (s *DropViewStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitDropViewStatement(s)
	}
}

func (s *DropViewStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitDropViewStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) DropViewStatement() (localctx IDropViewStatementContext) {
	localctx = NewDropViewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, HiveParserRULE_dropViewStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1950)
		p.Match(HiveParserKW_DROP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1951)
		p.Match(HiveParserKW_VIEW)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1953)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_IF {
		{
			p.SetState(1952)
			p.IfExists()
		}

	}
	{
		p.SetState(1955)
		p.ViewName()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreateMaterializedViewStatementContext is an interface to support dynamic dispatch.
type ICreateMaterializedViewStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() ITableNameContext


	// SetName sets the name rule contexts.
	SetName(ITableNameContext)


	// Getter signatures
	KW_CREATE() antlr.TerminalNode
	KW_MATERIALIZED() antlr.TerminalNode
	KW_VIEW() antlr.TerminalNode
	KW_AS() antlr.TerminalNode
	SelectStatementWithCTE() ISelectStatementWithCTEContext
	TableName() ITableNameContext
	IfNotExists() IIfNotExistsContext
	RewriteDisabled() IRewriteDisabledContext
	TableComment() ITableCommentContext
	ViewPartition() IViewPartitionContext
	ViewOrganization() IViewOrganizationContext
	TableRowFormat() ITableRowFormatContext
	TableFileFormat() ITableFileFormatContext
	TableLocation() ITableLocationContext
	TablePropertiesPrefixed() ITablePropertiesPrefixedContext

	// IsCreateMaterializedViewStatementContext differentiates from other interfaces.
	IsCreateMaterializedViewStatementContext()
}

type CreateMaterializedViewStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name ITableNameContext 
}

func NewEmptyCreateMaterializedViewStatementContext() *CreateMaterializedViewStatementContext {
	var p = new(CreateMaterializedViewStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_createMaterializedViewStatement
	return p
}

func InitEmptyCreateMaterializedViewStatementContext(p *CreateMaterializedViewStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_createMaterializedViewStatement
}

func (*CreateMaterializedViewStatementContext) IsCreateMaterializedViewStatementContext() {}

func NewCreateMaterializedViewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateMaterializedViewStatementContext {
	var p = new(CreateMaterializedViewStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_createMaterializedViewStatement

	return p
}

func (s *CreateMaterializedViewStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateMaterializedViewStatementContext) GetName() ITableNameContext { return s.name }


func (s *CreateMaterializedViewStatementContext) SetName(v ITableNameContext) { s.name = v }


func (s *CreateMaterializedViewStatementContext) KW_CREATE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_CREATE, 0)
}

func (s *CreateMaterializedViewStatementContext) KW_MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_MATERIALIZED, 0)
}

func (s *CreateMaterializedViewStatementContext) KW_VIEW() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_VIEW, 0)
}

func (s *CreateMaterializedViewStatementContext) KW_AS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_AS, 0)
}

func (s *CreateMaterializedViewStatementContext) SelectStatementWithCTE() ISelectStatementWithCTEContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementWithCTEContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementWithCTEContext)
}

func (s *CreateMaterializedViewStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *CreateMaterializedViewStatementContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *CreateMaterializedViewStatementContext) RewriteDisabled() IRewriteDisabledContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRewriteDisabledContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRewriteDisabledContext)
}

func (s *CreateMaterializedViewStatementContext) TableComment() ITableCommentContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableCommentContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableCommentContext)
}

func (s *CreateMaterializedViewStatementContext) ViewPartition() IViewPartitionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IViewPartitionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IViewPartitionContext)
}

func (s *CreateMaterializedViewStatementContext) ViewOrganization() IViewOrganizationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IViewOrganizationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IViewOrganizationContext)
}

func (s *CreateMaterializedViewStatementContext) TableRowFormat() ITableRowFormatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableRowFormatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableRowFormatContext)
}

func (s *CreateMaterializedViewStatementContext) TableFileFormat() ITableFileFormatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableFileFormatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableFileFormatContext)
}

func (s *CreateMaterializedViewStatementContext) TableLocation() ITableLocationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableLocationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableLocationContext)
}

func (s *CreateMaterializedViewStatementContext) TablePropertiesPrefixed() ITablePropertiesPrefixedContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablePropertiesPrefixedContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablePropertiesPrefixedContext)
}

func (s *CreateMaterializedViewStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateMaterializedViewStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CreateMaterializedViewStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterCreateMaterializedViewStatement(s)
	}
}

func (s *CreateMaterializedViewStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitCreateMaterializedViewStatement(s)
	}
}

func (s *CreateMaterializedViewStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitCreateMaterializedViewStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) CreateMaterializedViewStatement() (localctx ICreateMaterializedViewStatementContext) {
	localctx = NewCreateMaterializedViewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, HiveParserRULE_createMaterializedViewStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1957)
		p.Match(HiveParserKW_CREATE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1958)
		p.Match(HiveParserKW_MATERIALIZED)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1959)
		p.Match(HiveParserKW_VIEW)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1961)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_IF {
		{
			p.SetState(1960)
			p.IfNotExists()
		}

	}
	{
		p.SetState(1963)

		var _x = p.TableName()


		localctx.(*CreateMaterializedViewStatementContext).name = _x
	}
	p.SetState(1965)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_DISABLE {
		{
			p.SetState(1964)
			p.RewriteDisabled()
		}

	}
	p.SetState(1968)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_COMMENT {
		{
			p.SetState(1967)
			p.TableComment()
		}

	}
	p.SetState(1971)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_PARTITIONED {
		{
			p.SetState(1970)
			p.ViewPartition()
		}

	}
	p.SetState(1974)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_CLUSTERED || _la == HiveParserKW_DISTRIBUTED {
		{
			p.SetState(1973)
			p.ViewOrganization()
		}

	}
	p.SetState(1977)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_ROW {
		{
			p.SetState(1976)
			p.TableRowFormat()
		}

	}
	p.SetState(1980)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_STORED {
		{
			p.SetState(1979)
			p.TableFileFormat()
		}

	}
	p.SetState(1983)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_LOCATION {
		{
			p.SetState(1982)
			p.TableLocation()
		}

	}
	p.SetState(1986)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_TBLPROPERTIES {
		{
			p.SetState(1985)
			p.TablePropertiesPrefixed()
		}

	}
	{
		p.SetState(1988)
		p.Match(HiveParserKW_AS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1989)
		p.SelectStatementWithCTE()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDropMaterializedViewStatementContext is an interface to support dynamic dispatch.
type IDropMaterializedViewStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_DROP() antlr.TerminalNode
	KW_MATERIALIZED() antlr.TerminalNode
	KW_VIEW() antlr.TerminalNode
	ViewName() IViewNameContext
	IfExists() IIfExistsContext

	// IsDropMaterializedViewStatementContext differentiates from other interfaces.
	IsDropMaterializedViewStatementContext()
}

type DropMaterializedViewStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropMaterializedViewStatementContext() *DropMaterializedViewStatementContext {
	var p = new(DropMaterializedViewStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_dropMaterializedViewStatement
	return p
}

func InitEmptyDropMaterializedViewStatementContext(p *DropMaterializedViewStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_dropMaterializedViewStatement
}

func (*DropMaterializedViewStatementContext) IsDropMaterializedViewStatementContext() {}

func NewDropMaterializedViewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropMaterializedViewStatementContext {
	var p = new(DropMaterializedViewStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_dropMaterializedViewStatement

	return p
}

func (s *DropMaterializedViewStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropMaterializedViewStatementContext) KW_DROP() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DROP, 0)
}

func (s *DropMaterializedViewStatementContext) KW_MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_MATERIALIZED, 0)
}

func (s *DropMaterializedViewStatementContext) KW_VIEW() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_VIEW, 0)
}

func (s *DropMaterializedViewStatementContext) ViewName() IViewNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IViewNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IViewNameContext)
}

func (s *DropMaterializedViewStatementContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropMaterializedViewStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropMaterializedViewStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DropMaterializedViewStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterDropMaterializedViewStatement(s)
	}
}

func (s *DropMaterializedViewStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitDropMaterializedViewStatement(s)
	}
}

func (s *DropMaterializedViewStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitDropMaterializedViewStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) DropMaterializedViewStatement() (localctx IDropMaterializedViewStatementContext) {
	localctx = NewDropMaterializedViewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, HiveParserRULE_dropMaterializedViewStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1991)
		p.Match(HiveParserKW_DROP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1992)
		p.Match(HiveParserKW_MATERIALIZED)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1993)
		p.Match(HiveParserKW_VIEW)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1995)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_IF {
		{
			p.SetState(1994)
			p.IfExists()
		}

	}
	{
		p.SetState(1997)
		p.ViewName()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreateScheduledQueryStatementContext is an interface to support dynamic dispatch.
type ICreateScheduledQueryStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IId_Context


	// SetName sets the name rule contexts.
	SetName(IId_Context)


	// Getter signatures
	KW_CREATE() antlr.TerminalNode
	KW_SCHEDULED() antlr.TerminalNode
	KW_QUERY() antlr.TerminalNode
	ScheduleSpec() IScheduleSpecContext
	DefinedAsSpec() IDefinedAsSpecContext
	Id_() IId_Context
	ExecutedAsSpec() IExecutedAsSpecContext
	EnableSpecification() IEnableSpecificationContext

	// IsCreateScheduledQueryStatementContext differentiates from other interfaces.
	IsCreateScheduledQueryStatementContext()
}

type CreateScheduledQueryStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name IId_Context 
}

func NewEmptyCreateScheduledQueryStatementContext() *CreateScheduledQueryStatementContext {
	var p = new(CreateScheduledQueryStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_createScheduledQueryStatement
	return p
}

func InitEmptyCreateScheduledQueryStatementContext(p *CreateScheduledQueryStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_createScheduledQueryStatement
}

func (*CreateScheduledQueryStatementContext) IsCreateScheduledQueryStatementContext() {}

func NewCreateScheduledQueryStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateScheduledQueryStatementContext {
	var p = new(CreateScheduledQueryStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_createScheduledQueryStatement

	return p
}

func (s *CreateScheduledQueryStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateScheduledQueryStatementContext) GetName() IId_Context { return s.name }


func (s *CreateScheduledQueryStatementContext) SetName(v IId_Context) { s.name = v }


func (s *CreateScheduledQueryStatementContext) KW_CREATE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_CREATE, 0)
}

func (s *CreateScheduledQueryStatementContext) KW_SCHEDULED() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SCHEDULED, 0)
}

func (s *CreateScheduledQueryStatementContext) KW_QUERY() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_QUERY, 0)
}

func (s *CreateScheduledQueryStatementContext) ScheduleSpec() IScheduleSpecContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScheduleSpecContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScheduleSpecContext)
}

func (s *CreateScheduledQueryStatementContext) DefinedAsSpec() IDefinedAsSpecContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefinedAsSpecContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefinedAsSpecContext)
}

func (s *CreateScheduledQueryStatementContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *CreateScheduledQueryStatementContext) ExecutedAsSpec() IExecutedAsSpecContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExecutedAsSpecContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExecutedAsSpecContext)
}

func (s *CreateScheduledQueryStatementContext) EnableSpecification() IEnableSpecificationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnableSpecificationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnableSpecificationContext)
}

func (s *CreateScheduledQueryStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateScheduledQueryStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CreateScheduledQueryStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterCreateScheduledQueryStatement(s)
	}
}

func (s *CreateScheduledQueryStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitCreateScheduledQueryStatement(s)
	}
}

func (s *CreateScheduledQueryStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitCreateScheduledQueryStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) CreateScheduledQueryStatement() (localctx ICreateScheduledQueryStatementContext) {
	localctx = NewCreateScheduledQueryStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, HiveParserRULE_createScheduledQueryStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1999)
		p.Match(HiveParserKW_CREATE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2000)
		p.Match(HiveParserKW_SCHEDULED)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2001)
		p.Match(HiveParserKW_QUERY)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2002)

		var _x = p.Id_()


		localctx.(*CreateScheduledQueryStatementContext).name = _x
	}
	{
		p.SetState(2003)
		p.ScheduleSpec()
	}
	p.SetState(2005)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_EXECUTED {
		{
			p.SetState(2004)
			p.ExecutedAsSpec()
		}

	}
	p.SetState(2008)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_DISABLE || _la == HiveParserKW_ENABLE {
		{
			p.SetState(2007)
			p.EnableSpecification()
		}

	}
	{
		p.SetState(2010)
		p.DefinedAsSpec()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDropScheduledQueryStatementContext is an interface to support dynamic dispatch.
type IDropScheduledQueryStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IId_Context


	// SetName sets the name rule contexts.
	SetName(IId_Context)


	// Getter signatures
	KW_DROP() antlr.TerminalNode
	KW_SCHEDULED() antlr.TerminalNode
	KW_QUERY() antlr.TerminalNode
	Id_() IId_Context

	// IsDropScheduledQueryStatementContext differentiates from other interfaces.
	IsDropScheduledQueryStatementContext()
}

type DropScheduledQueryStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name IId_Context 
}

func NewEmptyDropScheduledQueryStatementContext() *DropScheduledQueryStatementContext {
	var p = new(DropScheduledQueryStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_dropScheduledQueryStatement
	return p
}

func InitEmptyDropScheduledQueryStatementContext(p *DropScheduledQueryStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_dropScheduledQueryStatement
}

func (*DropScheduledQueryStatementContext) IsDropScheduledQueryStatementContext() {}

func NewDropScheduledQueryStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropScheduledQueryStatementContext {
	var p = new(DropScheduledQueryStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_dropScheduledQueryStatement

	return p
}

func (s *DropScheduledQueryStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropScheduledQueryStatementContext) GetName() IId_Context { return s.name }


func (s *DropScheduledQueryStatementContext) SetName(v IId_Context) { s.name = v }


func (s *DropScheduledQueryStatementContext) KW_DROP() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DROP, 0)
}

func (s *DropScheduledQueryStatementContext) KW_SCHEDULED() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SCHEDULED, 0)
}

func (s *DropScheduledQueryStatementContext) KW_QUERY() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_QUERY, 0)
}

func (s *DropScheduledQueryStatementContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *DropScheduledQueryStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropScheduledQueryStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DropScheduledQueryStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterDropScheduledQueryStatement(s)
	}
}

func (s *DropScheduledQueryStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitDropScheduledQueryStatement(s)
	}
}

func (s *DropScheduledQueryStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitDropScheduledQueryStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) DropScheduledQueryStatement() (localctx IDropScheduledQueryStatementContext) {
	localctx = NewDropScheduledQueryStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, HiveParserRULE_dropScheduledQueryStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2012)
		p.Match(HiveParserKW_DROP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2013)
		p.Match(HiveParserKW_SCHEDULED)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2014)
		p.Match(HiveParserKW_QUERY)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2015)

		var _x = p.Id_()


		localctx.(*DropScheduledQueryStatementContext).name = _x
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlterScheduledQueryStatementContext is an interface to support dynamic dispatch.
type IAlterScheduledQueryStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IId_Context

	// GetMod returns the mod rule contexts.
	GetMod() IAlterScheduledQueryChangeContext


	// SetName sets the name rule contexts.
	SetName(IId_Context)

	// SetMod sets the mod rule contexts.
	SetMod(IAlterScheduledQueryChangeContext)


	// Getter signatures
	KW_ALTER() antlr.TerminalNode
	KW_SCHEDULED() antlr.TerminalNode
	KW_QUERY() antlr.TerminalNode
	Id_() IId_Context
	AlterScheduledQueryChange() IAlterScheduledQueryChangeContext

	// IsAlterScheduledQueryStatementContext differentiates from other interfaces.
	IsAlterScheduledQueryStatementContext()
}

type AlterScheduledQueryStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name IId_Context 
	mod IAlterScheduledQueryChangeContext 
}

func NewEmptyAlterScheduledQueryStatementContext() *AlterScheduledQueryStatementContext {
	var p = new(AlterScheduledQueryStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterScheduledQueryStatement
	return p
}

func InitEmptyAlterScheduledQueryStatementContext(p *AlterScheduledQueryStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterScheduledQueryStatement
}

func (*AlterScheduledQueryStatementContext) IsAlterScheduledQueryStatementContext() {}

func NewAlterScheduledQueryStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterScheduledQueryStatementContext {
	var p = new(AlterScheduledQueryStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_alterScheduledQueryStatement

	return p
}

func (s *AlterScheduledQueryStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterScheduledQueryStatementContext) GetName() IId_Context { return s.name }

func (s *AlterScheduledQueryStatementContext) GetMod() IAlterScheduledQueryChangeContext { return s.mod }


func (s *AlterScheduledQueryStatementContext) SetName(v IId_Context) { s.name = v }

func (s *AlterScheduledQueryStatementContext) SetMod(v IAlterScheduledQueryChangeContext) { s.mod = v }


func (s *AlterScheduledQueryStatementContext) KW_ALTER() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ALTER, 0)
}

func (s *AlterScheduledQueryStatementContext) KW_SCHEDULED() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SCHEDULED, 0)
}

func (s *AlterScheduledQueryStatementContext) KW_QUERY() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_QUERY, 0)
}

func (s *AlterScheduledQueryStatementContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *AlterScheduledQueryStatementContext) AlterScheduledQueryChange() IAlterScheduledQueryChangeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterScheduledQueryChangeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterScheduledQueryChangeContext)
}

func (s *AlterScheduledQueryStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterScheduledQueryStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AlterScheduledQueryStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterAlterScheduledQueryStatement(s)
	}
}

func (s *AlterScheduledQueryStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitAlterScheduledQueryStatement(s)
	}
}

func (s *AlterScheduledQueryStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitAlterScheduledQueryStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) AlterScheduledQueryStatement() (localctx IAlterScheduledQueryStatementContext) {
	localctx = NewAlterScheduledQueryStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, HiveParserRULE_alterScheduledQueryStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2017)
		p.Match(HiveParserKW_ALTER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2018)
		p.Match(HiveParserKW_SCHEDULED)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2019)
		p.Match(HiveParserKW_QUERY)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2020)

		var _x = p.Id_()


		localctx.(*AlterScheduledQueryStatementContext).name = _x
	}
	{
		p.SetState(2021)

		var _x = p.AlterScheduledQueryChange()


		localctx.(*AlterScheduledQueryStatementContext).mod = _x
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlterScheduledQueryChangeContext is an interface to support dynamic dispatch.
type IAlterScheduledQueryChangeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ScheduleSpec() IScheduleSpecContext
	ExecutedAsSpec() IExecutedAsSpecContext
	EnableSpecification() IEnableSpecificationContext
	DefinedAsSpec() IDefinedAsSpecContext
	KW_EXECUTE() antlr.TerminalNode

	// IsAlterScheduledQueryChangeContext differentiates from other interfaces.
	IsAlterScheduledQueryChangeContext()
}

type AlterScheduledQueryChangeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterScheduledQueryChangeContext() *AlterScheduledQueryChangeContext {
	var p = new(AlterScheduledQueryChangeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterScheduledQueryChange
	return p
}

func InitEmptyAlterScheduledQueryChangeContext(p *AlterScheduledQueryChangeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterScheduledQueryChange
}

func (*AlterScheduledQueryChangeContext) IsAlterScheduledQueryChangeContext() {}

func NewAlterScheduledQueryChangeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterScheduledQueryChangeContext {
	var p = new(AlterScheduledQueryChangeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_alterScheduledQueryChange

	return p
}

func (s *AlterScheduledQueryChangeContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterScheduledQueryChangeContext) ScheduleSpec() IScheduleSpecContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScheduleSpecContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScheduleSpecContext)
}

func (s *AlterScheduledQueryChangeContext) ExecutedAsSpec() IExecutedAsSpecContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExecutedAsSpecContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExecutedAsSpecContext)
}

func (s *AlterScheduledQueryChangeContext) EnableSpecification() IEnableSpecificationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnableSpecificationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnableSpecificationContext)
}

func (s *AlterScheduledQueryChangeContext) DefinedAsSpec() IDefinedAsSpecContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefinedAsSpecContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefinedAsSpecContext)
}

func (s *AlterScheduledQueryChangeContext) KW_EXECUTE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_EXECUTE, 0)
}

func (s *AlterScheduledQueryChangeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterScheduledQueryChangeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AlterScheduledQueryChangeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterAlterScheduledQueryChange(s)
	}
}

func (s *AlterScheduledQueryChangeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitAlterScheduledQueryChange(s)
	}
}

func (s *AlterScheduledQueryChangeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitAlterScheduledQueryChange(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) AlterScheduledQueryChange() (localctx IAlterScheduledQueryChangeContext) {
	localctx = NewAlterScheduledQueryChangeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, HiveParserRULE_alterScheduledQueryChange)
	p.SetState(2028)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserKW_CRON, HiveParserKW_EVERY:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2023)
			p.ScheduleSpec()
		}


	case HiveParserKW_EXECUTED:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2024)
			p.ExecutedAsSpec()
		}


	case HiveParserKW_DISABLE, HiveParserKW_ENABLE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2025)
			p.EnableSpecification()
		}


	case HiveParserKW_AS, HiveParserKW_DEFINED:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2026)
			p.DefinedAsSpec()
		}


	case HiveParserKW_EXECUTE:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2027)
			p.Match(HiveParserKW_EXECUTE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IScheduleSpecContext is an interface to support dynamic dispatch.
type IScheduleSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCronString returns the cronString token.
	GetCronString() antlr.Token 

	// GetValue returns the value token.
	GetValue() antlr.Token 

	// GetOffsetTs returns the offsetTs token.
	GetOffsetTs() antlr.Token 


	// SetCronString sets the cronString token.
	SetCronString(antlr.Token) 

	// SetValue sets the value token.
	SetValue(antlr.Token) 

	// SetOffsetTs sets the offsetTs token.
	SetOffsetTs(antlr.Token) 


	// GetQualifier returns the qualifier rule contexts.
	GetQualifier() IIntervalQualifiersContext


	// SetQualifier sets the qualifier rule contexts.
	SetQualifier(IIntervalQualifiersContext)


	// Getter signatures
	KW_CRON() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode
	KW_EVERY() antlr.TerminalNode
	IntervalQualifiers() IIntervalQualifiersContext
	Number() antlr.TerminalNode
	KW_AT() antlr.TerminalNode
	KW_OFFSET() antlr.TerminalNode
	KW_BY() antlr.TerminalNode

	// IsScheduleSpecContext differentiates from other interfaces.
	IsScheduleSpecContext()
}

type ScheduleSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	cronString antlr.Token
	value antlr.Token
	qualifier IIntervalQualifiersContext 
	offsetTs antlr.Token
}

func NewEmptyScheduleSpecContext() *ScheduleSpecContext {
	var p = new(ScheduleSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_scheduleSpec
	return p
}

func InitEmptyScheduleSpecContext(p *ScheduleSpecContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_scheduleSpec
}

func (*ScheduleSpecContext) IsScheduleSpecContext() {}

func NewScheduleSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScheduleSpecContext {
	var p = new(ScheduleSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_scheduleSpec

	return p
}

func (s *ScheduleSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *ScheduleSpecContext) GetCronString() antlr.Token { return s.cronString }

func (s *ScheduleSpecContext) GetValue() antlr.Token { return s.value }

func (s *ScheduleSpecContext) GetOffsetTs() antlr.Token { return s.offsetTs }


func (s *ScheduleSpecContext) SetCronString(v antlr.Token) { s.cronString = v }

func (s *ScheduleSpecContext) SetValue(v antlr.Token) { s.value = v }

func (s *ScheduleSpecContext) SetOffsetTs(v antlr.Token) { s.offsetTs = v }


func (s *ScheduleSpecContext) GetQualifier() IIntervalQualifiersContext { return s.qualifier }


func (s *ScheduleSpecContext) SetQualifier(v IIntervalQualifiersContext) { s.qualifier = v }


func (s *ScheduleSpecContext) KW_CRON() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_CRON, 0)
}

func (s *ScheduleSpecContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(HiveParserStringLiteral, 0)
}

func (s *ScheduleSpecContext) KW_EVERY() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_EVERY, 0)
}

func (s *ScheduleSpecContext) IntervalQualifiers() IIntervalQualifiersContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalQualifiersContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalQualifiersContext)
}

func (s *ScheduleSpecContext) Number() antlr.TerminalNode {
	return s.GetToken(HiveParserNumber, 0)
}

func (s *ScheduleSpecContext) KW_AT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_AT, 0)
}

func (s *ScheduleSpecContext) KW_OFFSET() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_OFFSET, 0)
}

func (s *ScheduleSpecContext) KW_BY() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_BY, 0)
}

func (s *ScheduleSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScheduleSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ScheduleSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterScheduleSpec(s)
	}
}

func (s *ScheduleSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitScheduleSpec(s)
	}
}

func (s *ScheduleSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitScheduleSpec(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ScheduleSpec() (localctx IScheduleSpecContext) {
	localctx = NewScheduleSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, HiveParserRULE_scheduleSpec)
	var _la int

	p.SetState(2045)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserKW_CRON:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2030)
			p.Match(HiveParserKW_CRON)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2031)

			var _m = p.Match(HiveParserStringLiteral)

			localctx.(*ScheduleSpecContext).cronString = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HiveParserKW_EVERY:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2032)
			p.Match(HiveParserKW_EVERY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2034)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserNumber {
			{
				p.SetState(2033)

				var _m = p.Match(HiveParserNumber)

				localctx.(*ScheduleSpecContext).value = _m
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(2036)

			var _x = p.IntervalQualifiers()


			localctx.(*ScheduleSpecContext).qualifier = _x
		}
		p.SetState(2043)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_AT || _la == HiveParserKW_OFFSET {
			p.SetState(2040)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case HiveParserKW_AT:
				{
					p.SetState(2037)
					p.Match(HiveParserKW_AT)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}


			case HiveParserKW_OFFSET:
				{
					p.SetState(2038)
					p.Match(HiveParserKW_OFFSET)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(2039)
					p.Match(HiveParserKW_BY)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}



			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}
			{
				p.SetState(2042)

				var _m = p.Match(HiveParserStringLiteral)

				localctx.(*ScheduleSpecContext).offsetTs = _m
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExecutedAsSpecContext is an interface to support dynamic dispatch.
type IExecutedAsSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetExecutedAs returns the executedAs token.
	GetExecutedAs() antlr.Token 


	// SetExecutedAs sets the executedAs token.
	SetExecutedAs(antlr.Token) 


	// Getter signatures
	KW_EXECUTED() antlr.TerminalNode
	KW_AS() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode

	// IsExecutedAsSpecContext differentiates from other interfaces.
	IsExecutedAsSpecContext()
}

type ExecutedAsSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	executedAs antlr.Token
}

func NewEmptyExecutedAsSpecContext() *ExecutedAsSpecContext {
	var p = new(ExecutedAsSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_executedAsSpec
	return p
}

func InitEmptyExecutedAsSpecContext(p *ExecutedAsSpecContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_executedAsSpec
}

func (*ExecutedAsSpecContext) IsExecutedAsSpecContext() {}

func NewExecutedAsSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExecutedAsSpecContext {
	var p = new(ExecutedAsSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_executedAsSpec

	return p
}

func (s *ExecutedAsSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *ExecutedAsSpecContext) GetExecutedAs() antlr.Token { return s.executedAs }


func (s *ExecutedAsSpecContext) SetExecutedAs(v antlr.Token) { s.executedAs = v }


func (s *ExecutedAsSpecContext) KW_EXECUTED() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_EXECUTED, 0)
}

func (s *ExecutedAsSpecContext) KW_AS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_AS, 0)
}

func (s *ExecutedAsSpecContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(HiveParserStringLiteral, 0)
}

func (s *ExecutedAsSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExecutedAsSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ExecutedAsSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterExecutedAsSpec(s)
	}
}

func (s *ExecutedAsSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitExecutedAsSpec(s)
	}
}

func (s *ExecutedAsSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitExecutedAsSpec(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ExecutedAsSpec() (localctx IExecutedAsSpecContext) {
	localctx = NewExecutedAsSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, HiveParserRULE_executedAsSpec)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2047)
		p.Match(HiveParserKW_EXECUTED)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2048)
		p.Match(HiveParserKW_AS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2049)

		var _m = p.Match(HiveParserStringLiteral)

		localctx.(*ExecutedAsSpecContext).executedAs = _m
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDefinedAsSpecContext is an interface to support dynamic dispatch.
type IDefinedAsSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_AS() antlr.TerminalNode
	Statement() IStatementContext
	KW_DEFINED() antlr.TerminalNode

	// IsDefinedAsSpecContext differentiates from other interfaces.
	IsDefinedAsSpecContext()
}

type DefinedAsSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefinedAsSpecContext() *DefinedAsSpecContext {
	var p = new(DefinedAsSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_definedAsSpec
	return p
}

func InitEmptyDefinedAsSpecContext(p *DefinedAsSpecContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_definedAsSpec
}

func (*DefinedAsSpecContext) IsDefinedAsSpecContext() {}

func NewDefinedAsSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefinedAsSpecContext {
	var p = new(DefinedAsSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_definedAsSpec

	return p
}

func (s *DefinedAsSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *DefinedAsSpecContext) KW_AS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_AS, 0)
}

func (s *DefinedAsSpecContext) Statement() IStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *DefinedAsSpecContext) KW_DEFINED() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DEFINED, 0)
}

func (s *DefinedAsSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefinedAsSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DefinedAsSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterDefinedAsSpec(s)
	}
}

func (s *DefinedAsSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitDefinedAsSpec(s)
	}
}

func (s *DefinedAsSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitDefinedAsSpec(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) DefinedAsSpec() (localctx IDefinedAsSpecContext) {
	localctx = NewDefinedAsSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, HiveParserRULE_definedAsSpec)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2052)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_DEFINED {
		{
			p.SetState(2051)
			p.Match(HiveParserKW_DEFINED)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(2054)
		p.Match(HiveParserKW_AS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2055)
		p.Statement()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IShowFunctionIdentifierContext is an interface to support dynamic dispatch.
type IShowFunctionIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FunctionIdentifier() IFunctionIdentifierContext
	StringLiteral() antlr.TerminalNode

	// IsShowFunctionIdentifierContext differentiates from other interfaces.
	IsShowFunctionIdentifierContext()
}

type ShowFunctionIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowFunctionIdentifierContext() *ShowFunctionIdentifierContext {
	var p = new(ShowFunctionIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_showFunctionIdentifier
	return p
}

func InitEmptyShowFunctionIdentifierContext(p *ShowFunctionIdentifierContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_showFunctionIdentifier
}

func (*ShowFunctionIdentifierContext) IsShowFunctionIdentifierContext() {}

func NewShowFunctionIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowFunctionIdentifierContext {
	var p = new(ShowFunctionIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_showFunctionIdentifier

	return p
}

func (s *ShowFunctionIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowFunctionIdentifierContext) FunctionIdentifier() IFunctionIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionIdentifierContext)
}

func (s *ShowFunctionIdentifierContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(HiveParserStringLiteral, 0)
}

func (s *ShowFunctionIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowFunctionIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ShowFunctionIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterShowFunctionIdentifier(s)
	}
}

func (s *ShowFunctionIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitShowFunctionIdentifier(s)
	}
}

func (s *ShowFunctionIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitShowFunctionIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ShowFunctionIdentifier() (localctx IShowFunctionIdentifierContext) {
	localctx = NewShowFunctionIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, HiveParserRULE_showFunctionIdentifier)
	p.SetState(2059)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserKW_ABORT, HiveParserKW_ACTIVATE, HiveParserKW_ACTIVE, HiveParserKW_ADD, HiveParserKW_ADMIN, HiveParserKW_AFTER, HiveParserKW_ALLOC_FRACTION, HiveParserKW_ANALYZE, HiveParserKW_ARCHIVE, HiveParserKW_ASC, HiveParserKW_AST, HiveParserKW_AT, HiveParserKW_AUTOCOMMIT, HiveParserKW_BATCH, HiveParserKW_BEFORE, HiveParserKW_BUCKET, HiveParserKW_BUCKETS, HiveParserKW_CACHE, HiveParserKW_CASCADE, HiveParserKW_CBO, HiveParserKW_CHANGE, HiveParserKW_CHECK, HiveParserKW_CLUSTER, HiveParserKW_CLUSTERED, HiveParserKW_CLUSTERSTATUS, HiveParserKW_COLLECTION, HiveParserKW_COLUMNS, HiveParserKW_COMMENT, HiveParserKW_COMPACT, HiveParserKW_COMPACTIONS, HiveParserKW_COMPUTE, HiveParserKW_CONCATENATE, HiveParserKW_CONTINUE, HiveParserKW_COST, HiveParserKW_CRON, HiveParserKW_DATA, HiveParserKW_DATABASES, HiveParserKW_DATETIME, HiveParserKW_DAY, HiveParserKW_DAYOFWEEK, HiveParserKW_DBPROPERTIES, HiveParserKW_DCPROPERTIES, HiveParserKW_DEBUG, HiveParserKW_DEFAULT, HiveParserKW_DEFERRED, HiveParserKW_DEFINED, HiveParserKW_DELIMITED, HiveParserKW_DEPENDENCY, HiveParserKW_DESC, HiveParserKW_DETAIL, HiveParserKW_DIRECTORIES, HiveParserKW_DIRECTORY, HiveParserKW_DISABLE, HiveParserKW_DISTRIBUTE, HiveParserKW_DISTRIBUTED, HiveParserKW_DO, HiveParserKW_DOW, HiveParserKW_DUMP, HiveParserKW_ELEM_TYPE, HiveParserKW_ENABLE, HiveParserKW_ENFORCED, HiveParserKW_ESCAPED, HiveParserKW_EVERY, HiveParserKW_EXCLUSIVE, HiveParserKW_EXECUTE, HiveParserKW_EXECUTED, HiveParserKW_EXPIRE_SNAPSHOTS, HiveParserKW_EXPLAIN, HiveParserKW_EXPORT, HiveParserKW_EXPRESSION, HiveParserKW_FIELDS, HiveParserKW_FILE, HiveParserKW_FILEFORMAT, HiveParserKW_FIRST, HiveParserKW_FORMAT, HiveParserKW_FORMATTED, HiveParserKW_FUNCTIONS, HiveParserKW_HOLD_DDLTIME, HiveParserKW_HOUR, HiveParserKW_IDXPROPERTIES, HiveParserKW_IGNORE, HiveParserKW_INDEX, HiveParserKW_INDEXES, HiveParserKW_INPATH, HiveParserKW_INPUTDRIVER, HiveParserKW_INPUTFORMAT, HiveParserKW_ISOLATION, HiveParserKW_ITEMS, HiveParserKW_JAR, HiveParserKW_JOINCOST, HiveParserKW_KEY, HiveParserKW_KEYS, HiveParserKW_KEY_TYPE, HiveParserKW_KILL, HiveParserKW_LAST, HiveParserKW_LEVEL, HiveParserKW_LIMIT, HiveParserKW_LINES, HiveParserKW_LOAD, HiveParserKW_LOCATION, HiveParserKW_LOCK, HiveParserKW_LOCKS, HiveParserKW_LOGICAL, HiveParserKW_LONG, HiveParserKW_MANAGED, HiveParserKW_MANAGEDLOCATION, HiveParserKW_MANAGEMENT, HiveParserKW_MAPJOIN, HiveParserKW_MAPPING, HiveParserKW_MATCHED, HiveParserKW_MATERIALIZED, HiveParserKW_METADATA, HiveParserKW_MINUTE, HiveParserKW_MONTH, HiveParserKW_MOVE, HiveParserKW_MSCK, HiveParserKW_NORELY, HiveParserKW_NOSCAN, HiveParserKW_NOVALIDATE, HiveParserKW_NO_DROP, HiveParserKW_NULLS, HiveParserKW_OFFLINE, HiveParserKW_OFFSET, HiveParserKW_OPERATOR, HiveParserKW_OPTION, HiveParserKW_OUTPUTDRIVER, HiveParserKW_OUTPUTFORMAT, HiveParserKW_OVERWRITE, HiveParserKW_OWNER, HiveParserKW_PARTITIONED, HiveParserKW_PARTITIONS, HiveParserKW_PATH, HiveParserKW_PLAN, HiveParserKW_PLANS, HiveParserKW_PLUS, HiveParserKW_POOL, HiveParserKW_PRINCIPALS, HiveParserKW_PROTECTION, HiveParserKW_PURGE, HiveParserKW_QUARTER, HiveParserKW_QUERY, HiveParserKW_QUERY_PARALLELISM, HiveParserKW_READ, HiveParserKW_READONLY, HiveParserKW_REBUILD, HiveParserKW_RECORDREADER, HiveParserKW_RECORDWRITER, HiveParserKW_RELOAD, HiveParserKW_RELY, HiveParserKW_REMOTE, HiveParserKW_RENAME, HiveParserKW_REOPTIMIZATION, HiveParserKW_REPAIR, HiveParserKW_REPL, HiveParserKW_REPLACE, HiveParserKW_REPLICATION, HiveParserKW_RESOURCE, HiveParserKW_RESPECT, HiveParserKW_RESTRICT, HiveParserKW_REWRITE, HiveParserKW_ROLE, HiveParserKW_ROLES, HiveParserKW_SCHEDULED, HiveParserKW_SCHEDULING_POLICY, HiveParserKW_SCHEMA, HiveParserKW_SCHEMAS, HiveParserKW_SECOND, HiveParserKW_SEMI, HiveParserKW_SERDE, HiveParserKW_SERDEPROPERTIES, HiveParserKW_SERVER, HiveParserKW_SETS, HiveParserKW_SET_CURRENT_SNAPSHOT, HiveParserKW_SHARED, HiveParserKW_SHOW, HiveParserKW_SHOW_DATABASE, HiveParserKW_SKEWED, HiveParserKW_SNAPSHOT, HiveParserKW_SORT, HiveParserKW_SORTED, HiveParserKW_SPEC, HiveParserKW_SSL, HiveParserKW_STATISTICS, HiveParserKW_STATUS, HiveParserKW_STORED, HiveParserKW_STREAMTABLE, HiveParserKW_STRING, HiveParserKW_STRUCT, HiveParserKW_SUMMARY, HiveParserKW_SYSTEM_TIME, HiveParserKW_SYSTEM_VERSION, HiveParserKW_TABLES, HiveParserKW_TBLPROPERTIES, HiveParserKW_TEMPORARY, HiveParserKW_TERMINATED, HiveParserKW_TIMESTAMPTZ, HiveParserKW_TINYINT, HiveParserKW_TOUCH, HiveParserKW_TRANSACTION, HiveParserKW_TRANSACTIONAL, HiveParserKW_TRANSACTIONS, HiveParserKW_TRIM, HiveParserKW_TYPE, HiveParserKW_UNARCHIVE, HiveParserKW_UNDO, HiveParserKW_UNIONTYPE, HiveParserKW_UNKNOWN, HiveParserKW_UNLOCK, HiveParserKW_UNMANAGED, HiveParserKW_UNSET, HiveParserKW_UNSIGNED, HiveParserKW_URI, HiveParserKW_URL, HiveParserKW_USE, HiveParserKW_UTC, HiveParserKW_UTCTIMESTAMP, HiveParserKW_VALIDATE, HiveParserKW_VALUE_TYPE, HiveParserKW_VECTORIZATION, HiveParserKW_VIEW, HiveParserKW_VIEWS, HiveParserKW_WAIT, HiveParserKW_WEEK, HiveParserKW_WHILE, HiveParserKW_WITHIN, HiveParserKW_WORK, HiveParserKW_WORKLOAD, HiveParserKW_WRITE, HiveParserKW_YEAR, HiveParserKW_ZONE, HiveParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2057)
			p.FunctionIdentifier()
		}


	case HiveParserStringLiteral:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2058)
			p.Match(HiveParserStringLiteral)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IShowStmtIdentifierContext is an interface to support dynamic dispatch.
type IShowStmtIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Id_() IId_Context
	StringLiteral() antlr.TerminalNode

	// IsShowStmtIdentifierContext differentiates from other interfaces.
	IsShowStmtIdentifierContext()
}

type ShowStmtIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowStmtIdentifierContext() *ShowStmtIdentifierContext {
	var p = new(ShowStmtIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_showStmtIdentifier
	return p
}

func InitEmptyShowStmtIdentifierContext(p *ShowStmtIdentifierContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_showStmtIdentifier
}

func (*ShowStmtIdentifierContext) IsShowStmtIdentifierContext() {}

func NewShowStmtIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowStmtIdentifierContext {
	var p = new(ShowStmtIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_showStmtIdentifier

	return p
}

func (s *ShowStmtIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowStmtIdentifierContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *ShowStmtIdentifierContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(HiveParserStringLiteral, 0)
}

func (s *ShowStmtIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowStmtIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ShowStmtIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterShowStmtIdentifier(s)
	}
}

func (s *ShowStmtIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitShowStmtIdentifier(s)
	}
}

func (s *ShowStmtIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitShowStmtIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ShowStmtIdentifier() (localctx IShowStmtIdentifierContext) {
	localctx = NewShowStmtIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, HiveParserRULE_showStmtIdentifier)
	p.SetState(2063)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserKW_ABORT, HiveParserKW_ACTIVATE, HiveParserKW_ACTIVE, HiveParserKW_ADD, HiveParserKW_ADMIN, HiveParserKW_AFTER, HiveParserKW_ALLOC_FRACTION, HiveParserKW_ANALYZE, HiveParserKW_ARCHIVE, HiveParserKW_ASC, HiveParserKW_AST, HiveParserKW_AT, HiveParserKW_AUTOCOMMIT, HiveParserKW_BATCH, HiveParserKW_BEFORE, HiveParserKW_BUCKET, HiveParserKW_BUCKETS, HiveParserKW_CACHE, HiveParserKW_CASCADE, HiveParserKW_CBO, HiveParserKW_CHANGE, HiveParserKW_CHECK, HiveParserKW_CLUSTER, HiveParserKW_CLUSTERED, HiveParserKW_CLUSTERSTATUS, HiveParserKW_COLLECTION, HiveParserKW_COLUMNS, HiveParserKW_COMMENT, HiveParserKW_COMPACT, HiveParserKW_COMPACTIONS, HiveParserKW_COMPUTE, HiveParserKW_CONCATENATE, HiveParserKW_CONTINUE, HiveParserKW_COST, HiveParserKW_CRON, HiveParserKW_DATA, HiveParserKW_DATABASES, HiveParserKW_DATETIME, HiveParserKW_DAY, HiveParserKW_DAYOFWEEK, HiveParserKW_DBPROPERTIES, HiveParserKW_DCPROPERTIES, HiveParserKW_DEBUG, HiveParserKW_DEFAULT, HiveParserKW_DEFERRED, HiveParserKW_DEFINED, HiveParserKW_DELIMITED, HiveParserKW_DEPENDENCY, HiveParserKW_DESC, HiveParserKW_DETAIL, HiveParserKW_DIRECTORIES, HiveParserKW_DIRECTORY, HiveParserKW_DISABLE, HiveParserKW_DISTRIBUTE, HiveParserKW_DISTRIBUTED, HiveParserKW_DO, HiveParserKW_DOW, HiveParserKW_DUMP, HiveParserKW_ELEM_TYPE, HiveParserKW_ENABLE, HiveParserKW_ENFORCED, HiveParserKW_ESCAPED, HiveParserKW_EVERY, HiveParserKW_EXCLUSIVE, HiveParserKW_EXECUTE, HiveParserKW_EXECUTED, HiveParserKW_EXPIRE_SNAPSHOTS, HiveParserKW_EXPLAIN, HiveParserKW_EXPORT, HiveParserKW_EXPRESSION, HiveParserKW_FIELDS, HiveParserKW_FILE, HiveParserKW_FILEFORMAT, HiveParserKW_FIRST, HiveParserKW_FORMAT, HiveParserKW_FORMATTED, HiveParserKW_FUNCTIONS, HiveParserKW_HOLD_DDLTIME, HiveParserKW_HOUR, HiveParserKW_IDXPROPERTIES, HiveParserKW_IGNORE, HiveParserKW_INDEX, HiveParserKW_INDEXES, HiveParserKW_INPATH, HiveParserKW_INPUTDRIVER, HiveParserKW_INPUTFORMAT, HiveParserKW_ISOLATION, HiveParserKW_ITEMS, HiveParserKW_JAR, HiveParserKW_JOINCOST, HiveParserKW_KEY, HiveParserKW_KEYS, HiveParserKW_KEY_TYPE, HiveParserKW_KILL, HiveParserKW_LAST, HiveParserKW_LEVEL, HiveParserKW_LIMIT, HiveParserKW_LINES, HiveParserKW_LOAD, HiveParserKW_LOCATION, HiveParserKW_LOCK, HiveParserKW_LOCKS, HiveParserKW_LOGICAL, HiveParserKW_LONG, HiveParserKW_MANAGED, HiveParserKW_MANAGEDLOCATION, HiveParserKW_MANAGEMENT, HiveParserKW_MAPJOIN, HiveParserKW_MAPPING, HiveParserKW_MATCHED, HiveParserKW_MATERIALIZED, HiveParserKW_METADATA, HiveParserKW_MINUTE, HiveParserKW_MONTH, HiveParserKW_MOVE, HiveParserKW_MSCK, HiveParserKW_NORELY, HiveParserKW_NOSCAN, HiveParserKW_NOVALIDATE, HiveParserKW_NO_DROP, HiveParserKW_NULLS, HiveParserKW_OFFLINE, HiveParserKW_OFFSET, HiveParserKW_OPERATOR, HiveParserKW_OPTION, HiveParserKW_OUTPUTDRIVER, HiveParserKW_OUTPUTFORMAT, HiveParserKW_OVERWRITE, HiveParserKW_OWNER, HiveParserKW_PARTITIONED, HiveParserKW_PARTITIONS, HiveParserKW_PATH, HiveParserKW_PLAN, HiveParserKW_PLANS, HiveParserKW_PLUS, HiveParserKW_POOL, HiveParserKW_PRINCIPALS, HiveParserKW_PROTECTION, HiveParserKW_PURGE, HiveParserKW_QUARTER, HiveParserKW_QUERY, HiveParserKW_QUERY_PARALLELISM, HiveParserKW_READ, HiveParserKW_READONLY, HiveParserKW_REBUILD, HiveParserKW_RECORDREADER, HiveParserKW_RECORDWRITER, HiveParserKW_RELOAD, HiveParserKW_RELY, HiveParserKW_REMOTE, HiveParserKW_RENAME, HiveParserKW_REOPTIMIZATION, HiveParserKW_REPAIR, HiveParserKW_REPL, HiveParserKW_REPLACE, HiveParserKW_REPLICATION, HiveParserKW_RESOURCE, HiveParserKW_RESPECT, HiveParserKW_RESTRICT, HiveParserKW_REWRITE, HiveParserKW_ROLE, HiveParserKW_ROLES, HiveParserKW_SCHEDULED, HiveParserKW_SCHEDULING_POLICY, HiveParserKW_SCHEMA, HiveParserKW_SCHEMAS, HiveParserKW_SECOND, HiveParserKW_SEMI, HiveParserKW_SERDE, HiveParserKW_SERDEPROPERTIES, HiveParserKW_SERVER, HiveParserKW_SETS, HiveParserKW_SET_CURRENT_SNAPSHOT, HiveParserKW_SHARED, HiveParserKW_SHOW, HiveParserKW_SHOW_DATABASE, HiveParserKW_SKEWED, HiveParserKW_SNAPSHOT, HiveParserKW_SORT, HiveParserKW_SORTED, HiveParserKW_SPEC, HiveParserKW_SSL, HiveParserKW_STATISTICS, HiveParserKW_STATUS, HiveParserKW_STORED, HiveParserKW_STREAMTABLE, HiveParserKW_STRING, HiveParserKW_STRUCT, HiveParserKW_SUMMARY, HiveParserKW_SYSTEM_TIME, HiveParserKW_SYSTEM_VERSION, HiveParserKW_TABLES, HiveParserKW_TBLPROPERTIES, HiveParserKW_TEMPORARY, HiveParserKW_TERMINATED, HiveParserKW_TIMESTAMPTZ, HiveParserKW_TINYINT, HiveParserKW_TOUCH, HiveParserKW_TRANSACTION, HiveParserKW_TRANSACTIONAL, HiveParserKW_TRANSACTIONS, HiveParserKW_TRIM, HiveParserKW_TYPE, HiveParserKW_UNARCHIVE, HiveParserKW_UNDO, HiveParserKW_UNIONTYPE, HiveParserKW_UNKNOWN, HiveParserKW_UNLOCK, HiveParserKW_UNMANAGED, HiveParserKW_UNSET, HiveParserKW_UNSIGNED, HiveParserKW_URI, HiveParserKW_URL, HiveParserKW_USE, HiveParserKW_UTC, HiveParserKW_UTCTIMESTAMP, HiveParserKW_VALIDATE, HiveParserKW_VALUE_TYPE, HiveParserKW_VECTORIZATION, HiveParserKW_VIEW, HiveParserKW_VIEWS, HiveParserKW_WAIT, HiveParserKW_WEEK, HiveParserKW_WHILE, HiveParserKW_WITHIN, HiveParserKW_WORK, HiveParserKW_WORKLOAD, HiveParserKW_WRITE, HiveParserKW_YEAR, HiveParserKW_ZONE, HiveParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2061)
			p.Id_()
		}


	case HiveParserStringLiteral:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2062)
			p.Match(HiveParserStringLiteral)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITableCommentContext is an interface to support dynamic dispatch.
type ITableCommentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetComment returns the comment token.
	GetComment() antlr.Token 


	// SetComment sets the comment token.
	SetComment(antlr.Token) 


	// Getter signatures
	KW_COMMENT() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode

	// IsTableCommentContext differentiates from other interfaces.
	IsTableCommentContext()
}

type TableCommentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	comment antlr.Token
}

func NewEmptyTableCommentContext() *TableCommentContext {
	var p = new(TableCommentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_tableComment
	return p
}

func InitEmptyTableCommentContext(p *TableCommentContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_tableComment
}

func (*TableCommentContext) IsTableCommentContext() {}

func NewTableCommentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableCommentContext {
	var p = new(TableCommentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_tableComment

	return p
}

func (s *TableCommentContext) GetParser() antlr.Parser { return s.parser }

func (s *TableCommentContext) GetComment() antlr.Token { return s.comment }


func (s *TableCommentContext) SetComment(v antlr.Token) { s.comment = v }


func (s *TableCommentContext) KW_COMMENT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_COMMENT, 0)
}

func (s *TableCommentContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(HiveParserStringLiteral, 0)
}

func (s *TableCommentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableCommentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TableCommentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterTableComment(s)
	}
}

func (s *TableCommentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitTableComment(s)
	}
}

func (s *TableCommentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitTableComment(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) TableComment() (localctx ITableCommentContext) {
	localctx = NewTableCommentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, HiveParserRULE_tableComment)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2065)
		p.Match(HiveParserKW_COMMENT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2066)

		var _m = p.Match(HiveParserStringLiteral)

		localctx.(*TableCommentContext).comment = _m
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreateTablePartitionSpecContext is an interface to support dynamic dispatch.
type ICreateTablePartitionSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOpt1 returns the opt1 rule contexts.
	GetOpt1() ICreateTablePartitionColumnTypeSpecContext

	// GetOpt2 returns the opt2 rule contexts.
	GetOpt2() ICreateTablePartitionColumnSpecContext

	// GetSpec returns the spec rule contexts.
	GetSpec() IPartitionTransformSpecContext


	// SetOpt1 sets the opt1 rule contexts.
	SetOpt1(ICreateTablePartitionColumnTypeSpecContext)

	// SetOpt2 sets the opt2 rule contexts.
	SetOpt2(ICreateTablePartitionColumnSpecContext)

	// SetSpec sets the spec rule contexts.
	SetSpec(IPartitionTransformSpecContext)


	// Getter signatures
	KW_PARTITIONED() antlr.TerminalNode
	KW_BY() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	KW_SPEC() antlr.TerminalNode
	PartitionTransformSpec() IPartitionTransformSpecContext
	CreateTablePartitionColumnTypeSpec() ICreateTablePartitionColumnTypeSpecContext
	CreateTablePartitionColumnSpec() ICreateTablePartitionColumnSpecContext

	// IsCreateTablePartitionSpecContext differentiates from other interfaces.
	IsCreateTablePartitionSpecContext()
}

type CreateTablePartitionSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	opt1 ICreateTablePartitionColumnTypeSpecContext 
	opt2 ICreateTablePartitionColumnSpecContext 
	spec IPartitionTransformSpecContext 
}

func NewEmptyCreateTablePartitionSpecContext() *CreateTablePartitionSpecContext {
	var p = new(CreateTablePartitionSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_createTablePartitionSpec
	return p
}

func InitEmptyCreateTablePartitionSpecContext(p *CreateTablePartitionSpecContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_createTablePartitionSpec
}

func (*CreateTablePartitionSpecContext) IsCreateTablePartitionSpecContext() {}

func NewCreateTablePartitionSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateTablePartitionSpecContext {
	var p = new(CreateTablePartitionSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_createTablePartitionSpec

	return p
}

func (s *CreateTablePartitionSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateTablePartitionSpecContext) GetOpt1() ICreateTablePartitionColumnTypeSpecContext { return s.opt1 }

func (s *CreateTablePartitionSpecContext) GetOpt2() ICreateTablePartitionColumnSpecContext { return s.opt2 }

func (s *CreateTablePartitionSpecContext) GetSpec() IPartitionTransformSpecContext { return s.spec }


func (s *CreateTablePartitionSpecContext) SetOpt1(v ICreateTablePartitionColumnTypeSpecContext) { s.opt1 = v }

func (s *CreateTablePartitionSpecContext) SetOpt2(v ICreateTablePartitionColumnSpecContext) { s.opt2 = v }

func (s *CreateTablePartitionSpecContext) SetSpec(v IPartitionTransformSpecContext) { s.spec = v }


func (s *CreateTablePartitionSpecContext) KW_PARTITIONED() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_PARTITIONED, 0)
}

func (s *CreateTablePartitionSpecContext) KW_BY() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_BY, 0)
}

func (s *CreateTablePartitionSpecContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserRPAREN, 0)
}

func (s *CreateTablePartitionSpecContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserLPAREN, 0)
}

func (s *CreateTablePartitionSpecContext) KW_SPEC() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SPEC, 0)
}

func (s *CreateTablePartitionSpecContext) PartitionTransformSpec() IPartitionTransformSpecContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionTransformSpecContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionTransformSpecContext)
}

func (s *CreateTablePartitionSpecContext) CreateTablePartitionColumnTypeSpec() ICreateTablePartitionColumnTypeSpecContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateTablePartitionColumnTypeSpecContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateTablePartitionColumnTypeSpecContext)
}

func (s *CreateTablePartitionSpecContext) CreateTablePartitionColumnSpec() ICreateTablePartitionColumnSpecContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateTablePartitionColumnSpecContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateTablePartitionColumnSpecContext)
}

func (s *CreateTablePartitionSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTablePartitionSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CreateTablePartitionSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterCreateTablePartitionSpec(s)
	}
}

func (s *CreateTablePartitionSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitCreateTablePartitionSpec(s)
	}
}

func (s *CreateTablePartitionSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitCreateTablePartitionSpec(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) CreateTablePartitionSpec() (localctx ICreateTablePartitionSpecContext) {
	localctx = NewCreateTablePartitionSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, HiveParserRULE_createTablePartitionSpec)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2068)
		p.Match(HiveParserKW_PARTITIONED)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2069)
		p.Match(HiveParserKW_BY)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(2078)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserLPAREN:
		{
			p.SetState(2070)
			p.Match(HiveParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2073)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 163, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(2071)

				var _x = p.CreateTablePartitionColumnTypeSpec()


				localctx.(*CreateTablePartitionSpecContext).opt1 = _x
			}


		case 2:
			{
				p.SetState(2072)

				var _x = p.CreateTablePartitionColumnSpec()


				localctx.(*CreateTablePartitionSpecContext).opt2 = _x
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}


	case HiveParserKW_SPEC:
		{
			p.SetState(2075)
			p.Match(HiveParserKW_SPEC)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2076)
			p.Match(HiveParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2077)

			var _x = p.PartitionTransformSpec()


			localctx.(*CreateTablePartitionSpecContext).spec = _x
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(2080)
		p.Match(HiveParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreateTablePartitionColumnTypeSpecContext is an interface to support dynamic dispatch.
type ICreateTablePartitionColumnTypeSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllColumnNameTypeConstraint() []IColumnNameTypeConstraintContext
	ColumnNameTypeConstraint(i int) IColumnNameTypeConstraintContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsCreateTablePartitionColumnTypeSpecContext differentiates from other interfaces.
	IsCreateTablePartitionColumnTypeSpecContext()
}

type CreateTablePartitionColumnTypeSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateTablePartitionColumnTypeSpecContext() *CreateTablePartitionColumnTypeSpecContext {
	var p = new(CreateTablePartitionColumnTypeSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_createTablePartitionColumnTypeSpec
	return p
}

func InitEmptyCreateTablePartitionColumnTypeSpecContext(p *CreateTablePartitionColumnTypeSpecContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_createTablePartitionColumnTypeSpec
}

func (*CreateTablePartitionColumnTypeSpecContext) IsCreateTablePartitionColumnTypeSpecContext() {}

func NewCreateTablePartitionColumnTypeSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateTablePartitionColumnTypeSpecContext {
	var p = new(CreateTablePartitionColumnTypeSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_createTablePartitionColumnTypeSpec

	return p
}

func (s *CreateTablePartitionColumnTypeSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateTablePartitionColumnTypeSpecContext) AllColumnNameTypeConstraint() []IColumnNameTypeConstraintContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnNameTypeConstraintContext); ok {
			len++
		}
	}

	tst := make([]IColumnNameTypeConstraintContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnNameTypeConstraintContext); ok {
			tst[i] = t.(IColumnNameTypeConstraintContext)
			i++
		}
	}

	return tst
}

func (s *CreateTablePartitionColumnTypeSpecContext) ColumnNameTypeConstraint(i int) IColumnNameTypeConstraintContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNameTypeConstraintContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNameTypeConstraintContext)
}

func (s *CreateTablePartitionColumnTypeSpecContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(HiveParserCOMMA)
}

func (s *CreateTablePartitionColumnTypeSpecContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserCOMMA, i)
}

func (s *CreateTablePartitionColumnTypeSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTablePartitionColumnTypeSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CreateTablePartitionColumnTypeSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterCreateTablePartitionColumnTypeSpec(s)
	}
}

func (s *CreateTablePartitionColumnTypeSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitCreateTablePartitionColumnTypeSpec(s)
	}
}

func (s *CreateTablePartitionColumnTypeSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitCreateTablePartitionColumnTypeSpec(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) CreateTablePartitionColumnTypeSpec() (localctx ICreateTablePartitionColumnTypeSpecContext) {
	localctx = NewCreateTablePartitionColumnTypeSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, HiveParserRULE_createTablePartitionColumnTypeSpec)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2082)
		p.ColumnNameTypeConstraint()
	}
	p.SetState(2087)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HiveParserCOMMA {
		{
			p.SetState(2083)
			p.Match(HiveParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2084)
			p.ColumnNameTypeConstraint()
		}


		p.SetState(2089)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreateTablePartitionColumnSpecContext is an interface to support dynamic dispatch.
type ICreateTablePartitionColumnSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllColumnName() []IColumnNameContext
	ColumnName(i int) IColumnNameContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsCreateTablePartitionColumnSpecContext differentiates from other interfaces.
	IsCreateTablePartitionColumnSpecContext()
}

type CreateTablePartitionColumnSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateTablePartitionColumnSpecContext() *CreateTablePartitionColumnSpecContext {
	var p = new(CreateTablePartitionColumnSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_createTablePartitionColumnSpec
	return p
}

func InitEmptyCreateTablePartitionColumnSpecContext(p *CreateTablePartitionColumnSpecContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_createTablePartitionColumnSpec
}

func (*CreateTablePartitionColumnSpecContext) IsCreateTablePartitionColumnSpecContext() {}

func NewCreateTablePartitionColumnSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateTablePartitionColumnSpecContext {
	var p = new(CreateTablePartitionColumnSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_createTablePartitionColumnSpec

	return p
}

func (s *CreateTablePartitionColumnSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateTablePartitionColumnSpecContext) AllColumnName() []IColumnNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnNameContext); ok {
			len++
		}
	}

	tst := make([]IColumnNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnNameContext); ok {
			tst[i] = t.(IColumnNameContext)
			i++
		}
	}

	return tst
}

func (s *CreateTablePartitionColumnSpecContext) ColumnName(i int) IColumnNameContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNameContext)
}

func (s *CreateTablePartitionColumnSpecContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(HiveParserCOMMA)
}

func (s *CreateTablePartitionColumnSpecContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserCOMMA, i)
}

func (s *CreateTablePartitionColumnSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTablePartitionColumnSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CreateTablePartitionColumnSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterCreateTablePartitionColumnSpec(s)
	}
}

func (s *CreateTablePartitionColumnSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitCreateTablePartitionColumnSpec(s)
	}
}

func (s *CreateTablePartitionColumnSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitCreateTablePartitionColumnSpec(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) CreateTablePartitionColumnSpec() (localctx ICreateTablePartitionColumnSpecContext) {
	localctx = NewCreateTablePartitionColumnSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, HiveParserRULE_createTablePartitionColumnSpec)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2090)
		p.ColumnName()
	}
	p.SetState(2095)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HiveParserCOMMA {
		{
			p.SetState(2091)
			p.Match(HiveParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2092)
			p.ColumnName()
		}


		p.SetState(2097)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPartitionTransformSpecContext is an interface to support dynamic dispatch.
type IPartitionTransformSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllColumnNameTransformConstraint() []IColumnNameTransformConstraintContext
	ColumnNameTransformConstraint(i int) IColumnNameTransformConstraintContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPartitionTransformSpecContext differentiates from other interfaces.
	IsPartitionTransformSpecContext()
}

type PartitionTransformSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionTransformSpecContext() *PartitionTransformSpecContext {
	var p = new(PartitionTransformSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_partitionTransformSpec
	return p
}

func InitEmptyPartitionTransformSpecContext(p *PartitionTransformSpecContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_partitionTransformSpec
}

func (*PartitionTransformSpecContext) IsPartitionTransformSpecContext() {}

func NewPartitionTransformSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionTransformSpecContext {
	var p = new(PartitionTransformSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_partitionTransformSpec

	return p
}

func (s *PartitionTransformSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionTransformSpecContext) AllColumnNameTransformConstraint() []IColumnNameTransformConstraintContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnNameTransformConstraintContext); ok {
			len++
		}
	}

	tst := make([]IColumnNameTransformConstraintContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnNameTransformConstraintContext); ok {
			tst[i] = t.(IColumnNameTransformConstraintContext)
			i++
		}
	}

	return tst
}

func (s *PartitionTransformSpecContext) ColumnNameTransformConstraint(i int) IColumnNameTransformConstraintContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNameTransformConstraintContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNameTransformConstraintContext)
}

func (s *PartitionTransformSpecContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(HiveParserCOMMA)
}

func (s *PartitionTransformSpecContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserCOMMA, i)
}

func (s *PartitionTransformSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionTransformSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PartitionTransformSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterPartitionTransformSpec(s)
	}
}

func (s *PartitionTransformSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitPartitionTransformSpec(s)
	}
}

func (s *PartitionTransformSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitPartitionTransformSpec(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) PartitionTransformSpec() (localctx IPartitionTransformSpecContext) {
	localctx = NewPartitionTransformSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, HiveParserRULE_partitionTransformSpec)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2098)
		p.ColumnNameTransformConstraint()
	}
	p.SetState(2103)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HiveParserCOMMA {
		{
			p.SetState(2099)
			p.Match(HiveParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2100)
			p.ColumnNameTransformConstraint()
		}


		p.SetState(2105)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IColumnNameTransformConstraintContext is an interface to support dynamic dispatch.
type IColumnNameTransformConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PartitionTransformType() IPartitionTransformTypeContext

	// IsColumnNameTransformConstraintContext differentiates from other interfaces.
	IsColumnNameTransformConstraintContext()
}

type ColumnNameTransformConstraintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnNameTransformConstraintContext() *ColumnNameTransformConstraintContext {
	var p = new(ColumnNameTransformConstraintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_columnNameTransformConstraint
	return p
}

func InitEmptyColumnNameTransformConstraintContext(p *ColumnNameTransformConstraintContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_columnNameTransformConstraint
}

func (*ColumnNameTransformConstraintContext) IsColumnNameTransformConstraintContext() {}

func NewColumnNameTransformConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnNameTransformConstraintContext {
	var p = new(ColumnNameTransformConstraintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_columnNameTransformConstraint

	return p
}

func (s *ColumnNameTransformConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnNameTransformConstraintContext) PartitionTransformType() IPartitionTransformTypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionTransformTypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionTransformTypeContext)
}

func (s *ColumnNameTransformConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnNameTransformConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ColumnNameTransformConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterColumnNameTransformConstraint(s)
	}
}

func (s *ColumnNameTransformConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitColumnNameTransformConstraint(s)
	}
}

func (s *ColumnNameTransformConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitColumnNameTransformConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ColumnNameTransformConstraint() (localctx IColumnNameTransformConstraintContext) {
	localctx = NewColumnNameTransformConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, HiveParserRULE_columnNameTransformConstraint)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2106)
		p.PartitionTransformType()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPartitionTransformTypeContext is an interface to support dynamic dispatch.
type IPartitionTransformTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetValue returns the value token.
	GetValue() antlr.Token 


	// SetValue sets the value token.
	SetValue(antlr.Token) 


	// Getter signatures
	ColumnName() IColumnNameContext
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	KW_YEAR() antlr.TerminalNode
	KW_MONTH() antlr.TerminalNode
	KW_DAY() antlr.TerminalNode
	KW_HOUR() antlr.TerminalNode
	COMMA() antlr.TerminalNode
	KW_TRUNCATE() antlr.TerminalNode
	KW_BUCKET() antlr.TerminalNode
	Number() antlr.TerminalNode

	// IsPartitionTransformTypeContext differentiates from other interfaces.
	IsPartitionTransformTypeContext()
}

type PartitionTransformTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	value antlr.Token
}

func NewEmptyPartitionTransformTypeContext() *PartitionTransformTypeContext {
	var p = new(PartitionTransformTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_partitionTransformType
	return p
}

func InitEmptyPartitionTransformTypeContext(p *PartitionTransformTypeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_partitionTransformType
}

func (*PartitionTransformTypeContext) IsPartitionTransformTypeContext() {}

func NewPartitionTransformTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionTransformTypeContext {
	var p = new(PartitionTransformTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_partitionTransformType

	return p
}

func (s *PartitionTransformTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionTransformTypeContext) GetValue() antlr.Token { return s.value }


func (s *PartitionTransformTypeContext) SetValue(v antlr.Token) { s.value = v }


func (s *PartitionTransformTypeContext) ColumnName() IColumnNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNameContext)
}

func (s *PartitionTransformTypeContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserLPAREN, 0)
}

func (s *PartitionTransformTypeContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserRPAREN, 0)
}

func (s *PartitionTransformTypeContext) KW_YEAR() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_YEAR, 0)
}

func (s *PartitionTransformTypeContext) KW_MONTH() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_MONTH, 0)
}

func (s *PartitionTransformTypeContext) KW_DAY() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DAY, 0)
}

func (s *PartitionTransformTypeContext) KW_HOUR() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_HOUR, 0)
}

func (s *PartitionTransformTypeContext) COMMA() antlr.TerminalNode {
	return s.GetToken(HiveParserCOMMA, 0)
}

func (s *PartitionTransformTypeContext) KW_TRUNCATE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TRUNCATE, 0)
}

func (s *PartitionTransformTypeContext) KW_BUCKET() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_BUCKET, 0)
}

func (s *PartitionTransformTypeContext) Number() antlr.TerminalNode {
	return s.GetToken(HiveParserNumber, 0)
}

func (s *PartitionTransformTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionTransformTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PartitionTransformTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterPartitionTransformType(s)
	}
}

func (s *PartitionTransformTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitPartitionTransformType(s)
	}
}

func (s *PartitionTransformTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitPartitionTransformType(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) PartitionTransformType() (localctx IPartitionTransformTypeContext) {
	localctx = NewPartitionTransformTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, HiveParserRULE_partitionTransformType)
	var _la int

	p.SetState(2121)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 168, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2108)
			p.ColumnName()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2109)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HiveParserKW_DAY || _la == HiveParserKW_HOUR || _la == HiveParserKW_MONTH || _la == HiveParserKW_YEAR) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2110)
			p.Match(HiveParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2111)
			p.ColumnName()
		}
		{
			p.SetState(2112)
			p.Match(HiveParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2114)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HiveParserKW_BUCKET || _la == HiveParserKW_TRUNCATE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2115)
			p.Match(HiveParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2116)

			var _m = p.Match(HiveParserNumber)

			localctx.(*PartitionTransformTypeContext).value = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2117)
			p.Match(HiveParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2118)
			p.ColumnName()
		}
		{
			p.SetState(2119)
			p.Match(HiveParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITableBucketsContext is an interface to support dynamic dispatch.
type ITableBucketsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetNum returns the num token.
	GetNum() antlr.Token 


	// SetNum sets the num token.
	SetNum(antlr.Token) 


	// GetBucketCols returns the bucketCols rule contexts.
	GetBucketCols() IColumnNameListContext

	// GetSortCols returns the sortCols rule contexts.
	GetSortCols() IColumnNameOrderListContext


	// SetBucketCols sets the bucketCols rule contexts.
	SetBucketCols(IColumnNameListContext)

	// SetSortCols sets the sortCols rule contexts.
	SetSortCols(IColumnNameOrderListContext)


	// Getter signatures
	KW_CLUSTERED() antlr.TerminalNode
	AllKW_BY() []antlr.TerminalNode
	KW_BY(i int) antlr.TerminalNode
	AllLPAREN() []antlr.TerminalNode
	LPAREN(i int) antlr.TerminalNode
	AllRPAREN() []antlr.TerminalNode
	RPAREN(i int) antlr.TerminalNode
	KW_INTO() antlr.TerminalNode
	KW_BUCKETS() antlr.TerminalNode
	ColumnNameList() IColumnNameListContext
	Number() antlr.TerminalNode
	KW_SORTED() antlr.TerminalNode
	ColumnNameOrderList() IColumnNameOrderListContext

	// IsTableBucketsContext differentiates from other interfaces.
	IsTableBucketsContext()
}

type TableBucketsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	bucketCols IColumnNameListContext 
	sortCols IColumnNameOrderListContext 
	num antlr.Token
}

func NewEmptyTableBucketsContext() *TableBucketsContext {
	var p = new(TableBucketsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_tableBuckets
	return p
}

func InitEmptyTableBucketsContext(p *TableBucketsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_tableBuckets
}

func (*TableBucketsContext) IsTableBucketsContext() {}

func NewTableBucketsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableBucketsContext {
	var p = new(TableBucketsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_tableBuckets

	return p
}

func (s *TableBucketsContext) GetParser() antlr.Parser { return s.parser }

func (s *TableBucketsContext) GetNum() antlr.Token { return s.num }


func (s *TableBucketsContext) SetNum(v antlr.Token) { s.num = v }


func (s *TableBucketsContext) GetBucketCols() IColumnNameListContext { return s.bucketCols }

func (s *TableBucketsContext) GetSortCols() IColumnNameOrderListContext { return s.sortCols }


func (s *TableBucketsContext) SetBucketCols(v IColumnNameListContext) { s.bucketCols = v }

func (s *TableBucketsContext) SetSortCols(v IColumnNameOrderListContext) { s.sortCols = v }


func (s *TableBucketsContext) KW_CLUSTERED() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_CLUSTERED, 0)
}

func (s *TableBucketsContext) AllKW_BY() []antlr.TerminalNode {
	return s.GetTokens(HiveParserKW_BY)
}

func (s *TableBucketsContext) KW_BY(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserKW_BY, i)
}

func (s *TableBucketsContext) AllLPAREN() []antlr.TerminalNode {
	return s.GetTokens(HiveParserLPAREN)
}

func (s *TableBucketsContext) LPAREN(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserLPAREN, i)
}

func (s *TableBucketsContext) AllRPAREN() []antlr.TerminalNode {
	return s.GetTokens(HiveParserRPAREN)
}

func (s *TableBucketsContext) RPAREN(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserRPAREN, i)
}

func (s *TableBucketsContext) KW_INTO() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_INTO, 0)
}

func (s *TableBucketsContext) KW_BUCKETS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_BUCKETS, 0)
}

func (s *TableBucketsContext) ColumnNameList() IColumnNameListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNameListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNameListContext)
}

func (s *TableBucketsContext) Number() antlr.TerminalNode {
	return s.GetToken(HiveParserNumber, 0)
}

func (s *TableBucketsContext) KW_SORTED() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SORTED, 0)
}

func (s *TableBucketsContext) ColumnNameOrderList() IColumnNameOrderListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNameOrderListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNameOrderListContext)
}

func (s *TableBucketsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableBucketsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TableBucketsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterTableBuckets(s)
	}
}

func (s *TableBucketsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitTableBuckets(s)
	}
}

func (s *TableBucketsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitTableBuckets(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) TableBuckets() (localctx ITableBucketsContext) {
	localctx = NewTableBucketsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, HiveParserRULE_tableBuckets)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2123)
		p.Match(HiveParserKW_CLUSTERED)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2124)
		p.Match(HiveParserKW_BY)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2125)
		p.Match(HiveParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2126)

		var _x = p.ColumnNameList()


		localctx.(*TableBucketsContext).bucketCols = _x
	}
	{
		p.SetState(2127)
		p.Match(HiveParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(2134)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_SORTED {
		{
			p.SetState(2128)
			p.Match(HiveParserKW_SORTED)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2129)
			p.Match(HiveParserKW_BY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2130)
			p.Match(HiveParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2131)

			var _x = p.ColumnNameOrderList()


			localctx.(*TableBucketsContext).sortCols = _x
		}
		{
			p.SetState(2132)
			p.Match(HiveParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(2136)
		p.Match(HiveParserKW_INTO)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2137)

		var _m = p.Match(HiveParserNumber)

		localctx.(*TableBucketsContext).num = _m
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2138)
		p.Match(HiveParserKW_BUCKETS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITableImplBucketsContext is an interface to support dynamic dispatch.
type ITableImplBucketsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetNum returns the num token.
	GetNum() antlr.Token 


	// SetNum sets the num token.
	SetNum(antlr.Token) 


	// Getter signatures
	KW_CLUSTERED() antlr.TerminalNode
	KW_INTO() antlr.TerminalNode
	KW_BUCKETS() antlr.TerminalNode
	Number() antlr.TerminalNode

	// IsTableImplBucketsContext differentiates from other interfaces.
	IsTableImplBucketsContext()
}

type TableImplBucketsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	num antlr.Token
}

func NewEmptyTableImplBucketsContext() *TableImplBucketsContext {
	var p = new(TableImplBucketsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_tableImplBuckets
	return p
}

func InitEmptyTableImplBucketsContext(p *TableImplBucketsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_tableImplBuckets
}

func (*TableImplBucketsContext) IsTableImplBucketsContext() {}

func NewTableImplBucketsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableImplBucketsContext {
	var p = new(TableImplBucketsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_tableImplBuckets

	return p
}

func (s *TableImplBucketsContext) GetParser() antlr.Parser { return s.parser }

func (s *TableImplBucketsContext) GetNum() antlr.Token { return s.num }


func (s *TableImplBucketsContext) SetNum(v antlr.Token) { s.num = v }


func (s *TableImplBucketsContext) KW_CLUSTERED() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_CLUSTERED, 0)
}

func (s *TableImplBucketsContext) KW_INTO() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_INTO, 0)
}

func (s *TableImplBucketsContext) KW_BUCKETS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_BUCKETS, 0)
}

func (s *TableImplBucketsContext) Number() antlr.TerminalNode {
	return s.GetToken(HiveParserNumber, 0)
}

func (s *TableImplBucketsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableImplBucketsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TableImplBucketsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterTableImplBuckets(s)
	}
}

func (s *TableImplBucketsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitTableImplBuckets(s)
	}
}

func (s *TableImplBucketsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitTableImplBuckets(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) TableImplBuckets() (localctx ITableImplBucketsContext) {
	localctx = NewTableImplBucketsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, HiveParserRULE_tableImplBuckets)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2140)
		p.Match(HiveParserKW_CLUSTERED)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2141)
		p.Match(HiveParserKW_INTO)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2142)

		var _m = p.Match(HiveParserNumber)

		localctx.(*TableImplBucketsContext).num = _m
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2143)
		p.Match(HiveParserKW_BUCKETS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITableSkewedContext is an interface to support dynamic dispatch.
type ITableSkewedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSkewedCols returns the skewedCols rule contexts.
	GetSkewedCols() IColumnNameListContext

	// GetSkewedValues returns the skewedValues rule contexts.
	GetSkewedValues() ISkewedValueElementContext


	// SetSkewedCols sets the skewedCols rule contexts.
	SetSkewedCols(IColumnNameListContext)

	// SetSkewedValues sets the skewedValues rule contexts.
	SetSkewedValues(ISkewedValueElementContext)


	// Getter signatures
	KW_SKEWED() antlr.TerminalNode
	KW_BY() antlr.TerminalNode
	AllLPAREN() []antlr.TerminalNode
	LPAREN(i int) antlr.TerminalNode
	AllRPAREN() []antlr.TerminalNode
	RPAREN(i int) antlr.TerminalNode
	KW_ON() antlr.TerminalNode
	ColumnNameList() IColumnNameListContext
	SkewedValueElement() ISkewedValueElementContext
	StoredAsDirs() IStoredAsDirsContext

	// IsTableSkewedContext differentiates from other interfaces.
	IsTableSkewedContext()
}

type TableSkewedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	skewedCols IColumnNameListContext 
	skewedValues ISkewedValueElementContext 
}

func NewEmptyTableSkewedContext() *TableSkewedContext {
	var p = new(TableSkewedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_tableSkewed
	return p
}

func InitEmptyTableSkewedContext(p *TableSkewedContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_tableSkewed
}

func (*TableSkewedContext) IsTableSkewedContext() {}

func NewTableSkewedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableSkewedContext {
	var p = new(TableSkewedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_tableSkewed

	return p
}

func (s *TableSkewedContext) GetParser() antlr.Parser { return s.parser }

func (s *TableSkewedContext) GetSkewedCols() IColumnNameListContext { return s.skewedCols }

func (s *TableSkewedContext) GetSkewedValues() ISkewedValueElementContext { return s.skewedValues }


func (s *TableSkewedContext) SetSkewedCols(v IColumnNameListContext) { s.skewedCols = v }

func (s *TableSkewedContext) SetSkewedValues(v ISkewedValueElementContext) { s.skewedValues = v }


func (s *TableSkewedContext) KW_SKEWED() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SKEWED, 0)
}

func (s *TableSkewedContext) KW_BY() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_BY, 0)
}

func (s *TableSkewedContext) AllLPAREN() []antlr.TerminalNode {
	return s.GetTokens(HiveParserLPAREN)
}

func (s *TableSkewedContext) LPAREN(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserLPAREN, i)
}

func (s *TableSkewedContext) AllRPAREN() []antlr.TerminalNode {
	return s.GetTokens(HiveParserRPAREN)
}

func (s *TableSkewedContext) RPAREN(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserRPAREN, i)
}

func (s *TableSkewedContext) KW_ON() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ON, 0)
}

func (s *TableSkewedContext) ColumnNameList() IColumnNameListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNameListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNameListContext)
}

func (s *TableSkewedContext) SkewedValueElement() ISkewedValueElementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISkewedValueElementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISkewedValueElementContext)
}

func (s *TableSkewedContext) StoredAsDirs() IStoredAsDirsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStoredAsDirsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStoredAsDirsContext)
}

func (s *TableSkewedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableSkewedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TableSkewedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterTableSkewed(s)
	}
}

func (s *TableSkewedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitTableSkewed(s)
	}
}

func (s *TableSkewedContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitTableSkewed(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) TableSkewed() (localctx ITableSkewedContext) {
	localctx = NewTableSkewedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, HiveParserRULE_tableSkewed)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2145)
		p.Match(HiveParserKW_SKEWED)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2146)
		p.Match(HiveParserKW_BY)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2147)
		p.Match(HiveParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2148)

		var _x = p.ColumnNameList()


		localctx.(*TableSkewedContext).skewedCols = _x
	}
	{
		p.SetState(2149)
		p.Match(HiveParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2150)
		p.Match(HiveParserKW_ON)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2151)
		p.Match(HiveParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2152)

		var _x = p.SkewedValueElement()


		localctx.(*TableSkewedContext).skewedValues = _x
	}
	{
		p.SetState(2153)
		p.Match(HiveParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(2155)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 170, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2154)
			p.StoredAsDirs()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRowFormatContext is an interface to support dynamic dispatch.
type IRowFormatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RowFormatSerde() IRowFormatSerdeContext
	RowFormatDelimited() IRowFormatDelimitedContext

	// IsRowFormatContext differentiates from other interfaces.
	IsRowFormatContext()
}

type RowFormatContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRowFormatContext() *RowFormatContext {
	var p = new(RowFormatContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_rowFormat
	return p
}

func InitEmptyRowFormatContext(p *RowFormatContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_rowFormat
}

func (*RowFormatContext) IsRowFormatContext() {}

func NewRowFormatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RowFormatContext {
	var p = new(RowFormatContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_rowFormat

	return p
}

func (s *RowFormatContext) GetParser() antlr.Parser { return s.parser }

func (s *RowFormatContext) RowFormatSerde() IRowFormatSerdeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRowFormatSerdeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRowFormatSerdeContext)
}

func (s *RowFormatContext) RowFormatDelimited() IRowFormatDelimitedContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRowFormatDelimitedContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRowFormatDelimitedContext)
}

func (s *RowFormatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RowFormatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *RowFormatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterRowFormat(s)
	}
}

func (s *RowFormatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitRowFormat(s)
	}
}

func (s *RowFormatContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitRowFormat(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) RowFormat() (localctx IRowFormatContext) {
	localctx = NewRowFormatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, HiveParserRULE_rowFormat)
	p.SetState(2159)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 171, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2157)
			p.RowFormatSerde()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2158)
			p.RowFormatDelimited()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRecordReaderContext is an interface to support dynamic dispatch.
type IRecordReaderContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_RECORDREADER() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode

	// IsRecordReaderContext differentiates from other interfaces.
	IsRecordReaderContext()
}

type RecordReaderContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordReaderContext() *RecordReaderContext {
	var p = new(RecordReaderContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_recordReader
	return p
}

func InitEmptyRecordReaderContext(p *RecordReaderContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_recordReader
}

func (*RecordReaderContext) IsRecordReaderContext() {}

func NewRecordReaderContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordReaderContext {
	var p = new(RecordReaderContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_recordReader

	return p
}

func (s *RecordReaderContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordReaderContext) KW_RECORDREADER() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_RECORDREADER, 0)
}

func (s *RecordReaderContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(HiveParserStringLiteral, 0)
}

func (s *RecordReaderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordReaderContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *RecordReaderContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterRecordReader(s)
	}
}

func (s *RecordReaderContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitRecordReader(s)
	}
}

func (s *RecordReaderContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitRecordReader(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) RecordReader() (localctx IRecordReaderContext) {
	localctx = NewRecordReaderContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, HiveParserRULE_recordReader)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2161)
		p.Match(HiveParserKW_RECORDREADER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2162)
		p.Match(HiveParserStringLiteral)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRecordWriterContext is an interface to support dynamic dispatch.
type IRecordWriterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_RECORDWRITER() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode

	// IsRecordWriterContext differentiates from other interfaces.
	IsRecordWriterContext()
}

type RecordWriterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordWriterContext() *RecordWriterContext {
	var p = new(RecordWriterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_recordWriter
	return p
}

func InitEmptyRecordWriterContext(p *RecordWriterContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_recordWriter
}

func (*RecordWriterContext) IsRecordWriterContext() {}

func NewRecordWriterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordWriterContext {
	var p = new(RecordWriterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_recordWriter

	return p
}

func (s *RecordWriterContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordWriterContext) KW_RECORDWRITER() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_RECORDWRITER, 0)
}

func (s *RecordWriterContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(HiveParserStringLiteral, 0)
}

func (s *RecordWriterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordWriterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *RecordWriterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterRecordWriter(s)
	}
}

func (s *RecordWriterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitRecordWriter(s)
	}
}

func (s *RecordWriterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitRecordWriter(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) RecordWriter() (localctx IRecordWriterContext) {
	localctx = NewRecordWriterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, HiveParserRULE_recordWriter)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2164)
		p.Match(HiveParserKW_RECORDWRITER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2165)
		p.Match(HiveParserStringLiteral)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRowFormatSerdeContext is an interface to support dynamic dispatch.
type IRowFormatSerdeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name token.
	GetName() antlr.Token 


	// SetName sets the name token.
	SetName(antlr.Token) 


	// GetSerdeprops returns the serdeprops rule contexts.
	GetSerdeprops() ITablePropertiesContext


	// SetSerdeprops sets the serdeprops rule contexts.
	SetSerdeprops(ITablePropertiesContext)


	// Getter signatures
	KW_ROW() antlr.TerminalNode
	KW_FORMAT() antlr.TerminalNode
	KW_SERDE() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode
	KW_WITH() antlr.TerminalNode
	KW_SERDEPROPERTIES() antlr.TerminalNode
	TableProperties() ITablePropertiesContext

	// IsRowFormatSerdeContext differentiates from other interfaces.
	IsRowFormatSerdeContext()
}

type RowFormatSerdeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name antlr.Token
	serdeprops ITablePropertiesContext 
}

func NewEmptyRowFormatSerdeContext() *RowFormatSerdeContext {
	var p = new(RowFormatSerdeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_rowFormatSerde
	return p
}

func InitEmptyRowFormatSerdeContext(p *RowFormatSerdeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_rowFormatSerde
}

func (*RowFormatSerdeContext) IsRowFormatSerdeContext() {}

func NewRowFormatSerdeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RowFormatSerdeContext {
	var p = new(RowFormatSerdeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_rowFormatSerde

	return p
}

func (s *RowFormatSerdeContext) GetParser() antlr.Parser { return s.parser }

func (s *RowFormatSerdeContext) GetName() antlr.Token { return s.name }


func (s *RowFormatSerdeContext) SetName(v antlr.Token) { s.name = v }


func (s *RowFormatSerdeContext) GetSerdeprops() ITablePropertiesContext { return s.serdeprops }


func (s *RowFormatSerdeContext) SetSerdeprops(v ITablePropertiesContext) { s.serdeprops = v }


func (s *RowFormatSerdeContext) KW_ROW() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ROW, 0)
}

func (s *RowFormatSerdeContext) KW_FORMAT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_FORMAT, 0)
}

func (s *RowFormatSerdeContext) KW_SERDE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SERDE, 0)
}

func (s *RowFormatSerdeContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(HiveParserStringLiteral, 0)
}

func (s *RowFormatSerdeContext) KW_WITH() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_WITH, 0)
}

func (s *RowFormatSerdeContext) KW_SERDEPROPERTIES() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SERDEPROPERTIES, 0)
}

func (s *RowFormatSerdeContext) TableProperties() ITablePropertiesContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablePropertiesContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablePropertiesContext)
}

func (s *RowFormatSerdeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RowFormatSerdeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *RowFormatSerdeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterRowFormatSerde(s)
	}
}

func (s *RowFormatSerdeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitRowFormatSerde(s)
	}
}

func (s *RowFormatSerdeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitRowFormatSerde(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) RowFormatSerde() (localctx IRowFormatSerdeContext) {
	localctx = NewRowFormatSerdeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, HiveParserRULE_rowFormatSerde)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2167)
		p.Match(HiveParserKW_ROW)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2168)
		p.Match(HiveParserKW_FORMAT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2169)
		p.Match(HiveParserKW_SERDE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2170)

		var _m = p.Match(HiveParserStringLiteral)

		localctx.(*RowFormatSerdeContext).name = _m
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(2174)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_WITH {
		{
			p.SetState(2171)
			p.Match(HiveParserKW_WITH)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2172)
			p.Match(HiveParserKW_SERDEPROPERTIES)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2173)

			var _x = p.TableProperties()


			localctx.(*RowFormatSerdeContext).serdeprops = _x
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRowFormatDelimitedContext is an interface to support dynamic dispatch.
type IRowFormatDelimitedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_ROW() antlr.TerminalNode
	KW_FORMAT() antlr.TerminalNode
	KW_DELIMITED() antlr.TerminalNode
	TableRowFormatFieldIdentifier() ITableRowFormatFieldIdentifierContext
	TableRowFormatCollItemsIdentifier() ITableRowFormatCollItemsIdentifierContext
	TableRowFormatMapKeysIdentifier() ITableRowFormatMapKeysIdentifierContext
	TableRowFormatLinesIdentifier() ITableRowFormatLinesIdentifierContext
	TableRowNullFormat() ITableRowNullFormatContext

	// IsRowFormatDelimitedContext differentiates from other interfaces.
	IsRowFormatDelimitedContext()
}

type RowFormatDelimitedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRowFormatDelimitedContext() *RowFormatDelimitedContext {
	var p = new(RowFormatDelimitedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_rowFormatDelimited
	return p
}

func InitEmptyRowFormatDelimitedContext(p *RowFormatDelimitedContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_rowFormatDelimited
}

func (*RowFormatDelimitedContext) IsRowFormatDelimitedContext() {}

func NewRowFormatDelimitedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RowFormatDelimitedContext {
	var p = new(RowFormatDelimitedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_rowFormatDelimited

	return p
}

func (s *RowFormatDelimitedContext) GetParser() antlr.Parser { return s.parser }

func (s *RowFormatDelimitedContext) KW_ROW() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ROW, 0)
}

func (s *RowFormatDelimitedContext) KW_FORMAT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_FORMAT, 0)
}

func (s *RowFormatDelimitedContext) KW_DELIMITED() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DELIMITED, 0)
}

func (s *RowFormatDelimitedContext) TableRowFormatFieldIdentifier() ITableRowFormatFieldIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableRowFormatFieldIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableRowFormatFieldIdentifierContext)
}

func (s *RowFormatDelimitedContext) TableRowFormatCollItemsIdentifier() ITableRowFormatCollItemsIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableRowFormatCollItemsIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableRowFormatCollItemsIdentifierContext)
}

func (s *RowFormatDelimitedContext) TableRowFormatMapKeysIdentifier() ITableRowFormatMapKeysIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableRowFormatMapKeysIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableRowFormatMapKeysIdentifierContext)
}

func (s *RowFormatDelimitedContext) TableRowFormatLinesIdentifier() ITableRowFormatLinesIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableRowFormatLinesIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableRowFormatLinesIdentifierContext)
}

func (s *RowFormatDelimitedContext) TableRowNullFormat() ITableRowNullFormatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableRowNullFormatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableRowNullFormatContext)
}

func (s *RowFormatDelimitedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RowFormatDelimitedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *RowFormatDelimitedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterRowFormatDelimited(s)
	}
}

func (s *RowFormatDelimitedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitRowFormatDelimited(s)
	}
}

func (s *RowFormatDelimitedContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitRowFormatDelimited(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) RowFormatDelimited() (localctx IRowFormatDelimitedContext) {
	localctx = NewRowFormatDelimitedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, HiveParserRULE_rowFormatDelimited)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2176)
		p.Match(HiveParserKW_ROW)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2177)
		p.Match(HiveParserKW_FORMAT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2178)
		p.Match(HiveParserKW_DELIMITED)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(2180)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_FIELDS {
		{
			p.SetState(2179)
			p.TableRowFormatFieldIdentifier()
		}

	}
	p.SetState(2183)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_COLLECTION {
		{
			p.SetState(2182)
			p.TableRowFormatCollItemsIdentifier()
		}

	}
	p.SetState(2186)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 175, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2185)
			p.TableRowFormatMapKeysIdentifier()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	p.SetState(2189)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_LINES {
		{
			p.SetState(2188)
			p.TableRowFormatLinesIdentifier()
		}

	}
	p.SetState(2192)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_NULL {
		{
			p.SetState(2191)
			p.TableRowNullFormat()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITableRowFormatContext is an interface to support dynamic dispatch.
type ITableRowFormatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RowFormatDelimited() IRowFormatDelimitedContext
	RowFormatSerde() IRowFormatSerdeContext

	// IsTableRowFormatContext differentiates from other interfaces.
	IsTableRowFormatContext()
}

type TableRowFormatContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableRowFormatContext() *TableRowFormatContext {
	var p = new(TableRowFormatContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_tableRowFormat
	return p
}

func InitEmptyTableRowFormatContext(p *TableRowFormatContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_tableRowFormat
}

func (*TableRowFormatContext) IsTableRowFormatContext() {}

func NewTableRowFormatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableRowFormatContext {
	var p = new(TableRowFormatContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_tableRowFormat

	return p
}

func (s *TableRowFormatContext) GetParser() antlr.Parser { return s.parser }

func (s *TableRowFormatContext) RowFormatDelimited() IRowFormatDelimitedContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRowFormatDelimitedContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRowFormatDelimitedContext)
}

func (s *TableRowFormatContext) RowFormatSerde() IRowFormatSerdeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRowFormatSerdeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRowFormatSerdeContext)
}

func (s *TableRowFormatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableRowFormatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TableRowFormatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterTableRowFormat(s)
	}
}

func (s *TableRowFormatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitTableRowFormat(s)
	}
}

func (s *TableRowFormatContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitTableRowFormat(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) TableRowFormat() (localctx ITableRowFormatContext) {
	localctx = NewTableRowFormatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, HiveParserRULE_tableRowFormat)
	p.SetState(2196)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 178, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2194)
			p.RowFormatDelimited()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2195)
			p.RowFormatSerde()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITablePropertiesPrefixedContext is an interface to support dynamic dispatch.
type ITablePropertiesPrefixedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_TBLPROPERTIES() antlr.TerminalNode
	TableProperties() ITablePropertiesContext

	// IsTablePropertiesPrefixedContext differentiates from other interfaces.
	IsTablePropertiesPrefixedContext()
}

type TablePropertiesPrefixedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTablePropertiesPrefixedContext() *TablePropertiesPrefixedContext {
	var p = new(TablePropertiesPrefixedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_tablePropertiesPrefixed
	return p
}

func InitEmptyTablePropertiesPrefixedContext(p *TablePropertiesPrefixedContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_tablePropertiesPrefixed
}

func (*TablePropertiesPrefixedContext) IsTablePropertiesPrefixedContext() {}

func NewTablePropertiesPrefixedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TablePropertiesPrefixedContext {
	var p = new(TablePropertiesPrefixedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_tablePropertiesPrefixed

	return p
}

func (s *TablePropertiesPrefixedContext) GetParser() antlr.Parser { return s.parser }

func (s *TablePropertiesPrefixedContext) KW_TBLPROPERTIES() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TBLPROPERTIES, 0)
}

func (s *TablePropertiesPrefixedContext) TableProperties() ITablePropertiesContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablePropertiesContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablePropertiesContext)
}

func (s *TablePropertiesPrefixedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TablePropertiesPrefixedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TablePropertiesPrefixedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterTablePropertiesPrefixed(s)
	}
}

func (s *TablePropertiesPrefixedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitTablePropertiesPrefixed(s)
	}
}

func (s *TablePropertiesPrefixedContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitTablePropertiesPrefixed(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) TablePropertiesPrefixed() (localctx ITablePropertiesPrefixedContext) {
	localctx = NewTablePropertiesPrefixedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, HiveParserRULE_tablePropertiesPrefixed)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2198)
		p.Match(HiveParserKW_TBLPROPERTIES)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2199)
		p.TableProperties()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITablePropertiesContext is an interface to support dynamic dispatch.
type ITablePropertiesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	TablePropertiesList() ITablePropertiesListContext
	RPAREN() antlr.TerminalNode

	// IsTablePropertiesContext differentiates from other interfaces.
	IsTablePropertiesContext()
}

type TablePropertiesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTablePropertiesContext() *TablePropertiesContext {
	var p = new(TablePropertiesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_tableProperties
	return p
}

func InitEmptyTablePropertiesContext(p *TablePropertiesContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_tableProperties
}

func (*TablePropertiesContext) IsTablePropertiesContext() {}

func NewTablePropertiesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TablePropertiesContext {
	var p = new(TablePropertiesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_tableProperties

	return p
}

func (s *TablePropertiesContext) GetParser() antlr.Parser { return s.parser }

func (s *TablePropertiesContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserLPAREN, 0)
}

func (s *TablePropertiesContext) TablePropertiesList() ITablePropertiesListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablePropertiesListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablePropertiesListContext)
}

func (s *TablePropertiesContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserRPAREN, 0)
}

func (s *TablePropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TablePropertiesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TablePropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterTableProperties(s)
	}
}

func (s *TablePropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitTableProperties(s)
	}
}

func (s *TablePropertiesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitTableProperties(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) TableProperties() (localctx ITablePropertiesContext) {
	localctx = NewTablePropertiesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, HiveParserRULE_tableProperties)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2201)
		p.Match(HiveParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2202)
		p.TablePropertiesList()
	}
	{
		p.SetState(2203)
		p.Match(HiveParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITablePropertiesListContext is an interface to support dynamic dispatch.
type ITablePropertiesListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllKeyValueProperty() []IKeyValuePropertyContext
	KeyValueProperty(i int) IKeyValuePropertyContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	AllKeyProperty() []IKeyPropertyContext
	KeyProperty(i int) IKeyPropertyContext

	// IsTablePropertiesListContext differentiates from other interfaces.
	IsTablePropertiesListContext()
}

type TablePropertiesListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTablePropertiesListContext() *TablePropertiesListContext {
	var p = new(TablePropertiesListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_tablePropertiesList
	return p
}

func InitEmptyTablePropertiesListContext(p *TablePropertiesListContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_tablePropertiesList
}

func (*TablePropertiesListContext) IsTablePropertiesListContext() {}

func NewTablePropertiesListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TablePropertiesListContext {
	var p = new(TablePropertiesListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_tablePropertiesList

	return p
}

func (s *TablePropertiesListContext) GetParser() antlr.Parser { return s.parser }

func (s *TablePropertiesListContext) AllKeyValueProperty() []IKeyValuePropertyContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IKeyValuePropertyContext); ok {
			len++
		}
	}

	tst := make([]IKeyValuePropertyContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IKeyValuePropertyContext); ok {
			tst[i] = t.(IKeyValuePropertyContext)
			i++
		}
	}

	return tst
}

func (s *TablePropertiesListContext) KeyValueProperty(i int) IKeyValuePropertyContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyValuePropertyContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyValuePropertyContext)
}

func (s *TablePropertiesListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(HiveParserCOMMA)
}

func (s *TablePropertiesListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserCOMMA, i)
}

func (s *TablePropertiesListContext) AllKeyProperty() []IKeyPropertyContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IKeyPropertyContext); ok {
			len++
		}
	}

	tst := make([]IKeyPropertyContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IKeyPropertyContext); ok {
			tst[i] = t.(IKeyPropertyContext)
			i++
		}
	}

	return tst
}

func (s *TablePropertiesListContext) KeyProperty(i int) IKeyPropertyContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyPropertyContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyPropertyContext)
}

func (s *TablePropertiesListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TablePropertiesListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TablePropertiesListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterTablePropertiesList(s)
	}
}

func (s *TablePropertiesListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitTablePropertiesList(s)
	}
}

func (s *TablePropertiesListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitTablePropertiesList(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) TablePropertiesList() (localctx ITablePropertiesListContext) {
	localctx = NewTablePropertiesListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, HiveParserRULE_tablePropertiesList)
	var _la int

	p.SetState(2221)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 181, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2205)
			p.KeyValueProperty()
		}
		p.SetState(2210)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == HiveParserCOMMA {
			{
				p.SetState(2206)
				p.Match(HiveParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2207)
				p.KeyValueProperty()
			}


			p.SetState(2212)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2213)
			p.KeyProperty()
		}
		p.SetState(2218)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == HiveParserCOMMA {
			{
				p.SetState(2214)
				p.Match(HiveParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2215)
				p.KeyProperty()
			}


			p.SetState(2220)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IKeyValuePropertyContext is an interface to support dynamic dispatch.
type IKeyValuePropertyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetKey returns the key token.
	GetKey() antlr.Token 

	// GetValue returns the value token.
	GetValue() antlr.Token 


	// SetKey sets the key token.
	SetKey(antlr.Token) 

	// SetValue sets the value token.
	SetValue(antlr.Token) 


	// Getter signatures
	EQUAL() antlr.TerminalNode
	AllStringLiteral() []antlr.TerminalNode
	StringLiteral(i int) antlr.TerminalNode

	// IsKeyValuePropertyContext differentiates from other interfaces.
	IsKeyValuePropertyContext()
}

type KeyValuePropertyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	key antlr.Token
	value antlr.Token
}

func NewEmptyKeyValuePropertyContext() *KeyValuePropertyContext {
	var p = new(KeyValuePropertyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_keyValueProperty
	return p
}

func InitEmptyKeyValuePropertyContext(p *KeyValuePropertyContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_keyValueProperty
}

func (*KeyValuePropertyContext) IsKeyValuePropertyContext() {}

func NewKeyValuePropertyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeyValuePropertyContext {
	var p = new(KeyValuePropertyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_keyValueProperty

	return p
}

func (s *KeyValuePropertyContext) GetParser() antlr.Parser { return s.parser }

func (s *KeyValuePropertyContext) GetKey() antlr.Token { return s.key }

func (s *KeyValuePropertyContext) GetValue() antlr.Token { return s.value }


func (s *KeyValuePropertyContext) SetKey(v antlr.Token) { s.key = v }

func (s *KeyValuePropertyContext) SetValue(v antlr.Token) { s.value = v }


func (s *KeyValuePropertyContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(HiveParserEQUAL, 0)
}

func (s *KeyValuePropertyContext) AllStringLiteral() []antlr.TerminalNode {
	return s.GetTokens(HiveParserStringLiteral)
}

func (s *KeyValuePropertyContext) StringLiteral(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserStringLiteral, i)
}

func (s *KeyValuePropertyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeyValuePropertyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *KeyValuePropertyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterKeyValueProperty(s)
	}
}

func (s *KeyValuePropertyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitKeyValueProperty(s)
	}
}

func (s *KeyValuePropertyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitKeyValueProperty(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) KeyValueProperty() (localctx IKeyValuePropertyContext) {
	localctx = NewKeyValuePropertyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, HiveParserRULE_keyValueProperty)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2223)

		var _m = p.Match(HiveParserStringLiteral)

		localctx.(*KeyValuePropertyContext).key = _m
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2224)
		p.Match(HiveParserEQUAL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2225)

		var _m = p.Match(HiveParserStringLiteral)

		localctx.(*KeyValuePropertyContext).value = _m
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IKeyPropertyContext is an interface to support dynamic dispatch.
type IKeyPropertyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetKey returns the key token.
	GetKey() antlr.Token 


	// SetKey sets the key token.
	SetKey(antlr.Token) 


	// Getter signatures
	StringLiteral() antlr.TerminalNode

	// IsKeyPropertyContext differentiates from other interfaces.
	IsKeyPropertyContext()
}

type KeyPropertyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	key antlr.Token
}

func NewEmptyKeyPropertyContext() *KeyPropertyContext {
	var p = new(KeyPropertyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_keyProperty
	return p
}

func InitEmptyKeyPropertyContext(p *KeyPropertyContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_keyProperty
}

func (*KeyPropertyContext) IsKeyPropertyContext() {}

func NewKeyPropertyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeyPropertyContext {
	var p = new(KeyPropertyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_keyProperty

	return p
}

func (s *KeyPropertyContext) GetParser() antlr.Parser { return s.parser }

func (s *KeyPropertyContext) GetKey() antlr.Token { return s.key }


func (s *KeyPropertyContext) SetKey(v antlr.Token) { s.key = v }


func (s *KeyPropertyContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(HiveParserStringLiteral, 0)
}

func (s *KeyPropertyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeyPropertyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *KeyPropertyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterKeyProperty(s)
	}
}

func (s *KeyPropertyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitKeyProperty(s)
	}
}

func (s *KeyPropertyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitKeyProperty(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) KeyProperty() (localctx IKeyPropertyContext) {
	localctx = NewKeyPropertyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, HiveParserRULE_keyProperty)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2227)

		var _m = p.Match(HiveParserStringLiteral)

		localctx.(*KeyPropertyContext).key = _m
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITableRowFormatFieldIdentifierContext is an interface to support dynamic dispatch.
type ITableRowFormatFieldIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFldIdnt returns the fldIdnt token.
	GetFldIdnt() antlr.Token 

	// GetFldEscape returns the fldEscape token.
	GetFldEscape() antlr.Token 


	// SetFldIdnt sets the fldIdnt token.
	SetFldIdnt(antlr.Token) 

	// SetFldEscape sets the fldEscape token.
	SetFldEscape(antlr.Token) 


	// Getter signatures
	KW_FIELDS() antlr.TerminalNode
	KW_TERMINATED() antlr.TerminalNode
	AllKW_BY() []antlr.TerminalNode
	KW_BY(i int) antlr.TerminalNode
	AllStringLiteral() []antlr.TerminalNode
	StringLiteral(i int) antlr.TerminalNode
	KW_ESCAPED() antlr.TerminalNode

	// IsTableRowFormatFieldIdentifierContext differentiates from other interfaces.
	IsTableRowFormatFieldIdentifierContext()
}

type TableRowFormatFieldIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	fldIdnt antlr.Token
	fldEscape antlr.Token
}

func NewEmptyTableRowFormatFieldIdentifierContext() *TableRowFormatFieldIdentifierContext {
	var p = new(TableRowFormatFieldIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_tableRowFormatFieldIdentifier
	return p
}

func InitEmptyTableRowFormatFieldIdentifierContext(p *TableRowFormatFieldIdentifierContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_tableRowFormatFieldIdentifier
}

func (*TableRowFormatFieldIdentifierContext) IsTableRowFormatFieldIdentifierContext() {}

func NewTableRowFormatFieldIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableRowFormatFieldIdentifierContext {
	var p = new(TableRowFormatFieldIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_tableRowFormatFieldIdentifier

	return p
}

func (s *TableRowFormatFieldIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *TableRowFormatFieldIdentifierContext) GetFldIdnt() antlr.Token { return s.fldIdnt }

func (s *TableRowFormatFieldIdentifierContext) GetFldEscape() antlr.Token { return s.fldEscape }


func (s *TableRowFormatFieldIdentifierContext) SetFldIdnt(v antlr.Token) { s.fldIdnt = v }

func (s *TableRowFormatFieldIdentifierContext) SetFldEscape(v antlr.Token) { s.fldEscape = v }


func (s *TableRowFormatFieldIdentifierContext) KW_FIELDS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_FIELDS, 0)
}

func (s *TableRowFormatFieldIdentifierContext) KW_TERMINATED() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TERMINATED, 0)
}

func (s *TableRowFormatFieldIdentifierContext) AllKW_BY() []antlr.TerminalNode {
	return s.GetTokens(HiveParserKW_BY)
}

func (s *TableRowFormatFieldIdentifierContext) KW_BY(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserKW_BY, i)
}

func (s *TableRowFormatFieldIdentifierContext) AllStringLiteral() []antlr.TerminalNode {
	return s.GetTokens(HiveParserStringLiteral)
}

func (s *TableRowFormatFieldIdentifierContext) StringLiteral(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserStringLiteral, i)
}

func (s *TableRowFormatFieldIdentifierContext) KW_ESCAPED() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ESCAPED, 0)
}

func (s *TableRowFormatFieldIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableRowFormatFieldIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TableRowFormatFieldIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterTableRowFormatFieldIdentifier(s)
	}
}

func (s *TableRowFormatFieldIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitTableRowFormatFieldIdentifier(s)
	}
}

func (s *TableRowFormatFieldIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitTableRowFormatFieldIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) TableRowFormatFieldIdentifier() (localctx ITableRowFormatFieldIdentifierContext) {
	localctx = NewTableRowFormatFieldIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, HiveParserRULE_tableRowFormatFieldIdentifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2229)
		p.Match(HiveParserKW_FIELDS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2230)
		p.Match(HiveParserKW_TERMINATED)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2231)
		p.Match(HiveParserKW_BY)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2232)

		var _m = p.Match(HiveParserStringLiteral)

		localctx.(*TableRowFormatFieldIdentifierContext).fldIdnt = _m
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(2236)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_ESCAPED {
		{
			p.SetState(2233)
			p.Match(HiveParserKW_ESCAPED)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2234)
			p.Match(HiveParserKW_BY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2235)

			var _m = p.Match(HiveParserStringLiteral)

			localctx.(*TableRowFormatFieldIdentifierContext).fldEscape = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITableRowFormatCollItemsIdentifierContext is an interface to support dynamic dispatch.
type ITableRowFormatCollItemsIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCollIdnt returns the collIdnt token.
	GetCollIdnt() antlr.Token 


	// SetCollIdnt sets the collIdnt token.
	SetCollIdnt(antlr.Token) 


	// Getter signatures
	KW_COLLECTION() antlr.TerminalNode
	KW_ITEMS() antlr.TerminalNode
	KW_TERMINATED() antlr.TerminalNode
	KW_BY() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode

	// IsTableRowFormatCollItemsIdentifierContext differentiates from other interfaces.
	IsTableRowFormatCollItemsIdentifierContext()
}

type TableRowFormatCollItemsIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	collIdnt antlr.Token
}

func NewEmptyTableRowFormatCollItemsIdentifierContext() *TableRowFormatCollItemsIdentifierContext {
	var p = new(TableRowFormatCollItemsIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_tableRowFormatCollItemsIdentifier
	return p
}

func InitEmptyTableRowFormatCollItemsIdentifierContext(p *TableRowFormatCollItemsIdentifierContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_tableRowFormatCollItemsIdentifier
}

func (*TableRowFormatCollItemsIdentifierContext) IsTableRowFormatCollItemsIdentifierContext() {}

func NewTableRowFormatCollItemsIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableRowFormatCollItemsIdentifierContext {
	var p = new(TableRowFormatCollItemsIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_tableRowFormatCollItemsIdentifier

	return p
}

func (s *TableRowFormatCollItemsIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *TableRowFormatCollItemsIdentifierContext) GetCollIdnt() antlr.Token { return s.collIdnt }


func (s *TableRowFormatCollItemsIdentifierContext) SetCollIdnt(v antlr.Token) { s.collIdnt = v }


func (s *TableRowFormatCollItemsIdentifierContext) KW_COLLECTION() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_COLLECTION, 0)
}

func (s *TableRowFormatCollItemsIdentifierContext) KW_ITEMS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ITEMS, 0)
}

func (s *TableRowFormatCollItemsIdentifierContext) KW_TERMINATED() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TERMINATED, 0)
}

func (s *TableRowFormatCollItemsIdentifierContext) KW_BY() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_BY, 0)
}

func (s *TableRowFormatCollItemsIdentifierContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(HiveParserStringLiteral, 0)
}

func (s *TableRowFormatCollItemsIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableRowFormatCollItemsIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TableRowFormatCollItemsIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterTableRowFormatCollItemsIdentifier(s)
	}
}

func (s *TableRowFormatCollItemsIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitTableRowFormatCollItemsIdentifier(s)
	}
}

func (s *TableRowFormatCollItemsIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitTableRowFormatCollItemsIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) TableRowFormatCollItemsIdentifier() (localctx ITableRowFormatCollItemsIdentifierContext) {
	localctx = NewTableRowFormatCollItemsIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, HiveParserRULE_tableRowFormatCollItemsIdentifier)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2238)
		p.Match(HiveParserKW_COLLECTION)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2239)
		p.Match(HiveParserKW_ITEMS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2240)
		p.Match(HiveParserKW_TERMINATED)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2241)
		p.Match(HiveParserKW_BY)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2242)

		var _m = p.Match(HiveParserStringLiteral)

		localctx.(*TableRowFormatCollItemsIdentifierContext).collIdnt = _m
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITableRowFormatMapKeysIdentifierContext is an interface to support dynamic dispatch.
type ITableRowFormatMapKeysIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetMapKeysIdnt returns the mapKeysIdnt token.
	GetMapKeysIdnt() antlr.Token 


	// SetMapKeysIdnt sets the mapKeysIdnt token.
	SetMapKeysIdnt(antlr.Token) 


	// Getter signatures
	KW_MAP() antlr.TerminalNode
	KW_KEYS() antlr.TerminalNode
	KW_TERMINATED() antlr.TerminalNode
	KW_BY() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode

	// IsTableRowFormatMapKeysIdentifierContext differentiates from other interfaces.
	IsTableRowFormatMapKeysIdentifierContext()
}

type TableRowFormatMapKeysIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	mapKeysIdnt antlr.Token
}

func NewEmptyTableRowFormatMapKeysIdentifierContext() *TableRowFormatMapKeysIdentifierContext {
	var p = new(TableRowFormatMapKeysIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_tableRowFormatMapKeysIdentifier
	return p
}

func InitEmptyTableRowFormatMapKeysIdentifierContext(p *TableRowFormatMapKeysIdentifierContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_tableRowFormatMapKeysIdentifier
}

func (*TableRowFormatMapKeysIdentifierContext) IsTableRowFormatMapKeysIdentifierContext() {}

func NewTableRowFormatMapKeysIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableRowFormatMapKeysIdentifierContext {
	var p = new(TableRowFormatMapKeysIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_tableRowFormatMapKeysIdentifier

	return p
}

func (s *TableRowFormatMapKeysIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *TableRowFormatMapKeysIdentifierContext) GetMapKeysIdnt() antlr.Token { return s.mapKeysIdnt }


func (s *TableRowFormatMapKeysIdentifierContext) SetMapKeysIdnt(v antlr.Token) { s.mapKeysIdnt = v }


func (s *TableRowFormatMapKeysIdentifierContext) KW_MAP() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_MAP, 0)
}

func (s *TableRowFormatMapKeysIdentifierContext) KW_KEYS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_KEYS, 0)
}

func (s *TableRowFormatMapKeysIdentifierContext) KW_TERMINATED() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TERMINATED, 0)
}

func (s *TableRowFormatMapKeysIdentifierContext) KW_BY() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_BY, 0)
}

func (s *TableRowFormatMapKeysIdentifierContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(HiveParserStringLiteral, 0)
}

func (s *TableRowFormatMapKeysIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableRowFormatMapKeysIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TableRowFormatMapKeysIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterTableRowFormatMapKeysIdentifier(s)
	}
}

func (s *TableRowFormatMapKeysIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitTableRowFormatMapKeysIdentifier(s)
	}
}

func (s *TableRowFormatMapKeysIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitTableRowFormatMapKeysIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) TableRowFormatMapKeysIdentifier() (localctx ITableRowFormatMapKeysIdentifierContext) {
	localctx = NewTableRowFormatMapKeysIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, HiveParserRULE_tableRowFormatMapKeysIdentifier)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2244)
		p.Match(HiveParserKW_MAP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2245)
		p.Match(HiveParserKW_KEYS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2246)
		p.Match(HiveParserKW_TERMINATED)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2247)
		p.Match(HiveParserKW_BY)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2248)

		var _m = p.Match(HiveParserStringLiteral)

		localctx.(*TableRowFormatMapKeysIdentifierContext).mapKeysIdnt = _m
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITableRowFormatLinesIdentifierContext is an interface to support dynamic dispatch.
type ITableRowFormatLinesIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLinesIdnt returns the linesIdnt token.
	GetLinesIdnt() antlr.Token 


	// SetLinesIdnt sets the linesIdnt token.
	SetLinesIdnt(antlr.Token) 


	// Getter signatures
	KW_LINES() antlr.TerminalNode
	KW_TERMINATED() antlr.TerminalNode
	KW_BY() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode

	// IsTableRowFormatLinesIdentifierContext differentiates from other interfaces.
	IsTableRowFormatLinesIdentifierContext()
}

type TableRowFormatLinesIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	linesIdnt antlr.Token
}

func NewEmptyTableRowFormatLinesIdentifierContext() *TableRowFormatLinesIdentifierContext {
	var p = new(TableRowFormatLinesIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_tableRowFormatLinesIdentifier
	return p
}

func InitEmptyTableRowFormatLinesIdentifierContext(p *TableRowFormatLinesIdentifierContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_tableRowFormatLinesIdentifier
}

func (*TableRowFormatLinesIdentifierContext) IsTableRowFormatLinesIdentifierContext() {}

func NewTableRowFormatLinesIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableRowFormatLinesIdentifierContext {
	var p = new(TableRowFormatLinesIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_tableRowFormatLinesIdentifier

	return p
}

func (s *TableRowFormatLinesIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *TableRowFormatLinesIdentifierContext) GetLinesIdnt() antlr.Token { return s.linesIdnt }


func (s *TableRowFormatLinesIdentifierContext) SetLinesIdnt(v antlr.Token) { s.linesIdnt = v }


func (s *TableRowFormatLinesIdentifierContext) KW_LINES() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_LINES, 0)
}

func (s *TableRowFormatLinesIdentifierContext) KW_TERMINATED() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TERMINATED, 0)
}

func (s *TableRowFormatLinesIdentifierContext) KW_BY() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_BY, 0)
}

func (s *TableRowFormatLinesIdentifierContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(HiveParserStringLiteral, 0)
}

func (s *TableRowFormatLinesIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableRowFormatLinesIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TableRowFormatLinesIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterTableRowFormatLinesIdentifier(s)
	}
}

func (s *TableRowFormatLinesIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitTableRowFormatLinesIdentifier(s)
	}
}

func (s *TableRowFormatLinesIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitTableRowFormatLinesIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) TableRowFormatLinesIdentifier() (localctx ITableRowFormatLinesIdentifierContext) {
	localctx = NewTableRowFormatLinesIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, HiveParserRULE_tableRowFormatLinesIdentifier)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2250)
		p.Match(HiveParserKW_LINES)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2251)
		p.Match(HiveParserKW_TERMINATED)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2252)
		p.Match(HiveParserKW_BY)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2253)

		var _m = p.Match(HiveParserStringLiteral)

		localctx.(*TableRowFormatLinesIdentifierContext).linesIdnt = _m
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITableRowNullFormatContext is an interface to support dynamic dispatch.
type ITableRowNullFormatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetNullIdnt returns the nullIdnt token.
	GetNullIdnt() antlr.Token 


	// SetNullIdnt sets the nullIdnt token.
	SetNullIdnt(antlr.Token) 


	// Getter signatures
	KW_NULL() antlr.TerminalNode
	KW_DEFINED() antlr.TerminalNode
	KW_AS() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode

	// IsTableRowNullFormatContext differentiates from other interfaces.
	IsTableRowNullFormatContext()
}

type TableRowNullFormatContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	nullIdnt antlr.Token
}

func NewEmptyTableRowNullFormatContext() *TableRowNullFormatContext {
	var p = new(TableRowNullFormatContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_tableRowNullFormat
	return p
}

func InitEmptyTableRowNullFormatContext(p *TableRowNullFormatContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_tableRowNullFormat
}

func (*TableRowNullFormatContext) IsTableRowNullFormatContext() {}

func NewTableRowNullFormatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableRowNullFormatContext {
	var p = new(TableRowNullFormatContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_tableRowNullFormat

	return p
}

func (s *TableRowNullFormatContext) GetParser() antlr.Parser { return s.parser }

func (s *TableRowNullFormatContext) GetNullIdnt() antlr.Token { return s.nullIdnt }


func (s *TableRowNullFormatContext) SetNullIdnt(v antlr.Token) { s.nullIdnt = v }


func (s *TableRowNullFormatContext) KW_NULL() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_NULL, 0)
}

func (s *TableRowNullFormatContext) KW_DEFINED() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DEFINED, 0)
}

func (s *TableRowNullFormatContext) KW_AS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_AS, 0)
}

func (s *TableRowNullFormatContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(HiveParserStringLiteral, 0)
}

func (s *TableRowNullFormatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableRowNullFormatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TableRowNullFormatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterTableRowNullFormat(s)
	}
}

func (s *TableRowNullFormatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitTableRowNullFormat(s)
	}
}

func (s *TableRowNullFormatContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitTableRowNullFormat(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) TableRowNullFormat() (localctx ITableRowNullFormatContext) {
	localctx = NewTableRowNullFormatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, HiveParserRULE_tableRowNullFormat)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2255)
		p.Match(HiveParserKW_NULL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2256)
		p.Match(HiveParserKW_DEFINED)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2257)
		p.Match(HiveParserKW_AS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2258)

		var _m = p.Match(HiveParserStringLiteral)

		localctx.(*TableRowNullFormatContext).nullIdnt = _m
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITableFileFormatContext is an interface to support dynamic dispatch.
type ITableFileFormatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetInFmt returns the inFmt token.
	GetInFmt() antlr.Token 

	// GetOutFmt returns the outFmt token.
	GetOutFmt() antlr.Token 

	// GetInDriver returns the inDriver token.
	GetInDriver() antlr.Token 

	// GetOutDriver returns the outDriver token.
	GetOutDriver() antlr.Token 

	// GetStorageHandler returns the storageHandler token.
	GetStorageHandler() antlr.Token 


	// SetInFmt sets the inFmt token.
	SetInFmt(antlr.Token) 

	// SetOutFmt sets the outFmt token.
	SetOutFmt(antlr.Token) 

	// SetInDriver sets the inDriver token.
	SetInDriver(antlr.Token) 

	// SetOutDriver sets the outDriver token.
	SetOutDriver(antlr.Token) 

	// SetStorageHandler sets the storageHandler token.
	SetStorageHandler(antlr.Token) 


	// GetSerdeprops returns the serdeprops rule contexts.
	GetSerdeprops() ITablePropertiesContext

	// GetFileformat returns the fileformat rule contexts.
	GetFileformat() IId_Context

	// GetGenericSpec returns the genericSpec rule contexts.
	GetGenericSpec() IId_Context


	// SetSerdeprops sets the serdeprops rule contexts.
	SetSerdeprops(ITablePropertiesContext)

	// SetFileformat sets the fileformat rule contexts.
	SetFileformat(IId_Context)

	// SetGenericSpec sets the genericSpec rule contexts.
	SetGenericSpec(IId_Context)


	// Getter signatures
	AllKW_STORED() []antlr.TerminalNode
	KW_STORED(i int) antlr.TerminalNode
	KW_AS() antlr.TerminalNode
	KW_INPUTFORMAT() antlr.TerminalNode
	KW_OUTPUTFORMAT() antlr.TerminalNode
	AllStringLiteral() []antlr.TerminalNode
	StringLiteral(i int) antlr.TerminalNode
	KW_INPUTDRIVER() antlr.TerminalNode
	KW_OUTPUTDRIVER() antlr.TerminalNode
	KW_BY() antlr.TerminalNode
	KW_WITH() antlr.TerminalNode
	KW_SERDEPROPERTIES() antlr.TerminalNode
	TableProperties() ITablePropertiesContext
	AllId_() []IId_Context
	Id_(i int) IId_Context

	// IsTableFileFormatContext differentiates from other interfaces.
	IsTableFileFormatContext()
}

type TableFileFormatContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	inFmt antlr.Token
	outFmt antlr.Token
	inDriver antlr.Token
	outDriver antlr.Token
	storageHandler antlr.Token
	serdeprops ITablePropertiesContext 
	fileformat IId_Context 
	genericSpec IId_Context 
}

func NewEmptyTableFileFormatContext() *TableFileFormatContext {
	var p = new(TableFileFormatContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_tableFileFormat
	return p
}

func InitEmptyTableFileFormatContext(p *TableFileFormatContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_tableFileFormat
}

func (*TableFileFormatContext) IsTableFileFormatContext() {}

func NewTableFileFormatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableFileFormatContext {
	var p = new(TableFileFormatContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_tableFileFormat

	return p
}

func (s *TableFileFormatContext) GetParser() antlr.Parser { return s.parser }

func (s *TableFileFormatContext) GetInFmt() antlr.Token { return s.inFmt }

func (s *TableFileFormatContext) GetOutFmt() antlr.Token { return s.outFmt }

func (s *TableFileFormatContext) GetInDriver() antlr.Token { return s.inDriver }

func (s *TableFileFormatContext) GetOutDriver() antlr.Token { return s.outDriver }

func (s *TableFileFormatContext) GetStorageHandler() antlr.Token { return s.storageHandler }


func (s *TableFileFormatContext) SetInFmt(v antlr.Token) { s.inFmt = v }

func (s *TableFileFormatContext) SetOutFmt(v antlr.Token) { s.outFmt = v }

func (s *TableFileFormatContext) SetInDriver(v antlr.Token) { s.inDriver = v }

func (s *TableFileFormatContext) SetOutDriver(v antlr.Token) { s.outDriver = v }

func (s *TableFileFormatContext) SetStorageHandler(v antlr.Token) { s.storageHandler = v }


func (s *TableFileFormatContext) GetSerdeprops() ITablePropertiesContext { return s.serdeprops }

func (s *TableFileFormatContext) GetFileformat() IId_Context { return s.fileformat }

func (s *TableFileFormatContext) GetGenericSpec() IId_Context { return s.genericSpec }


func (s *TableFileFormatContext) SetSerdeprops(v ITablePropertiesContext) { s.serdeprops = v }

func (s *TableFileFormatContext) SetFileformat(v IId_Context) { s.fileformat = v }

func (s *TableFileFormatContext) SetGenericSpec(v IId_Context) { s.genericSpec = v }


func (s *TableFileFormatContext) AllKW_STORED() []antlr.TerminalNode {
	return s.GetTokens(HiveParserKW_STORED)
}

func (s *TableFileFormatContext) KW_STORED(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserKW_STORED, i)
}

func (s *TableFileFormatContext) KW_AS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_AS, 0)
}

func (s *TableFileFormatContext) KW_INPUTFORMAT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_INPUTFORMAT, 0)
}

func (s *TableFileFormatContext) KW_OUTPUTFORMAT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_OUTPUTFORMAT, 0)
}

func (s *TableFileFormatContext) AllStringLiteral() []antlr.TerminalNode {
	return s.GetTokens(HiveParserStringLiteral)
}

func (s *TableFileFormatContext) StringLiteral(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserStringLiteral, i)
}

func (s *TableFileFormatContext) KW_INPUTDRIVER() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_INPUTDRIVER, 0)
}

func (s *TableFileFormatContext) KW_OUTPUTDRIVER() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_OUTPUTDRIVER, 0)
}

func (s *TableFileFormatContext) KW_BY() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_BY, 0)
}

func (s *TableFileFormatContext) KW_WITH() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_WITH, 0)
}

func (s *TableFileFormatContext) KW_SERDEPROPERTIES() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SERDEPROPERTIES, 0)
}

func (s *TableFileFormatContext) TableProperties() ITablePropertiesContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablePropertiesContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablePropertiesContext)
}

func (s *TableFileFormatContext) AllId_() []IId_Context {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IId_Context); ok {
			len++
		}
	}

	tst := make([]IId_Context, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IId_Context); ok {
			tst[i] = t.(IId_Context)
			i++
		}
	}

	return tst
}

func (s *TableFileFormatContext) Id_(i int) IId_Context {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *TableFileFormatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableFileFormatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TableFileFormatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterTableFileFormat(s)
	}
}

func (s *TableFileFormatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitTableFileFormat(s)
	}
}

func (s *TableFileFormatContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitTableFileFormat(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) TableFileFormat() (localctx ITableFileFormatContext) {
	localctx = NewTableFileFormatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, HiveParserRULE_tableFileFormat)
	var _la int

	p.SetState(2301)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 188, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2260)
			p.Match(HiveParserKW_STORED)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2261)
			p.Match(HiveParserKW_AS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2262)
			p.Match(HiveParserKW_INPUTFORMAT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2263)

			var _m = p.Match(HiveParserStringLiteral)

			localctx.(*TableFileFormatContext).inFmt = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2264)
			p.Match(HiveParserKW_OUTPUTFORMAT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2265)

			var _m = p.Match(HiveParserStringLiteral)

			localctx.(*TableFileFormatContext).outFmt = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2270)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_INPUTDRIVER {
			{
				p.SetState(2266)
				p.Match(HiveParserKW_INPUTDRIVER)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2267)

				var _m = p.Match(HiveParserStringLiteral)

				localctx.(*TableFileFormatContext).inDriver = _m
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2268)
				p.Match(HiveParserKW_OUTPUTDRIVER)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2269)

				var _m = p.Match(HiveParserStringLiteral)

				localctx.(*TableFileFormatContext).outDriver = _m
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2272)
			p.Match(HiveParserKW_STORED)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2273)
			p.Match(HiveParserKW_BY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2274)

			var _m = p.Match(HiveParserStringLiteral)

			localctx.(*TableFileFormatContext).storageHandler = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2278)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_WITH {
			{
				p.SetState(2275)
				p.Match(HiveParserKW_WITH)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2276)
				p.Match(HiveParserKW_SERDEPROPERTIES)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2277)

				var _x = p.TableProperties()


				localctx.(*TableFileFormatContext).serdeprops = _x
			}

		}
		p.SetState(2283)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_STORED {
			{
				p.SetState(2280)
				p.Match(HiveParserKW_STORED)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2281)
				p.Match(HiveParserKW_AS)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2282)

				var _x = p.Id_()


				localctx.(*TableFileFormatContext).fileformat = _x
			}

		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2285)
			p.Match(HiveParserKW_STORED)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2286)
			p.Match(HiveParserKW_BY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2287)

			var _x = p.Id_()


			localctx.(*TableFileFormatContext).genericSpec = _x
		}
		p.SetState(2291)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_WITH {
			{
				p.SetState(2288)
				p.Match(HiveParserKW_WITH)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2289)
				p.Match(HiveParserKW_SERDEPROPERTIES)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2290)

				var _x = p.TableProperties()


				localctx.(*TableFileFormatContext).serdeprops = _x
			}

		}
		p.SetState(2296)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_STORED {
			{
				p.SetState(2293)
				p.Match(HiveParserKW_STORED)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2294)
				p.Match(HiveParserKW_AS)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2295)

				var _x = p.Id_()


				localctx.(*TableFileFormatContext).fileformat = _x
			}

		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2298)
			p.Match(HiveParserKW_STORED)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2299)
			p.Match(HiveParserKW_AS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2300)

			var _x = p.Id_()


			localctx.(*TableFileFormatContext).genericSpec = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITableLocationContext is an interface to support dynamic dispatch.
type ITableLocationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLocn returns the locn token.
	GetLocn() antlr.Token 


	// SetLocn sets the locn token.
	SetLocn(antlr.Token) 


	// Getter signatures
	KW_LOCATION() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode

	// IsTableLocationContext differentiates from other interfaces.
	IsTableLocationContext()
}

type TableLocationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	locn antlr.Token
}

func NewEmptyTableLocationContext() *TableLocationContext {
	var p = new(TableLocationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_tableLocation
	return p
}

func InitEmptyTableLocationContext(p *TableLocationContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_tableLocation
}

func (*TableLocationContext) IsTableLocationContext() {}

func NewTableLocationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableLocationContext {
	var p = new(TableLocationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_tableLocation

	return p
}

func (s *TableLocationContext) GetParser() antlr.Parser { return s.parser }

func (s *TableLocationContext) GetLocn() antlr.Token { return s.locn }


func (s *TableLocationContext) SetLocn(v antlr.Token) { s.locn = v }


func (s *TableLocationContext) KW_LOCATION() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_LOCATION, 0)
}

func (s *TableLocationContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(HiveParserStringLiteral, 0)
}

func (s *TableLocationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableLocationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TableLocationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterTableLocation(s)
	}
}

func (s *TableLocationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitTableLocation(s)
	}
}

func (s *TableLocationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitTableLocation(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) TableLocation() (localctx ITableLocationContext) {
	localctx = NewTableLocationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, HiveParserRULE_tableLocation)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2303)
		p.Match(HiveParserKW_LOCATION)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2304)

		var _m = p.Match(HiveParserStringLiteral)

		localctx.(*TableLocationContext).locn = _m
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IColumnNameTypeListContext is an interface to support dynamic dispatch.
type IColumnNameTypeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllColumnNameType() []IColumnNameTypeContext
	ColumnNameType(i int) IColumnNameTypeContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsColumnNameTypeListContext differentiates from other interfaces.
	IsColumnNameTypeListContext()
}

type ColumnNameTypeListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnNameTypeListContext() *ColumnNameTypeListContext {
	var p = new(ColumnNameTypeListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_columnNameTypeList
	return p
}

func InitEmptyColumnNameTypeListContext(p *ColumnNameTypeListContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_columnNameTypeList
}

func (*ColumnNameTypeListContext) IsColumnNameTypeListContext() {}

func NewColumnNameTypeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnNameTypeListContext {
	var p = new(ColumnNameTypeListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_columnNameTypeList

	return p
}

func (s *ColumnNameTypeListContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnNameTypeListContext) AllColumnNameType() []IColumnNameTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnNameTypeContext); ok {
			len++
		}
	}

	tst := make([]IColumnNameTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnNameTypeContext); ok {
			tst[i] = t.(IColumnNameTypeContext)
			i++
		}
	}

	return tst
}

func (s *ColumnNameTypeListContext) ColumnNameType(i int) IColumnNameTypeContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNameTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNameTypeContext)
}

func (s *ColumnNameTypeListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(HiveParserCOMMA)
}

func (s *ColumnNameTypeListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserCOMMA, i)
}

func (s *ColumnNameTypeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnNameTypeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ColumnNameTypeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterColumnNameTypeList(s)
	}
}

func (s *ColumnNameTypeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitColumnNameTypeList(s)
	}
}

func (s *ColumnNameTypeListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitColumnNameTypeList(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ColumnNameTypeList() (localctx IColumnNameTypeListContext) {
	localctx = NewColumnNameTypeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, HiveParserRULE_columnNameTypeList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2306)
		p.ColumnNameType()
	}
	p.SetState(2311)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HiveParserCOMMA {
		{
			p.SetState(2307)
			p.Match(HiveParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2308)
			p.ColumnNameType()
		}


		p.SetState(2313)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IColumnNameTypeOrConstraintListContext is an interface to support dynamic dispatch.
type IColumnNameTypeOrConstraintListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllColumnNameTypeOrConstraint() []IColumnNameTypeOrConstraintContext
	ColumnNameTypeOrConstraint(i int) IColumnNameTypeOrConstraintContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsColumnNameTypeOrConstraintListContext differentiates from other interfaces.
	IsColumnNameTypeOrConstraintListContext()
}

type ColumnNameTypeOrConstraintListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnNameTypeOrConstraintListContext() *ColumnNameTypeOrConstraintListContext {
	var p = new(ColumnNameTypeOrConstraintListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_columnNameTypeOrConstraintList
	return p
}

func InitEmptyColumnNameTypeOrConstraintListContext(p *ColumnNameTypeOrConstraintListContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_columnNameTypeOrConstraintList
}

func (*ColumnNameTypeOrConstraintListContext) IsColumnNameTypeOrConstraintListContext() {}

func NewColumnNameTypeOrConstraintListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnNameTypeOrConstraintListContext {
	var p = new(ColumnNameTypeOrConstraintListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_columnNameTypeOrConstraintList

	return p
}

func (s *ColumnNameTypeOrConstraintListContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnNameTypeOrConstraintListContext) AllColumnNameTypeOrConstraint() []IColumnNameTypeOrConstraintContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnNameTypeOrConstraintContext); ok {
			len++
		}
	}

	tst := make([]IColumnNameTypeOrConstraintContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnNameTypeOrConstraintContext); ok {
			tst[i] = t.(IColumnNameTypeOrConstraintContext)
			i++
		}
	}

	return tst
}

func (s *ColumnNameTypeOrConstraintListContext) ColumnNameTypeOrConstraint(i int) IColumnNameTypeOrConstraintContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNameTypeOrConstraintContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNameTypeOrConstraintContext)
}

func (s *ColumnNameTypeOrConstraintListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(HiveParserCOMMA)
}

func (s *ColumnNameTypeOrConstraintListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserCOMMA, i)
}

func (s *ColumnNameTypeOrConstraintListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnNameTypeOrConstraintListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ColumnNameTypeOrConstraintListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterColumnNameTypeOrConstraintList(s)
	}
}

func (s *ColumnNameTypeOrConstraintListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitColumnNameTypeOrConstraintList(s)
	}
}

func (s *ColumnNameTypeOrConstraintListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitColumnNameTypeOrConstraintList(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ColumnNameTypeOrConstraintList() (localctx IColumnNameTypeOrConstraintListContext) {
	localctx = NewColumnNameTypeOrConstraintListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, HiveParserRULE_columnNameTypeOrConstraintList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2314)
		p.ColumnNameTypeOrConstraint()
	}
	p.SetState(2319)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HiveParserCOMMA {
		{
			p.SetState(2315)
			p.Match(HiveParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2316)
			p.ColumnNameTypeOrConstraint()
		}


		p.SetState(2321)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IColumnNameColonTypeListContext is an interface to support dynamic dispatch.
type IColumnNameColonTypeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllColumnNameColonType() []IColumnNameColonTypeContext
	ColumnNameColonType(i int) IColumnNameColonTypeContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsColumnNameColonTypeListContext differentiates from other interfaces.
	IsColumnNameColonTypeListContext()
}

type ColumnNameColonTypeListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnNameColonTypeListContext() *ColumnNameColonTypeListContext {
	var p = new(ColumnNameColonTypeListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_columnNameColonTypeList
	return p
}

func InitEmptyColumnNameColonTypeListContext(p *ColumnNameColonTypeListContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_columnNameColonTypeList
}

func (*ColumnNameColonTypeListContext) IsColumnNameColonTypeListContext() {}

func NewColumnNameColonTypeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnNameColonTypeListContext {
	var p = new(ColumnNameColonTypeListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_columnNameColonTypeList

	return p
}

func (s *ColumnNameColonTypeListContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnNameColonTypeListContext) AllColumnNameColonType() []IColumnNameColonTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnNameColonTypeContext); ok {
			len++
		}
	}

	tst := make([]IColumnNameColonTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnNameColonTypeContext); ok {
			tst[i] = t.(IColumnNameColonTypeContext)
			i++
		}
	}

	return tst
}

func (s *ColumnNameColonTypeListContext) ColumnNameColonType(i int) IColumnNameColonTypeContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNameColonTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNameColonTypeContext)
}

func (s *ColumnNameColonTypeListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(HiveParserCOMMA)
}

func (s *ColumnNameColonTypeListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserCOMMA, i)
}

func (s *ColumnNameColonTypeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnNameColonTypeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ColumnNameColonTypeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterColumnNameColonTypeList(s)
	}
}

func (s *ColumnNameColonTypeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitColumnNameColonTypeList(s)
	}
}

func (s *ColumnNameColonTypeListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitColumnNameColonTypeList(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ColumnNameColonTypeList() (localctx IColumnNameColonTypeListContext) {
	localctx = NewColumnNameColonTypeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, HiveParserRULE_columnNameColonTypeList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2322)
		p.ColumnNameColonType()
	}
	p.SetState(2327)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HiveParserCOMMA {
		{
			p.SetState(2323)
			p.Match(HiveParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2324)
			p.ColumnNameColonType()
		}


		p.SetState(2329)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IColumnNameListContext is an interface to support dynamic dispatch.
type IColumnNameListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllColumnName() []IColumnNameContext
	ColumnName(i int) IColumnNameContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsColumnNameListContext differentiates from other interfaces.
	IsColumnNameListContext()
}

type ColumnNameListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnNameListContext() *ColumnNameListContext {
	var p = new(ColumnNameListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_columnNameList
	return p
}

func InitEmptyColumnNameListContext(p *ColumnNameListContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_columnNameList
}

func (*ColumnNameListContext) IsColumnNameListContext() {}

func NewColumnNameListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnNameListContext {
	var p = new(ColumnNameListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_columnNameList

	return p
}

func (s *ColumnNameListContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnNameListContext) AllColumnName() []IColumnNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnNameContext); ok {
			len++
		}
	}

	tst := make([]IColumnNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnNameContext); ok {
			tst[i] = t.(IColumnNameContext)
			i++
		}
	}

	return tst
}

func (s *ColumnNameListContext) ColumnName(i int) IColumnNameContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNameContext)
}

func (s *ColumnNameListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(HiveParserCOMMA)
}

func (s *ColumnNameListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserCOMMA, i)
}

func (s *ColumnNameListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnNameListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ColumnNameListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterColumnNameList(s)
	}
}

func (s *ColumnNameListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitColumnNameList(s)
	}
}

func (s *ColumnNameListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitColumnNameList(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ColumnNameList() (localctx IColumnNameListContext) {
	localctx = NewColumnNameListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, HiveParserRULE_columnNameList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2330)
		p.ColumnName()
	}
	p.SetState(2335)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HiveParserCOMMA {
		{
			p.SetState(2331)
			p.Match(HiveParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2332)
			p.ColumnName()
		}


		p.SetState(2337)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IColumnNameContext is an interface to support dynamic dispatch.
type IColumnNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Id_() IId_Context

	// IsColumnNameContext differentiates from other interfaces.
	IsColumnNameContext()
}

type ColumnNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnNameContext() *ColumnNameContext {
	var p = new(ColumnNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_columnName
	return p
}

func InitEmptyColumnNameContext(p *ColumnNameContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_columnName
}

func (*ColumnNameContext) IsColumnNameContext() {}

func NewColumnNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnNameContext {
	var p = new(ColumnNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_columnName

	return p
}

func (s *ColumnNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnNameContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *ColumnNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ColumnNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterColumnName(s)
	}
}

func (s *ColumnNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitColumnName(s)
	}
}

func (s *ColumnNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitColumnName(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ColumnName() (localctx IColumnNameContext) {
	localctx = NewColumnNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, HiveParserRULE_columnName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2338)
		p.Id_()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExtColumnNameContext is an interface to support dynamic dispatch.
type IExtColumnNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllId_() []IId_Context
	Id_(i int) IId_Context
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode
	AllKW_ELEM_TYPE() []antlr.TerminalNode
	KW_ELEM_TYPE(i int) antlr.TerminalNode
	AllKW_KEY_TYPE() []antlr.TerminalNode
	KW_KEY_TYPE(i int) antlr.TerminalNode
	AllKW_VALUE_TYPE() []antlr.TerminalNode
	KW_VALUE_TYPE(i int) antlr.TerminalNode

	// IsExtColumnNameContext differentiates from other interfaces.
	IsExtColumnNameContext()
}

type ExtColumnNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtColumnNameContext() *ExtColumnNameContext {
	var p = new(ExtColumnNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_extColumnName
	return p
}

func InitEmptyExtColumnNameContext(p *ExtColumnNameContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_extColumnName
}

func (*ExtColumnNameContext) IsExtColumnNameContext() {}

func NewExtColumnNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtColumnNameContext {
	var p = new(ExtColumnNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_extColumnName

	return p
}

func (s *ExtColumnNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtColumnNameContext) AllId_() []IId_Context {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IId_Context); ok {
			len++
		}
	}

	tst := make([]IId_Context, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IId_Context); ok {
			tst[i] = t.(IId_Context)
			i++
		}
	}

	return tst
}

func (s *ExtColumnNameContext) Id_(i int) IId_Context {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *ExtColumnNameContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(HiveParserDOT)
}

func (s *ExtColumnNameContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserDOT, i)
}

func (s *ExtColumnNameContext) AllKW_ELEM_TYPE() []antlr.TerminalNode {
	return s.GetTokens(HiveParserKW_ELEM_TYPE)
}

func (s *ExtColumnNameContext) KW_ELEM_TYPE(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ELEM_TYPE, i)
}

func (s *ExtColumnNameContext) AllKW_KEY_TYPE() []antlr.TerminalNode {
	return s.GetTokens(HiveParserKW_KEY_TYPE)
}

func (s *ExtColumnNameContext) KW_KEY_TYPE(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserKW_KEY_TYPE, i)
}

func (s *ExtColumnNameContext) AllKW_VALUE_TYPE() []antlr.TerminalNode {
	return s.GetTokens(HiveParserKW_VALUE_TYPE)
}

func (s *ExtColumnNameContext) KW_VALUE_TYPE(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserKW_VALUE_TYPE, i)
}

func (s *ExtColumnNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtColumnNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ExtColumnNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterExtColumnName(s)
	}
}

func (s *ExtColumnNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitExtColumnName(s)
	}
}

func (s *ExtColumnNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitExtColumnName(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ExtColumnName() (localctx IExtColumnNameContext) {
	localctx = NewExtColumnNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, HiveParserRULE_extColumnName)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2340)
		p.Id_()
	}
	p.SetState(2350)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HiveParserDOT {
		{
			p.SetState(2341)
			p.Match(HiveParserDOT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2346)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 193, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(2342)
				p.Match(HiveParserKW_ELEM_TYPE)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


		case 2:
			{
				p.SetState(2343)
				p.Match(HiveParserKW_KEY_TYPE)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


		case 3:
			{
				p.SetState(2344)
				p.Match(HiveParserKW_VALUE_TYPE)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


		case 4:
			{
				p.SetState(2345)
				p.Id_()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}


		p.SetState(2352)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IColumnNameOrderListContext is an interface to support dynamic dispatch.
type IColumnNameOrderListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllColumnNameOrder() []IColumnNameOrderContext
	ColumnNameOrder(i int) IColumnNameOrderContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsColumnNameOrderListContext differentiates from other interfaces.
	IsColumnNameOrderListContext()
}

type ColumnNameOrderListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnNameOrderListContext() *ColumnNameOrderListContext {
	var p = new(ColumnNameOrderListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_columnNameOrderList
	return p
}

func InitEmptyColumnNameOrderListContext(p *ColumnNameOrderListContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_columnNameOrderList
}

func (*ColumnNameOrderListContext) IsColumnNameOrderListContext() {}

func NewColumnNameOrderListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnNameOrderListContext {
	var p = new(ColumnNameOrderListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_columnNameOrderList

	return p
}

func (s *ColumnNameOrderListContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnNameOrderListContext) AllColumnNameOrder() []IColumnNameOrderContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnNameOrderContext); ok {
			len++
		}
	}

	tst := make([]IColumnNameOrderContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnNameOrderContext); ok {
			tst[i] = t.(IColumnNameOrderContext)
			i++
		}
	}

	return tst
}

func (s *ColumnNameOrderListContext) ColumnNameOrder(i int) IColumnNameOrderContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNameOrderContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNameOrderContext)
}

func (s *ColumnNameOrderListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(HiveParserCOMMA)
}

func (s *ColumnNameOrderListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserCOMMA, i)
}

func (s *ColumnNameOrderListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnNameOrderListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ColumnNameOrderListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterColumnNameOrderList(s)
	}
}

func (s *ColumnNameOrderListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitColumnNameOrderList(s)
	}
}

func (s *ColumnNameOrderListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitColumnNameOrderList(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ColumnNameOrderList() (localctx IColumnNameOrderListContext) {
	localctx = NewColumnNameOrderListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, HiveParserRULE_columnNameOrderList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2353)
		p.ColumnNameOrder()
	}
	p.SetState(2358)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HiveParserCOMMA {
		{
			p.SetState(2354)
			p.Match(HiveParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2355)
			p.ColumnNameOrder()
		}


		p.SetState(2360)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IColumnParenthesesListContext is an interface to support dynamic dispatch.
type IColumnParenthesesListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	ColumnNameList() IColumnNameListContext
	RPAREN() antlr.TerminalNode

	// IsColumnParenthesesListContext differentiates from other interfaces.
	IsColumnParenthesesListContext()
}

type ColumnParenthesesListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnParenthesesListContext() *ColumnParenthesesListContext {
	var p = new(ColumnParenthesesListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_columnParenthesesList
	return p
}

func InitEmptyColumnParenthesesListContext(p *ColumnParenthesesListContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_columnParenthesesList
}

func (*ColumnParenthesesListContext) IsColumnParenthesesListContext() {}

func NewColumnParenthesesListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnParenthesesListContext {
	var p = new(ColumnParenthesesListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_columnParenthesesList

	return p
}

func (s *ColumnParenthesesListContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnParenthesesListContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserLPAREN, 0)
}

func (s *ColumnParenthesesListContext) ColumnNameList() IColumnNameListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNameListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNameListContext)
}

func (s *ColumnParenthesesListContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserRPAREN, 0)
}

func (s *ColumnParenthesesListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnParenthesesListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ColumnParenthesesListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterColumnParenthesesList(s)
	}
}

func (s *ColumnParenthesesListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitColumnParenthesesList(s)
	}
}

func (s *ColumnParenthesesListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitColumnParenthesesList(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ColumnParenthesesList() (localctx IColumnParenthesesListContext) {
	localctx = NewColumnParenthesesListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, HiveParserRULE_columnParenthesesList)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2361)
		p.Match(HiveParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2362)
		p.ColumnNameList()
	}
	{
		p.SetState(2363)
		p.Match(HiveParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IEnableValidateSpecificationContext is an interface to support dynamic dispatch.
type IEnableValidateSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EnableSpecification() IEnableSpecificationContext
	ValidateSpecification() IValidateSpecificationContext
	EnforcedSpecification() IEnforcedSpecificationContext

	// IsEnableValidateSpecificationContext differentiates from other interfaces.
	IsEnableValidateSpecificationContext()
}

type EnableValidateSpecificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnableValidateSpecificationContext() *EnableValidateSpecificationContext {
	var p = new(EnableValidateSpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_enableValidateSpecification
	return p
}

func InitEmptyEnableValidateSpecificationContext(p *EnableValidateSpecificationContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_enableValidateSpecification
}

func (*EnableValidateSpecificationContext) IsEnableValidateSpecificationContext() {}

func NewEnableValidateSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnableValidateSpecificationContext {
	var p = new(EnableValidateSpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_enableValidateSpecification

	return p
}

func (s *EnableValidateSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *EnableValidateSpecificationContext) EnableSpecification() IEnableSpecificationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnableSpecificationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnableSpecificationContext)
}

func (s *EnableValidateSpecificationContext) ValidateSpecification() IValidateSpecificationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValidateSpecificationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValidateSpecificationContext)
}

func (s *EnableValidateSpecificationContext) EnforcedSpecification() IEnforcedSpecificationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnforcedSpecificationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnforcedSpecificationContext)
}

func (s *EnableValidateSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnableValidateSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *EnableValidateSpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterEnableValidateSpecification(s)
	}
}

func (s *EnableValidateSpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitEnableValidateSpecification(s)
	}
}

func (s *EnableValidateSpecificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitEnableValidateSpecification(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) EnableValidateSpecification() (localctx IEnableValidateSpecificationContext) {
	localctx = NewEnableValidateSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, HiveParserRULE_enableValidateSpecification)
	var _la int

	p.SetState(2370)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserKW_DISABLE, HiveParserKW_ENABLE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2365)
			p.EnableSpecification()
		}
		p.SetState(2367)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_NOVALIDATE || _la == HiveParserKW_VALIDATE {
			{
				p.SetState(2366)
				p.ValidateSpecification()
			}

		}


	case HiveParserKW_ENFORCED, HiveParserKW_NOT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2369)
			p.EnforcedSpecification()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IEnableSpecificationContext is an interface to support dynamic dispatch.
type IEnableSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_ENABLE() antlr.TerminalNode
	KW_DISABLE() antlr.TerminalNode

	// IsEnableSpecificationContext differentiates from other interfaces.
	IsEnableSpecificationContext()
}

type EnableSpecificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnableSpecificationContext() *EnableSpecificationContext {
	var p = new(EnableSpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_enableSpecification
	return p
}

func InitEmptyEnableSpecificationContext(p *EnableSpecificationContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_enableSpecification
}

func (*EnableSpecificationContext) IsEnableSpecificationContext() {}

func NewEnableSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnableSpecificationContext {
	var p = new(EnableSpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_enableSpecification

	return p
}

func (s *EnableSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *EnableSpecificationContext) KW_ENABLE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ENABLE, 0)
}

func (s *EnableSpecificationContext) KW_DISABLE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DISABLE, 0)
}

func (s *EnableSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnableSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *EnableSpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterEnableSpecification(s)
	}
}

func (s *EnableSpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitEnableSpecification(s)
	}
}

func (s *EnableSpecificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitEnableSpecification(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) EnableSpecification() (localctx IEnableSpecificationContext) {
	localctx = NewEnableSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, HiveParserRULE_enableSpecification)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2372)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HiveParserKW_DISABLE || _la == HiveParserKW_ENABLE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IValidateSpecificationContext is an interface to support dynamic dispatch.
type IValidateSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_VALIDATE() antlr.TerminalNode
	KW_NOVALIDATE() antlr.TerminalNode

	// IsValidateSpecificationContext differentiates from other interfaces.
	IsValidateSpecificationContext()
}

type ValidateSpecificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValidateSpecificationContext() *ValidateSpecificationContext {
	var p = new(ValidateSpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_validateSpecification
	return p
}

func InitEmptyValidateSpecificationContext(p *ValidateSpecificationContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_validateSpecification
}

func (*ValidateSpecificationContext) IsValidateSpecificationContext() {}

func NewValidateSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValidateSpecificationContext {
	var p = new(ValidateSpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_validateSpecification

	return p
}

func (s *ValidateSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *ValidateSpecificationContext) KW_VALIDATE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_VALIDATE, 0)
}

func (s *ValidateSpecificationContext) KW_NOVALIDATE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_NOVALIDATE, 0)
}

func (s *ValidateSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValidateSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ValidateSpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterValidateSpecification(s)
	}
}

func (s *ValidateSpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitValidateSpecification(s)
	}
}

func (s *ValidateSpecificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitValidateSpecification(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ValidateSpecification() (localctx IValidateSpecificationContext) {
	localctx = NewValidateSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, HiveParserRULE_validateSpecification)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2374)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HiveParserKW_NOVALIDATE || _la == HiveParserKW_VALIDATE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IEnforcedSpecificationContext is an interface to support dynamic dispatch.
type IEnforcedSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_ENFORCED() antlr.TerminalNode
	KW_NOT() antlr.TerminalNode

	// IsEnforcedSpecificationContext differentiates from other interfaces.
	IsEnforcedSpecificationContext()
}

type EnforcedSpecificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnforcedSpecificationContext() *EnforcedSpecificationContext {
	var p = new(EnforcedSpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_enforcedSpecification
	return p
}

func InitEmptyEnforcedSpecificationContext(p *EnforcedSpecificationContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_enforcedSpecification
}

func (*EnforcedSpecificationContext) IsEnforcedSpecificationContext() {}

func NewEnforcedSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnforcedSpecificationContext {
	var p = new(EnforcedSpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_enforcedSpecification

	return p
}

func (s *EnforcedSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *EnforcedSpecificationContext) KW_ENFORCED() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ENFORCED, 0)
}

func (s *EnforcedSpecificationContext) KW_NOT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_NOT, 0)
}

func (s *EnforcedSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnforcedSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *EnforcedSpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterEnforcedSpecification(s)
	}
}

func (s *EnforcedSpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitEnforcedSpecification(s)
	}
}

func (s *EnforcedSpecificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitEnforcedSpecification(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) EnforcedSpecification() (localctx IEnforcedSpecificationContext) {
	localctx = NewEnforcedSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, HiveParserRULE_enforcedSpecification)
	p.SetState(2379)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserKW_ENFORCED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2376)
			p.Match(HiveParserKW_ENFORCED)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HiveParserKW_NOT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2377)
			p.Match(HiveParserKW_NOT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2378)
			p.Match(HiveParserKW_ENFORCED)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRelySpecificationContext is an interface to support dynamic dispatch.
type IRelySpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_RELY() antlr.TerminalNode
	KW_NORELY() antlr.TerminalNode

	// IsRelySpecificationContext differentiates from other interfaces.
	IsRelySpecificationContext()
}

type RelySpecificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelySpecificationContext() *RelySpecificationContext {
	var p = new(RelySpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_relySpecification
	return p
}

func InitEmptyRelySpecificationContext(p *RelySpecificationContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_relySpecification
}

func (*RelySpecificationContext) IsRelySpecificationContext() {}

func NewRelySpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelySpecificationContext {
	var p = new(RelySpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_relySpecification

	return p
}

func (s *RelySpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *RelySpecificationContext) KW_RELY() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_RELY, 0)
}

func (s *RelySpecificationContext) KW_NORELY() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_NORELY, 0)
}

func (s *RelySpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelySpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *RelySpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterRelySpecification(s)
	}
}

func (s *RelySpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitRelySpecification(s)
	}
}

func (s *RelySpecificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitRelySpecification(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) RelySpecification() (localctx IRelySpecificationContext) {
	localctx = NewRelySpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 290, HiveParserRULE_relySpecification)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2381)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HiveParserKW_NORELY || _la == HiveParserKW_RELY) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreateConstraintContext is an interface to support dynamic dispatch.
type ICreateConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetConstraintName returns the constraintName rule contexts.
	GetConstraintName() IId_Context


	// SetConstraintName sets the constraintName rule contexts.
	SetConstraintName(IId_Context)


	// Getter signatures
	TableLevelConstraint() ITableLevelConstraintContext
	KW_CONSTRAINT() antlr.TerminalNode
	ConstraintOptsCreate() IConstraintOptsCreateContext
	Id_() IId_Context

	// IsCreateConstraintContext differentiates from other interfaces.
	IsCreateConstraintContext()
}

type CreateConstraintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	constraintName IId_Context 
}

func NewEmptyCreateConstraintContext() *CreateConstraintContext {
	var p = new(CreateConstraintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_createConstraint
	return p
}

func InitEmptyCreateConstraintContext(p *CreateConstraintContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_createConstraint
}

func (*CreateConstraintContext) IsCreateConstraintContext() {}

func NewCreateConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateConstraintContext {
	var p = new(CreateConstraintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_createConstraint

	return p
}

func (s *CreateConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateConstraintContext) GetConstraintName() IId_Context { return s.constraintName }


func (s *CreateConstraintContext) SetConstraintName(v IId_Context) { s.constraintName = v }


func (s *CreateConstraintContext) TableLevelConstraint() ITableLevelConstraintContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableLevelConstraintContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableLevelConstraintContext)
}

func (s *CreateConstraintContext) KW_CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_CONSTRAINT, 0)
}

func (s *CreateConstraintContext) ConstraintOptsCreate() IConstraintOptsCreateContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstraintOptsCreateContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstraintOptsCreateContext)
}

func (s *CreateConstraintContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *CreateConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CreateConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterCreateConstraint(s)
	}
}

func (s *CreateConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitCreateConstraint(s)
	}
}

func (s *CreateConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitCreateConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) CreateConstraint() (localctx ICreateConstraintContext) {
	localctx = NewCreateConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 292, HiveParserRULE_createConstraint)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2385)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_CONSTRAINT {
		{
			p.SetState(2383)
			p.Match(HiveParserKW_CONSTRAINT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2384)

			var _x = p.Id_()


			localctx.(*CreateConstraintContext).constraintName = _x
		}

	}
	{
		p.SetState(2387)
		p.TableLevelConstraint()
	}
	p.SetState(2389)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if ((int64((_la - 91)) & ^0x3f) == 0 && ((int64(1) << (_la - 91)) & 10241) != 0) || _la == HiveParserKW_NOT {
		{
			p.SetState(2388)
			p.ConstraintOptsCreate()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlterConstraintWithNameContext is an interface to support dynamic dispatch.
type IAlterConstraintWithNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetConstraintName returns the constraintName rule contexts.
	GetConstraintName() IId_Context


	// SetConstraintName sets the constraintName rule contexts.
	SetConstraintName(IId_Context)


	// Getter signatures
	KW_CONSTRAINT() antlr.TerminalNode
	TableLevelConstraint() ITableLevelConstraintContext
	Id_() IId_Context
	ConstraintOptsAlter() IConstraintOptsAlterContext

	// IsAlterConstraintWithNameContext differentiates from other interfaces.
	IsAlterConstraintWithNameContext()
}

type AlterConstraintWithNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	constraintName IId_Context 
}

func NewEmptyAlterConstraintWithNameContext() *AlterConstraintWithNameContext {
	var p = new(AlterConstraintWithNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterConstraintWithName
	return p
}

func InitEmptyAlterConstraintWithNameContext(p *AlterConstraintWithNameContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterConstraintWithName
}

func (*AlterConstraintWithNameContext) IsAlterConstraintWithNameContext() {}

func NewAlterConstraintWithNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterConstraintWithNameContext {
	var p = new(AlterConstraintWithNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_alterConstraintWithName

	return p
}

func (s *AlterConstraintWithNameContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterConstraintWithNameContext) GetConstraintName() IId_Context { return s.constraintName }


func (s *AlterConstraintWithNameContext) SetConstraintName(v IId_Context) { s.constraintName = v }


func (s *AlterConstraintWithNameContext) KW_CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_CONSTRAINT, 0)
}

func (s *AlterConstraintWithNameContext) TableLevelConstraint() ITableLevelConstraintContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableLevelConstraintContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableLevelConstraintContext)
}

func (s *AlterConstraintWithNameContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *AlterConstraintWithNameContext) ConstraintOptsAlter() IConstraintOptsAlterContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstraintOptsAlterContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstraintOptsAlterContext)
}

func (s *AlterConstraintWithNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterConstraintWithNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AlterConstraintWithNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterAlterConstraintWithName(s)
	}
}

func (s *AlterConstraintWithNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitAlterConstraintWithName(s)
	}
}

func (s *AlterConstraintWithNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitAlterConstraintWithName(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) AlterConstraintWithName() (localctx IAlterConstraintWithNameContext) {
	localctx = NewAlterConstraintWithNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 294, HiveParserRULE_alterConstraintWithName)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2391)
		p.Match(HiveParserKW_CONSTRAINT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2392)

		var _x = p.Id_()


		localctx.(*AlterConstraintWithNameContext).constraintName = _x
	}
	{
		p.SetState(2393)
		p.TableLevelConstraint()
	}
	p.SetState(2395)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if ((int64((_la - 91)) & ^0x3f) == 0 && ((int64(1) << (_la - 91)) & 10241) != 0) || _la == HiveParserKW_NOT {
		{
			p.SetState(2394)
			p.ConstraintOptsAlter()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITableLevelConstraintContext is an interface to support dynamic dispatch.
type ITableLevelConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PkUkConstraint() IPkUkConstraintContext
	CheckConstraint() ICheckConstraintContext

	// IsTableLevelConstraintContext differentiates from other interfaces.
	IsTableLevelConstraintContext()
}

type TableLevelConstraintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableLevelConstraintContext() *TableLevelConstraintContext {
	var p = new(TableLevelConstraintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_tableLevelConstraint
	return p
}

func InitEmptyTableLevelConstraintContext(p *TableLevelConstraintContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_tableLevelConstraint
}

func (*TableLevelConstraintContext) IsTableLevelConstraintContext() {}

func NewTableLevelConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableLevelConstraintContext {
	var p = new(TableLevelConstraintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_tableLevelConstraint

	return p
}

func (s *TableLevelConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *TableLevelConstraintContext) PkUkConstraint() IPkUkConstraintContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPkUkConstraintContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPkUkConstraintContext)
}

func (s *TableLevelConstraintContext) CheckConstraint() ICheckConstraintContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICheckConstraintContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICheckConstraintContext)
}

func (s *TableLevelConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableLevelConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TableLevelConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterTableLevelConstraint(s)
	}
}

func (s *TableLevelConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitTableLevelConstraint(s)
	}
}

func (s *TableLevelConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitTableLevelConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) TableLevelConstraint() (localctx ITableLevelConstraintContext) {
	localctx = NewTableLevelConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 296, HiveParserRULE_tableLevelConstraint)
	p.SetState(2399)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserKW_PRIMARY, HiveParserKW_UNIQUE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2397)
			p.PkUkConstraint()
		}


	case HiveParserKW_CHECK:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2398)
			p.CheckConstraint()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPkUkConstraintContext is an interface to support dynamic dispatch.
type IPkUkConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPkCols returns the pkCols rule contexts.
	GetPkCols() IColumnParenthesesListContext


	// SetPkCols sets the pkCols rule contexts.
	SetPkCols(IColumnParenthesesListContext)


	// Getter signatures
	TableConstraintType() ITableConstraintTypeContext
	ColumnParenthesesList() IColumnParenthesesListContext

	// IsPkUkConstraintContext differentiates from other interfaces.
	IsPkUkConstraintContext()
}

type PkUkConstraintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	pkCols IColumnParenthesesListContext 
}

func NewEmptyPkUkConstraintContext() *PkUkConstraintContext {
	var p = new(PkUkConstraintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_pkUkConstraint
	return p
}

func InitEmptyPkUkConstraintContext(p *PkUkConstraintContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_pkUkConstraint
}

func (*PkUkConstraintContext) IsPkUkConstraintContext() {}

func NewPkUkConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PkUkConstraintContext {
	var p = new(PkUkConstraintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_pkUkConstraint

	return p
}

func (s *PkUkConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *PkUkConstraintContext) GetPkCols() IColumnParenthesesListContext { return s.pkCols }


func (s *PkUkConstraintContext) SetPkCols(v IColumnParenthesesListContext) { s.pkCols = v }


func (s *PkUkConstraintContext) TableConstraintType() ITableConstraintTypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableConstraintTypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableConstraintTypeContext)
}

func (s *PkUkConstraintContext) ColumnParenthesesList() IColumnParenthesesListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnParenthesesListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnParenthesesListContext)
}

func (s *PkUkConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PkUkConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PkUkConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterPkUkConstraint(s)
	}
}

func (s *PkUkConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitPkUkConstraint(s)
	}
}

func (s *PkUkConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitPkUkConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) PkUkConstraint() (localctx IPkUkConstraintContext) {
	localctx = NewPkUkConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 298, HiveParserRULE_pkUkConstraint)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2401)
		p.TableConstraintType()
	}
	{
		p.SetState(2402)

		var _x = p.ColumnParenthesesList()


		localctx.(*PkUkConstraintContext).pkCols = _x
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICheckConstraintContext is an interface to support dynamic dispatch.
type ICheckConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_CHECK() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Expression() IExpressionContext
	RPAREN() antlr.TerminalNode

	// IsCheckConstraintContext differentiates from other interfaces.
	IsCheckConstraintContext()
}

type CheckConstraintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCheckConstraintContext() *CheckConstraintContext {
	var p = new(CheckConstraintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_checkConstraint
	return p
}

func InitEmptyCheckConstraintContext(p *CheckConstraintContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_checkConstraint
}

func (*CheckConstraintContext) IsCheckConstraintContext() {}

func NewCheckConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CheckConstraintContext {
	var p = new(CheckConstraintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_checkConstraint

	return p
}

func (s *CheckConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *CheckConstraintContext) KW_CHECK() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_CHECK, 0)
}

func (s *CheckConstraintContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserLPAREN, 0)
}

func (s *CheckConstraintContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CheckConstraintContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserRPAREN, 0)
}

func (s *CheckConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CheckConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CheckConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterCheckConstraint(s)
	}
}

func (s *CheckConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitCheckConstraint(s)
	}
}

func (s *CheckConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitCheckConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) CheckConstraint() (localctx ICheckConstraintContext) {
	localctx = NewCheckConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 300, HiveParserRULE_checkConstraint)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2404)
		p.Match(HiveParserKW_CHECK)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2405)
		p.Match(HiveParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2406)
		p.Expression()
	}
	{
		p.SetState(2407)
		p.Match(HiveParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreateForeignKeyContext is an interface to support dynamic dispatch.
type ICreateForeignKeyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetConstraintName returns the constraintName rule contexts.
	GetConstraintName() IId_Context

	// GetFkCols returns the fkCols rule contexts.
	GetFkCols() IColumnParenthesesListContext

	// GetTabName returns the tabName rule contexts.
	GetTabName() ITableNameContext

	// GetParCols returns the parCols rule contexts.
	GetParCols() IColumnParenthesesListContext


	// SetConstraintName sets the constraintName rule contexts.
	SetConstraintName(IId_Context)

	// SetFkCols sets the fkCols rule contexts.
	SetFkCols(IColumnParenthesesListContext)

	// SetTabName sets the tabName rule contexts.
	SetTabName(ITableNameContext)

	// SetParCols sets the parCols rule contexts.
	SetParCols(IColumnParenthesesListContext)


	// Getter signatures
	KW_FOREIGN() antlr.TerminalNode
	KW_KEY() antlr.TerminalNode
	KW_REFERENCES() antlr.TerminalNode
	AllColumnParenthesesList() []IColumnParenthesesListContext
	ColumnParenthesesList(i int) IColumnParenthesesListContext
	TableName() ITableNameContext
	KW_CONSTRAINT() antlr.TerminalNode
	ConstraintOptsCreate() IConstraintOptsCreateContext
	Id_() IId_Context

	// IsCreateForeignKeyContext differentiates from other interfaces.
	IsCreateForeignKeyContext()
}

type CreateForeignKeyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	constraintName IId_Context 
	fkCols IColumnParenthesesListContext 
	tabName ITableNameContext 
	parCols IColumnParenthesesListContext 
}

func NewEmptyCreateForeignKeyContext() *CreateForeignKeyContext {
	var p = new(CreateForeignKeyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_createForeignKey
	return p
}

func InitEmptyCreateForeignKeyContext(p *CreateForeignKeyContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_createForeignKey
}

func (*CreateForeignKeyContext) IsCreateForeignKeyContext() {}

func NewCreateForeignKeyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateForeignKeyContext {
	var p = new(CreateForeignKeyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_createForeignKey

	return p
}

func (s *CreateForeignKeyContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateForeignKeyContext) GetConstraintName() IId_Context { return s.constraintName }

func (s *CreateForeignKeyContext) GetFkCols() IColumnParenthesesListContext { return s.fkCols }

func (s *CreateForeignKeyContext) GetTabName() ITableNameContext { return s.tabName }

func (s *CreateForeignKeyContext) GetParCols() IColumnParenthesesListContext { return s.parCols }


func (s *CreateForeignKeyContext) SetConstraintName(v IId_Context) { s.constraintName = v }

func (s *CreateForeignKeyContext) SetFkCols(v IColumnParenthesesListContext) { s.fkCols = v }

func (s *CreateForeignKeyContext) SetTabName(v ITableNameContext) { s.tabName = v }

func (s *CreateForeignKeyContext) SetParCols(v IColumnParenthesesListContext) { s.parCols = v }


func (s *CreateForeignKeyContext) KW_FOREIGN() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_FOREIGN, 0)
}

func (s *CreateForeignKeyContext) KW_KEY() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_KEY, 0)
}

func (s *CreateForeignKeyContext) KW_REFERENCES() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_REFERENCES, 0)
}

func (s *CreateForeignKeyContext) AllColumnParenthesesList() []IColumnParenthesesListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnParenthesesListContext); ok {
			len++
		}
	}

	tst := make([]IColumnParenthesesListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnParenthesesListContext); ok {
			tst[i] = t.(IColumnParenthesesListContext)
			i++
		}
	}

	return tst
}

func (s *CreateForeignKeyContext) ColumnParenthesesList(i int) IColumnParenthesesListContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnParenthesesListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnParenthesesListContext)
}

func (s *CreateForeignKeyContext) TableName() ITableNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *CreateForeignKeyContext) KW_CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_CONSTRAINT, 0)
}

func (s *CreateForeignKeyContext) ConstraintOptsCreate() IConstraintOptsCreateContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstraintOptsCreateContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstraintOptsCreateContext)
}

func (s *CreateForeignKeyContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *CreateForeignKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateForeignKeyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CreateForeignKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterCreateForeignKey(s)
	}
}

func (s *CreateForeignKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitCreateForeignKey(s)
	}
}

func (s *CreateForeignKeyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitCreateForeignKey(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) CreateForeignKey() (localctx ICreateForeignKeyContext) {
	localctx = NewCreateForeignKeyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 302, HiveParserRULE_createForeignKey)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2411)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_CONSTRAINT {
		{
			p.SetState(2409)
			p.Match(HiveParserKW_CONSTRAINT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2410)

			var _x = p.Id_()


			localctx.(*CreateForeignKeyContext).constraintName = _x
		}

	}
	{
		p.SetState(2413)
		p.Match(HiveParserKW_FOREIGN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2414)
		p.Match(HiveParserKW_KEY)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2415)

		var _x = p.ColumnParenthesesList()


		localctx.(*CreateForeignKeyContext).fkCols = _x
	}
	{
		p.SetState(2416)
		p.Match(HiveParserKW_REFERENCES)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2417)

		var _x = p.TableName()


		localctx.(*CreateForeignKeyContext).tabName = _x
	}
	{
		p.SetState(2418)

		var _x = p.ColumnParenthesesList()


		localctx.(*CreateForeignKeyContext).parCols = _x
	}
	p.SetState(2420)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if ((int64((_la - 91)) & ^0x3f) == 0 && ((int64(1) << (_la - 91)) & 10241) != 0) || _la == HiveParserKW_NOT {
		{
			p.SetState(2419)
			p.ConstraintOptsCreate()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlterForeignKeyWithNameContext is an interface to support dynamic dispatch.
type IAlterForeignKeyWithNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetConstraintName returns the constraintName rule contexts.
	GetConstraintName() IId_Context

	// GetFkCols returns the fkCols rule contexts.
	GetFkCols() IColumnParenthesesListContext

	// GetTabName returns the tabName rule contexts.
	GetTabName() ITableNameContext

	// GetParCols returns the parCols rule contexts.
	GetParCols() IColumnParenthesesListContext


	// SetConstraintName sets the constraintName rule contexts.
	SetConstraintName(IId_Context)

	// SetFkCols sets the fkCols rule contexts.
	SetFkCols(IColumnParenthesesListContext)

	// SetTabName sets the tabName rule contexts.
	SetTabName(ITableNameContext)

	// SetParCols sets the parCols rule contexts.
	SetParCols(IColumnParenthesesListContext)


	// Getter signatures
	KW_CONSTRAINT() antlr.TerminalNode
	KW_FOREIGN() antlr.TerminalNode
	KW_KEY() antlr.TerminalNode
	KW_REFERENCES() antlr.TerminalNode
	Id_() IId_Context
	AllColumnParenthesesList() []IColumnParenthesesListContext
	ColumnParenthesesList(i int) IColumnParenthesesListContext
	TableName() ITableNameContext
	ConstraintOptsAlter() IConstraintOptsAlterContext

	// IsAlterForeignKeyWithNameContext differentiates from other interfaces.
	IsAlterForeignKeyWithNameContext()
}

type AlterForeignKeyWithNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	constraintName IId_Context 
	fkCols IColumnParenthesesListContext 
	tabName ITableNameContext 
	parCols IColumnParenthesesListContext 
}

func NewEmptyAlterForeignKeyWithNameContext() *AlterForeignKeyWithNameContext {
	var p = new(AlterForeignKeyWithNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterForeignKeyWithName
	return p
}

func InitEmptyAlterForeignKeyWithNameContext(p *AlterForeignKeyWithNameContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterForeignKeyWithName
}

func (*AlterForeignKeyWithNameContext) IsAlterForeignKeyWithNameContext() {}

func NewAlterForeignKeyWithNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterForeignKeyWithNameContext {
	var p = new(AlterForeignKeyWithNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_alterForeignKeyWithName

	return p
}

func (s *AlterForeignKeyWithNameContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterForeignKeyWithNameContext) GetConstraintName() IId_Context { return s.constraintName }

func (s *AlterForeignKeyWithNameContext) GetFkCols() IColumnParenthesesListContext { return s.fkCols }

func (s *AlterForeignKeyWithNameContext) GetTabName() ITableNameContext { return s.tabName }

func (s *AlterForeignKeyWithNameContext) GetParCols() IColumnParenthesesListContext { return s.parCols }


func (s *AlterForeignKeyWithNameContext) SetConstraintName(v IId_Context) { s.constraintName = v }

func (s *AlterForeignKeyWithNameContext) SetFkCols(v IColumnParenthesesListContext) { s.fkCols = v }

func (s *AlterForeignKeyWithNameContext) SetTabName(v ITableNameContext) { s.tabName = v }

func (s *AlterForeignKeyWithNameContext) SetParCols(v IColumnParenthesesListContext) { s.parCols = v }


func (s *AlterForeignKeyWithNameContext) KW_CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_CONSTRAINT, 0)
}

func (s *AlterForeignKeyWithNameContext) KW_FOREIGN() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_FOREIGN, 0)
}

func (s *AlterForeignKeyWithNameContext) KW_KEY() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_KEY, 0)
}

func (s *AlterForeignKeyWithNameContext) KW_REFERENCES() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_REFERENCES, 0)
}

func (s *AlterForeignKeyWithNameContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *AlterForeignKeyWithNameContext) AllColumnParenthesesList() []IColumnParenthesesListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnParenthesesListContext); ok {
			len++
		}
	}

	tst := make([]IColumnParenthesesListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnParenthesesListContext); ok {
			tst[i] = t.(IColumnParenthesesListContext)
			i++
		}
	}

	return tst
}

func (s *AlterForeignKeyWithNameContext) ColumnParenthesesList(i int) IColumnParenthesesListContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnParenthesesListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnParenthesesListContext)
}

func (s *AlterForeignKeyWithNameContext) TableName() ITableNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *AlterForeignKeyWithNameContext) ConstraintOptsAlter() IConstraintOptsAlterContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstraintOptsAlterContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstraintOptsAlterContext)
}

func (s *AlterForeignKeyWithNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterForeignKeyWithNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AlterForeignKeyWithNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterAlterForeignKeyWithName(s)
	}
}

func (s *AlterForeignKeyWithNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitAlterForeignKeyWithName(s)
	}
}

func (s *AlterForeignKeyWithNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitAlterForeignKeyWithName(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) AlterForeignKeyWithName() (localctx IAlterForeignKeyWithNameContext) {
	localctx = NewAlterForeignKeyWithNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 304, HiveParserRULE_alterForeignKeyWithName)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2422)
		p.Match(HiveParserKW_CONSTRAINT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2423)

		var _x = p.Id_()


		localctx.(*AlterForeignKeyWithNameContext).constraintName = _x
	}
	{
		p.SetState(2424)
		p.Match(HiveParserKW_FOREIGN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2425)
		p.Match(HiveParserKW_KEY)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2426)

		var _x = p.ColumnParenthesesList()


		localctx.(*AlterForeignKeyWithNameContext).fkCols = _x
	}
	{
		p.SetState(2427)
		p.Match(HiveParserKW_REFERENCES)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2428)

		var _x = p.TableName()


		localctx.(*AlterForeignKeyWithNameContext).tabName = _x
	}
	{
		p.SetState(2429)

		var _x = p.ColumnParenthesesList()


		localctx.(*AlterForeignKeyWithNameContext).parCols = _x
	}
	p.SetState(2431)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if ((int64((_la - 91)) & ^0x3f) == 0 && ((int64(1) << (_la - 91)) & 10241) != 0) || _la == HiveParserKW_NOT {
		{
			p.SetState(2430)
			p.ConstraintOptsAlter()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISkewedValueElementContext is an interface to support dynamic dispatch.
type ISkewedValueElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SkewedColumnValues() ISkewedColumnValuesContext
	SkewedColumnValuePairList() ISkewedColumnValuePairListContext

	// IsSkewedValueElementContext differentiates from other interfaces.
	IsSkewedValueElementContext()
}

type SkewedValueElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySkewedValueElementContext() *SkewedValueElementContext {
	var p = new(SkewedValueElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_skewedValueElement
	return p
}

func InitEmptySkewedValueElementContext(p *SkewedValueElementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_skewedValueElement
}

func (*SkewedValueElementContext) IsSkewedValueElementContext() {}

func NewSkewedValueElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SkewedValueElementContext {
	var p = new(SkewedValueElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_skewedValueElement

	return p
}

func (s *SkewedValueElementContext) GetParser() antlr.Parser { return s.parser }

func (s *SkewedValueElementContext) SkewedColumnValues() ISkewedColumnValuesContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISkewedColumnValuesContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISkewedColumnValuesContext)
}

func (s *SkewedValueElementContext) SkewedColumnValuePairList() ISkewedColumnValuePairListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISkewedColumnValuePairListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISkewedColumnValuePairListContext)
}

func (s *SkewedValueElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SkewedValueElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SkewedValueElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterSkewedValueElement(s)
	}
}

func (s *SkewedValueElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitSkewedValueElement(s)
	}
}

func (s *SkewedValueElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitSkewedValueElement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) SkewedValueElement() (localctx ISkewedValueElementContext) {
	localctx = NewSkewedValueElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 306, HiveParserRULE_skewedValueElement)
	p.SetState(2435)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserKW_CURRENT_DATE, HiveParserKW_CURRENT_TIMESTAMP, HiveParserKW_DATE, HiveParserKW_FALSE, HiveParserKW_NULL, HiveParserKW_TIMESTAMP, HiveParserKW_TIMESTAMPLOCALTZ, HiveParserKW_TRUE, HiveParserQUESTION, HiveParserStringLiteral, HiveParserIntegralLiteral, HiveParserNumberLiteral, HiveParserNumber, HiveParserCharSetName:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2433)
			p.SkewedColumnValues()
		}


	case HiveParserLPAREN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2434)
			p.SkewedColumnValuePairList()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISkewedColumnValuePairListContext is an interface to support dynamic dispatch.
type ISkewedColumnValuePairListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSkewedColumnValuePair() []ISkewedColumnValuePairContext
	SkewedColumnValuePair(i int) ISkewedColumnValuePairContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsSkewedColumnValuePairListContext differentiates from other interfaces.
	IsSkewedColumnValuePairListContext()
}

type SkewedColumnValuePairListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySkewedColumnValuePairListContext() *SkewedColumnValuePairListContext {
	var p = new(SkewedColumnValuePairListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_skewedColumnValuePairList
	return p
}

func InitEmptySkewedColumnValuePairListContext(p *SkewedColumnValuePairListContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_skewedColumnValuePairList
}

func (*SkewedColumnValuePairListContext) IsSkewedColumnValuePairListContext() {}

func NewSkewedColumnValuePairListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SkewedColumnValuePairListContext {
	var p = new(SkewedColumnValuePairListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_skewedColumnValuePairList

	return p
}

func (s *SkewedColumnValuePairListContext) GetParser() antlr.Parser { return s.parser }

func (s *SkewedColumnValuePairListContext) AllSkewedColumnValuePair() []ISkewedColumnValuePairContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISkewedColumnValuePairContext); ok {
			len++
		}
	}

	tst := make([]ISkewedColumnValuePairContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISkewedColumnValuePairContext); ok {
			tst[i] = t.(ISkewedColumnValuePairContext)
			i++
		}
	}

	return tst
}

func (s *SkewedColumnValuePairListContext) SkewedColumnValuePair(i int) ISkewedColumnValuePairContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISkewedColumnValuePairContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISkewedColumnValuePairContext)
}

func (s *SkewedColumnValuePairListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(HiveParserCOMMA)
}

func (s *SkewedColumnValuePairListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserCOMMA, i)
}

func (s *SkewedColumnValuePairListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SkewedColumnValuePairListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SkewedColumnValuePairListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterSkewedColumnValuePairList(s)
	}
}

func (s *SkewedColumnValuePairListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitSkewedColumnValuePairList(s)
	}
}

func (s *SkewedColumnValuePairListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitSkewedColumnValuePairList(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) SkewedColumnValuePairList() (localctx ISkewedColumnValuePairListContext) {
	localctx = NewSkewedColumnValuePairListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 308, HiveParserRULE_skewedColumnValuePairList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2437)
		p.SkewedColumnValuePair()
	}
	p.SetState(2442)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HiveParserCOMMA {
		{
			p.SetState(2438)
			p.Match(HiveParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2439)
			p.SkewedColumnValuePair()
		}


		p.SetState(2444)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISkewedColumnValuePairContext is an interface to support dynamic dispatch.
type ISkewedColumnValuePairContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetColValues returns the colValues rule contexts.
	GetColValues() ISkewedColumnValuesContext


	// SetColValues sets the colValues rule contexts.
	SetColValues(ISkewedColumnValuesContext)


	// Getter signatures
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	SkewedColumnValues() ISkewedColumnValuesContext

	// IsSkewedColumnValuePairContext differentiates from other interfaces.
	IsSkewedColumnValuePairContext()
}

type SkewedColumnValuePairContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	colValues ISkewedColumnValuesContext 
}

func NewEmptySkewedColumnValuePairContext() *SkewedColumnValuePairContext {
	var p = new(SkewedColumnValuePairContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_skewedColumnValuePair
	return p
}

func InitEmptySkewedColumnValuePairContext(p *SkewedColumnValuePairContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_skewedColumnValuePair
}

func (*SkewedColumnValuePairContext) IsSkewedColumnValuePairContext() {}

func NewSkewedColumnValuePairContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SkewedColumnValuePairContext {
	var p = new(SkewedColumnValuePairContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_skewedColumnValuePair

	return p
}

func (s *SkewedColumnValuePairContext) GetParser() antlr.Parser { return s.parser }

func (s *SkewedColumnValuePairContext) GetColValues() ISkewedColumnValuesContext { return s.colValues }


func (s *SkewedColumnValuePairContext) SetColValues(v ISkewedColumnValuesContext) { s.colValues = v }


func (s *SkewedColumnValuePairContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserLPAREN, 0)
}

func (s *SkewedColumnValuePairContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserRPAREN, 0)
}

func (s *SkewedColumnValuePairContext) SkewedColumnValues() ISkewedColumnValuesContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISkewedColumnValuesContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISkewedColumnValuesContext)
}

func (s *SkewedColumnValuePairContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SkewedColumnValuePairContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SkewedColumnValuePairContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterSkewedColumnValuePair(s)
	}
}

func (s *SkewedColumnValuePairContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitSkewedColumnValuePair(s)
	}
}

func (s *SkewedColumnValuePairContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitSkewedColumnValuePair(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) SkewedColumnValuePair() (localctx ISkewedColumnValuePairContext) {
	localctx = NewSkewedColumnValuePairContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 310, HiveParserRULE_skewedColumnValuePair)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2445)
		p.Match(HiveParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2446)

		var _x = p.SkewedColumnValues()


		localctx.(*SkewedColumnValuePairContext).colValues = _x
	}
	{
		p.SetState(2447)
		p.Match(HiveParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISkewedColumnValuesContext is an interface to support dynamic dispatch.
type ISkewedColumnValuesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSkewedColumnValue() []ISkewedColumnValueContext
	SkewedColumnValue(i int) ISkewedColumnValueContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsSkewedColumnValuesContext differentiates from other interfaces.
	IsSkewedColumnValuesContext()
}

type SkewedColumnValuesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySkewedColumnValuesContext() *SkewedColumnValuesContext {
	var p = new(SkewedColumnValuesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_skewedColumnValues
	return p
}

func InitEmptySkewedColumnValuesContext(p *SkewedColumnValuesContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_skewedColumnValues
}

func (*SkewedColumnValuesContext) IsSkewedColumnValuesContext() {}

func NewSkewedColumnValuesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SkewedColumnValuesContext {
	var p = new(SkewedColumnValuesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_skewedColumnValues

	return p
}

func (s *SkewedColumnValuesContext) GetParser() antlr.Parser { return s.parser }

func (s *SkewedColumnValuesContext) AllSkewedColumnValue() []ISkewedColumnValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISkewedColumnValueContext); ok {
			len++
		}
	}

	tst := make([]ISkewedColumnValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISkewedColumnValueContext); ok {
			tst[i] = t.(ISkewedColumnValueContext)
			i++
		}
	}

	return tst
}

func (s *SkewedColumnValuesContext) SkewedColumnValue(i int) ISkewedColumnValueContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISkewedColumnValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISkewedColumnValueContext)
}

func (s *SkewedColumnValuesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(HiveParserCOMMA)
}

func (s *SkewedColumnValuesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserCOMMA, i)
}

func (s *SkewedColumnValuesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SkewedColumnValuesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SkewedColumnValuesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterSkewedColumnValues(s)
	}
}

func (s *SkewedColumnValuesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitSkewedColumnValues(s)
	}
}

func (s *SkewedColumnValuesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitSkewedColumnValues(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) SkewedColumnValues() (localctx ISkewedColumnValuesContext) {
	localctx = NewSkewedColumnValuesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 312, HiveParserRULE_skewedColumnValues)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2449)
		p.SkewedColumnValue()
	}
	p.SetState(2454)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HiveParserCOMMA {
		{
			p.SetState(2450)
			p.Match(HiveParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2451)
			p.SkewedColumnValue()
		}


		p.SetState(2456)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISkewedColumnValueContext is an interface to support dynamic dispatch.
type ISkewedColumnValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Constant() IConstantContext

	// IsSkewedColumnValueContext differentiates from other interfaces.
	IsSkewedColumnValueContext()
}

type SkewedColumnValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySkewedColumnValueContext() *SkewedColumnValueContext {
	var p = new(SkewedColumnValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_skewedColumnValue
	return p
}

func InitEmptySkewedColumnValueContext(p *SkewedColumnValueContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_skewedColumnValue
}

func (*SkewedColumnValueContext) IsSkewedColumnValueContext() {}

func NewSkewedColumnValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SkewedColumnValueContext {
	var p = new(SkewedColumnValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_skewedColumnValue

	return p
}

func (s *SkewedColumnValueContext) GetParser() antlr.Parser { return s.parser }

func (s *SkewedColumnValueContext) Constant() IConstantContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *SkewedColumnValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SkewedColumnValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SkewedColumnValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterSkewedColumnValue(s)
	}
}

func (s *SkewedColumnValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitSkewedColumnValue(s)
	}
}

func (s *SkewedColumnValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitSkewedColumnValue(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) SkewedColumnValue() (localctx ISkewedColumnValueContext) {
	localctx = NewSkewedColumnValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 314, HiveParserRULE_skewedColumnValue)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2457)
		p.Constant()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISkewedValueLocationElementContext is an interface to support dynamic dispatch.
type ISkewedValueLocationElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SkewedColumnValue() ISkewedColumnValueContext
	SkewedColumnValuePair() ISkewedColumnValuePairContext

	// IsSkewedValueLocationElementContext differentiates from other interfaces.
	IsSkewedValueLocationElementContext()
}

type SkewedValueLocationElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySkewedValueLocationElementContext() *SkewedValueLocationElementContext {
	var p = new(SkewedValueLocationElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_skewedValueLocationElement
	return p
}

func InitEmptySkewedValueLocationElementContext(p *SkewedValueLocationElementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_skewedValueLocationElement
}

func (*SkewedValueLocationElementContext) IsSkewedValueLocationElementContext() {}

func NewSkewedValueLocationElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SkewedValueLocationElementContext {
	var p = new(SkewedValueLocationElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_skewedValueLocationElement

	return p
}

func (s *SkewedValueLocationElementContext) GetParser() antlr.Parser { return s.parser }

func (s *SkewedValueLocationElementContext) SkewedColumnValue() ISkewedColumnValueContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISkewedColumnValueContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISkewedColumnValueContext)
}

func (s *SkewedValueLocationElementContext) SkewedColumnValuePair() ISkewedColumnValuePairContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISkewedColumnValuePairContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISkewedColumnValuePairContext)
}

func (s *SkewedValueLocationElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SkewedValueLocationElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SkewedValueLocationElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterSkewedValueLocationElement(s)
	}
}

func (s *SkewedValueLocationElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitSkewedValueLocationElement(s)
	}
}

func (s *SkewedValueLocationElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitSkewedValueLocationElement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) SkewedValueLocationElement() (localctx ISkewedValueLocationElementContext) {
	localctx = NewSkewedValueLocationElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 316, HiveParserRULE_skewedValueLocationElement)
	p.SetState(2461)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserKW_CURRENT_DATE, HiveParserKW_CURRENT_TIMESTAMP, HiveParserKW_DATE, HiveParserKW_FALSE, HiveParserKW_NULL, HiveParserKW_TIMESTAMP, HiveParserKW_TIMESTAMPLOCALTZ, HiveParserKW_TRUE, HiveParserQUESTION, HiveParserStringLiteral, HiveParserIntegralLiteral, HiveParserNumberLiteral, HiveParserNumber, HiveParserCharSetName:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2459)
			p.SkewedColumnValue()
		}


	case HiveParserLPAREN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2460)
			p.SkewedColumnValuePair()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IOrderSpecificationContext is an interface to support dynamic dispatch.
type IOrderSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_ASC() antlr.TerminalNode
	KW_DESC() antlr.TerminalNode

	// IsOrderSpecificationContext differentiates from other interfaces.
	IsOrderSpecificationContext()
}

type OrderSpecificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrderSpecificationContext() *OrderSpecificationContext {
	var p = new(OrderSpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_orderSpecification
	return p
}

func InitEmptyOrderSpecificationContext(p *OrderSpecificationContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_orderSpecification
}

func (*OrderSpecificationContext) IsOrderSpecificationContext() {}

func NewOrderSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrderSpecificationContext {
	var p = new(OrderSpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_orderSpecification

	return p
}

func (s *OrderSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *OrderSpecificationContext) KW_ASC() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ASC, 0)
}

func (s *OrderSpecificationContext) KW_DESC() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DESC, 0)
}

func (s *OrderSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrderSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OrderSpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterOrderSpecification(s)
	}
}

func (s *OrderSpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitOrderSpecification(s)
	}
}

func (s *OrderSpecificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitOrderSpecification(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) OrderSpecification() (localctx IOrderSpecificationContext) {
	localctx = NewOrderSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 318, HiveParserRULE_orderSpecification)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2463)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HiveParserKW_ASC || _la == HiveParserKW_DESC) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// INullOrderingContext is an interface to support dynamic dispatch.
type INullOrderingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_NULLS() antlr.TerminalNode
	KW_FIRST() antlr.TerminalNode
	KW_LAST() antlr.TerminalNode

	// IsNullOrderingContext differentiates from other interfaces.
	IsNullOrderingContext()
}

type NullOrderingContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNullOrderingContext() *NullOrderingContext {
	var p = new(NullOrderingContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_nullOrdering
	return p
}

func InitEmptyNullOrderingContext(p *NullOrderingContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_nullOrdering
}

func (*NullOrderingContext) IsNullOrderingContext() {}

func NewNullOrderingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NullOrderingContext {
	var p = new(NullOrderingContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_nullOrdering

	return p
}

func (s *NullOrderingContext) GetParser() antlr.Parser { return s.parser }

func (s *NullOrderingContext) KW_NULLS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_NULLS, 0)
}

func (s *NullOrderingContext) KW_FIRST() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_FIRST, 0)
}

func (s *NullOrderingContext) KW_LAST() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_LAST, 0)
}

func (s *NullOrderingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullOrderingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *NullOrderingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterNullOrdering(s)
	}
}

func (s *NullOrderingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitNullOrdering(s)
	}
}

func (s *NullOrderingContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitNullOrdering(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) NullOrdering() (localctx INullOrderingContext) {
	localctx = NewNullOrderingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 320, HiveParserRULE_nullOrdering)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2465)
		p.Match(HiveParserKW_NULLS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2466)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HiveParserKW_FIRST || _la == HiveParserKW_LAST) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IColumnNameOrderContext is an interface to support dynamic dispatch.
type IColumnNameOrderContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOrderSpec returns the orderSpec rule contexts.
	GetOrderSpec() IOrderSpecificationContext

	// GetNullSpec returns the nullSpec rule contexts.
	GetNullSpec() INullOrderingContext


	// SetOrderSpec sets the orderSpec rule contexts.
	SetOrderSpec(IOrderSpecificationContext)

	// SetNullSpec sets the nullSpec rule contexts.
	SetNullSpec(INullOrderingContext)


	// Getter signatures
	Id_() IId_Context
	OrderSpecification() IOrderSpecificationContext
	NullOrdering() INullOrderingContext

	// IsColumnNameOrderContext differentiates from other interfaces.
	IsColumnNameOrderContext()
}

type ColumnNameOrderContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	orderSpec IOrderSpecificationContext 
	nullSpec INullOrderingContext 
}

func NewEmptyColumnNameOrderContext() *ColumnNameOrderContext {
	var p = new(ColumnNameOrderContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_columnNameOrder
	return p
}

func InitEmptyColumnNameOrderContext(p *ColumnNameOrderContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_columnNameOrder
}

func (*ColumnNameOrderContext) IsColumnNameOrderContext() {}

func NewColumnNameOrderContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnNameOrderContext {
	var p = new(ColumnNameOrderContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_columnNameOrder

	return p
}

func (s *ColumnNameOrderContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnNameOrderContext) GetOrderSpec() IOrderSpecificationContext { return s.orderSpec }

func (s *ColumnNameOrderContext) GetNullSpec() INullOrderingContext { return s.nullSpec }


func (s *ColumnNameOrderContext) SetOrderSpec(v IOrderSpecificationContext) { s.orderSpec = v }

func (s *ColumnNameOrderContext) SetNullSpec(v INullOrderingContext) { s.nullSpec = v }


func (s *ColumnNameOrderContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *ColumnNameOrderContext) OrderSpecification() IOrderSpecificationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderSpecificationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderSpecificationContext)
}

func (s *ColumnNameOrderContext) NullOrdering() INullOrderingContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INullOrderingContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INullOrderingContext)
}

func (s *ColumnNameOrderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnNameOrderContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ColumnNameOrderContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterColumnNameOrder(s)
	}
}

func (s *ColumnNameOrderContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitColumnNameOrder(s)
	}
}

func (s *ColumnNameOrderContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitColumnNameOrder(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ColumnNameOrder() (localctx IColumnNameOrderContext) {
	localctx = NewColumnNameOrderContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 322, HiveParserRULE_columnNameOrder)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2468)
		p.Id_()
	}
	p.SetState(2470)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_ASC || _la == HiveParserKW_DESC {
		{
			p.SetState(2469)

			var _x = p.OrderSpecification()


			localctx.(*ColumnNameOrderContext).orderSpec = _x
		}

	}
	p.SetState(2473)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_NULLS {
		{
			p.SetState(2472)

			var _x = p.NullOrdering()


			localctx.(*ColumnNameOrderContext).nullSpec = _x
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IColumnNameCommentListContext is an interface to support dynamic dispatch.
type IColumnNameCommentListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllColumnNameComment() []IColumnNameCommentContext
	ColumnNameComment(i int) IColumnNameCommentContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsColumnNameCommentListContext differentiates from other interfaces.
	IsColumnNameCommentListContext()
}

type ColumnNameCommentListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnNameCommentListContext() *ColumnNameCommentListContext {
	var p = new(ColumnNameCommentListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_columnNameCommentList
	return p
}

func InitEmptyColumnNameCommentListContext(p *ColumnNameCommentListContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_columnNameCommentList
}

func (*ColumnNameCommentListContext) IsColumnNameCommentListContext() {}

func NewColumnNameCommentListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnNameCommentListContext {
	var p = new(ColumnNameCommentListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_columnNameCommentList

	return p
}

func (s *ColumnNameCommentListContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnNameCommentListContext) AllColumnNameComment() []IColumnNameCommentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnNameCommentContext); ok {
			len++
		}
	}

	tst := make([]IColumnNameCommentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnNameCommentContext); ok {
			tst[i] = t.(IColumnNameCommentContext)
			i++
		}
	}

	return tst
}

func (s *ColumnNameCommentListContext) ColumnNameComment(i int) IColumnNameCommentContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNameCommentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNameCommentContext)
}

func (s *ColumnNameCommentListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(HiveParserCOMMA)
}

func (s *ColumnNameCommentListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserCOMMA, i)
}

func (s *ColumnNameCommentListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnNameCommentListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ColumnNameCommentListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterColumnNameCommentList(s)
	}
}

func (s *ColumnNameCommentListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitColumnNameCommentList(s)
	}
}

func (s *ColumnNameCommentListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitColumnNameCommentList(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ColumnNameCommentList() (localctx IColumnNameCommentListContext) {
	localctx = NewColumnNameCommentListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 324, HiveParserRULE_columnNameCommentList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2475)
		p.ColumnNameComment()
	}
	p.SetState(2480)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HiveParserCOMMA {
		{
			p.SetState(2476)
			p.Match(HiveParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2477)
			p.ColumnNameComment()
		}


		p.SetState(2482)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IColumnNameCommentContext is an interface to support dynamic dispatch.
type IColumnNameCommentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetComment returns the comment token.
	GetComment() antlr.Token 


	// SetComment sets the comment token.
	SetComment(antlr.Token) 


	// GetColName returns the colName rule contexts.
	GetColName() IId_Context


	// SetColName sets the colName rule contexts.
	SetColName(IId_Context)


	// Getter signatures
	Id_() IId_Context
	KW_COMMENT() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode

	// IsColumnNameCommentContext differentiates from other interfaces.
	IsColumnNameCommentContext()
}

type ColumnNameCommentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	colName IId_Context 
	comment antlr.Token
}

func NewEmptyColumnNameCommentContext() *ColumnNameCommentContext {
	var p = new(ColumnNameCommentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_columnNameComment
	return p
}

func InitEmptyColumnNameCommentContext(p *ColumnNameCommentContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_columnNameComment
}

func (*ColumnNameCommentContext) IsColumnNameCommentContext() {}

func NewColumnNameCommentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnNameCommentContext {
	var p = new(ColumnNameCommentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_columnNameComment

	return p
}

func (s *ColumnNameCommentContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnNameCommentContext) GetComment() antlr.Token { return s.comment }


func (s *ColumnNameCommentContext) SetComment(v antlr.Token) { s.comment = v }


func (s *ColumnNameCommentContext) GetColName() IId_Context { return s.colName }


func (s *ColumnNameCommentContext) SetColName(v IId_Context) { s.colName = v }


func (s *ColumnNameCommentContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *ColumnNameCommentContext) KW_COMMENT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_COMMENT, 0)
}

func (s *ColumnNameCommentContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(HiveParserStringLiteral, 0)
}

func (s *ColumnNameCommentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnNameCommentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ColumnNameCommentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterColumnNameComment(s)
	}
}

func (s *ColumnNameCommentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitColumnNameComment(s)
	}
}

func (s *ColumnNameCommentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitColumnNameComment(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ColumnNameComment() (localctx IColumnNameCommentContext) {
	localctx = NewColumnNameCommentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 326, HiveParserRULE_columnNameComment)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2483)

		var _x = p.Id_()


		localctx.(*ColumnNameCommentContext).colName = _x
	}
	p.SetState(2486)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_COMMENT {
		{
			p.SetState(2484)
			p.Match(HiveParserKW_COMMENT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2485)

			var _m = p.Match(HiveParserStringLiteral)

			localctx.(*ColumnNameCommentContext).comment = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IOrderSpecificationRewriteContext is an interface to support dynamic dispatch.
type IOrderSpecificationRewriteContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_ASC() antlr.TerminalNode
	KW_DESC() antlr.TerminalNode

	// IsOrderSpecificationRewriteContext differentiates from other interfaces.
	IsOrderSpecificationRewriteContext()
}

type OrderSpecificationRewriteContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrderSpecificationRewriteContext() *OrderSpecificationRewriteContext {
	var p = new(OrderSpecificationRewriteContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_orderSpecificationRewrite
	return p
}

func InitEmptyOrderSpecificationRewriteContext(p *OrderSpecificationRewriteContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_orderSpecificationRewrite
}

func (*OrderSpecificationRewriteContext) IsOrderSpecificationRewriteContext() {}

func NewOrderSpecificationRewriteContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrderSpecificationRewriteContext {
	var p = new(OrderSpecificationRewriteContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_orderSpecificationRewrite

	return p
}

func (s *OrderSpecificationRewriteContext) GetParser() antlr.Parser { return s.parser }

func (s *OrderSpecificationRewriteContext) KW_ASC() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ASC, 0)
}

func (s *OrderSpecificationRewriteContext) KW_DESC() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DESC, 0)
}

func (s *OrderSpecificationRewriteContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrderSpecificationRewriteContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OrderSpecificationRewriteContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterOrderSpecificationRewrite(s)
	}
}

func (s *OrderSpecificationRewriteContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitOrderSpecificationRewrite(s)
	}
}

func (s *OrderSpecificationRewriteContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitOrderSpecificationRewrite(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) OrderSpecificationRewrite() (localctx IOrderSpecificationRewriteContext) {
	localctx = NewOrderSpecificationRewriteContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 328, HiveParserRULE_orderSpecificationRewrite)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2488)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HiveParserKW_ASC || _la == HiveParserKW_DESC) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IColumnRefOrderContext is an interface to support dynamic dispatch.
type IColumnRefOrderContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOrderSpec returns the orderSpec rule contexts.
	GetOrderSpec() IOrderSpecificationRewriteContext

	// GetNullSpec returns the nullSpec rule contexts.
	GetNullSpec() INullOrderingContext


	// SetOrderSpec sets the orderSpec rule contexts.
	SetOrderSpec(IOrderSpecificationRewriteContext)

	// SetNullSpec sets the nullSpec rule contexts.
	SetNullSpec(INullOrderingContext)


	// Getter signatures
	Expression() IExpressionContext
	OrderSpecificationRewrite() IOrderSpecificationRewriteContext
	NullOrdering() INullOrderingContext

	// IsColumnRefOrderContext differentiates from other interfaces.
	IsColumnRefOrderContext()
}

type ColumnRefOrderContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	orderSpec IOrderSpecificationRewriteContext 
	nullSpec INullOrderingContext 
}

func NewEmptyColumnRefOrderContext() *ColumnRefOrderContext {
	var p = new(ColumnRefOrderContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_columnRefOrder
	return p
}

func InitEmptyColumnRefOrderContext(p *ColumnRefOrderContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_columnRefOrder
}

func (*ColumnRefOrderContext) IsColumnRefOrderContext() {}

func NewColumnRefOrderContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnRefOrderContext {
	var p = new(ColumnRefOrderContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_columnRefOrder

	return p
}

func (s *ColumnRefOrderContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnRefOrderContext) GetOrderSpec() IOrderSpecificationRewriteContext { return s.orderSpec }

func (s *ColumnRefOrderContext) GetNullSpec() INullOrderingContext { return s.nullSpec }


func (s *ColumnRefOrderContext) SetOrderSpec(v IOrderSpecificationRewriteContext) { s.orderSpec = v }

func (s *ColumnRefOrderContext) SetNullSpec(v INullOrderingContext) { s.nullSpec = v }


func (s *ColumnRefOrderContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ColumnRefOrderContext) OrderSpecificationRewrite() IOrderSpecificationRewriteContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderSpecificationRewriteContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderSpecificationRewriteContext)
}

func (s *ColumnRefOrderContext) NullOrdering() INullOrderingContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INullOrderingContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INullOrderingContext)
}

func (s *ColumnRefOrderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnRefOrderContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ColumnRefOrderContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterColumnRefOrder(s)
	}
}

func (s *ColumnRefOrderContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitColumnRefOrder(s)
	}
}

func (s *ColumnRefOrderContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitColumnRefOrder(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ColumnRefOrder() (localctx IColumnRefOrderContext) {
	localctx = NewColumnRefOrderContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 330, HiveParserRULE_columnRefOrder)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2490)
		p.Expression()
	}
	p.SetState(2492)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_ASC || _la == HiveParserKW_DESC {
		{
			p.SetState(2491)

			var _x = p.OrderSpecificationRewrite()


			localctx.(*ColumnRefOrderContext).orderSpec = _x
		}

	}
	p.SetState(2495)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_NULLS {
		{
			p.SetState(2494)

			var _x = p.NullOrdering()


			localctx.(*ColumnRefOrderContext).nullSpec = _x
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IColumnNameTypeContext is an interface to support dynamic dispatch.
type IColumnNameTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetComment returns the comment token.
	GetComment() antlr.Token 


	// SetComment sets the comment token.
	SetComment(antlr.Token) 


	// GetColName returns the colName rule contexts.
	GetColName() IId_Context


	// SetColName sets the colName rule contexts.
	SetColName(IId_Context)


	// Getter signatures
	ColType() IColTypeContext
	Id_() IId_Context
	KW_COMMENT() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode

	// IsColumnNameTypeContext differentiates from other interfaces.
	IsColumnNameTypeContext()
}

type ColumnNameTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	colName IId_Context 
	comment antlr.Token
}

func NewEmptyColumnNameTypeContext() *ColumnNameTypeContext {
	var p = new(ColumnNameTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_columnNameType
	return p
}

func InitEmptyColumnNameTypeContext(p *ColumnNameTypeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_columnNameType
}

func (*ColumnNameTypeContext) IsColumnNameTypeContext() {}

func NewColumnNameTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnNameTypeContext {
	var p = new(ColumnNameTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_columnNameType

	return p
}

func (s *ColumnNameTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnNameTypeContext) GetComment() antlr.Token { return s.comment }


func (s *ColumnNameTypeContext) SetComment(v antlr.Token) { s.comment = v }


func (s *ColumnNameTypeContext) GetColName() IId_Context { return s.colName }


func (s *ColumnNameTypeContext) SetColName(v IId_Context) { s.colName = v }


func (s *ColumnNameTypeContext) ColType() IColTypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColTypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColTypeContext)
}

func (s *ColumnNameTypeContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *ColumnNameTypeContext) KW_COMMENT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_COMMENT, 0)
}

func (s *ColumnNameTypeContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(HiveParserStringLiteral, 0)
}

func (s *ColumnNameTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnNameTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ColumnNameTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterColumnNameType(s)
	}
}

func (s *ColumnNameTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitColumnNameType(s)
	}
}

func (s *ColumnNameTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitColumnNameType(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ColumnNameType() (localctx IColumnNameTypeContext) {
	localctx = NewColumnNameTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 332, HiveParserRULE_columnNameType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2497)

		var _x = p.Id_()


		localctx.(*ColumnNameTypeContext).colName = _x
	}
	{
		p.SetState(2498)
		p.ColType()
	}
	p.SetState(2501)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_COMMENT {
		{
			p.SetState(2499)
			p.Match(HiveParserKW_COMMENT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2500)

			var _m = p.Match(HiveParserStringLiteral)

			localctx.(*ColumnNameTypeContext).comment = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IColumnNameTypeOrConstraintContext is an interface to support dynamic dispatch.
type IColumnNameTypeOrConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TableConstraint() ITableConstraintContext
	ColumnNameTypeConstraint() IColumnNameTypeConstraintContext

	// IsColumnNameTypeOrConstraintContext differentiates from other interfaces.
	IsColumnNameTypeOrConstraintContext()
}

type ColumnNameTypeOrConstraintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnNameTypeOrConstraintContext() *ColumnNameTypeOrConstraintContext {
	var p = new(ColumnNameTypeOrConstraintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_columnNameTypeOrConstraint
	return p
}

func InitEmptyColumnNameTypeOrConstraintContext(p *ColumnNameTypeOrConstraintContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_columnNameTypeOrConstraint
}

func (*ColumnNameTypeOrConstraintContext) IsColumnNameTypeOrConstraintContext() {}

func NewColumnNameTypeOrConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnNameTypeOrConstraintContext {
	var p = new(ColumnNameTypeOrConstraintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_columnNameTypeOrConstraint

	return p
}

func (s *ColumnNameTypeOrConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnNameTypeOrConstraintContext) TableConstraint() ITableConstraintContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableConstraintContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableConstraintContext)
}

func (s *ColumnNameTypeOrConstraintContext) ColumnNameTypeConstraint() IColumnNameTypeConstraintContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNameTypeConstraintContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNameTypeConstraintContext)
}

func (s *ColumnNameTypeOrConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnNameTypeOrConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ColumnNameTypeOrConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterColumnNameTypeOrConstraint(s)
	}
}

func (s *ColumnNameTypeOrConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitColumnNameTypeOrConstraint(s)
	}
}

func (s *ColumnNameTypeOrConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitColumnNameTypeOrConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ColumnNameTypeOrConstraint() (localctx IColumnNameTypeOrConstraintContext) {
	localctx = NewColumnNameTypeOrConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 334, HiveParserRULE_columnNameTypeOrConstraint)
	p.SetState(2505)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 217, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2503)
			p.TableConstraint()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2504)
			p.ColumnNameTypeConstraint()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITableConstraintContext is an interface to support dynamic dispatch.
type ITableConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CreateForeignKey() ICreateForeignKeyContext
	CreateConstraint() ICreateConstraintContext

	// IsTableConstraintContext differentiates from other interfaces.
	IsTableConstraintContext()
}

type TableConstraintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableConstraintContext() *TableConstraintContext {
	var p = new(TableConstraintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_tableConstraint
	return p
}

func InitEmptyTableConstraintContext(p *TableConstraintContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_tableConstraint
}

func (*TableConstraintContext) IsTableConstraintContext() {}

func NewTableConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableConstraintContext {
	var p = new(TableConstraintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_tableConstraint

	return p
}

func (s *TableConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *TableConstraintContext) CreateForeignKey() ICreateForeignKeyContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateForeignKeyContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateForeignKeyContext)
}

func (s *TableConstraintContext) CreateConstraint() ICreateConstraintContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateConstraintContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateConstraintContext)
}

func (s *TableConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TableConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterTableConstraint(s)
	}
}

func (s *TableConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitTableConstraint(s)
	}
}

func (s *TableConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitTableConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) TableConstraint() (localctx ITableConstraintContext) {
	localctx = NewTableConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 336, HiveParserRULE_tableConstraint)
	p.SetState(2509)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 218, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2507)
			p.CreateForeignKey()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2508)
			p.CreateConstraint()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IColumnNameTypeConstraintContext is an interface to support dynamic dispatch.
type IColumnNameTypeConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetComment returns the comment token.
	GetComment() antlr.Token 


	// SetComment sets the comment token.
	SetComment(antlr.Token) 


	// GetColName returns the colName rule contexts.
	GetColName() IId_Context


	// SetColName sets the colName rule contexts.
	SetColName(IId_Context)


	// Getter signatures
	ColType() IColTypeContext
	Id_() IId_Context
	ColumnConstraint() IColumnConstraintContext
	KW_COMMENT() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode

	// IsColumnNameTypeConstraintContext differentiates from other interfaces.
	IsColumnNameTypeConstraintContext()
}

type ColumnNameTypeConstraintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	colName IId_Context 
	comment antlr.Token
}

func NewEmptyColumnNameTypeConstraintContext() *ColumnNameTypeConstraintContext {
	var p = new(ColumnNameTypeConstraintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_columnNameTypeConstraint
	return p
}

func InitEmptyColumnNameTypeConstraintContext(p *ColumnNameTypeConstraintContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_columnNameTypeConstraint
}

func (*ColumnNameTypeConstraintContext) IsColumnNameTypeConstraintContext() {}

func NewColumnNameTypeConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnNameTypeConstraintContext {
	var p = new(ColumnNameTypeConstraintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_columnNameTypeConstraint

	return p
}

func (s *ColumnNameTypeConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnNameTypeConstraintContext) GetComment() antlr.Token { return s.comment }


func (s *ColumnNameTypeConstraintContext) SetComment(v antlr.Token) { s.comment = v }


func (s *ColumnNameTypeConstraintContext) GetColName() IId_Context { return s.colName }


func (s *ColumnNameTypeConstraintContext) SetColName(v IId_Context) { s.colName = v }


func (s *ColumnNameTypeConstraintContext) ColType() IColTypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColTypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColTypeContext)
}

func (s *ColumnNameTypeConstraintContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *ColumnNameTypeConstraintContext) ColumnConstraint() IColumnConstraintContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnConstraintContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnConstraintContext)
}

func (s *ColumnNameTypeConstraintContext) KW_COMMENT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_COMMENT, 0)
}

func (s *ColumnNameTypeConstraintContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(HiveParserStringLiteral, 0)
}

func (s *ColumnNameTypeConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnNameTypeConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ColumnNameTypeConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterColumnNameTypeConstraint(s)
	}
}

func (s *ColumnNameTypeConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitColumnNameTypeConstraint(s)
	}
}

func (s *ColumnNameTypeConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitColumnNameTypeConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ColumnNameTypeConstraint() (localctx IColumnNameTypeConstraintContext) {
	localctx = NewColumnNameTypeConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 338, HiveParserRULE_columnNameTypeConstraint)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2511)

		var _x = p.Id_()


		localctx.(*ColumnNameTypeConstraintContext).colName = _x
	}
	{
		p.SetState(2512)
		p.ColType()
	}
	p.SetState(2514)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if ((int64((_la - 40)) & ^0x3f) == 0 && ((int64(1) << (_la - 40)) & 1099511660545) != 0) || ((int64((_la - 206)) & ^0x3f) == 0 && ((int64(1) << (_la - 206)) & 9007233614479361) != 0) || _la == HiveParserKW_UNIQUE {
		{
			p.SetState(2513)
			p.ColumnConstraint()
		}

	}
	p.SetState(2518)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_COMMENT {
		{
			p.SetState(2516)
			p.Match(HiveParserKW_COMMENT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2517)

			var _m = p.Match(HiveParserStringLiteral)

			localctx.(*ColumnNameTypeConstraintContext).comment = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IColumnConstraintContext is an interface to support dynamic dispatch.
type IColumnConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ForeignKeyConstraint() IForeignKeyConstraintContext
	ColConstraint() IColConstraintContext

	// IsColumnConstraintContext differentiates from other interfaces.
	IsColumnConstraintContext()
}

type ColumnConstraintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnConstraintContext() *ColumnConstraintContext {
	var p = new(ColumnConstraintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_columnConstraint
	return p
}

func InitEmptyColumnConstraintContext(p *ColumnConstraintContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_columnConstraint
}

func (*ColumnConstraintContext) IsColumnConstraintContext() {}

func NewColumnConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnConstraintContext {
	var p = new(ColumnConstraintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_columnConstraint

	return p
}

func (s *ColumnConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnConstraintContext) ForeignKeyConstraint() IForeignKeyConstraintContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForeignKeyConstraintContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForeignKeyConstraintContext)
}

func (s *ColumnConstraintContext) ColConstraint() IColConstraintContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColConstraintContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColConstraintContext)
}

func (s *ColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterColumnConstraint(s)
	}
}

func (s *ColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitColumnConstraint(s)
	}
}

func (s *ColumnConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitColumnConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ColumnConstraint() (localctx IColumnConstraintContext) {
	localctx = NewColumnConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 340, HiveParserRULE_columnConstraint)
	p.SetState(2522)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 221, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2520)
			p.ForeignKeyConstraint()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2521)
			p.ColConstraint()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IForeignKeyConstraintContext is an interface to support dynamic dispatch.
type IForeignKeyConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetConstraintName returns the constraintName rule contexts.
	GetConstraintName() IId_Context

	// GetTabName returns the tabName rule contexts.
	GetTabName() ITableNameContext

	// GetColName returns the colName rule contexts.
	GetColName() IColumnNameContext


	// SetConstraintName sets the constraintName rule contexts.
	SetConstraintName(IId_Context)

	// SetTabName sets the tabName rule contexts.
	SetTabName(ITableNameContext)

	// SetColName sets the colName rule contexts.
	SetColName(IColumnNameContext)


	// Getter signatures
	KW_REFERENCES() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	TableName() ITableNameContext
	ColumnName() IColumnNameContext
	KW_CONSTRAINT() antlr.TerminalNode
	ConstraintOptsCreate() IConstraintOptsCreateContext
	Id_() IId_Context

	// IsForeignKeyConstraintContext differentiates from other interfaces.
	IsForeignKeyConstraintContext()
}

type ForeignKeyConstraintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	constraintName IId_Context 
	tabName ITableNameContext 
	colName IColumnNameContext 
}

func NewEmptyForeignKeyConstraintContext() *ForeignKeyConstraintContext {
	var p = new(ForeignKeyConstraintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_foreignKeyConstraint
	return p
}

func InitEmptyForeignKeyConstraintContext(p *ForeignKeyConstraintContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_foreignKeyConstraint
}

func (*ForeignKeyConstraintContext) IsForeignKeyConstraintContext() {}

func NewForeignKeyConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForeignKeyConstraintContext {
	var p = new(ForeignKeyConstraintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_foreignKeyConstraint

	return p
}

func (s *ForeignKeyConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *ForeignKeyConstraintContext) GetConstraintName() IId_Context { return s.constraintName }

func (s *ForeignKeyConstraintContext) GetTabName() ITableNameContext { return s.tabName }

func (s *ForeignKeyConstraintContext) GetColName() IColumnNameContext { return s.colName }


func (s *ForeignKeyConstraintContext) SetConstraintName(v IId_Context) { s.constraintName = v }

func (s *ForeignKeyConstraintContext) SetTabName(v ITableNameContext) { s.tabName = v }

func (s *ForeignKeyConstraintContext) SetColName(v IColumnNameContext) { s.colName = v }


func (s *ForeignKeyConstraintContext) KW_REFERENCES() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_REFERENCES, 0)
}

func (s *ForeignKeyConstraintContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserLPAREN, 0)
}

func (s *ForeignKeyConstraintContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserRPAREN, 0)
}

func (s *ForeignKeyConstraintContext) TableName() ITableNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *ForeignKeyConstraintContext) ColumnName() IColumnNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNameContext)
}

func (s *ForeignKeyConstraintContext) KW_CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_CONSTRAINT, 0)
}

func (s *ForeignKeyConstraintContext) ConstraintOptsCreate() IConstraintOptsCreateContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstraintOptsCreateContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstraintOptsCreateContext)
}

func (s *ForeignKeyConstraintContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *ForeignKeyConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForeignKeyConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ForeignKeyConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterForeignKeyConstraint(s)
	}
}

func (s *ForeignKeyConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitForeignKeyConstraint(s)
	}
}

func (s *ForeignKeyConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitForeignKeyConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ForeignKeyConstraint() (localctx IForeignKeyConstraintContext) {
	localctx = NewForeignKeyConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 342, HiveParserRULE_foreignKeyConstraint)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2526)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_CONSTRAINT {
		{
			p.SetState(2524)
			p.Match(HiveParserKW_CONSTRAINT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2525)

			var _x = p.Id_()


			localctx.(*ForeignKeyConstraintContext).constraintName = _x
		}

	}
	{
		p.SetState(2528)
		p.Match(HiveParserKW_REFERENCES)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2529)

		var _x = p.TableName()


		localctx.(*ForeignKeyConstraintContext).tabName = _x
	}
	{
		p.SetState(2530)
		p.Match(HiveParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2531)

		var _x = p.ColumnName()


		localctx.(*ForeignKeyConstraintContext).colName = _x
	}
	{
		p.SetState(2532)
		p.Match(HiveParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(2534)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if ((int64((_la - 91)) & ^0x3f) == 0 && ((int64(1) << (_la - 91)) & 10241) != 0) || _la == HiveParserKW_NOT {
		{
			p.SetState(2533)
			p.ConstraintOptsCreate()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IColConstraintContext is an interface to support dynamic dispatch.
type IColConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetConstraintName returns the constraintName rule contexts.
	GetConstraintName() IId_Context


	// SetConstraintName sets the constraintName rule contexts.
	SetConstraintName(IId_Context)


	// Getter signatures
	ColumnConstraintType() IColumnConstraintTypeContext
	KW_CONSTRAINT() antlr.TerminalNode
	ConstraintOptsCreate() IConstraintOptsCreateContext
	Id_() IId_Context

	// IsColConstraintContext differentiates from other interfaces.
	IsColConstraintContext()
}

type ColConstraintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	constraintName IId_Context 
}

func NewEmptyColConstraintContext() *ColConstraintContext {
	var p = new(ColConstraintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_colConstraint
	return p
}

func InitEmptyColConstraintContext(p *ColConstraintContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_colConstraint
}

func (*ColConstraintContext) IsColConstraintContext() {}

func NewColConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColConstraintContext {
	var p = new(ColConstraintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_colConstraint

	return p
}

func (s *ColConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *ColConstraintContext) GetConstraintName() IId_Context { return s.constraintName }


func (s *ColConstraintContext) SetConstraintName(v IId_Context) { s.constraintName = v }


func (s *ColConstraintContext) ColumnConstraintType() IColumnConstraintTypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnConstraintTypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnConstraintTypeContext)
}

func (s *ColConstraintContext) KW_CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_CONSTRAINT, 0)
}

func (s *ColConstraintContext) ConstraintOptsCreate() IConstraintOptsCreateContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstraintOptsCreateContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstraintOptsCreateContext)
}

func (s *ColConstraintContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *ColConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ColConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterColConstraint(s)
	}
}

func (s *ColConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitColConstraint(s)
	}
}

func (s *ColConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitColConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ColConstraint() (localctx IColConstraintContext) {
	localctx = NewColConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 344, HiveParserRULE_colConstraint)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2538)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_CONSTRAINT {
		{
			p.SetState(2536)
			p.Match(HiveParserKW_CONSTRAINT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2537)

			var _x = p.Id_()


			localctx.(*ColConstraintContext).constraintName = _x
		}

	}
	{
		p.SetState(2540)
		p.ColumnConstraintType()
	}
	p.SetState(2542)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if ((int64((_la - 91)) & ^0x3f) == 0 && ((int64(1) << (_la - 91)) & 10241) != 0) || _la == HiveParserKW_NOT {
		{
			p.SetState(2541)
			p.ConstraintOptsCreate()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlterColumnConstraintContext is an interface to support dynamic dispatch.
type IAlterColumnConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AlterForeignKeyConstraint() IAlterForeignKeyConstraintContext
	AlterColConstraint() IAlterColConstraintContext

	// IsAlterColumnConstraintContext differentiates from other interfaces.
	IsAlterColumnConstraintContext()
}

type AlterColumnConstraintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterColumnConstraintContext() *AlterColumnConstraintContext {
	var p = new(AlterColumnConstraintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterColumnConstraint
	return p
}

func InitEmptyAlterColumnConstraintContext(p *AlterColumnConstraintContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterColumnConstraint
}

func (*AlterColumnConstraintContext) IsAlterColumnConstraintContext() {}

func NewAlterColumnConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterColumnConstraintContext {
	var p = new(AlterColumnConstraintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_alterColumnConstraint

	return p
}

func (s *AlterColumnConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterColumnConstraintContext) AlterForeignKeyConstraint() IAlterForeignKeyConstraintContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterForeignKeyConstraintContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterForeignKeyConstraintContext)
}

func (s *AlterColumnConstraintContext) AlterColConstraint() IAlterColConstraintContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterColConstraintContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterColConstraintContext)
}

func (s *AlterColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterColumnConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AlterColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterAlterColumnConstraint(s)
	}
}

func (s *AlterColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitAlterColumnConstraint(s)
	}
}

func (s *AlterColumnConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitAlterColumnConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) AlterColumnConstraint() (localctx IAlterColumnConstraintContext) {
	localctx = NewAlterColumnConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 346, HiveParserRULE_alterColumnConstraint)
	p.SetState(2546)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 226, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2544)
			p.AlterForeignKeyConstraint()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2545)
			p.AlterColConstraint()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlterForeignKeyConstraintContext is an interface to support dynamic dispatch.
type IAlterForeignKeyConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetConstraintName returns the constraintName rule contexts.
	GetConstraintName() IId_Context

	// GetTabName returns the tabName rule contexts.
	GetTabName() ITableNameContext

	// GetColName returns the colName rule contexts.
	GetColName() IColumnNameContext


	// SetConstraintName sets the constraintName rule contexts.
	SetConstraintName(IId_Context)

	// SetTabName sets the tabName rule contexts.
	SetTabName(ITableNameContext)

	// SetColName sets the colName rule contexts.
	SetColName(IColumnNameContext)


	// Getter signatures
	KW_REFERENCES() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	TableName() ITableNameContext
	ColumnName() IColumnNameContext
	KW_CONSTRAINT() antlr.TerminalNode
	ConstraintOptsAlter() IConstraintOptsAlterContext
	Id_() IId_Context

	// IsAlterForeignKeyConstraintContext differentiates from other interfaces.
	IsAlterForeignKeyConstraintContext()
}

type AlterForeignKeyConstraintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	constraintName IId_Context 
	tabName ITableNameContext 
	colName IColumnNameContext 
}

func NewEmptyAlterForeignKeyConstraintContext() *AlterForeignKeyConstraintContext {
	var p = new(AlterForeignKeyConstraintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterForeignKeyConstraint
	return p
}

func InitEmptyAlterForeignKeyConstraintContext(p *AlterForeignKeyConstraintContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterForeignKeyConstraint
}

func (*AlterForeignKeyConstraintContext) IsAlterForeignKeyConstraintContext() {}

func NewAlterForeignKeyConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterForeignKeyConstraintContext {
	var p = new(AlterForeignKeyConstraintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_alterForeignKeyConstraint

	return p
}

func (s *AlterForeignKeyConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterForeignKeyConstraintContext) GetConstraintName() IId_Context { return s.constraintName }

func (s *AlterForeignKeyConstraintContext) GetTabName() ITableNameContext { return s.tabName }

func (s *AlterForeignKeyConstraintContext) GetColName() IColumnNameContext { return s.colName }


func (s *AlterForeignKeyConstraintContext) SetConstraintName(v IId_Context) { s.constraintName = v }

func (s *AlterForeignKeyConstraintContext) SetTabName(v ITableNameContext) { s.tabName = v }

func (s *AlterForeignKeyConstraintContext) SetColName(v IColumnNameContext) { s.colName = v }


func (s *AlterForeignKeyConstraintContext) KW_REFERENCES() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_REFERENCES, 0)
}

func (s *AlterForeignKeyConstraintContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserLPAREN, 0)
}

func (s *AlterForeignKeyConstraintContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserRPAREN, 0)
}

func (s *AlterForeignKeyConstraintContext) TableName() ITableNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *AlterForeignKeyConstraintContext) ColumnName() IColumnNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNameContext)
}

func (s *AlterForeignKeyConstraintContext) KW_CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_CONSTRAINT, 0)
}

func (s *AlterForeignKeyConstraintContext) ConstraintOptsAlter() IConstraintOptsAlterContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstraintOptsAlterContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstraintOptsAlterContext)
}

func (s *AlterForeignKeyConstraintContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *AlterForeignKeyConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterForeignKeyConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AlterForeignKeyConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterAlterForeignKeyConstraint(s)
	}
}

func (s *AlterForeignKeyConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitAlterForeignKeyConstraint(s)
	}
}

func (s *AlterForeignKeyConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitAlterForeignKeyConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) AlterForeignKeyConstraint() (localctx IAlterForeignKeyConstraintContext) {
	localctx = NewAlterForeignKeyConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 348, HiveParserRULE_alterForeignKeyConstraint)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2550)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_CONSTRAINT {
		{
			p.SetState(2548)
			p.Match(HiveParserKW_CONSTRAINT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2549)

			var _x = p.Id_()


			localctx.(*AlterForeignKeyConstraintContext).constraintName = _x
		}

	}
	{
		p.SetState(2552)
		p.Match(HiveParserKW_REFERENCES)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2553)

		var _x = p.TableName()


		localctx.(*AlterForeignKeyConstraintContext).tabName = _x
	}
	{
		p.SetState(2554)
		p.Match(HiveParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2555)

		var _x = p.ColumnName()


		localctx.(*AlterForeignKeyConstraintContext).colName = _x
	}
	{
		p.SetState(2556)
		p.Match(HiveParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(2558)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if ((int64((_la - 91)) & ^0x3f) == 0 && ((int64(1) << (_la - 91)) & 10241) != 0) || _la == HiveParserKW_NOT {
		{
			p.SetState(2557)
			p.ConstraintOptsAlter()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlterColConstraintContext is an interface to support dynamic dispatch.
type IAlterColConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetConstraintName returns the constraintName rule contexts.
	GetConstraintName() IId_Context


	// SetConstraintName sets the constraintName rule contexts.
	SetConstraintName(IId_Context)


	// Getter signatures
	ColumnConstraintType() IColumnConstraintTypeContext
	KW_CONSTRAINT() antlr.TerminalNode
	ConstraintOptsAlter() IConstraintOptsAlterContext
	Id_() IId_Context

	// IsAlterColConstraintContext differentiates from other interfaces.
	IsAlterColConstraintContext()
}

type AlterColConstraintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	constraintName IId_Context 
}

func NewEmptyAlterColConstraintContext() *AlterColConstraintContext {
	var p = new(AlterColConstraintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterColConstraint
	return p
}

func InitEmptyAlterColConstraintContext(p *AlterColConstraintContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterColConstraint
}

func (*AlterColConstraintContext) IsAlterColConstraintContext() {}

func NewAlterColConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterColConstraintContext {
	var p = new(AlterColConstraintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_alterColConstraint

	return p
}

func (s *AlterColConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterColConstraintContext) GetConstraintName() IId_Context { return s.constraintName }


func (s *AlterColConstraintContext) SetConstraintName(v IId_Context) { s.constraintName = v }


func (s *AlterColConstraintContext) ColumnConstraintType() IColumnConstraintTypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnConstraintTypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnConstraintTypeContext)
}

func (s *AlterColConstraintContext) KW_CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_CONSTRAINT, 0)
}

func (s *AlterColConstraintContext) ConstraintOptsAlter() IConstraintOptsAlterContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstraintOptsAlterContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstraintOptsAlterContext)
}

func (s *AlterColConstraintContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *AlterColConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterColConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AlterColConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterAlterColConstraint(s)
	}
}

func (s *AlterColConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitAlterColConstraint(s)
	}
}

func (s *AlterColConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitAlterColConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) AlterColConstraint() (localctx IAlterColConstraintContext) {
	localctx = NewAlterColConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 350, HiveParserRULE_alterColConstraint)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2562)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_CONSTRAINT {
		{
			p.SetState(2560)
			p.Match(HiveParserKW_CONSTRAINT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2561)

			var _x = p.Id_()


			localctx.(*AlterColConstraintContext).constraintName = _x
		}

	}
	{
		p.SetState(2564)
		p.ColumnConstraintType()
	}
	p.SetState(2566)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if ((int64((_la - 91)) & ^0x3f) == 0 && ((int64(1) << (_la - 91)) & 10241) != 0) || _la == HiveParserKW_NOT {
		{
			p.SetState(2565)
			p.ConstraintOptsAlter()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IColumnConstraintTypeContext is an interface to support dynamic dispatch.
type IColumnConstraintTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_NOT() antlr.TerminalNode
	KW_NULL() antlr.TerminalNode
	KW_DEFAULT() antlr.TerminalNode
	DefaultVal() IDefaultValContext
	CheckConstraint() ICheckConstraintContext
	TableConstraintType() ITableConstraintTypeContext

	// IsColumnConstraintTypeContext differentiates from other interfaces.
	IsColumnConstraintTypeContext()
}

type ColumnConstraintTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnConstraintTypeContext() *ColumnConstraintTypeContext {
	var p = new(ColumnConstraintTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_columnConstraintType
	return p
}

func InitEmptyColumnConstraintTypeContext(p *ColumnConstraintTypeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_columnConstraintType
}

func (*ColumnConstraintTypeContext) IsColumnConstraintTypeContext() {}

func NewColumnConstraintTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnConstraintTypeContext {
	var p = new(ColumnConstraintTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_columnConstraintType

	return p
}

func (s *ColumnConstraintTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnConstraintTypeContext) KW_NOT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_NOT, 0)
}

func (s *ColumnConstraintTypeContext) KW_NULL() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_NULL, 0)
}

func (s *ColumnConstraintTypeContext) KW_DEFAULT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DEFAULT, 0)
}

func (s *ColumnConstraintTypeContext) DefaultVal() IDefaultValContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefaultValContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefaultValContext)
}

func (s *ColumnConstraintTypeContext) CheckConstraint() ICheckConstraintContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICheckConstraintContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICheckConstraintContext)
}

func (s *ColumnConstraintTypeContext) TableConstraintType() ITableConstraintTypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableConstraintTypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableConstraintTypeContext)
}

func (s *ColumnConstraintTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnConstraintTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ColumnConstraintTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterColumnConstraintType(s)
	}
}

func (s *ColumnConstraintTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitColumnConstraintType(s)
	}
}

func (s *ColumnConstraintTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitColumnConstraintType(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ColumnConstraintType() (localctx IColumnConstraintTypeContext) {
	localctx = NewColumnConstraintTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 352, HiveParserRULE_columnConstraintType)
	p.SetState(2574)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserKW_NOT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2568)
			p.Match(HiveParserKW_NOT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2569)
			p.Match(HiveParserKW_NULL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HiveParserKW_DEFAULT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2570)
			p.Match(HiveParserKW_DEFAULT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2571)
			p.DefaultVal()
		}


	case HiveParserKW_CHECK:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2572)
			p.CheckConstraint()
		}


	case HiveParserKW_PRIMARY, HiveParserKW_UNIQUE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2573)
			p.TableConstraintType()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDefaultValContext is an interface to support dynamic dispatch.
type IDefaultValContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Constant() IConstantContext
	Function_() IFunction_Context
	CastExpression() ICastExpressionContext

	// IsDefaultValContext differentiates from other interfaces.
	IsDefaultValContext()
}

type DefaultValContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefaultValContext() *DefaultValContext {
	var p = new(DefaultValContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_defaultVal
	return p
}

func InitEmptyDefaultValContext(p *DefaultValContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_defaultVal
}

func (*DefaultValContext) IsDefaultValContext() {}

func NewDefaultValContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefaultValContext {
	var p = new(DefaultValContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_defaultVal

	return p
}

func (s *DefaultValContext) GetParser() antlr.Parser { return s.parser }

func (s *DefaultValContext) Constant() IConstantContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *DefaultValContext) Function_() IFunction_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunction_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunction_Context)
}

func (s *DefaultValContext) CastExpression() ICastExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICastExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICastExpressionContext)
}

func (s *DefaultValContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultValContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DefaultValContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterDefaultVal(s)
	}
}

func (s *DefaultValContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitDefaultVal(s)
	}
}

func (s *DefaultValContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitDefaultVal(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) DefaultVal() (localctx IDefaultValContext) {
	localctx = NewDefaultValContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 354, HiveParserRULE_defaultVal)
	p.SetState(2579)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 232, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2576)
			p.Constant()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2577)
			p.Function_()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2578)
			p.CastExpression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITableConstraintTypeContext is an interface to support dynamic dispatch.
type ITableConstraintTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_PRIMARY() antlr.TerminalNode
	KW_KEY() antlr.TerminalNode
	KW_UNIQUE() antlr.TerminalNode

	// IsTableConstraintTypeContext differentiates from other interfaces.
	IsTableConstraintTypeContext()
}

type TableConstraintTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableConstraintTypeContext() *TableConstraintTypeContext {
	var p = new(TableConstraintTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_tableConstraintType
	return p
}

func InitEmptyTableConstraintTypeContext(p *TableConstraintTypeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_tableConstraintType
}

func (*TableConstraintTypeContext) IsTableConstraintTypeContext() {}

func NewTableConstraintTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableConstraintTypeContext {
	var p = new(TableConstraintTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_tableConstraintType

	return p
}

func (s *TableConstraintTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *TableConstraintTypeContext) KW_PRIMARY() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_PRIMARY, 0)
}

func (s *TableConstraintTypeContext) KW_KEY() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_KEY, 0)
}

func (s *TableConstraintTypeContext) KW_UNIQUE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_UNIQUE, 0)
}

func (s *TableConstraintTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableConstraintTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TableConstraintTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterTableConstraintType(s)
	}
}

func (s *TableConstraintTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitTableConstraintType(s)
	}
}

func (s *TableConstraintTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitTableConstraintType(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) TableConstraintType() (localctx ITableConstraintTypeContext) {
	localctx = NewTableConstraintTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 356, HiveParserRULE_tableConstraintType)
	p.SetState(2584)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserKW_PRIMARY:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2581)
			p.Match(HiveParserKW_PRIMARY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2582)
			p.Match(HiveParserKW_KEY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HiveParserKW_UNIQUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2583)
			p.Match(HiveParserKW_UNIQUE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IConstraintOptsCreateContext is an interface to support dynamic dispatch.
type IConstraintOptsCreateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EnableValidateSpecification() IEnableValidateSpecificationContext
	RelySpecification() IRelySpecificationContext

	// IsConstraintOptsCreateContext differentiates from other interfaces.
	IsConstraintOptsCreateContext()
}

type ConstraintOptsCreateContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstraintOptsCreateContext() *ConstraintOptsCreateContext {
	var p = new(ConstraintOptsCreateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_constraintOptsCreate
	return p
}

func InitEmptyConstraintOptsCreateContext(p *ConstraintOptsCreateContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_constraintOptsCreate
}

func (*ConstraintOptsCreateContext) IsConstraintOptsCreateContext() {}

func NewConstraintOptsCreateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstraintOptsCreateContext {
	var p = new(ConstraintOptsCreateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_constraintOptsCreate

	return p
}

func (s *ConstraintOptsCreateContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstraintOptsCreateContext) EnableValidateSpecification() IEnableValidateSpecificationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnableValidateSpecificationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnableValidateSpecificationContext)
}

func (s *ConstraintOptsCreateContext) RelySpecification() IRelySpecificationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelySpecificationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelySpecificationContext)
}

func (s *ConstraintOptsCreateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstraintOptsCreateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ConstraintOptsCreateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterConstraintOptsCreate(s)
	}
}

func (s *ConstraintOptsCreateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitConstraintOptsCreate(s)
	}
}

func (s *ConstraintOptsCreateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitConstraintOptsCreate(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ConstraintOptsCreate() (localctx IConstraintOptsCreateContext) {
	localctx = NewConstraintOptsCreateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 358, HiveParserRULE_constraintOptsCreate)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2586)
		p.EnableValidateSpecification()
	}
	p.SetState(2588)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_NORELY || _la == HiveParserKW_RELY {
		{
			p.SetState(2587)
			p.RelySpecification()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IConstraintOptsAlterContext is an interface to support dynamic dispatch.
type IConstraintOptsAlterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EnableValidateSpecification() IEnableValidateSpecificationContext
	RelySpecification() IRelySpecificationContext

	// IsConstraintOptsAlterContext differentiates from other interfaces.
	IsConstraintOptsAlterContext()
}

type ConstraintOptsAlterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstraintOptsAlterContext() *ConstraintOptsAlterContext {
	var p = new(ConstraintOptsAlterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_constraintOptsAlter
	return p
}

func InitEmptyConstraintOptsAlterContext(p *ConstraintOptsAlterContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_constraintOptsAlter
}

func (*ConstraintOptsAlterContext) IsConstraintOptsAlterContext() {}

func NewConstraintOptsAlterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstraintOptsAlterContext {
	var p = new(ConstraintOptsAlterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_constraintOptsAlter

	return p
}

func (s *ConstraintOptsAlterContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstraintOptsAlterContext) EnableValidateSpecification() IEnableValidateSpecificationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnableValidateSpecificationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnableValidateSpecificationContext)
}

func (s *ConstraintOptsAlterContext) RelySpecification() IRelySpecificationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelySpecificationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelySpecificationContext)
}

func (s *ConstraintOptsAlterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstraintOptsAlterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ConstraintOptsAlterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterConstraintOptsAlter(s)
	}
}

func (s *ConstraintOptsAlterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitConstraintOptsAlter(s)
	}
}

func (s *ConstraintOptsAlterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitConstraintOptsAlter(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ConstraintOptsAlter() (localctx IConstraintOptsAlterContext) {
	localctx = NewConstraintOptsAlterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 360, HiveParserRULE_constraintOptsAlter)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2590)
		p.EnableValidateSpecification()
	}
	p.SetState(2592)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_NORELY || _la == HiveParserKW_RELY {
		{
			p.SetState(2591)
			p.RelySpecification()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IColumnNameColonTypeContext is an interface to support dynamic dispatch.
type IColumnNameColonTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetComment returns the comment token.
	GetComment() antlr.Token 


	// SetComment sets the comment token.
	SetComment(antlr.Token) 


	// GetColName returns the colName rule contexts.
	GetColName() IId_Context


	// SetColName sets the colName rule contexts.
	SetColName(IId_Context)


	// Getter signatures
	COLON() antlr.TerminalNode
	ColType() IColTypeContext
	Id_() IId_Context
	KW_COMMENT() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode

	// IsColumnNameColonTypeContext differentiates from other interfaces.
	IsColumnNameColonTypeContext()
}

type ColumnNameColonTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	colName IId_Context 
	comment antlr.Token
}

func NewEmptyColumnNameColonTypeContext() *ColumnNameColonTypeContext {
	var p = new(ColumnNameColonTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_columnNameColonType
	return p
}

func InitEmptyColumnNameColonTypeContext(p *ColumnNameColonTypeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_columnNameColonType
}

func (*ColumnNameColonTypeContext) IsColumnNameColonTypeContext() {}

func NewColumnNameColonTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnNameColonTypeContext {
	var p = new(ColumnNameColonTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_columnNameColonType

	return p
}

func (s *ColumnNameColonTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnNameColonTypeContext) GetComment() antlr.Token { return s.comment }


func (s *ColumnNameColonTypeContext) SetComment(v antlr.Token) { s.comment = v }


func (s *ColumnNameColonTypeContext) GetColName() IId_Context { return s.colName }


func (s *ColumnNameColonTypeContext) SetColName(v IId_Context) { s.colName = v }


func (s *ColumnNameColonTypeContext) COLON() antlr.TerminalNode {
	return s.GetToken(HiveParserCOLON, 0)
}

func (s *ColumnNameColonTypeContext) ColType() IColTypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColTypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColTypeContext)
}

func (s *ColumnNameColonTypeContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *ColumnNameColonTypeContext) KW_COMMENT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_COMMENT, 0)
}

func (s *ColumnNameColonTypeContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(HiveParserStringLiteral, 0)
}

func (s *ColumnNameColonTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnNameColonTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ColumnNameColonTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterColumnNameColonType(s)
	}
}

func (s *ColumnNameColonTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitColumnNameColonType(s)
	}
}

func (s *ColumnNameColonTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitColumnNameColonType(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ColumnNameColonType() (localctx IColumnNameColonTypeContext) {
	localctx = NewColumnNameColonTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 362, HiveParserRULE_columnNameColonType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2594)

		var _x = p.Id_()


		localctx.(*ColumnNameColonTypeContext).colName = _x
	}
	{
		p.SetState(2595)
		p.Match(HiveParserCOLON)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2596)
		p.ColType()
	}
	p.SetState(2599)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_COMMENT {
		{
			p.SetState(2597)
			p.Match(HiveParserKW_COMMENT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2598)

			var _m = p.Match(HiveParserStringLiteral)

			localctx.(*ColumnNameColonTypeContext).comment = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IColTypeContext is an interface to support dynamic dispatch.
type IColTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Type_() ITypeContext

	// IsColTypeContext differentiates from other interfaces.
	IsColTypeContext()
}

type ColTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColTypeContext() *ColTypeContext {
	var p = new(ColTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_colType
	return p
}

func InitEmptyColTypeContext(p *ColTypeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_colType
}

func (*ColTypeContext) IsColTypeContext() {}

func NewColTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColTypeContext {
	var p = new(ColTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_colType

	return p
}

func (s *ColTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ColTypeContext) Type_() ITypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *ColTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ColTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterColType(s)
	}
}

func (s *ColTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitColType(s)
	}
}

func (s *ColTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitColType(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ColType() (localctx IColTypeContext) {
	localctx = NewColTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 364, HiveParserRULE_colType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2601)
		p.Type_()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IColTypeListContext is an interface to support dynamic dispatch.
type IColTypeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllColType() []IColTypeContext
	ColType(i int) IColTypeContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsColTypeListContext differentiates from other interfaces.
	IsColTypeListContext()
}

type ColTypeListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColTypeListContext() *ColTypeListContext {
	var p = new(ColTypeListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_colTypeList
	return p
}

func InitEmptyColTypeListContext(p *ColTypeListContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_colTypeList
}

func (*ColTypeListContext) IsColTypeListContext() {}

func NewColTypeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColTypeListContext {
	var p = new(ColTypeListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_colTypeList

	return p
}

func (s *ColTypeListContext) GetParser() antlr.Parser { return s.parser }

func (s *ColTypeListContext) AllColType() []IColTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColTypeContext); ok {
			len++
		}
	}

	tst := make([]IColTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColTypeContext); ok {
			tst[i] = t.(IColTypeContext)
			i++
		}
	}

	return tst
}

func (s *ColTypeListContext) ColType(i int) IColTypeContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColTypeContext)
}

func (s *ColTypeListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(HiveParserCOMMA)
}

func (s *ColTypeListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserCOMMA, i)
}

func (s *ColTypeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColTypeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ColTypeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterColTypeList(s)
	}
}

func (s *ColTypeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitColTypeList(s)
	}
}

func (s *ColTypeListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitColTypeList(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ColTypeList() (localctx IColTypeListContext) {
	localctx = NewColTypeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 366, HiveParserRULE_colTypeList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2603)
		p.ColType()
	}
	p.SetState(2608)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HiveParserCOMMA {
		{
			p.SetState(2604)
			p.Match(HiveParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2605)
			p.ColType()
		}


		p.SetState(2610)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITypeContext is an interface to support dynamic dispatch.
type ITypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PrimitiveType() IPrimitiveTypeContext
	ListType() IListTypeContext
	StructType() IStructTypeContext
	MapType() IMapTypeContext
	UnionType() IUnionTypeContext

	// IsTypeContext differentiates from other interfaces.
	IsTypeContext()
}

type TypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeContext() *TypeContext {
	var p = new(TypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_type
	return p
}

func InitEmptyTypeContext(p *TypeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_type
}

func (*TypeContext) IsTypeContext() {}

func NewTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeContext {
	var p = new(TypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_type

	return p
}

func (s *TypeContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeContext) PrimitiveType() IPrimitiveTypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimitiveTypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimitiveTypeContext)
}

func (s *TypeContext) ListType() IListTypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListTypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListTypeContext)
}

func (s *TypeContext) StructType() IStructTypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructTypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructTypeContext)
}

func (s *TypeContext) MapType() IMapTypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapTypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapTypeContext)
}

func (s *TypeContext) UnionType() IUnionTypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnionTypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnionTypeContext)
}

func (s *TypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterType(s)
	}
}

func (s *TypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitType(s)
	}
}

func (s *TypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitType(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) Type_() (localctx ITypeContext) {
	localctx = NewTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 368, HiveParserRULE_type)
	p.SetState(2616)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserKW_BIGINT, HiveParserKW_BINARY, HiveParserKW_BOOLEAN, HiveParserKW_CHAR, HiveParserKW_DATE, HiveParserKW_DATETIME, HiveParserKW_DECIMAL, HiveParserKW_DOUBLE, HiveParserKW_FLOAT, HiveParserKW_INT, HiveParserKW_REAL, HiveParserKW_SMALLINT, HiveParserKW_STRING, HiveParserKW_TIMESTAMP, HiveParserKW_TIMESTAMPLOCALTZ, HiveParserKW_TINYINT, HiveParserKW_VARCHAR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2611)
			p.PrimitiveType()
		}


	case HiveParserKW_ARRAY:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2612)
			p.ListType()
		}


	case HiveParserKW_STRUCT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2613)
			p.StructType()
		}


	case HiveParserKW_MAP:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2614)
			p.MapType()
		}


	case HiveParserKW_UNIONTYPE:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2615)
			p.UnionType()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPrimitiveTypeContext is an interface to support dynamic dispatch.
type IPrimitiveTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPrec returns the prec token.
	GetPrec() antlr.Token 

	// GetScale returns the scale token.
	GetScale() antlr.Token 

	// GetLength returns the length token.
	GetLength() antlr.Token 


	// SetPrec sets the prec token.
	SetPrec(antlr.Token) 

	// SetScale sets the scale token.
	SetScale(antlr.Token) 

	// SetLength sets the length token.
	SetLength(antlr.Token) 


	// Getter signatures
	KW_TINYINT() antlr.TerminalNode
	KW_SMALLINT() antlr.TerminalNode
	KW_INT() antlr.TerminalNode
	KW_BIGINT() antlr.TerminalNode
	KW_BOOLEAN() antlr.TerminalNode
	KW_FLOAT() antlr.TerminalNode
	KW_REAL() antlr.TerminalNode
	KW_DOUBLE() antlr.TerminalNode
	KW_PRECISION() antlr.TerminalNode
	KW_DATE() antlr.TerminalNode
	KW_DATETIME() antlr.TerminalNode
	KW_TIMESTAMP() antlr.TerminalNode
	KW_TIMESTAMPLOCALTZ() antlr.TerminalNode
	KW_WITH() antlr.TerminalNode
	KW_LOCAL() antlr.TerminalNode
	KW_TIME() antlr.TerminalNode
	KW_ZONE() antlr.TerminalNode
	KW_STRING() antlr.TerminalNode
	KW_BINARY() antlr.TerminalNode
	KW_DECIMAL() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	AllNumber() []antlr.TerminalNode
	Number(i int) antlr.TerminalNode
	COMMA() antlr.TerminalNode
	KW_VARCHAR() antlr.TerminalNode
	KW_CHAR() antlr.TerminalNode

	// IsPrimitiveTypeContext differentiates from other interfaces.
	IsPrimitiveTypeContext()
}

type PrimitiveTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	prec antlr.Token
	scale antlr.Token
	length antlr.Token
}

func NewEmptyPrimitiveTypeContext() *PrimitiveTypeContext {
	var p = new(PrimitiveTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_primitiveType
	return p
}

func InitEmptyPrimitiveTypeContext(p *PrimitiveTypeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_primitiveType
}

func (*PrimitiveTypeContext) IsPrimitiveTypeContext() {}

func NewPrimitiveTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimitiveTypeContext {
	var p = new(PrimitiveTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_primitiveType

	return p
}

func (s *PrimitiveTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimitiveTypeContext) GetPrec() antlr.Token { return s.prec }

func (s *PrimitiveTypeContext) GetScale() antlr.Token { return s.scale }

func (s *PrimitiveTypeContext) GetLength() antlr.Token { return s.length }


func (s *PrimitiveTypeContext) SetPrec(v antlr.Token) { s.prec = v }

func (s *PrimitiveTypeContext) SetScale(v antlr.Token) { s.scale = v }

func (s *PrimitiveTypeContext) SetLength(v antlr.Token) { s.length = v }


func (s *PrimitiveTypeContext) KW_TINYINT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TINYINT, 0)
}

func (s *PrimitiveTypeContext) KW_SMALLINT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SMALLINT, 0)
}

func (s *PrimitiveTypeContext) KW_INT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_INT, 0)
}

func (s *PrimitiveTypeContext) KW_BIGINT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_BIGINT, 0)
}

func (s *PrimitiveTypeContext) KW_BOOLEAN() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_BOOLEAN, 0)
}

func (s *PrimitiveTypeContext) KW_FLOAT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_FLOAT, 0)
}

func (s *PrimitiveTypeContext) KW_REAL() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_REAL, 0)
}

func (s *PrimitiveTypeContext) KW_DOUBLE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DOUBLE, 0)
}

func (s *PrimitiveTypeContext) KW_PRECISION() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_PRECISION, 0)
}

func (s *PrimitiveTypeContext) KW_DATE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DATE, 0)
}

func (s *PrimitiveTypeContext) KW_DATETIME() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DATETIME, 0)
}

func (s *PrimitiveTypeContext) KW_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TIMESTAMP, 0)
}

func (s *PrimitiveTypeContext) KW_TIMESTAMPLOCALTZ() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TIMESTAMPLOCALTZ, 0)
}

func (s *PrimitiveTypeContext) KW_WITH() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_WITH, 0)
}

func (s *PrimitiveTypeContext) KW_LOCAL() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_LOCAL, 0)
}

func (s *PrimitiveTypeContext) KW_TIME() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TIME, 0)
}

func (s *PrimitiveTypeContext) KW_ZONE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ZONE, 0)
}

func (s *PrimitiveTypeContext) KW_STRING() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_STRING, 0)
}

func (s *PrimitiveTypeContext) KW_BINARY() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_BINARY, 0)
}

func (s *PrimitiveTypeContext) KW_DECIMAL() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DECIMAL, 0)
}

func (s *PrimitiveTypeContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserLPAREN, 0)
}

func (s *PrimitiveTypeContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserRPAREN, 0)
}

func (s *PrimitiveTypeContext) AllNumber() []antlr.TerminalNode {
	return s.GetTokens(HiveParserNumber)
}

func (s *PrimitiveTypeContext) Number(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserNumber, i)
}

func (s *PrimitiveTypeContext) COMMA() antlr.TerminalNode {
	return s.GetToken(HiveParserCOMMA, 0)
}

func (s *PrimitiveTypeContext) KW_VARCHAR() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_VARCHAR, 0)
}

func (s *PrimitiveTypeContext) KW_CHAR() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_CHAR, 0)
}

func (s *PrimitiveTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimitiveTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PrimitiveTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterPrimitiveType(s)
	}
}

func (s *PrimitiveTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitPrimitiveType(s)
	}
}

func (s *PrimitiveTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitPrimitiveType(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) PrimitiveType() (localctx IPrimitiveTypeContext) {
	localctx = NewPrimitiveTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 370, HiveParserRULE_primitiveType)
	var _la int

	p.SetState(2654)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 242, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2618)
			p.Match(HiveParserKW_TINYINT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2619)
			p.Match(HiveParserKW_SMALLINT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2620)
			p.Match(HiveParserKW_INT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2621)
			p.Match(HiveParserKW_BIGINT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2622)
			p.Match(HiveParserKW_BOOLEAN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2623)
			p.Match(HiveParserKW_FLOAT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2624)
			p.Match(HiveParserKW_REAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(2625)
			p.Match(HiveParserKW_DOUBLE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2627)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_PRECISION {
			{
				p.SetState(2626)
				p.Match(HiveParserKW_PRECISION)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}


	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(2629)
			p.Match(HiveParserKW_DATE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(2630)
			p.Match(HiveParserKW_DATETIME)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(2631)
			p.Match(HiveParserKW_TIMESTAMP)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(2632)
			p.Match(HiveParserKW_TIMESTAMPLOCALTZ)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(2633)
			p.Match(HiveParserKW_TIMESTAMP)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2634)
			p.Match(HiveParserKW_WITH)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2635)
			p.Match(HiveParserKW_LOCAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2636)
			p.Match(HiveParserKW_TIME)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2637)
			p.Match(HiveParserKW_ZONE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(2638)
			p.Match(HiveParserKW_STRING)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(2639)
			p.Match(HiveParserKW_BINARY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(2640)
			p.Match(HiveParserKW_DECIMAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2648)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserLPAREN {
			{
				p.SetState(2641)
				p.Match(HiveParserLPAREN)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2642)

				var _m = p.Match(HiveParserNumber)

				localctx.(*PrimitiveTypeContext).prec = _m
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			p.SetState(2645)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == HiveParserCOMMA {
				{
					p.SetState(2643)
					p.Match(HiveParserCOMMA)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(2644)

					var _m = p.Match(HiveParserNumber)

					localctx.(*PrimitiveTypeContext).scale = _m
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}

			}
			{
				p.SetState(2647)
				p.Match(HiveParserRPAREN)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}


	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(2650)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HiveParserKW_CHAR || _la == HiveParserKW_VARCHAR) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2651)
			p.Match(HiveParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2652)

			var _m = p.Match(HiveParserNumber)

			localctx.(*PrimitiveTypeContext).length = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2653)
			p.Match(HiveParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IListTypeContext is an interface to support dynamic dispatch.
type IListTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_ARRAY() antlr.TerminalNode
	LESSTHAN() antlr.TerminalNode
	Type_() ITypeContext
	GREATERTHAN() antlr.TerminalNode

	// IsListTypeContext differentiates from other interfaces.
	IsListTypeContext()
}

type ListTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyListTypeContext() *ListTypeContext {
	var p = new(ListTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_listType
	return p
}

func InitEmptyListTypeContext(p *ListTypeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_listType
}

func (*ListTypeContext) IsListTypeContext() {}

func NewListTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListTypeContext {
	var p = new(ListTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_listType

	return p
}

func (s *ListTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ListTypeContext) KW_ARRAY() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ARRAY, 0)
}

func (s *ListTypeContext) LESSTHAN() antlr.TerminalNode {
	return s.GetToken(HiveParserLESSTHAN, 0)
}

func (s *ListTypeContext) Type_() ITypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *ListTypeContext) GREATERTHAN() antlr.TerminalNode {
	return s.GetToken(HiveParserGREATERTHAN, 0)
}

func (s *ListTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ListTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterListType(s)
	}
}

func (s *ListTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitListType(s)
	}
}

func (s *ListTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitListType(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ListType() (localctx IListTypeContext) {
	localctx = NewListTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 372, HiveParserRULE_listType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2656)
		p.Match(HiveParserKW_ARRAY)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2657)
		p.Match(HiveParserLESSTHAN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2658)
		p.Type_()
	}
	{
		p.SetState(2659)
		p.Match(HiveParserGREATERTHAN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IStructTypeContext is an interface to support dynamic dispatch.
type IStructTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_STRUCT() antlr.TerminalNode
	LESSTHAN() antlr.TerminalNode
	ColumnNameColonTypeList() IColumnNameColonTypeListContext
	GREATERTHAN() antlr.TerminalNode

	// IsStructTypeContext differentiates from other interfaces.
	IsStructTypeContext()
}

type StructTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStructTypeContext() *StructTypeContext {
	var p = new(StructTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_structType
	return p
}

func InitEmptyStructTypeContext(p *StructTypeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_structType
}

func (*StructTypeContext) IsStructTypeContext() {}

func NewStructTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructTypeContext {
	var p = new(StructTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_structType

	return p
}

func (s *StructTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *StructTypeContext) KW_STRUCT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_STRUCT, 0)
}

func (s *StructTypeContext) LESSTHAN() antlr.TerminalNode {
	return s.GetToken(HiveParserLESSTHAN, 0)
}

func (s *StructTypeContext) ColumnNameColonTypeList() IColumnNameColonTypeListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNameColonTypeListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNameColonTypeListContext)
}

func (s *StructTypeContext) GREATERTHAN() antlr.TerminalNode {
	return s.GetToken(HiveParserGREATERTHAN, 0)
}

func (s *StructTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *StructTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterStructType(s)
	}
}

func (s *StructTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitStructType(s)
	}
}

func (s *StructTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitStructType(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) StructType() (localctx IStructTypeContext) {
	localctx = NewStructTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 374, HiveParserRULE_structType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2661)
		p.Match(HiveParserKW_STRUCT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2662)
		p.Match(HiveParserLESSTHAN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2663)
		p.ColumnNameColonTypeList()
	}
	{
		p.SetState(2664)
		p.Match(HiveParserGREATERTHAN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IMapTypeContext is an interface to support dynamic dispatch.
type IMapTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLeft returns the left rule contexts.
	GetLeft() IPrimitiveTypeContext

	// GetRight returns the right rule contexts.
	GetRight() ITypeContext


	// SetLeft sets the left rule contexts.
	SetLeft(IPrimitiveTypeContext)

	// SetRight sets the right rule contexts.
	SetRight(ITypeContext)


	// Getter signatures
	KW_MAP() antlr.TerminalNode
	LESSTHAN() antlr.TerminalNode
	COMMA() antlr.TerminalNode
	GREATERTHAN() antlr.TerminalNode
	PrimitiveType() IPrimitiveTypeContext
	Type_() ITypeContext

	// IsMapTypeContext differentiates from other interfaces.
	IsMapTypeContext()
}

type MapTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	left IPrimitiveTypeContext 
	right ITypeContext 
}

func NewEmptyMapTypeContext() *MapTypeContext {
	var p = new(MapTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_mapType
	return p
}

func InitEmptyMapTypeContext(p *MapTypeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_mapType
}

func (*MapTypeContext) IsMapTypeContext() {}

func NewMapTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapTypeContext {
	var p = new(MapTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_mapType

	return p
}

func (s *MapTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *MapTypeContext) GetLeft() IPrimitiveTypeContext { return s.left }

func (s *MapTypeContext) GetRight() ITypeContext { return s.right }


func (s *MapTypeContext) SetLeft(v IPrimitiveTypeContext) { s.left = v }

func (s *MapTypeContext) SetRight(v ITypeContext) { s.right = v }


func (s *MapTypeContext) KW_MAP() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_MAP, 0)
}

func (s *MapTypeContext) LESSTHAN() antlr.TerminalNode {
	return s.GetToken(HiveParserLESSTHAN, 0)
}

func (s *MapTypeContext) COMMA() antlr.TerminalNode {
	return s.GetToken(HiveParserCOMMA, 0)
}

func (s *MapTypeContext) GREATERTHAN() antlr.TerminalNode {
	return s.GetToken(HiveParserGREATERTHAN, 0)
}

func (s *MapTypeContext) PrimitiveType() IPrimitiveTypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimitiveTypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimitiveTypeContext)
}

func (s *MapTypeContext) Type_() ITypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *MapTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *MapTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterMapType(s)
	}
}

func (s *MapTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitMapType(s)
	}
}

func (s *MapTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitMapType(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) MapType() (localctx IMapTypeContext) {
	localctx = NewMapTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 376, HiveParserRULE_mapType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2666)
		p.Match(HiveParserKW_MAP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2667)
		p.Match(HiveParserLESSTHAN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2668)

		var _x = p.PrimitiveType()


		localctx.(*MapTypeContext).left = _x
	}
	{
		p.SetState(2669)
		p.Match(HiveParserCOMMA)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2670)

		var _x = p.Type_()


		localctx.(*MapTypeContext).right = _x
	}
	{
		p.SetState(2671)
		p.Match(HiveParserGREATERTHAN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IUnionTypeContext is an interface to support dynamic dispatch.
type IUnionTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_UNIONTYPE() antlr.TerminalNode
	LESSTHAN() antlr.TerminalNode
	ColTypeList() IColTypeListContext
	GREATERTHAN() antlr.TerminalNode

	// IsUnionTypeContext differentiates from other interfaces.
	IsUnionTypeContext()
}

type UnionTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnionTypeContext() *UnionTypeContext {
	var p = new(UnionTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_unionType
	return p
}

func InitEmptyUnionTypeContext(p *UnionTypeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_unionType
}

func (*UnionTypeContext) IsUnionTypeContext() {}

func NewUnionTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnionTypeContext {
	var p = new(UnionTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_unionType

	return p
}

func (s *UnionTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *UnionTypeContext) KW_UNIONTYPE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_UNIONTYPE, 0)
}

func (s *UnionTypeContext) LESSTHAN() antlr.TerminalNode {
	return s.GetToken(HiveParserLESSTHAN, 0)
}

func (s *UnionTypeContext) ColTypeList() IColTypeListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColTypeListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColTypeListContext)
}

func (s *UnionTypeContext) GREATERTHAN() antlr.TerminalNode {
	return s.GetToken(HiveParserGREATERTHAN, 0)
}

func (s *UnionTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnionTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *UnionTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterUnionType(s)
	}
}

func (s *UnionTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitUnionType(s)
	}
}

func (s *UnionTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitUnionType(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) UnionType() (localctx IUnionTypeContext) {
	localctx = NewUnionTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 378, HiveParserRULE_unionType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2673)
		p.Match(HiveParserKW_UNIONTYPE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2674)
		p.Match(HiveParserLESSTHAN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2675)
		p.ColTypeList()
	}
	{
		p.SetState(2676)
		p.Match(HiveParserGREATERTHAN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISetOperatorContext is an interface to support dynamic dispatch.
type ISetOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_UNION() antlr.TerminalNode
	KW_INTERSECT() antlr.TerminalNode
	KW_EXCEPT() antlr.TerminalNode
	KW_MINUS() antlr.TerminalNode
	KW_ALL() antlr.TerminalNode
	KW_DISTINCT() antlr.TerminalNode

	// IsSetOperatorContext differentiates from other interfaces.
	IsSetOperatorContext()
}

type SetOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetOperatorContext() *SetOperatorContext {
	var p = new(SetOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_setOperator
	return p
}

func InitEmptySetOperatorContext(p *SetOperatorContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_setOperator
}

func (*SetOperatorContext) IsSetOperatorContext() {}

func NewSetOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetOperatorContext {
	var p = new(SetOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_setOperator

	return p
}

func (s *SetOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *SetOperatorContext) KW_UNION() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_UNION, 0)
}

func (s *SetOperatorContext) KW_INTERSECT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_INTERSECT, 0)
}

func (s *SetOperatorContext) KW_EXCEPT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_EXCEPT, 0)
}

func (s *SetOperatorContext) KW_MINUS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_MINUS, 0)
}

func (s *SetOperatorContext) KW_ALL() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ALL, 0)
}

func (s *SetOperatorContext) KW_DISTINCT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DISTINCT, 0)
}

func (s *SetOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SetOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterSetOperator(s)
	}
}

func (s *SetOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitSetOperator(s)
	}
}

func (s *SetOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitSetOperator(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) SetOperator() (localctx ISetOperatorContext) {
	localctx = NewSetOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 380, HiveParserRULE_setOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2678)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HiveParserKW_EXCEPT || _la == HiveParserKW_INTERSECT || _la == HiveParserKW_MINUS || _la == HiveParserKW_UNION) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(2680)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_ALL || _la == HiveParserKW_DISTINCT {
		{
			p.SetState(2679)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HiveParserKW_ALL || _la == HiveParserKW_DISTINCT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IQueryStatementExpressionContext is an interface to support dynamic dispatch.
type IQueryStatementExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetW returns the w rule contexts.
	GetW() IWithClauseContext


	// SetW sets the w rule contexts.
	SetW(IWithClauseContext)


	// Getter signatures
	QueryStatementExpressionBody() IQueryStatementExpressionBodyContext
	WithClause() IWithClauseContext

	// IsQueryStatementExpressionContext differentiates from other interfaces.
	IsQueryStatementExpressionContext()
}

type QueryStatementExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	w IWithClauseContext 
}

func NewEmptyQueryStatementExpressionContext() *QueryStatementExpressionContext {
	var p = new(QueryStatementExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_queryStatementExpression
	return p
}

func InitEmptyQueryStatementExpressionContext(p *QueryStatementExpressionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_queryStatementExpression
}

func (*QueryStatementExpressionContext) IsQueryStatementExpressionContext() {}

func NewQueryStatementExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryStatementExpressionContext {
	var p = new(QueryStatementExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_queryStatementExpression

	return p
}

func (s *QueryStatementExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryStatementExpressionContext) GetW() IWithClauseContext { return s.w }


func (s *QueryStatementExpressionContext) SetW(v IWithClauseContext) { s.w = v }


func (s *QueryStatementExpressionContext) QueryStatementExpressionBody() IQueryStatementExpressionBodyContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryStatementExpressionBodyContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryStatementExpressionBodyContext)
}

func (s *QueryStatementExpressionContext) WithClause() IWithClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithClauseContext)
}

func (s *QueryStatementExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryStatementExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *QueryStatementExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterQueryStatementExpression(s)
	}
}

func (s *QueryStatementExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitQueryStatementExpression(s)
	}
}

func (s *QueryStatementExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitQueryStatementExpression(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) QueryStatementExpression() (localctx IQueryStatementExpressionContext) {
	localctx = NewQueryStatementExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 382, HiveParserRULE_queryStatementExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2683)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_WITH {
		{
			p.SetState(2682)

			var _x = p.WithClause()


			localctx.(*QueryStatementExpressionContext).w = _x
		}

	}
	{
		p.SetState(2685)
		p.QueryStatementExpressionBody()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IQueryStatementExpressionBodyContext is an interface to support dynamic dispatch.
type IQueryStatementExpressionBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FromStatement() IFromStatementContext
	RegularBody() IRegularBodyContext

	// IsQueryStatementExpressionBodyContext differentiates from other interfaces.
	IsQueryStatementExpressionBodyContext()
}

type QueryStatementExpressionBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryStatementExpressionBodyContext() *QueryStatementExpressionBodyContext {
	var p = new(QueryStatementExpressionBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_queryStatementExpressionBody
	return p
}

func InitEmptyQueryStatementExpressionBodyContext(p *QueryStatementExpressionBodyContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_queryStatementExpressionBody
}

func (*QueryStatementExpressionBodyContext) IsQueryStatementExpressionBodyContext() {}

func NewQueryStatementExpressionBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryStatementExpressionBodyContext {
	var p = new(QueryStatementExpressionBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_queryStatementExpressionBody

	return p
}

func (s *QueryStatementExpressionBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryStatementExpressionBodyContext) FromStatement() IFromStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromStatementContext)
}

func (s *QueryStatementExpressionBodyContext) RegularBody() IRegularBodyContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRegularBodyContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRegularBodyContext)
}

func (s *QueryStatementExpressionBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryStatementExpressionBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *QueryStatementExpressionBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterQueryStatementExpressionBody(s)
	}
}

func (s *QueryStatementExpressionBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitQueryStatementExpressionBody(s)
	}
}

func (s *QueryStatementExpressionBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitQueryStatementExpressionBody(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) QueryStatementExpressionBody() (localctx IQueryStatementExpressionBodyContext) {
	localctx = NewQueryStatementExpressionBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 384, HiveParserRULE_queryStatementExpressionBody)
	p.SetState(2689)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserKW_FROM:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2687)
			p.FromStatement()
		}


	case HiveParserKW_INSERT, HiveParserKW_MAP, HiveParserKW_REDUCE, HiveParserKW_SELECT, HiveParserKW_VALUES, HiveParserLPAREN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2688)
			p.RegularBody()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IWithClauseContext is an interface to support dynamic dispatch.
type IWithClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_WITH() antlr.TerminalNode
	AllCteStatement() []ICteStatementContext
	CteStatement(i int) ICteStatementContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsWithClauseContext differentiates from other interfaces.
	IsWithClauseContext()
}

type WithClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithClauseContext() *WithClauseContext {
	var p = new(WithClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_withClause
	return p
}

func InitEmptyWithClauseContext(p *WithClauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_withClause
}

func (*WithClauseContext) IsWithClauseContext() {}

func NewWithClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithClauseContext {
	var p = new(WithClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_withClause

	return p
}

func (s *WithClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WithClauseContext) KW_WITH() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_WITH, 0)
}

func (s *WithClauseContext) AllCteStatement() []ICteStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICteStatementContext); ok {
			len++
		}
	}

	tst := make([]ICteStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICteStatementContext); ok {
			tst[i] = t.(ICteStatementContext)
			i++
		}
	}

	return tst
}

func (s *WithClauseContext) CteStatement(i int) ICteStatementContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICteStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICteStatementContext)
}

func (s *WithClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(HiveParserCOMMA)
}

func (s *WithClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserCOMMA, i)
}

func (s *WithClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *WithClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterWithClause(s)
	}
}

func (s *WithClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitWithClause(s)
	}
}

func (s *WithClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitWithClause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) WithClause() (localctx IWithClauseContext) {
	localctx = NewWithClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 386, HiveParserRULE_withClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2691)
		p.Match(HiveParserKW_WITH)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2692)
		p.CteStatement()
	}
	p.SetState(2697)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HiveParserCOMMA {
		{
			p.SetState(2693)
			p.Match(HiveParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2694)
			p.CteStatement()
		}


		p.SetState(2699)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICteStatementContext is an interface to support dynamic dispatch.
type ICteStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetColAliases returns the colAliases rule contexts.
	GetColAliases() IColumnNameListContext


	// SetColAliases sets the colAliases rule contexts.
	SetColAliases(IColumnNameListContext)


	// Getter signatures
	Id_() IId_Context
	KW_AS() antlr.TerminalNode
	AllLPAREN() []antlr.TerminalNode
	LPAREN(i int) antlr.TerminalNode
	QueryStatementExpression() IQueryStatementExpressionContext
	AllRPAREN() []antlr.TerminalNode
	RPAREN(i int) antlr.TerminalNode
	ColumnNameList() IColumnNameListContext

	// IsCteStatementContext differentiates from other interfaces.
	IsCteStatementContext()
}

type CteStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	colAliases IColumnNameListContext 
}

func NewEmptyCteStatementContext() *CteStatementContext {
	var p = new(CteStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_cteStatement
	return p
}

func InitEmptyCteStatementContext(p *CteStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_cteStatement
}

func (*CteStatementContext) IsCteStatementContext() {}

func NewCteStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CteStatementContext {
	var p = new(CteStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_cteStatement

	return p
}

func (s *CteStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CteStatementContext) GetColAliases() IColumnNameListContext { return s.colAliases }


func (s *CteStatementContext) SetColAliases(v IColumnNameListContext) { s.colAliases = v }


func (s *CteStatementContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *CteStatementContext) KW_AS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_AS, 0)
}

func (s *CteStatementContext) AllLPAREN() []antlr.TerminalNode {
	return s.GetTokens(HiveParserLPAREN)
}

func (s *CteStatementContext) LPAREN(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserLPAREN, i)
}

func (s *CteStatementContext) QueryStatementExpression() IQueryStatementExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryStatementExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryStatementExpressionContext)
}

func (s *CteStatementContext) AllRPAREN() []antlr.TerminalNode {
	return s.GetTokens(HiveParserRPAREN)
}

func (s *CteStatementContext) RPAREN(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserRPAREN, i)
}

func (s *CteStatementContext) ColumnNameList() IColumnNameListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNameListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNameListContext)
}

func (s *CteStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CteStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CteStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterCteStatement(s)
	}
}

func (s *CteStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitCteStatement(s)
	}
}

func (s *CteStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitCteStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) CteStatement() (localctx ICteStatementContext) {
	localctx = NewCteStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 388, HiveParserRULE_cteStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2700)
		p.Id_()
	}
	p.SetState(2705)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserLPAREN {
		{
			p.SetState(2701)
			p.Match(HiveParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2702)

			var _x = p.ColumnNameList()


			localctx.(*CteStatementContext).colAliases = _x
		}
		{
			p.SetState(2703)
			p.Match(HiveParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(2707)
		p.Match(HiveParserKW_AS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2708)
		p.Match(HiveParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2709)
		p.QueryStatementExpression()
	}
	{
		p.SetState(2710)
		p.Match(HiveParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFromStatementContext is an interface to support dynamic dispatch.
type IFromStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetU returns the u rule contexts.
	GetU() ISetOperatorContext

	// GetR returns the r rule contexts.
	GetR() ISingleFromStatementContext


	// SetU sets the u rule contexts.
	SetU(ISetOperatorContext)

	// SetR sets the r rule contexts.
	SetR(ISingleFromStatementContext)


	// Getter signatures
	AllSingleFromStatement() []ISingleFromStatementContext
	SingleFromStatement(i int) ISingleFromStatementContext
	AllSetOperator() []ISetOperatorContext
	SetOperator(i int) ISetOperatorContext

	// IsFromStatementContext differentiates from other interfaces.
	IsFromStatementContext()
}

type FromStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	u ISetOperatorContext 
	r ISingleFromStatementContext 
}

func NewEmptyFromStatementContext() *FromStatementContext {
	var p = new(FromStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_fromStatement
	return p
}

func InitEmptyFromStatementContext(p *FromStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_fromStatement
}

func (*FromStatementContext) IsFromStatementContext() {}

func NewFromStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FromStatementContext {
	var p = new(FromStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_fromStatement

	return p
}

func (s *FromStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *FromStatementContext) GetU() ISetOperatorContext { return s.u }

func (s *FromStatementContext) GetR() ISingleFromStatementContext { return s.r }


func (s *FromStatementContext) SetU(v ISetOperatorContext) { s.u = v }

func (s *FromStatementContext) SetR(v ISingleFromStatementContext) { s.r = v }


func (s *FromStatementContext) AllSingleFromStatement() []ISingleFromStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleFromStatementContext); ok {
			len++
		}
	}

	tst := make([]ISingleFromStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleFromStatementContext); ok {
			tst[i] = t.(ISingleFromStatementContext)
			i++
		}
	}

	return tst
}

func (s *FromStatementContext) SingleFromStatement(i int) ISingleFromStatementContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleFromStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleFromStatementContext)
}

func (s *FromStatementContext) AllSetOperator() []ISetOperatorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISetOperatorContext); ok {
			len++
		}
	}

	tst := make([]ISetOperatorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISetOperatorContext); ok {
			tst[i] = t.(ISetOperatorContext)
			i++
		}
	}

	return tst
}

func (s *FromStatementContext) SetOperator(i int) ISetOperatorContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetOperatorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetOperatorContext)
}

func (s *FromStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FromStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *FromStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterFromStatement(s)
	}
}

func (s *FromStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitFromStatement(s)
	}
}

func (s *FromStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitFromStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) FromStatement() (localctx IFromStatementContext) {
	localctx = NewFromStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 390, HiveParserRULE_fromStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2712)
		p.SingleFromStatement()
	}
	p.SetState(2718)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HiveParserKW_EXCEPT || _la == HiveParserKW_INTERSECT || _la == HiveParserKW_MINUS || _la == HiveParserKW_UNION {
		{
			p.SetState(2713)

			var _x = p.SetOperator()


			localctx.(*FromStatementContext).u = _x
		}
		{
			p.SetState(2714)

			var _x = p.SingleFromStatement()


			localctx.(*FromStatementContext).r = _x
		}


		p.SetState(2720)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISingleFromStatementContext is an interface to support dynamic dispatch.
type ISingleFromStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_body returns the _body rule contexts.
	Get_body() IBodyContext


	// Set_body sets the _body rule contexts.
	Set_body(IBodyContext)


	// GetB returns the b rule context list.
	GetB() []IBodyContext


	// SetB sets the b rule context list.
	SetB([]IBodyContext) 


	// Getter signatures
	FromClause() IFromClauseContext
	AllBody() []IBodyContext
	Body(i int) IBodyContext

	// IsSingleFromStatementContext differentiates from other interfaces.
	IsSingleFromStatementContext()
}

type SingleFromStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	_body IBodyContext 
	b []IBodyContext
}

func NewEmptySingleFromStatementContext() *SingleFromStatementContext {
	var p = new(SingleFromStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_singleFromStatement
	return p
}

func InitEmptySingleFromStatementContext(p *SingleFromStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_singleFromStatement
}

func (*SingleFromStatementContext) IsSingleFromStatementContext() {}

func NewSingleFromStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleFromStatementContext {
	var p = new(SingleFromStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_singleFromStatement

	return p
}

func (s *SingleFromStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleFromStatementContext) Get_body() IBodyContext { return s._body }


func (s *SingleFromStatementContext) Set_body(v IBodyContext) { s._body = v }


func (s *SingleFromStatementContext) GetB() []IBodyContext { return s.b }


func (s *SingleFromStatementContext) SetB(v []IBodyContext) { s.b = v }


func (s *SingleFromStatementContext) FromClause() IFromClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromClauseContext)
}

func (s *SingleFromStatementContext) AllBody() []IBodyContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBodyContext); ok {
			len++
		}
	}

	tst := make([]IBodyContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBodyContext); ok {
			tst[i] = t.(IBodyContext)
			i++
		}
	}

	return tst
}

func (s *SingleFromStatementContext) Body(i int) IBodyContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBodyContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBodyContext)
}

func (s *SingleFromStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleFromStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SingleFromStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterSingleFromStatement(s)
	}
}

func (s *SingleFromStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitSingleFromStatement(s)
	}
}

func (s *SingleFromStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitSingleFromStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) SingleFromStatement() (localctx ISingleFromStatementContext) {
	localctx = NewSingleFromStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 392, HiveParserRULE_singleFromStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2721)
		p.FromClause()
	}
	p.SetState(2723)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for ok := true; ok; ok = _la == HiveParserKW_INSERT || _la == HiveParserKW_MAP || _la == HiveParserKW_REDUCE || _la == HiveParserKW_SELECT {
		{
			p.SetState(2722)

			var _x = p.Body()


			localctx.(*SingleFromStatementContext)._body = _x
		}
		localctx.(*SingleFromStatementContext).b = append(localctx.(*SingleFromStatementContext).b, localctx.(*SingleFromStatementContext)._body)


		p.SetState(2725)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRegularBodyContext is an interface to support dynamic dispatch.
type IRegularBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetI returns the i rule contexts.
	GetI() IInsertClauseContext

	// GetS returns the s rule contexts.
	GetS() ISelectStatementContext


	// SetI sets the i rule contexts.
	SetI(IInsertClauseContext)

	// SetS sets the s rule contexts.
	SetS(ISelectStatementContext)


	// Getter signatures
	InsertClause() IInsertClauseContext
	SelectStatement() ISelectStatementContext

	// IsRegularBodyContext differentiates from other interfaces.
	IsRegularBodyContext()
}

type RegularBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	i IInsertClauseContext 
	s ISelectStatementContext 
}

func NewEmptyRegularBodyContext() *RegularBodyContext {
	var p = new(RegularBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_regularBody
	return p
}

func InitEmptyRegularBodyContext(p *RegularBodyContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_regularBody
}

func (*RegularBodyContext) IsRegularBodyContext() {}

func NewRegularBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RegularBodyContext {
	var p = new(RegularBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_regularBody

	return p
}

func (s *RegularBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *RegularBodyContext) GetI() IInsertClauseContext { return s.i }

func (s *RegularBodyContext) GetS() ISelectStatementContext { return s.s }


func (s *RegularBodyContext) SetI(v IInsertClauseContext) { s.i = v }

func (s *RegularBodyContext) SetS(v ISelectStatementContext) { s.s = v }


func (s *RegularBodyContext) InsertClause() IInsertClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertClauseContext)
}

func (s *RegularBodyContext) SelectStatement() ISelectStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *RegularBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RegularBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *RegularBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterRegularBody(s)
	}
}

func (s *RegularBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitRegularBody(s)
	}
}

func (s *RegularBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitRegularBody(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) RegularBody() (localctx IRegularBodyContext) {
	localctx = NewRegularBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 394, HiveParserRULE_regularBody)
	p.SetState(2731)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserKW_INSERT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2727)

			var _x = p.InsertClause()


			localctx.(*RegularBodyContext).i = _x
		}
		{
			p.SetState(2728)

			var _x = p.SelectStatement()


			localctx.(*RegularBodyContext).s = _x
		}


	case HiveParserKW_MAP, HiveParserKW_REDUCE, HiveParserKW_SELECT, HiveParserKW_VALUES, HiveParserLPAREN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2730)
			p.SelectStatement()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAtomSelectStatementContext is an interface to support dynamic dispatch.
type IAtomSelectStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetS returns the s rule contexts.
	GetS() ISelectClauseContext

	// GetF returns the f rule contexts.
	GetF() IFromClauseContext

	// GetW returns the w rule contexts.
	GetW() IWhereClauseContext

	// GetG returns the g rule contexts.
	GetG() IGroupByClauseContext

	// GetH returns the h rule contexts.
	GetH() IHavingClauseContext

	// GetWin returns the win rule contexts.
	GetWin() IWindow_clauseContext

	// GetQ returns the q rule contexts.
	GetQ() IQualifyClauseContext


	// SetS sets the s rule contexts.
	SetS(ISelectClauseContext)

	// SetF sets the f rule contexts.
	SetF(IFromClauseContext)

	// SetW sets the w rule contexts.
	SetW(IWhereClauseContext)

	// SetG sets the g rule contexts.
	SetG(IGroupByClauseContext)

	// SetH sets the h rule contexts.
	SetH(IHavingClauseContext)

	// SetWin sets the win rule contexts.
	SetWin(IWindow_clauseContext)

	// SetQ sets the q rule contexts.
	SetQ(IQualifyClauseContext)


	// Getter signatures
	SelectClause() ISelectClauseContext
	FromClause() IFromClauseContext
	WhereClause() IWhereClauseContext
	GroupByClause() IGroupByClauseContext
	HavingClause() IHavingClauseContext
	Window_clause() IWindow_clauseContext
	QualifyClause() IQualifyClauseContext
	LPAREN() antlr.TerminalNode
	SelectStatement() ISelectStatementContext
	RPAREN() antlr.TerminalNode
	ValuesSource() IValuesSourceContext

	// IsAtomSelectStatementContext differentiates from other interfaces.
	IsAtomSelectStatementContext()
}

type AtomSelectStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	s ISelectClauseContext 
	f IFromClauseContext 
	w IWhereClauseContext 
	g IGroupByClauseContext 
	h IHavingClauseContext 
	win IWindow_clauseContext 
	q IQualifyClauseContext 
}

func NewEmptyAtomSelectStatementContext() *AtomSelectStatementContext {
	var p = new(AtomSelectStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_atomSelectStatement
	return p
}

func InitEmptyAtomSelectStatementContext(p *AtomSelectStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_atomSelectStatement
}

func (*AtomSelectStatementContext) IsAtomSelectStatementContext() {}

func NewAtomSelectStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtomSelectStatementContext {
	var p = new(AtomSelectStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_atomSelectStatement

	return p
}

func (s *AtomSelectStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AtomSelectStatementContext) GetS() ISelectClauseContext { return s.s }

func (s *AtomSelectStatementContext) GetF() IFromClauseContext { return s.f }

func (s *AtomSelectStatementContext) GetW() IWhereClauseContext { return s.w }

func (s *AtomSelectStatementContext) GetG() IGroupByClauseContext { return s.g }

func (s *AtomSelectStatementContext) GetH() IHavingClauseContext { return s.h }

func (s *AtomSelectStatementContext) GetWin() IWindow_clauseContext { return s.win }

func (s *AtomSelectStatementContext) GetQ() IQualifyClauseContext { return s.q }


func (s *AtomSelectStatementContext) SetS(v ISelectClauseContext) { s.s = v }

func (s *AtomSelectStatementContext) SetF(v IFromClauseContext) { s.f = v }

func (s *AtomSelectStatementContext) SetW(v IWhereClauseContext) { s.w = v }

func (s *AtomSelectStatementContext) SetG(v IGroupByClauseContext) { s.g = v }

func (s *AtomSelectStatementContext) SetH(v IHavingClauseContext) { s.h = v }

func (s *AtomSelectStatementContext) SetWin(v IWindow_clauseContext) { s.win = v }

func (s *AtomSelectStatementContext) SetQ(v IQualifyClauseContext) { s.q = v }


func (s *AtomSelectStatementContext) SelectClause() ISelectClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectClauseContext)
}

func (s *AtomSelectStatementContext) FromClause() IFromClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromClauseContext)
}

func (s *AtomSelectStatementContext) WhereClause() IWhereClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *AtomSelectStatementContext) GroupByClause() IGroupByClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupByClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupByClauseContext)
}

func (s *AtomSelectStatementContext) HavingClause() IHavingClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHavingClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHavingClauseContext)
}

func (s *AtomSelectStatementContext) Window_clause() IWindow_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindow_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindow_clauseContext)
}

func (s *AtomSelectStatementContext) QualifyClause() IQualifyClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifyClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifyClauseContext)
}

func (s *AtomSelectStatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserLPAREN, 0)
}

func (s *AtomSelectStatementContext) SelectStatement() ISelectStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *AtomSelectStatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserRPAREN, 0)
}

func (s *AtomSelectStatementContext) ValuesSource() IValuesSourceContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValuesSourceContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValuesSourceContext)
}

func (s *AtomSelectStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtomSelectStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AtomSelectStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterAtomSelectStatement(s)
	}
}

func (s *AtomSelectStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitAtomSelectStatement(s)
	}
}

func (s *AtomSelectStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitAtomSelectStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) AtomSelectStatement() (localctx IAtomSelectStatementContext) {
	localctx = NewAtomSelectStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 396, HiveParserRULE_atomSelectStatement)
	var _la int

	p.SetState(2757)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserKW_MAP, HiveParserKW_REDUCE, HiveParserKW_SELECT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2733)

			var _x = p.SelectClause()


			localctx.(*AtomSelectStatementContext).s = _x
		}
		p.SetState(2735)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_FROM {
			{
				p.SetState(2734)

				var _x = p.FromClause()


				localctx.(*AtomSelectStatementContext).f = _x
			}

		}
		p.SetState(2738)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_WHERE {
			{
				p.SetState(2737)

				var _x = p.WhereClause()


				localctx.(*AtomSelectStatementContext).w = _x
			}

		}
		p.SetState(2741)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_GROUP {
			{
				p.SetState(2740)

				var _x = p.GroupByClause()


				localctx.(*AtomSelectStatementContext).g = _x
			}

		}
		p.SetState(2744)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_HAVING {
			{
				p.SetState(2743)

				var _x = p.HavingClause()


				localctx.(*AtomSelectStatementContext).h = _x
			}

		}
		p.SetState(2747)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_WINDOW {
			{
				p.SetState(2746)

				var _x = p.Window_clause()


				localctx.(*AtomSelectStatementContext).win = _x
			}

		}
		p.SetState(2750)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_QUALIFY {
			{
				p.SetState(2749)

				var _x = p.QualifyClause()


				localctx.(*AtomSelectStatementContext).q = _x
			}

		}


	case HiveParserLPAREN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2752)
			p.Match(HiveParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2753)
			p.SelectStatement()
		}
		{
			p.SetState(2754)
			p.Match(HiveParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HiveParserKW_VALUES:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2756)
			p.ValuesSource()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISelectStatementContext is an interface to support dynamic dispatch.
type ISelectStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetA returns the a rule contexts.
	GetA() IAtomSelectStatementContext

	// GetSet returns the set rule contexts.
	GetSet() ISetOpSelectStatementContext

	// GetO returns the o rule contexts.
	GetO() IOrderByClauseContext

	// GetC returns the c rule contexts.
	GetC() IClusterByClauseContext

	// GetD returns the d rule contexts.
	GetD() IDistributeByClauseContext

	// GetSort returns the sort rule contexts.
	GetSort() ISortByClauseContext

	// GetL returns the l rule contexts.
	GetL() ILimitClauseContext


	// SetA sets the a rule contexts.
	SetA(IAtomSelectStatementContext)

	// SetSet sets the set rule contexts.
	SetSet(ISetOpSelectStatementContext)

	// SetO sets the o rule contexts.
	SetO(IOrderByClauseContext)

	// SetC sets the c rule contexts.
	SetC(IClusterByClauseContext)

	// SetD sets the d rule contexts.
	SetD(IDistributeByClauseContext)

	// SetSort sets the sort rule contexts.
	SetSort(ISortByClauseContext)

	// SetL sets the l rule contexts.
	SetL(ILimitClauseContext)


	// Getter signatures
	AtomSelectStatement() IAtomSelectStatementContext
	SetOpSelectStatement() ISetOpSelectStatementContext
	OrderByClause() IOrderByClauseContext
	ClusterByClause() IClusterByClauseContext
	DistributeByClause() IDistributeByClauseContext
	SortByClause() ISortByClauseContext
	LimitClause() ILimitClauseContext

	// IsSelectStatementContext differentiates from other interfaces.
	IsSelectStatementContext()
}

type SelectStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	a IAtomSelectStatementContext 
	set ISetOpSelectStatementContext 
	o IOrderByClauseContext 
	c IClusterByClauseContext 
	d IDistributeByClauseContext 
	sort ISortByClauseContext 
	l ILimitClauseContext 
}

func NewEmptySelectStatementContext() *SelectStatementContext {
	var p = new(SelectStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_selectStatement
	return p
}

func InitEmptySelectStatementContext(p *SelectStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_selectStatement
}

func (*SelectStatementContext) IsSelectStatementContext() {}

func NewSelectStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectStatementContext {
	var p = new(SelectStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_selectStatement

	return p
}

func (s *SelectStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectStatementContext) GetA() IAtomSelectStatementContext { return s.a }

func (s *SelectStatementContext) GetSet() ISetOpSelectStatementContext { return s.set }

func (s *SelectStatementContext) GetO() IOrderByClauseContext { return s.o }

func (s *SelectStatementContext) GetC() IClusterByClauseContext { return s.c }

func (s *SelectStatementContext) GetD() IDistributeByClauseContext { return s.d }

func (s *SelectStatementContext) GetSort() ISortByClauseContext { return s.sort }

func (s *SelectStatementContext) GetL() ILimitClauseContext { return s.l }


func (s *SelectStatementContext) SetA(v IAtomSelectStatementContext) { s.a = v }

func (s *SelectStatementContext) SetSet(v ISetOpSelectStatementContext) { s.set = v }

func (s *SelectStatementContext) SetO(v IOrderByClauseContext) { s.o = v }

func (s *SelectStatementContext) SetC(v IClusterByClauseContext) { s.c = v }

func (s *SelectStatementContext) SetD(v IDistributeByClauseContext) { s.d = v }

func (s *SelectStatementContext) SetSort(v ISortByClauseContext) { s.sort = v }

func (s *SelectStatementContext) SetL(v ILimitClauseContext) { s.l = v }


func (s *SelectStatementContext) AtomSelectStatement() IAtomSelectStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAtomSelectStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAtomSelectStatementContext)
}

func (s *SelectStatementContext) SetOpSelectStatement() ISetOpSelectStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetOpSelectStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetOpSelectStatementContext)
}

func (s *SelectStatementContext) OrderByClause() IOrderByClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByClauseContext)
}

func (s *SelectStatementContext) ClusterByClause() IClusterByClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClusterByClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClusterByClauseContext)
}

func (s *SelectStatementContext) DistributeByClause() IDistributeByClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDistributeByClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDistributeByClauseContext)
}

func (s *SelectStatementContext) SortByClause() ISortByClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortByClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortByClauseContext)
}

func (s *SelectStatementContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *SelectStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SelectStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterSelectStatement(s)
	}
}

func (s *SelectStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitSelectStatement(s)
	}
}

func (s *SelectStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitSelectStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) SelectStatement() (localctx ISelectStatementContext) {
	localctx = NewSelectStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 398, HiveParserRULE_selectStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2759)

		var _x = p.AtomSelectStatement()


		localctx.(*SelectStatementContext).a = _x
	}
	p.SetState(2761)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_EXCEPT || _la == HiveParserKW_INTERSECT || _la == HiveParserKW_MINUS || _la == HiveParserKW_UNION {
		{
			p.SetState(2760)

			var _x = p.SetOpSelectStatement()


			localctx.(*SelectStatementContext).set = _x
		}

	}
	p.SetState(2764)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_ORDER {
		{
			p.SetState(2763)

			var _x = p.OrderByClause()


			localctx.(*SelectStatementContext).o = _x
		}

	}
	p.SetState(2767)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_CLUSTER {
		{
			p.SetState(2766)

			var _x = p.ClusterByClause()


			localctx.(*SelectStatementContext).c = _x
		}

	}
	p.SetState(2770)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_DISTRIBUTE {
		{
			p.SetState(2769)

			var _x = p.DistributeByClause()


			localctx.(*SelectStatementContext).d = _x
		}

	}
	p.SetState(2773)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_SORT {
		{
			p.SetState(2772)

			var _x = p.SortByClause()


			localctx.(*SelectStatementContext).sort = _x
		}

	}
	p.SetState(2776)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_LIMIT {
		{
			p.SetState(2775)

			var _x = p.LimitClause()


			localctx.(*SelectStatementContext).l = _x
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISetOpSelectStatementContext is an interface to support dynamic dispatch.
type ISetOpSelectStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetU returns the u rule contexts.
	GetU() ISetOperatorContext

	// GetB returns the b rule contexts.
	GetB() IAtomSelectStatementContext


	// SetU sets the u rule contexts.
	SetU(ISetOperatorContext)

	// SetB sets the b rule contexts.
	SetB(IAtomSelectStatementContext)


	// Getter signatures
	AllSetOperator() []ISetOperatorContext
	SetOperator(i int) ISetOperatorContext
	AllAtomSelectStatement() []IAtomSelectStatementContext
	AtomSelectStatement(i int) IAtomSelectStatementContext

	// IsSetOpSelectStatementContext differentiates from other interfaces.
	IsSetOpSelectStatementContext()
}

type SetOpSelectStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	u ISetOperatorContext 
	b IAtomSelectStatementContext 
}

func NewEmptySetOpSelectStatementContext() *SetOpSelectStatementContext {
	var p = new(SetOpSelectStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_setOpSelectStatement
	return p
}

func InitEmptySetOpSelectStatementContext(p *SetOpSelectStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_setOpSelectStatement
}

func (*SetOpSelectStatementContext) IsSetOpSelectStatementContext() {}

func NewSetOpSelectStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetOpSelectStatementContext {
	var p = new(SetOpSelectStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_setOpSelectStatement

	return p
}

func (s *SetOpSelectStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SetOpSelectStatementContext) GetU() ISetOperatorContext { return s.u }

func (s *SetOpSelectStatementContext) GetB() IAtomSelectStatementContext { return s.b }


func (s *SetOpSelectStatementContext) SetU(v ISetOperatorContext) { s.u = v }

func (s *SetOpSelectStatementContext) SetB(v IAtomSelectStatementContext) { s.b = v }


func (s *SetOpSelectStatementContext) AllSetOperator() []ISetOperatorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISetOperatorContext); ok {
			len++
		}
	}

	tst := make([]ISetOperatorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISetOperatorContext); ok {
			tst[i] = t.(ISetOperatorContext)
			i++
		}
	}

	return tst
}

func (s *SetOpSelectStatementContext) SetOperator(i int) ISetOperatorContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetOperatorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetOperatorContext)
}

func (s *SetOpSelectStatementContext) AllAtomSelectStatement() []IAtomSelectStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAtomSelectStatementContext); ok {
			len++
		}
	}

	tst := make([]IAtomSelectStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAtomSelectStatementContext); ok {
			tst[i] = t.(IAtomSelectStatementContext)
			i++
		}
	}

	return tst
}

func (s *SetOpSelectStatementContext) AtomSelectStatement(i int) IAtomSelectStatementContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAtomSelectStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAtomSelectStatementContext)
}

func (s *SetOpSelectStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetOpSelectStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SetOpSelectStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterSetOpSelectStatement(s)
	}
}

func (s *SetOpSelectStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitSetOpSelectStatement(s)
	}
}

func (s *SetOpSelectStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitSetOpSelectStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) SetOpSelectStatement() (localctx ISetOpSelectStatementContext) {
	localctx = NewSetOpSelectStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 400, HiveParserRULE_setOpSelectStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2781)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for ok := true; ok; ok = _la == HiveParserKW_EXCEPT || _la == HiveParserKW_INTERSECT || _la == HiveParserKW_MINUS || _la == HiveParserKW_UNION {
		{
			p.SetState(2778)

			var _x = p.SetOperator()


			localctx.(*SetOpSelectStatementContext).u = _x
		}
		{
			p.SetState(2779)

			var _x = p.AtomSelectStatement()


			localctx.(*SetOpSelectStatementContext).b = _x
		}


		p.SetState(2783)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISelectStatementWithCTEContext is an interface to support dynamic dispatch.
type ISelectStatementWithCTEContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetW returns the w rule contexts.
	GetW() IWithClauseContext


	// SetW sets the w rule contexts.
	SetW(IWithClauseContext)


	// Getter signatures
	SelectStatement() ISelectStatementContext
	WithClause() IWithClauseContext

	// IsSelectStatementWithCTEContext differentiates from other interfaces.
	IsSelectStatementWithCTEContext()
}

type SelectStatementWithCTEContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	w IWithClauseContext 
}

func NewEmptySelectStatementWithCTEContext() *SelectStatementWithCTEContext {
	var p = new(SelectStatementWithCTEContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_selectStatementWithCTE
	return p
}

func InitEmptySelectStatementWithCTEContext(p *SelectStatementWithCTEContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_selectStatementWithCTE
}

func (*SelectStatementWithCTEContext) IsSelectStatementWithCTEContext() {}

func NewSelectStatementWithCTEContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectStatementWithCTEContext {
	var p = new(SelectStatementWithCTEContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_selectStatementWithCTE

	return p
}

func (s *SelectStatementWithCTEContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectStatementWithCTEContext) GetW() IWithClauseContext { return s.w }


func (s *SelectStatementWithCTEContext) SetW(v IWithClauseContext) { s.w = v }


func (s *SelectStatementWithCTEContext) SelectStatement() ISelectStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *SelectStatementWithCTEContext) WithClause() IWithClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithClauseContext)
}

func (s *SelectStatementWithCTEContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectStatementWithCTEContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SelectStatementWithCTEContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterSelectStatementWithCTE(s)
	}
}

func (s *SelectStatementWithCTEContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitSelectStatementWithCTE(s)
	}
}

func (s *SelectStatementWithCTEContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitSelectStatementWithCTE(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) SelectStatementWithCTE() (localctx ISelectStatementWithCTEContext) {
	localctx = NewSelectStatementWithCTEContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 402, HiveParserRULE_selectStatementWithCTE)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2786)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_WITH {
		{
			p.SetState(2785)

			var _x = p.WithClause()


			localctx.(*SelectStatementWithCTEContext).w = _x
		}

	}
	{
		p.SetState(2788)
		p.SelectStatement()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IBodyContext is an interface to support dynamic dispatch.
type IBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	InsertClause() IInsertClauseContext
	SelectClause() ISelectClauseContext
	LateralView() ILateralViewContext
	WhereClause() IWhereClauseContext
	GroupByClause() IGroupByClauseContext
	HavingClause() IHavingClauseContext
	Window_clause() IWindow_clauseContext
	QualifyClause() IQualifyClauseContext
	OrderByClause() IOrderByClauseContext
	ClusterByClause() IClusterByClauseContext
	DistributeByClause() IDistributeByClauseContext
	SortByClause() ISortByClauseContext
	LimitClause() ILimitClauseContext

	// IsBodyContext differentiates from other interfaces.
	IsBodyContext()
}

type BodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBodyContext() *BodyContext {
	var p = new(BodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_body
	return p
}

func InitEmptyBodyContext(p *BodyContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_body
}

func (*BodyContext) IsBodyContext() {}

func NewBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BodyContext {
	var p = new(BodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_body

	return p
}

func (s *BodyContext) GetParser() antlr.Parser { return s.parser }

func (s *BodyContext) InsertClause() IInsertClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertClauseContext)
}

func (s *BodyContext) SelectClause() ISelectClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectClauseContext)
}

func (s *BodyContext) LateralView() ILateralViewContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILateralViewContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILateralViewContext)
}

func (s *BodyContext) WhereClause() IWhereClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *BodyContext) GroupByClause() IGroupByClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupByClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupByClauseContext)
}

func (s *BodyContext) HavingClause() IHavingClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHavingClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHavingClauseContext)
}

func (s *BodyContext) Window_clause() IWindow_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindow_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindow_clauseContext)
}

func (s *BodyContext) QualifyClause() IQualifyClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifyClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifyClauseContext)
}

func (s *BodyContext) OrderByClause() IOrderByClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByClauseContext)
}

func (s *BodyContext) ClusterByClause() IClusterByClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClusterByClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClusterByClauseContext)
}

func (s *BodyContext) DistributeByClause() IDistributeByClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDistributeByClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDistributeByClauseContext)
}

func (s *BodyContext) SortByClause() ISortByClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortByClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortByClauseContext)
}

func (s *BodyContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *BodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *BodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterBody(s)
	}
}

func (s *BodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitBody(s)
	}
}

func (s *BodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitBody(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) Body() (localctx IBodyContext) {
	localctx = NewBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 404, HiveParserRULE_body)
	var _la int

	p.SetState(2859)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserKW_INSERT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2790)
			p.InsertClause()
		}
		{
			p.SetState(2791)
			p.SelectClause()
		}
		p.SetState(2793)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_LATERAL || _la == HiveParserCOMMA {
			{
				p.SetState(2792)
				p.LateralView()
			}

		}
		p.SetState(2796)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_WHERE {
			{
				p.SetState(2795)
				p.WhereClause()
			}

		}
		p.SetState(2799)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_GROUP {
			{
				p.SetState(2798)
				p.GroupByClause()
			}

		}
		p.SetState(2802)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_HAVING {
			{
				p.SetState(2801)
				p.HavingClause()
			}

		}
		p.SetState(2805)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_WINDOW {
			{
				p.SetState(2804)
				p.Window_clause()
			}

		}
		p.SetState(2808)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_QUALIFY {
			{
				p.SetState(2807)
				p.QualifyClause()
			}

		}
		p.SetState(2811)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_ORDER {
			{
				p.SetState(2810)
				p.OrderByClause()
			}

		}
		p.SetState(2814)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_CLUSTER {
			{
				p.SetState(2813)
				p.ClusterByClause()
			}

		}
		p.SetState(2817)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_DISTRIBUTE {
			{
				p.SetState(2816)
				p.DistributeByClause()
			}

		}
		p.SetState(2820)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_SORT {
			{
				p.SetState(2819)
				p.SortByClause()
			}

		}
		p.SetState(2823)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_LIMIT {
			{
				p.SetState(2822)
				p.LimitClause()
			}

		}


	case HiveParserKW_MAP, HiveParserKW_REDUCE, HiveParserKW_SELECT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2825)
			p.SelectClause()
		}
		p.SetState(2827)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_LATERAL || _la == HiveParserCOMMA {
			{
				p.SetState(2826)
				p.LateralView()
			}

		}
		p.SetState(2830)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_WHERE {
			{
				p.SetState(2829)
				p.WhereClause()
			}

		}
		p.SetState(2833)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_GROUP {
			{
				p.SetState(2832)
				p.GroupByClause()
			}

		}
		p.SetState(2836)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_HAVING {
			{
				p.SetState(2835)
				p.HavingClause()
			}

		}
		p.SetState(2839)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_WINDOW {
			{
				p.SetState(2838)
				p.Window_clause()
			}

		}
		p.SetState(2842)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_QUALIFY {
			{
				p.SetState(2841)
				p.QualifyClause()
			}

		}
		p.SetState(2845)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_ORDER {
			{
				p.SetState(2844)
				p.OrderByClause()
			}

		}
		p.SetState(2848)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_CLUSTER {
			{
				p.SetState(2847)
				p.ClusterByClause()
			}

		}
		p.SetState(2851)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_DISTRIBUTE {
			{
				p.SetState(2850)
				p.DistributeByClause()
			}

		}
		p.SetState(2854)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_SORT {
			{
				p.SetState(2853)
				p.SortByClause()
			}

		}
		p.SetState(2857)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_LIMIT {
			{
				p.SetState(2856)
				p.LimitClause()
			}

		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IInsertClauseContext is an interface to support dynamic dispatch.
type IInsertClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTargetCols returns the targetCols rule contexts.
	GetTargetCols() IColumnNameListContext


	// SetTargetCols sets the targetCols rule contexts.
	SetTargetCols(IColumnNameListContext)


	// Getter signatures
	KW_INSERT() antlr.TerminalNode
	KW_OVERWRITE() antlr.TerminalNode
	Destination() IDestinationContext
	KW_INTO() antlr.TerminalNode
	TableOrPartition() ITableOrPartitionContext
	IfNotExists() IIfNotExistsContext
	KW_TABLE() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	ColumnNameList() IColumnNameListContext

	// IsInsertClauseContext differentiates from other interfaces.
	IsInsertClauseContext()
}

type InsertClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	targetCols IColumnNameListContext 
}

func NewEmptyInsertClauseContext() *InsertClauseContext {
	var p = new(InsertClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_insertClause
	return p
}

func InitEmptyInsertClauseContext(p *InsertClauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_insertClause
}

func (*InsertClauseContext) IsInsertClauseContext() {}

func NewInsertClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InsertClauseContext {
	var p = new(InsertClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_insertClause

	return p
}

func (s *InsertClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *InsertClauseContext) GetTargetCols() IColumnNameListContext { return s.targetCols }


func (s *InsertClauseContext) SetTargetCols(v IColumnNameListContext) { s.targetCols = v }


func (s *InsertClauseContext) KW_INSERT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_INSERT, 0)
}

func (s *InsertClauseContext) KW_OVERWRITE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_OVERWRITE, 0)
}

func (s *InsertClauseContext) Destination() IDestinationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDestinationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDestinationContext)
}

func (s *InsertClauseContext) KW_INTO() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_INTO, 0)
}

func (s *InsertClauseContext) TableOrPartition() ITableOrPartitionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableOrPartitionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableOrPartitionContext)
}

func (s *InsertClauseContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *InsertClauseContext) KW_TABLE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TABLE, 0)
}

func (s *InsertClauseContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserLPAREN, 0)
}

func (s *InsertClauseContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserRPAREN, 0)
}

func (s *InsertClauseContext) ColumnNameList() IColumnNameListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNameListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNameListContext)
}

func (s *InsertClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *InsertClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterInsertClause(s)
	}
}

func (s *InsertClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitInsertClause(s)
	}
}

func (s *InsertClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitInsertClause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) InsertClause() (localctx IInsertClauseContext) {
	localctx = NewInsertClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 406, HiveParserRULE_insertClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2861)
		p.Match(HiveParserKW_INSERT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(2878)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserKW_OVERWRITE:
		{
			p.SetState(2862)
			p.Match(HiveParserKW_OVERWRITE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2863)
			p.Destination()
		}
		p.SetState(2865)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_IF {
			{
				p.SetState(2864)
				p.IfNotExists()
			}

		}


	case HiveParserKW_INTO:
		{
			p.SetState(2867)
			p.Match(HiveParserKW_INTO)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2869)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_TABLE {
			{
				p.SetState(2868)
				p.Match(HiveParserKW_TABLE)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(2871)
			p.TableOrPartition()
		}
		p.SetState(2876)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 291, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2872)
				p.Match(HiveParserLPAREN)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2873)

				var _x = p.ColumnNameList()


				localctx.(*InsertClauseContext).targetCols = _x
			}
			{
				p.SetState(2874)
				p.Match(HiveParserRPAREN)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDestinationContext is an interface to support dynamic dispatch.
type IDestinationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLocal returns the local token.
	GetLocal() antlr.Token 


	// SetLocal sets the local token.
	SetLocal(antlr.Token) 


	// Getter signatures
	KW_DIRECTORY() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode
	TableRowFormat() ITableRowFormatContext
	TableFileFormat() ITableFileFormatContext
	KW_LOCAL() antlr.TerminalNode
	KW_TABLE() antlr.TerminalNode
	TableOrPartition() ITableOrPartitionContext

	// IsDestinationContext differentiates from other interfaces.
	IsDestinationContext()
}

type DestinationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	local antlr.Token
}

func NewEmptyDestinationContext() *DestinationContext {
	var p = new(DestinationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_destination
	return p
}

func InitEmptyDestinationContext(p *DestinationContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_destination
}

func (*DestinationContext) IsDestinationContext() {}

func NewDestinationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DestinationContext {
	var p = new(DestinationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_destination

	return p
}

func (s *DestinationContext) GetParser() antlr.Parser { return s.parser }

func (s *DestinationContext) GetLocal() antlr.Token { return s.local }


func (s *DestinationContext) SetLocal(v antlr.Token) { s.local = v }


func (s *DestinationContext) KW_DIRECTORY() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DIRECTORY, 0)
}

func (s *DestinationContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(HiveParserStringLiteral, 0)
}

func (s *DestinationContext) TableRowFormat() ITableRowFormatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableRowFormatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableRowFormatContext)
}

func (s *DestinationContext) TableFileFormat() ITableFileFormatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableFileFormatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableFileFormatContext)
}

func (s *DestinationContext) KW_LOCAL() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_LOCAL, 0)
}

func (s *DestinationContext) KW_TABLE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TABLE, 0)
}

func (s *DestinationContext) TableOrPartition() ITableOrPartitionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableOrPartitionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableOrPartitionContext)
}

func (s *DestinationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DestinationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DestinationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterDestination(s)
	}
}

func (s *DestinationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitDestination(s)
	}
}

func (s *DestinationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitDestination(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) Destination() (localctx IDestinationContext) {
	localctx = NewDestinationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 408, HiveParserRULE_destination)
	var _la int

	p.SetState(2893)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserKW_DIRECTORY, HiveParserKW_LOCAL:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(2881)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_LOCAL {
			{
				p.SetState(2880)

				var _m = p.Match(HiveParserKW_LOCAL)

				localctx.(*DestinationContext).local = _m
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(2883)
			p.Match(HiveParserKW_DIRECTORY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2884)
			p.Match(HiveParserStringLiteral)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2886)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_ROW {
			{
				p.SetState(2885)
				p.TableRowFormat()
			}

		}
		p.SetState(2889)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_STORED {
			{
				p.SetState(2888)
				p.TableFileFormat()
			}

		}


	case HiveParserKW_TABLE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2891)
			p.Match(HiveParserKW_TABLE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2892)
			p.TableOrPartition()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ILimitClauseContext is an interface to support dynamic dispatch.
type ILimitClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOffset returns the offset token.
	GetOffset() antlr.Token 

	// GetNum returns the num token.
	GetNum() antlr.Token 


	// SetOffset sets the offset token.
	SetOffset(antlr.Token) 

	// SetNum sets the num token.
	SetNum(antlr.Token) 


	// Getter signatures
	KW_LIMIT() antlr.TerminalNode
	KW_OFFSET() antlr.TerminalNode
	AllNumber() []antlr.TerminalNode
	Number(i int) antlr.TerminalNode
	COMMA() antlr.TerminalNode

	// IsLimitClauseContext differentiates from other interfaces.
	IsLimitClauseContext()
}

type LimitClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	offset antlr.Token
	num antlr.Token
}

func NewEmptyLimitClauseContext() *LimitClauseContext {
	var p = new(LimitClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_limitClause
	return p
}

func InitEmptyLimitClauseContext(p *LimitClauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_limitClause
}

func (*LimitClauseContext) IsLimitClauseContext() {}

func NewLimitClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LimitClauseContext {
	var p = new(LimitClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_limitClause

	return p
}

func (s *LimitClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LimitClauseContext) GetOffset() antlr.Token { return s.offset }

func (s *LimitClauseContext) GetNum() antlr.Token { return s.num }


func (s *LimitClauseContext) SetOffset(v antlr.Token) { s.offset = v }

func (s *LimitClauseContext) SetNum(v antlr.Token) { s.num = v }


func (s *LimitClauseContext) KW_LIMIT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_LIMIT, 0)
}

func (s *LimitClauseContext) KW_OFFSET() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_OFFSET, 0)
}

func (s *LimitClauseContext) AllNumber() []antlr.TerminalNode {
	return s.GetTokens(HiveParserNumber)
}

func (s *LimitClauseContext) Number(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserNumber, i)
}

func (s *LimitClauseContext) COMMA() antlr.TerminalNode {
	return s.GetToken(HiveParserCOMMA, 0)
}

func (s *LimitClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LimitClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *LimitClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterLimitClause(s)
	}
}

func (s *LimitClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitLimitClause(s)
	}
}

func (s *LimitClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitLimitClause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) LimitClause() (localctx ILimitClauseContext) {
	localctx = NewLimitClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 410, HiveParserRULE_limitClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2895)
		p.Match(HiveParserKW_LIMIT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(2904)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 298, p.GetParserRuleContext()) {
	case 1:
		p.SetState(2898)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 297, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2896)

				var _m = p.Match(HiveParserNumber)

				localctx.(*LimitClauseContext).offset = _m
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2897)
				p.Match(HiveParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		{
			p.SetState(2900)

			var _m = p.Match(HiveParserNumber)

			localctx.(*LimitClauseContext).num = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		{
			p.SetState(2901)

			var _m = p.Match(HiveParserNumber)

			localctx.(*LimitClauseContext).num = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2902)
			p.Match(HiveParserKW_OFFSET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2903)

			var _m = p.Match(HiveParserNumber)

			localctx.(*LimitClauseContext).offset = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDeleteStatementContext is an interface to support dynamic dispatch.
type IDeleteStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_DELETE() antlr.TerminalNode
	KW_FROM() antlr.TerminalNode
	TableName() ITableNameContext
	WhereClause() IWhereClauseContext

	// IsDeleteStatementContext differentiates from other interfaces.
	IsDeleteStatementContext()
}

type DeleteStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeleteStatementContext() *DeleteStatementContext {
	var p = new(DeleteStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_deleteStatement
	return p
}

func InitEmptyDeleteStatementContext(p *DeleteStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_deleteStatement
}

func (*DeleteStatementContext) IsDeleteStatementContext() {}

func NewDeleteStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeleteStatementContext {
	var p = new(DeleteStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_deleteStatement

	return p
}

func (s *DeleteStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DeleteStatementContext) KW_DELETE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DELETE, 0)
}

func (s *DeleteStatementContext) KW_FROM() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_FROM, 0)
}

func (s *DeleteStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *DeleteStatementContext) WhereClause() IWhereClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *DeleteStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeleteStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DeleteStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterDeleteStatement(s)
	}
}

func (s *DeleteStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitDeleteStatement(s)
	}
}

func (s *DeleteStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitDeleteStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) DeleteStatement() (localctx IDeleteStatementContext) {
	localctx = NewDeleteStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 412, HiveParserRULE_deleteStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2906)
		p.Match(HiveParserKW_DELETE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2907)
		p.Match(HiveParserKW_FROM)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2908)
		p.TableName()
	}
	p.SetState(2910)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_WHERE {
		{
			p.SetState(2909)
			p.WhereClause()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IColumnAssignmentClauseContext is an interface to support dynamic dispatch.
type IColumnAssignmentClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TableOrColumn() ITableOrColumnContext
	EQUAL() antlr.TerminalNode
	PrecedencePlusExpressionOrDefault() IPrecedencePlusExpressionOrDefaultContext

	// IsColumnAssignmentClauseContext differentiates from other interfaces.
	IsColumnAssignmentClauseContext()
}

type ColumnAssignmentClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnAssignmentClauseContext() *ColumnAssignmentClauseContext {
	var p = new(ColumnAssignmentClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_columnAssignmentClause
	return p
}

func InitEmptyColumnAssignmentClauseContext(p *ColumnAssignmentClauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_columnAssignmentClause
}

func (*ColumnAssignmentClauseContext) IsColumnAssignmentClauseContext() {}

func NewColumnAssignmentClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnAssignmentClauseContext {
	var p = new(ColumnAssignmentClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_columnAssignmentClause

	return p
}

func (s *ColumnAssignmentClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnAssignmentClauseContext) TableOrColumn() ITableOrColumnContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableOrColumnContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableOrColumnContext)
}

func (s *ColumnAssignmentClauseContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(HiveParserEQUAL, 0)
}

func (s *ColumnAssignmentClauseContext) PrecedencePlusExpressionOrDefault() IPrecedencePlusExpressionOrDefaultContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrecedencePlusExpressionOrDefaultContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrecedencePlusExpressionOrDefaultContext)
}

func (s *ColumnAssignmentClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnAssignmentClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ColumnAssignmentClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterColumnAssignmentClause(s)
	}
}

func (s *ColumnAssignmentClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitColumnAssignmentClause(s)
	}
}

func (s *ColumnAssignmentClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitColumnAssignmentClause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ColumnAssignmentClause() (localctx IColumnAssignmentClauseContext) {
	localctx = NewColumnAssignmentClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 414, HiveParserRULE_columnAssignmentClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2912)
		p.TableOrColumn()
	}
	{
		p.SetState(2913)
		p.Match(HiveParserEQUAL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2914)
		p.PrecedencePlusExpressionOrDefault()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPrecedencePlusExpressionOrDefaultContext is an interface to support dynamic dispatch.
type IPrecedencePlusExpressionOrDefaultContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DefaultValue() IDefaultValueContext
	PrecedencePlusExpression() IPrecedencePlusExpressionContext

	// IsPrecedencePlusExpressionOrDefaultContext differentiates from other interfaces.
	IsPrecedencePlusExpressionOrDefaultContext()
}

type PrecedencePlusExpressionOrDefaultContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrecedencePlusExpressionOrDefaultContext() *PrecedencePlusExpressionOrDefaultContext {
	var p = new(PrecedencePlusExpressionOrDefaultContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_precedencePlusExpressionOrDefault
	return p
}

func InitEmptyPrecedencePlusExpressionOrDefaultContext(p *PrecedencePlusExpressionOrDefaultContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_precedencePlusExpressionOrDefault
}

func (*PrecedencePlusExpressionOrDefaultContext) IsPrecedencePlusExpressionOrDefaultContext() {}

func NewPrecedencePlusExpressionOrDefaultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrecedencePlusExpressionOrDefaultContext {
	var p = new(PrecedencePlusExpressionOrDefaultContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_precedencePlusExpressionOrDefault

	return p
}

func (s *PrecedencePlusExpressionOrDefaultContext) GetParser() antlr.Parser { return s.parser }

func (s *PrecedencePlusExpressionOrDefaultContext) DefaultValue() IDefaultValueContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefaultValueContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefaultValueContext)
}

func (s *PrecedencePlusExpressionOrDefaultContext) PrecedencePlusExpression() IPrecedencePlusExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrecedencePlusExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrecedencePlusExpressionContext)
}

func (s *PrecedencePlusExpressionOrDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrecedencePlusExpressionOrDefaultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PrecedencePlusExpressionOrDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterPrecedencePlusExpressionOrDefault(s)
	}
}

func (s *PrecedencePlusExpressionOrDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitPrecedencePlusExpressionOrDefault(s)
	}
}

func (s *PrecedencePlusExpressionOrDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitPrecedencePlusExpressionOrDefault(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) PrecedencePlusExpressionOrDefault() (localctx IPrecedencePlusExpressionOrDefaultContext) {
	localctx = NewPrecedencePlusExpressionOrDefaultContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 416, HiveParserRULE_precedencePlusExpressionOrDefault)
	p.SetState(2918)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 300, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2916)
			p.DefaultValue()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2917)
			p.PrecedencePlusExpression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISetColumnsClauseContext is an interface to support dynamic dispatch.
type ISetColumnsClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_SET() antlr.TerminalNode
	AllColumnAssignmentClause() []IColumnAssignmentClauseContext
	ColumnAssignmentClause(i int) IColumnAssignmentClauseContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsSetColumnsClauseContext differentiates from other interfaces.
	IsSetColumnsClauseContext()
}

type SetColumnsClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetColumnsClauseContext() *SetColumnsClauseContext {
	var p = new(SetColumnsClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_setColumnsClause
	return p
}

func InitEmptySetColumnsClauseContext(p *SetColumnsClauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_setColumnsClause
}

func (*SetColumnsClauseContext) IsSetColumnsClauseContext() {}

func NewSetColumnsClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetColumnsClauseContext {
	var p = new(SetColumnsClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_setColumnsClause

	return p
}

func (s *SetColumnsClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SetColumnsClauseContext) KW_SET() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SET, 0)
}

func (s *SetColumnsClauseContext) AllColumnAssignmentClause() []IColumnAssignmentClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnAssignmentClauseContext); ok {
			len++
		}
	}

	tst := make([]IColumnAssignmentClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnAssignmentClauseContext); ok {
			tst[i] = t.(IColumnAssignmentClauseContext)
			i++
		}
	}

	return tst
}

func (s *SetColumnsClauseContext) ColumnAssignmentClause(i int) IColumnAssignmentClauseContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnAssignmentClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnAssignmentClauseContext)
}

func (s *SetColumnsClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(HiveParserCOMMA)
}

func (s *SetColumnsClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserCOMMA, i)
}

func (s *SetColumnsClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetColumnsClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SetColumnsClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterSetColumnsClause(s)
	}
}

func (s *SetColumnsClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitSetColumnsClause(s)
	}
}

func (s *SetColumnsClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitSetColumnsClause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) SetColumnsClause() (localctx ISetColumnsClauseContext) {
	localctx = NewSetColumnsClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 418, HiveParserRULE_setColumnsClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2920)
		p.Match(HiveParserKW_SET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2921)
		p.ColumnAssignmentClause()
	}
	p.SetState(2926)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HiveParserCOMMA {
		{
			p.SetState(2922)
			p.Match(HiveParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2923)
			p.ColumnAssignmentClause()
		}


		p.SetState(2928)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IUpdateStatementContext is an interface to support dynamic dispatch.
type IUpdateStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_UPDATE() antlr.TerminalNode
	TableName() ITableNameContext
	SetColumnsClause() ISetColumnsClauseContext
	WhereClause() IWhereClauseContext

	// IsUpdateStatementContext differentiates from other interfaces.
	IsUpdateStatementContext()
}

type UpdateStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUpdateStatementContext() *UpdateStatementContext {
	var p = new(UpdateStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_updateStatement
	return p
}

func InitEmptyUpdateStatementContext(p *UpdateStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_updateStatement
}

func (*UpdateStatementContext) IsUpdateStatementContext() {}

func NewUpdateStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UpdateStatementContext {
	var p = new(UpdateStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_updateStatement

	return p
}

func (s *UpdateStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UpdateStatementContext) KW_UPDATE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_UPDATE, 0)
}

func (s *UpdateStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *UpdateStatementContext) SetColumnsClause() ISetColumnsClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetColumnsClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetColumnsClauseContext)
}

func (s *UpdateStatementContext) WhereClause() IWhereClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *UpdateStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UpdateStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *UpdateStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterUpdateStatement(s)
	}
}

func (s *UpdateStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitUpdateStatement(s)
	}
}

func (s *UpdateStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitUpdateStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) UpdateStatement() (localctx IUpdateStatementContext) {
	localctx = NewUpdateStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 420, HiveParserRULE_updateStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2929)
		p.Match(HiveParserKW_UPDATE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2930)
		p.TableName()
	}
	{
		p.SetState(2931)
		p.SetColumnsClause()
	}
	p.SetState(2933)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_WHERE {
		{
			p.SetState(2932)
			p.WhereClause()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISqlTransactionStatementContext is an interface to support dynamic dispatch.
type ISqlTransactionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	StartTransactionStatement() IStartTransactionStatementContext
	CommitStatement() ICommitStatementContext
	RollbackStatement() IRollbackStatementContext
	SetAutoCommitStatement() ISetAutoCommitStatementContext

	// IsSqlTransactionStatementContext differentiates from other interfaces.
	IsSqlTransactionStatementContext()
}

type SqlTransactionStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySqlTransactionStatementContext() *SqlTransactionStatementContext {
	var p = new(SqlTransactionStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_sqlTransactionStatement
	return p
}

func InitEmptySqlTransactionStatementContext(p *SqlTransactionStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_sqlTransactionStatement
}

func (*SqlTransactionStatementContext) IsSqlTransactionStatementContext() {}

func NewSqlTransactionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SqlTransactionStatementContext {
	var p = new(SqlTransactionStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_sqlTransactionStatement

	return p
}

func (s *SqlTransactionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SqlTransactionStatementContext) StartTransactionStatement() IStartTransactionStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStartTransactionStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStartTransactionStatementContext)
}

func (s *SqlTransactionStatementContext) CommitStatement() ICommitStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommitStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommitStatementContext)
}

func (s *SqlTransactionStatementContext) RollbackStatement() IRollbackStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRollbackStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRollbackStatementContext)
}

func (s *SqlTransactionStatementContext) SetAutoCommitStatement() ISetAutoCommitStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetAutoCommitStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetAutoCommitStatementContext)
}

func (s *SqlTransactionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SqlTransactionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SqlTransactionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterSqlTransactionStatement(s)
	}
}

func (s *SqlTransactionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitSqlTransactionStatement(s)
	}
}

func (s *SqlTransactionStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitSqlTransactionStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) SqlTransactionStatement() (localctx ISqlTransactionStatementContext) {
	localctx = NewSqlTransactionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 422, HiveParserRULE_sqlTransactionStatement)
	p.SetState(2939)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserKW_START:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2935)
			p.StartTransactionStatement()
		}


	case HiveParserKW_COMMIT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2936)
			p.CommitStatement()
		}


	case HiveParserKW_ROLLBACK:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2937)
			p.RollbackStatement()
		}


	case HiveParserKW_SET:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2938)
			p.SetAutoCommitStatement()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IStartTransactionStatementContext is an interface to support dynamic dispatch.
type IStartTransactionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_START() antlr.TerminalNode
	KW_TRANSACTION() antlr.TerminalNode
	AllTransactionMode() []ITransactionModeContext
	TransactionMode(i int) ITransactionModeContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsStartTransactionStatementContext differentiates from other interfaces.
	IsStartTransactionStatementContext()
}

type StartTransactionStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStartTransactionStatementContext() *StartTransactionStatementContext {
	var p = new(StartTransactionStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_startTransactionStatement
	return p
}

func InitEmptyStartTransactionStatementContext(p *StartTransactionStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_startTransactionStatement
}

func (*StartTransactionStatementContext) IsStartTransactionStatementContext() {}

func NewStartTransactionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StartTransactionStatementContext {
	var p = new(StartTransactionStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_startTransactionStatement

	return p
}

func (s *StartTransactionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StartTransactionStatementContext) KW_START() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_START, 0)
}

func (s *StartTransactionStatementContext) KW_TRANSACTION() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TRANSACTION, 0)
}

func (s *StartTransactionStatementContext) AllTransactionMode() []ITransactionModeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITransactionModeContext); ok {
			len++
		}
	}

	tst := make([]ITransactionModeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITransactionModeContext); ok {
			tst[i] = t.(ITransactionModeContext)
			i++
		}
	}

	return tst
}

func (s *StartTransactionStatementContext) TransactionMode(i int) ITransactionModeContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITransactionModeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITransactionModeContext)
}

func (s *StartTransactionStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(HiveParserCOMMA)
}

func (s *StartTransactionStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserCOMMA, i)
}

func (s *StartTransactionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StartTransactionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *StartTransactionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterStartTransactionStatement(s)
	}
}

func (s *StartTransactionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitStartTransactionStatement(s)
	}
}

func (s *StartTransactionStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitStartTransactionStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) StartTransactionStatement() (localctx IStartTransactionStatementContext) {
	localctx = NewStartTransactionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 424, HiveParserRULE_startTransactionStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2941)
		p.Match(HiveParserKW_START)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2942)
		p.Match(HiveParserKW_TRANSACTION)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(2951)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_ISOLATION || _la == HiveParserKW_READ {
		{
			p.SetState(2943)
			p.TransactionMode()
		}
		p.SetState(2948)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == HiveParserCOMMA {
			{
				p.SetState(2944)
				p.Match(HiveParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2945)
				p.TransactionMode()
			}


			p.SetState(2950)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITransactionModeContext is an interface to support dynamic dispatch.
type ITransactionModeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IsolationLevel() IIsolationLevelContext
	TransactionAccessMode() ITransactionAccessModeContext

	// IsTransactionModeContext differentiates from other interfaces.
	IsTransactionModeContext()
}

type TransactionModeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransactionModeContext() *TransactionModeContext {
	var p = new(TransactionModeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_transactionMode
	return p
}

func InitEmptyTransactionModeContext(p *TransactionModeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_transactionMode
}

func (*TransactionModeContext) IsTransactionModeContext() {}

func NewTransactionModeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TransactionModeContext {
	var p = new(TransactionModeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_transactionMode

	return p
}

func (s *TransactionModeContext) GetParser() antlr.Parser { return s.parser }

func (s *TransactionModeContext) IsolationLevel() IIsolationLevelContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIsolationLevelContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIsolationLevelContext)
}

func (s *TransactionModeContext) TransactionAccessMode() ITransactionAccessModeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITransactionAccessModeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITransactionAccessModeContext)
}

func (s *TransactionModeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransactionModeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TransactionModeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterTransactionMode(s)
	}
}

func (s *TransactionModeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitTransactionMode(s)
	}
}

func (s *TransactionModeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitTransactionMode(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) TransactionMode() (localctx ITransactionModeContext) {
	localctx = NewTransactionModeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 426, HiveParserRULE_transactionMode)
	p.SetState(2955)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserKW_ISOLATION:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2953)
			p.IsolationLevel()
		}


	case HiveParserKW_READ:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2954)
			p.TransactionAccessMode()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITransactionAccessModeContext is an interface to support dynamic dispatch.
type ITransactionAccessModeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_READ() antlr.TerminalNode
	KW_ONLY() antlr.TerminalNode
	KW_WRITE() antlr.TerminalNode

	// IsTransactionAccessModeContext differentiates from other interfaces.
	IsTransactionAccessModeContext()
}

type TransactionAccessModeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransactionAccessModeContext() *TransactionAccessModeContext {
	var p = new(TransactionAccessModeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_transactionAccessMode
	return p
}

func InitEmptyTransactionAccessModeContext(p *TransactionAccessModeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_transactionAccessMode
}

func (*TransactionAccessModeContext) IsTransactionAccessModeContext() {}

func NewTransactionAccessModeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TransactionAccessModeContext {
	var p = new(TransactionAccessModeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_transactionAccessMode

	return p
}

func (s *TransactionAccessModeContext) GetParser() antlr.Parser { return s.parser }

func (s *TransactionAccessModeContext) KW_READ() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_READ, 0)
}

func (s *TransactionAccessModeContext) KW_ONLY() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ONLY, 0)
}

func (s *TransactionAccessModeContext) KW_WRITE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_WRITE, 0)
}

func (s *TransactionAccessModeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransactionAccessModeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TransactionAccessModeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterTransactionAccessMode(s)
	}
}

func (s *TransactionAccessModeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitTransactionAccessMode(s)
	}
}

func (s *TransactionAccessModeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitTransactionAccessMode(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) TransactionAccessMode() (localctx ITransactionAccessModeContext) {
	localctx = NewTransactionAccessModeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 428, HiveParserRULE_transactionAccessMode)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2957)
		p.Match(HiveParserKW_READ)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2958)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HiveParserKW_ONLY || _la == HiveParserKW_WRITE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IIsolationLevelContext is an interface to support dynamic dispatch.
type IIsolationLevelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_ISOLATION() antlr.TerminalNode
	KW_LEVEL() antlr.TerminalNode
	LevelOfIsolation() ILevelOfIsolationContext

	// IsIsolationLevelContext differentiates from other interfaces.
	IsIsolationLevelContext()
}

type IsolationLevelContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIsolationLevelContext() *IsolationLevelContext {
	var p = new(IsolationLevelContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_isolationLevel
	return p
}

func InitEmptyIsolationLevelContext(p *IsolationLevelContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_isolationLevel
}

func (*IsolationLevelContext) IsIsolationLevelContext() {}

func NewIsolationLevelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IsolationLevelContext {
	var p = new(IsolationLevelContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_isolationLevel

	return p
}

func (s *IsolationLevelContext) GetParser() antlr.Parser { return s.parser }

func (s *IsolationLevelContext) KW_ISOLATION() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ISOLATION, 0)
}

func (s *IsolationLevelContext) KW_LEVEL() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_LEVEL, 0)
}

func (s *IsolationLevelContext) LevelOfIsolation() ILevelOfIsolationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILevelOfIsolationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILevelOfIsolationContext)
}

func (s *IsolationLevelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IsolationLevelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *IsolationLevelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterIsolationLevel(s)
	}
}

func (s *IsolationLevelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitIsolationLevel(s)
	}
}

func (s *IsolationLevelContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitIsolationLevel(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) IsolationLevel() (localctx IIsolationLevelContext) {
	localctx = NewIsolationLevelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 430, HiveParserRULE_isolationLevel)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2960)
		p.Match(HiveParserKW_ISOLATION)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2961)
		p.Match(HiveParserKW_LEVEL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2962)
		p.LevelOfIsolation()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ILevelOfIsolationContext is an interface to support dynamic dispatch.
type ILevelOfIsolationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_SNAPSHOT() antlr.TerminalNode

	// IsLevelOfIsolationContext differentiates from other interfaces.
	IsLevelOfIsolationContext()
}

type LevelOfIsolationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLevelOfIsolationContext() *LevelOfIsolationContext {
	var p = new(LevelOfIsolationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_levelOfIsolation
	return p
}

func InitEmptyLevelOfIsolationContext(p *LevelOfIsolationContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_levelOfIsolation
}

func (*LevelOfIsolationContext) IsLevelOfIsolationContext() {}

func NewLevelOfIsolationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LevelOfIsolationContext {
	var p = new(LevelOfIsolationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_levelOfIsolation

	return p
}

func (s *LevelOfIsolationContext) GetParser() antlr.Parser { return s.parser }

func (s *LevelOfIsolationContext) KW_SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SNAPSHOT, 0)
}

func (s *LevelOfIsolationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LevelOfIsolationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *LevelOfIsolationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterLevelOfIsolation(s)
	}
}

func (s *LevelOfIsolationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitLevelOfIsolation(s)
	}
}

func (s *LevelOfIsolationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitLevelOfIsolation(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) LevelOfIsolation() (localctx ILevelOfIsolationContext) {
	localctx = NewLevelOfIsolationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 432, HiveParserRULE_levelOfIsolation)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2964)
		p.Match(HiveParserKW_SNAPSHOT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICommitStatementContext is an interface to support dynamic dispatch.
type ICommitStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_COMMIT() antlr.TerminalNode
	KW_WORK() antlr.TerminalNode

	// IsCommitStatementContext differentiates from other interfaces.
	IsCommitStatementContext()
}

type CommitStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommitStatementContext() *CommitStatementContext {
	var p = new(CommitStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_commitStatement
	return p
}

func InitEmptyCommitStatementContext(p *CommitStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_commitStatement
}

func (*CommitStatementContext) IsCommitStatementContext() {}

func NewCommitStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommitStatementContext {
	var p = new(CommitStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_commitStatement

	return p
}

func (s *CommitStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CommitStatementContext) KW_COMMIT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_COMMIT, 0)
}

func (s *CommitStatementContext) KW_WORK() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_WORK, 0)
}

func (s *CommitStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommitStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CommitStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterCommitStatement(s)
	}
}

func (s *CommitStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitCommitStatement(s)
	}
}

func (s *CommitStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitCommitStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) CommitStatement() (localctx ICommitStatementContext) {
	localctx = NewCommitStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 434, HiveParserRULE_commitStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2966)
		p.Match(HiveParserKW_COMMIT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(2968)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_WORK {
		{
			p.SetState(2967)
			p.Match(HiveParserKW_WORK)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRollbackStatementContext is an interface to support dynamic dispatch.
type IRollbackStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_ROLLBACK() antlr.TerminalNode
	KW_WORK() antlr.TerminalNode

	// IsRollbackStatementContext differentiates from other interfaces.
	IsRollbackStatementContext()
}

type RollbackStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRollbackStatementContext() *RollbackStatementContext {
	var p = new(RollbackStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_rollbackStatement
	return p
}

func InitEmptyRollbackStatementContext(p *RollbackStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_rollbackStatement
}

func (*RollbackStatementContext) IsRollbackStatementContext() {}

func NewRollbackStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RollbackStatementContext {
	var p = new(RollbackStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_rollbackStatement

	return p
}

func (s *RollbackStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RollbackStatementContext) KW_ROLLBACK() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ROLLBACK, 0)
}

func (s *RollbackStatementContext) KW_WORK() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_WORK, 0)
}

func (s *RollbackStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RollbackStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *RollbackStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterRollbackStatement(s)
	}
}

func (s *RollbackStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitRollbackStatement(s)
	}
}

func (s *RollbackStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitRollbackStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) RollbackStatement() (localctx IRollbackStatementContext) {
	localctx = NewRollbackStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 436, HiveParserRULE_rollbackStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2970)
		p.Match(HiveParserKW_ROLLBACK)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(2972)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_WORK {
		{
			p.SetState(2971)
			p.Match(HiveParserKW_WORK)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISetAutoCommitStatementContext is an interface to support dynamic dispatch.
type ISetAutoCommitStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_SET() antlr.TerminalNode
	KW_AUTOCOMMIT() antlr.TerminalNode
	BooleanValueTok() IBooleanValueTokContext

	// IsSetAutoCommitStatementContext differentiates from other interfaces.
	IsSetAutoCommitStatementContext()
}

type SetAutoCommitStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetAutoCommitStatementContext() *SetAutoCommitStatementContext {
	var p = new(SetAutoCommitStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_setAutoCommitStatement
	return p
}

func InitEmptySetAutoCommitStatementContext(p *SetAutoCommitStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_setAutoCommitStatement
}

func (*SetAutoCommitStatementContext) IsSetAutoCommitStatementContext() {}

func NewSetAutoCommitStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetAutoCommitStatementContext {
	var p = new(SetAutoCommitStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_setAutoCommitStatement

	return p
}

func (s *SetAutoCommitStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SetAutoCommitStatementContext) KW_SET() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SET, 0)
}

func (s *SetAutoCommitStatementContext) KW_AUTOCOMMIT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_AUTOCOMMIT, 0)
}

func (s *SetAutoCommitStatementContext) BooleanValueTok() IBooleanValueTokContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanValueTokContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanValueTokContext)
}

func (s *SetAutoCommitStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetAutoCommitStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SetAutoCommitStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterSetAutoCommitStatement(s)
	}
}

func (s *SetAutoCommitStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitSetAutoCommitStatement(s)
	}
}

func (s *SetAutoCommitStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitSetAutoCommitStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) SetAutoCommitStatement() (localctx ISetAutoCommitStatementContext) {
	localctx = NewSetAutoCommitStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 438, HiveParserRULE_setAutoCommitStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2974)
		p.Match(HiveParserKW_SET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2975)
		p.Match(HiveParserKW_AUTOCOMMIT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2976)
		p.BooleanValueTok()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAbortTransactionStatementContext is an interface to support dynamic dispatch.
type IAbortTransactionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_ABORT() antlr.TerminalNode
	KW_TRANSACTIONS() antlr.TerminalNode
	AllNumber() []antlr.TerminalNode
	Number(i int) antlr.TerminalNode

	// IsAbortTransactionStatementContext differentiates from other interfaces.
	IsAbortTransactionStatementContext()
}

type AbortTransactionStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAbortTransactionStatementContext() *AbortTransactionStatementContext {
	var p = new(AbortTransactionStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_abortTransactionStatement
	return p
}

func InitEmptyAbortTransactionStatementContext(p *AbortTransactionStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_abortTransactionStatement
}

func (*AbortTransactionStatementContext) IsAbortTransactionStatementContext() {}

func NewAbortTransactionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AbortTransactionStatementContext {
	var p = new(AbortTransactionStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_abortTransactionStatement

	return p
}

func (s *AbortTransactionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AbortTransactionStatementContext) KW_ABORT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ABORT, 0)
}

func (s *AbortTransactionStatementContext) KW_TRANSACTIONS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TRANSACTIONS, 0)
}

func (s *AbortTransactionStatementContext) AllNumber() []antlr.TerminalNode {
	return s.GetTokens(HiveParserNumber)
}

func (s *AbortTransactionStatementContext) Number(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserNumber, i)
}

func (s *AbortTransactionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AbortTransactionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AbortTransactionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterAbortTransactionStatement(s)
	}
}

func (s *AbortTransactionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitAbortTransactionStatement(s)
	}
}

func (s *AbortTransactionStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitAbortTransactionStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) AbortTransactionStatement() (localctx IAbortTransactionStatementContext) {
	localctx = NewAbortTransactionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 440, HiveParserRULE_abortTransactionStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2978)
		p.Match(HiveParserKW_ABORT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2979)
		p.Match(HiveParserKW_TRANSACTIONS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(2981)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for ok := true; ok; ok = _la == HiveParserNumber {
		{
			p.SetState(2980)
			p.Match(HiveParserNumber)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


		p.SetState(2983)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAbortCompactionStatementContext is an interface to support dynamic dispatch.
type IAbortCompactionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_ABORT() antlr.TerminalNode
	KW_COMPACTIONS() antlr.TerminalNode
	AllNumber() []antlr.TerminalNode
	Number(i int) antlr.TerminalNode

	// IsAbortCompactionStatementContext differentiates from other interfaces.
	IsAbortCompactionStatementContext()
}

type AbortCompactionStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAbortCompactionStatementContext() *AbortCompactionStatementContext {
	var p = new(AbortCompactionStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_abortCompactionStatement
	return p
}

func InitEmptyAbortCompactionStatementContext(p *AbortCompactionStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_abortCompactionStatement
}

func (*AbortCompactionStatementContext) IsAbortCompactionStatementContext() {}

func NewAbortCompactionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AbortCompactionStatementContext {
	var p = new(AbortCompactionStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_abortCompactionStatement

	return p
}

func (s *AbortCompactionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AbortCompactionStatementContext) KW_ABORT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ABORT, 0)
}

func (s *AbortCompactionStatementContext) KW_COMPACTIONS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_COMPACTIONS, 0)
}

func (s *AbortCompactionStatementContext) AllNumber() []antlr.TerminalNode {
	return s.GetTokens(HiveParserNumber)
}

func (s *AbortCompactionStatementContext) Number(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserNumber, i)
}

func (s *AbortCompactionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AbortCompactionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AbortCompactionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterAbortCompactionStatement(s)
	}
}

func (s *AbortCompactionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitAbortCompactionStatement(s)
	}
}

func (s *AbortCompactionStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitAbortCompactionStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) AbortCompactionStatement() (localctx IAbortCompactionStatementContext) {
	localctx = NewAbortCompactionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 442, HiveParserRULE_abortCompactionStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2985)
		p.Match(HiveParserKW_ABORT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2986)
		p.Match(HiveParserKW_COMPACTIONS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(2988)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for ok := true; ok; ok = _la == HiveParserNumber {
		{
			p.SetState(2987)
			p.Match(HiveParserNumber)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


		p.SetState(2990)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IMergeStatementContext is an interface to support dynamic dispatch.
type IMergeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_MERGE() antlr.TerminalNode
	KW_INTO() antlr.TerminalNode
	TableName() ITableNameContext
	KW_USING() antlr.TerminalNode
	JoinSourcePart() IJoinSourcePartContext
	KW_ON() antlr.TerminalNode
	Expression() IExpressionContext
	WhenClauses() IWhenClausesContext
	QUERY_HINT() antlr.TerminalNode
	Id_() IId_Context
	KW_AS() antlr.TerminalNode

	// IsMergeStatementContext differentiates from other interfaces.
	IsMergeStatementContext()
}

type MergeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMergeStatementContext() *MergeStatementContext {
	var p = new(MergeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_mergeStatement
	return p
}

func InitEmptyMergeStatementContext(p *MergeStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_mergeStatement
}

func (*MergeStatementContext) IsMergeStatementContext() {}

func NewMergeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MergeStatementContext {
	var p = new(MergeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_mergeStatement

	return p
}

func (s *MergeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *MergeStatementContext) KW_MERGE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_MERGE, 0)
}

func (s *MergeStatementContext) KW_INTO() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_INTO, 0)
}

func (s *MergeStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *MergeStatementContext) KW_USING() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_USING, 0)
}

func (s *MergeStatementContext) JoinSourcePart() IJoinSourcePartContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinSourcePartContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinSourcePartContext)
}

func (s *MergeStatementContext) KW_ON() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ON, 0)
}

func (s *MergeStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MergeStatementContext) WhenClauses() IWhenClausesContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhenClausesContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhenClausesContext)
}

func (s *MergeStatementContext) QUERY_HINT() antlr.TerminalNode {
	return s.GetToken(HiveParserQUERY_HINT, 0)
}

func (s *MergeStatementContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *MergeStatementContext) KW_AS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_AS, 0)
}

func (s *MergeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MergeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *MergeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterMergeStatement(s)
	}
}

func (s *MergeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitMergeStatement(s)
	}
}

func (s *MergeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitMergeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) MergeStatement() (localctx IMergeStatementContext) {
	localctx = NewMergeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 444, HiveParserRULE_mergeStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2992)
		p.Match(HiveParserKW_MERGE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(2994)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserQUERY_HINT {
		{
			p.SetState(2993)
			p.Match(HiveParserQUERY_HINT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(2996)
		p.Match(HiveParserKW_INTO)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2997)
		p.TableName()
	}
	p.SetState(3002)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 808078815591826814) != 0) || ((int64((_la - 66)) & ^0x3f) == 0 && ((int64(1) << (_la - 66)) & 1083038567331911621) != 0) || ((int64((_la - 132)) & ^0x3f) == 0 && ((int64(1) << (_la - 132)) & 8916819943869537315) != 0) || ((int64((_la - 196)) & ^0x3f) == 0 && ((int64(1) << (_la - 196)) & 4159991143015340909) != 0) || ((int64((_la - 261)) & ^0x3f) == 0 && ((int64(1) << (_la - 261)) & 8484708576009596927) != 0) || ((int64((_la - 328)) & ^0x3f) == 0 && ((int64(1) << (_la - 328)) & 17776728909112555) != 0) || _la == HiveParserIdentifier {
		p.SetState(2999)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_AS {
			{
				p.SetState(2998)
				p.Match(HiveParserKW_AS)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(3001)
			p.Id_()
		}

	}
	{
		p.SetState(3004)
		p.Match(HiveParserKW_USING)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3005)
		p.JoinSourcePart()
	}
	{
		p.SetState(3006)
		p.Match(HiveParserKW_ON)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3007)
		p.Expression()
	}
	{
		p.SetState(3008)
		p.WhenClauses()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IWhenClausesContext is an interface to support dynamic dispatch.
type IWhenClausesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllWhenMatchedAndClause() []IWhenMatchedAndClauseContext
	WhenMatchedAndClause(i int) IWhenMatchedAndClauseContext
	AllWhenMatchedThenClause() []IWhenMatchedThenClauseContext
	WhenMatchedThenClause(i int) IWhenMatchedThenClauseContext
	WhenNotMatchedClause() IWhenNotMatchedClauseContext

	// IsWhenClausesContext differentiates from other interfaces.
	IsWhenClausesContext()
}

type WhenClausesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhenClausesContext() *WhenClausesContext {
	var p = new(WhenClausesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_whenClauses
	return p
}

func InitEmptyWhenClausesContext(p *WhenClausesContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_whenClauses
}

func (*WhenClausesContext) IsWhenClausesContext() {}

func NewWhenClausesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhenClausesContext {
	var p = new(WhenClausesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_whenClauses

	return p
}

func (s *WhenClausesContext) GetParser() antlr.Parser { return s.parser }

func (s *WhenClausesContext) AllWhenMatchedAndClause() []IWhenMatchedAndClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWhenMatchedAndClauseContext); ok {
			len++
		}
	}

	tst := make([]IWhenMatchedAndClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWhenMatchedAndClauseContext); ok {
			tst[i] = t.(IWhenMatchedAndClauseContext)
			i++
		}
	}

	return tst
}

func (s *WhenClausesContext) WhenMatchedAndClause(i int) IWhenMatchedAndClauseContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhenMatchedAndClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhenMatchedAndClauseContext)
}

func (s *WhenClausesContext) AllWhenMatchedThenClause() []IWhenMatchedThenClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWhenMatchedThenClauseContext); ok {
			len++
		}
	}

	tst := make([]IWhenMatchedThenClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWhenMatchedThenClauseContext); ok {
			tst[i] = t.(IWhenMatchedThenClauseContext)
			i++
		}
	}

	return tst
}

func (s *WhenClausesContext) WhenMatchedThenClause(i int) IWhenMatchedThenClauseContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhenMatchedThenClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhenMatchedThenClauseContext)
}

func (s *WhenClausesContext) WhenNotMatchedClause() IWhenNotMatchedClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhenNotMatchedClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhenNotMatchedClauseContext)
}

func (s *WhenClausesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenClausesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *WhenClausesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterWhenClauses(s)
	}
}

func (s *WhenClausesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitWhenClauses(s)
	}
}

func (s *WhenClausesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitWhenClauses(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) WhenClauses() (localctx IWhenClausesContext) {
	localctx = NewWhenClausesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 446, HiveParserRULE_whenClauses)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3014)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 315, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(3012)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 314, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(3010)
					p.WhenMatchedAndClause()
				}


			case 2:
				{
					p.SetState(3011)
					p.WhenMatchedThenClause()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(3016)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 315, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(3018)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_WHEN {
		{
			p.SetState(3017)
			p.WhenNotMatchedClause()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IWhenNotMatchedClauseContext is an interface to support dynamic dispatch.
type IWhenNotMatchedClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTargetCols returns the targetCols rule contexts.
	GetTargetCols() IColumnParenthesesListContext


	// SetTargetCols sets the targetCols rule contexts.
	SetTargetCols(IColumnParenthesesListContext)


	// Getter signatures
	KW_WHEN() antlr.TerminalNode
	KW_NOT() antlr.TerminalNode
	KW_MATCHED() antlr.TerminalNode
	KW_THEN() antlr.TerminalNode
	KW_INSERT() antlr.TerminalNode
	KW_VALUES() antlr.TerminalNode
	ValueRowConstructor() IValueRowConstructorContext
	KW_AND() antlr.TerminalNode
	Expression() IExpressionContext
	ColumnParenthesesList() IColumnParenthesesListContext

	// IsWhenNotMatchedClauseContext differentiates from other interfaces.
	IsWhenNotMatchedClauseContext()
}

type WhenNotMatchedClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	targetCols IColumnParenthesesListContext 
}

func NewEmptyWhenNotMatchedClauseContext() *WhenNotMatchedClauseContext {
	var p = new(WhenNotMatchedClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_whenNotMatchedClause
	return p
}

func InitEmptyWhenNotMatchedClauseContext(p *WhenNotMatchedClauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_whenNotMatchedClause
}

func (*WhenNotMatchedClauseContext) IsWhenNotMatchedClauseContext() {}

func NewWhenNotMatchedClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhenNotMatchedClauseContext {
	var p = new(WhenNotMatchedClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_whenNotMatchedClause

	return p
}

func (s *WhenNotMatchedClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WhenNotMatchedClauseContext) GetTargetCols() IColumnParenthesesListContext { return s.targetCols }


func (s *WhenNotMatchedClauseContext) SetTargetCols(v IColumnParenthesesListContext) { s.targetCols = v }


func (s *WhenNotMatchedClauseContext) KW_WHEN() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_WHEN, 0)
}

func (s *WhenNotMatchedClauseContext) KW_NOT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_NOT, 0)
}

func (s *WhenNotMatchedClauseContext) KW_MATCHED() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_MATCHED, 0)
}

func (s *WhenNotMatchedClauseContext) KW_THEN() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_THEN, 0)
}

func (s *WhenNotMatchedClauseContext) KW_INSERT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_INSERT, 0)
}

func (s *WhenNotMatchedClauseContext) KW_VALUES() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_VALUES, 0)
}

func (s *WhenNotMatchedClauseContext) ValueRowConstructor() IValueRowConstructorContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueRowConstructorContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueRowConstructorContext)
}

func (s *WhenNotMatchedClauseContext) KW_AND() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_AND, 0)
}

func (s *WhenNotMatchedClauseContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhenNotMatchedClauseContext) ColumnParenthesesList() IColumnParenthesesListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnParenthesesListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnParenthesesListContext)
}

func (s *WhenNotMatchedClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenNotMatchedClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *WhenNotMatchedClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterWhenNotMatchedClause(s)
	}
}

func (s *WhenNotMatchedClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitWhenNotMatchedClause(s)
	}
}

func (s *WhenNotMatchedClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitWhenNotMatchedClause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) WhenNotMatchedClause() (localctx IWhenNotMatchedClauseContext) {
	localctx = NewWhenNotMatchedClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 448, HiveParserRULE_whenNotMatchedClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3020)
		p.Match(HiveParserKW_WHEN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3021)
		p.Match(HiveParserKW_NOT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3022)
		p.Match(HiveParserKW_MATCHED)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(3025)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_AND {
		{
			p.SetState(3023)
			p.Match(HiveParserKW_AND)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3024)
			p.Expression()
		}

	}
	{
		p.SetState(3027)
		p.Match(HiveParserKW_THEN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3028)
		p.Match(HiveParserKW_INSERT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(3030)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserLPAREN {
		{
			p.SetState(3029)

			var _x = p.ColumnParenthesesList()


			localctx.(*WhenNotMatchedClauseContext).targetCols = _x
		}

	}
	{
		p.SetState(3032)
		p.Match(HiveParserKW_VALUES)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3033)
		p.ValueRowConstructor()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IWhenMatchedAndClauseContext is an interface to support dynamic dispatch.
type IWhenMatchedAndClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_WHEN() antlr.TerminalNode
	KW_MATCHED() antlr.TerminalNode
	KW_AND() antlr.TerminalNode
	Expression() IExpressionContext
	KW_THEN() antlr.TerminalNode
	UpdateOrDelete() IUpdateOrDeleteContext

	// IsWhenMatchedAndClauseContext differentiates from other interfaces.
	IsWhenMatchedAndClauseContext()
}

type WhenMatchedAndClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhenMatchedAndClauseContext() *WhenMatchedAndClauseContext {
	var p = new(WhenMatchedAndClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_whenMatchedAndClause
	return p
}

func InitEmptyWhenMatchedAndClauseContext(p *WhenMatchedAndClauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_whenMatchedAndClause
}

func (*WhenMatchedAndClauseContext) IsWhenMatchedAndClauseContext() {}

func NewWhenMatchedAndClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhenMatchedAndClauseContext {
	var p = new(WhenMatchedAndClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_whenMatchedAndClause

	return p
}

func (s *WhenMatchedAndClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WhenMatchedAndClauseContext) KW_WHEN() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_WHEN, 0)
}

func (s *WhenMatchedAndClauseContext) KW_MATCHED() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_MATCHED, 0)
}

func (s *WhenMatchedAndClauseContext) KW_AND() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_AND, 0)
}

func (s *WhenMatchedAndClauseContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhenMatchedAndClauseContext) KW_THEN() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_THEN, 0)
}

func (s *WhenMatchedAndClauseContext) UpdateOrDelete() IUpdateOrDeleteContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdateOrDeleteContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdateOrDeleteContext)
}

func (s *WhenMatchedAndClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenMatchedAndClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *WhenMatchedAndClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterWhenMatchedAndClause(s)
	}
}

func (s *WhenMatchedAndClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitWhenMatchedAndClause(s)
	}
}

func (s *WhenMatchedAndClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitWhenMatchedAndClause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) WhenMatchedAndClause() (localctx IWhenMatchedAndClauseContext) {
	localctx = NewWhenMatchedAndClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 450, HiveParserRULE_whenMatchedAndClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3035)
		p.Match(HiveParserKW_WHEN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3036)
		p.Match(HiveParserKW_MATCHED)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3037)
		p.Match(HiveParserKW_AND)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3038)
		p.Expression()
	}
	{
		p.SetState(3039)
		p.Match(HiveParserKW_THEN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3040)
		p.UpdateOrDelete()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IWhenMatchedThenClauseContext is an interface to support dynamic dispatch.
type IWhenMatchedThenClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_WHEN() antlr.TerminalNode
	KW_MATCHED() antlr.TerminalNode
	KW_THEN() antlr.TerminalNode
	UpdateOrDelete() IUpdateOrDeleteContext

	// IsWhenMatchedThenClauseContext differentiates from other interfaces.
	IsWhenMatchedThenClauseContext()
}

type WhenMatchedThenClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhenMatchedThenClauseContext() *WhenMatchedThenClauseContext {
	var p = new(WhenMatchedThenClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_whenMatchedThenClause
	return p
}

func InitEmptyWhenMatchedThenClauseContext(p *WhenMatchedThenClauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_whenMatchedThenClause
}

func (*WhenMatchedThenClauseContext) IsWhenMatchedThenClauseContext() {}

func NewWhenMatchedThenClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhenMatchedThenClauseContext {
	var p = new(WhenMatchedThenClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_whenMatchedThenClause

	return p
}

func (s *WhenMatchedThenClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WhenMatchedThenClauseContext) KW_WHEN() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_WHEN, 0)
}

func (s *WhenMatchedThenClauseContext) KW_MATCHED() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_MATCHED, 0)
}

func (s *WhenMatchedThenClauseContext) KW_THEN() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_THEN, 0)
}

func (s *WhenMatchedThenClauseContext) UpdateOrDelete() IUpdateOrDeleteContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdateOrDeleteContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdateOrDeleteContext)
}

func (s *WhenMatchedThenClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenMatchedThenClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *WhenMatchedThenClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterWhenMatchedThenClause(s)
	}
}

func (s *WhenMatchedThenClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitWhenMatchedThenClause(s)
	}
}

func (s *WhenMatchedThenClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitWhenMatchedThenClause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) WhenMatchedThenClause() (localctx IWhenMatchedThenClauseContext) {
	localctx = NewWhenMatchedThenClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 452, HiveParserRULE_whenMatchedThenClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3042)
		p.Match(HiveParserKW_WHEN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3043)
		p.Match(HiveParserKW_MATCHED)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3044)
		p.Match(HiveParserKW_THEN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3045)
		p.UpdateOrDelete()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IUpdateOrDeleteContext is an interface to support dynamic dispatch.
type IUpdateOrDeleteContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_UPDATE() antlr.TerminalNode
	SetColumnsClause() ISetColumnsClauseContext
	KW_DELETE() antlr.TerminalNode

	// IsUpdateOrDeleteContext differentiates from other interfaces.
	IsUpdateOrDeleteContext()
}

type UpdateOrDeleteContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUpdateOrDeleteContext() *UpdateOrDeleteContext {
	var p = new(UpdateOrDeleteContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_updateOrDelete
	return p
}

func InitEmptyUpdateOrDeleteContext(p *UpdateOrDeleteContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_updateOrDelete
}

func (*UpdateOrDeleteContext) IsUpdateOrDeleteContext() {}

func NewUpdateOrDeleteContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UpdateOrDeleteContext {
	var p = new(UpdateOrDeleteContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_updateOrDelete

	return p
}

func (s *UpdateOrDeleteContext) GetParser() antlr.Parser { return s.parser }

func (s *UpdateOrDeleteContext) KW_UPDATE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_UPDATE, 0)
}

func (s *UpdateOrDeleteContext) SetColumnsClause() ISetColumnsClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetColumnsClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetColumnsClauseContext)
}

func (s *UpdateOrDeleteContext) KW_DELETE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DELETE, 0)
}

func (s *UpdateOrDeleteContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UpdateOrDeleteContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *UpdateOrDeleteContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterUpdateOrDelete(s)
	}
}

func (s *UpdateOrDeleteContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitUpdateOrDelete(s)
	}
}

func (s *UpdateOrDeleteContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitUpdateOrDelete(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) UpdateOrDelete() (localctx IUpdateOrDeleteContext) {
	localctx = NewUpdateOrDeleteContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 454, HiveParserRULE_updateOrDelete)
	p.SetState(3050)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserKW_UPDATE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3047)
			p.Match(HiveParserKW_UPDATE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3048)
			p.SetColumnsClause()
		}


	case HiveParserKW_DELETE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3049)
			p.Match(HiveParserKW_DELETE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IKillQueryStatementContext is an interface to support dynamic dispatch.
type IKillQueryStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_KILL() antlr.TerminalNode
	KW_QUERY() antlr.TerminalNode
	AllStringLiteral() []antlr.TerminalNode
	StringLiteral(i int) antlr.TerminalNode

	// IsKillQueryStatementContext differentiates from other interfaces.
	IsKillQueryStatementContext()
}

type KillQueryStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKillQueryStatementContext() *KillQueryStatementContext {
	var p = new(KillQueryStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_killQueryStatement
	return p
}

func InitEmptyKillQueryStatementContext(p *KillQueryStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_killQueryStatement
}

func (*KillQueryStatementContext) IsKillQueryStatementContext() {}

func NewKillQueryStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KillQueryStatementContext {
	var p = new(KillQueryStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_killQueryStatement

	return p
}

func (s *KillQueryStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *KillQueryStatementContext) KW_KILL() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_KILL, 0)
}

func (s *KillQueryStatementContext) KW_QUERY() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_QUERY, 0)
}

func (s *KillQueryStatementContext) AllStringLiteral() []antlr.TerminalNode {
	return s.GetTokens(HiveParserStringLiteral)
}

func (s *KillQueryStatementContext) StringLiteral(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserStringLiteral, i)
}

func (s *KillQueryStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KillQueryStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *KillQueryStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterKillQueryStatement(s)
	}
}

func (s *KillQueryStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitKillQueryStatement(s)
	}
}

func (s *KillQueryStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitKillQueryStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) KillQueryStatement() (localctx IKillQueryStatementContext) {
	localctx = NewKillQueryStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 456, HiveParserRULE_killQueryStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3052)
		p.Match(HiveParserKW_KILL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3053)
		p.Match(HiveParserKW_QUERY)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(3055)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for ok := true; ok; ok = _la == HiveParserStringLiteral {
		{
			p.SetState(3054)
			p.Match(HiveParserStringLiteral)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


		p.SetState(3057)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICompactionIdContext is an interface to support dynamic dispatch.
type ICompactionIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCompactId returns the compactId token.
	GetCompactId() antlr.Token 


	// SetCompactId sets the compactId token.
	SetCompactId(antlr.Token) 


	// Getter signatures
	KW_COMPACT_ID() antlr.TerminalNode
	EQUAL() antlr.TerminalNode
	Number() antlr.TerminalNode

	// IsCompactionIdContext differentiates from other interfaces.
	IsCompactionIdContext()
}

type CompactionIdContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	compactId antlr.Token
}

func NewEmptyCompactionIdContext() *CompactionIdContext {
	var p = new(CompactionIdContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_compactionId
	return p
}

func InitEmptyCompactionIdContext(p *CompactionIdContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_compactionId
}

func (*CompactionIdContext) IsCompactionIdContext() {}

func NewCompactionIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompactionIdContext {
	var p = new(CompactionIdContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_compactionId

	return p
}

func (s *CompactionIdContext) GetParser() antlr.Parser { return s.parser }

func (s *CompactionIdContext) GetCompactId() antlr.Token { return s.compactId }


func (s *CompactionIdContext) SetCompactId(v antlr.Token) { s.compactId = v }


func (s *CompactionIdContext) KW_COMPACT_ID() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_COMPACT_ID, 0)
}

func (s *CompactionIdContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(HiveParserEQUAL, 0)
}

func (s *CompactionIdContext) Number() antlr.TerminalNode {
	return s.GetToken(HiveParserNumber, 0)
}

func (s *CompactionIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompactionIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CompactionIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterCompactionId(s)
	}
}

func (s *CompactionIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitCompactionId(s)
	}
}

func (s *CompactionIdContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitCompactionId(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) CompactionId() (localctx ICompactionIdContext) {
	localctx = NewCompactionIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 458, HiveParserRULE_compactionId)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3059)
		p.Match(HiveParserKW_COMPACT_ID)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3060)
		p.Match(HiveParserEQUAL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3061)

		var _m = p.Match(HiveParserNumber)

		localctx.(*CompactionIdContext).compactId = _m
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICompactionPoolContext is an interface to support dynamic dispatch.
type ICompactionPoolContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPoolName returns the poolName token.
	GetPoolName() antlr.Token 


	// SetPoolName sets the poolName token.
	SetPoolName(antlr.Token) 


	// Getter signatures
	KW_POOL() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode

	// IsCompactionPoolContext differentiates from other interfaces.
	IsCompactionPoolContext()
}

type CompactionPoolContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	poolName antlr.Token
}

func NewEmptyCompactionPoolContext() *CompactionPoolContext {
	var p = new(CompactionPoolContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_compactionPool
	return p
}

func InitEmptyCompactionPoolContext(p *CompactionPoolContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_compactionPool
}

func (*CompactionPoolContext) IsCompactionPoolContext() {}

func NewCompactionPoolContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompactionPoolContext {
	var p = new(CompactionPoolContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_compactionPool

	return p
}

func (s *CompactionPoolContext) GetParser() antlr.Parser { return s.parser }

func (s *CompactionPoolContext) GetPoolName() antlr.Token { return s.poolName }


func (s *CompactionPoolContext) SetPoolName(v antlr.Token) { s.poolName = v }


func (s *CompactionPoolContext) KW_POOL() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_POOL, 0)
}

func (s *CompactionPoolContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(HiveParserStringLiteral, 0)
}

func (s *CompactionPoolContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompactionPoolContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CompactionPoolContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterCompactionPool(s)
	}
}

func (s *CompactionPoolContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitCompactionPool(s)
	}
}

func (s *CompactionPoolContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitCompactionPool(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) CompactionPool() (localctx ICompactionPoolContext) {
	localctx = NewCompactionPoolContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 460, HiveParserRULE_compactionPool)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3063)
		p.Match(HiveParserKW_POOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3064)

		var _m = p.Match(HiveParserStringLiteral)

		localctx.(*CompactionPoolContext).poolName = _m
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICompactionTypeContext is an interface to support dynamic dispatch.
type ICompactionTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCompactType returns the compactType token.
	GetCompactType() antlr.Token 


	// SetCompactType sets the compactType token.
	SetCompactType(antlr.Token) 


	// Getter signatures
	KW_TYPE() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode

	// IsCompactionTypeContext differentiates from other interfaces.
	IsCompactionTypeContext()
}

type CompactionTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	compactType antlr.Token
}

func NewEmptyCompactionTypeContext() *CompactionTypeContext {
	var p = new(CompactionTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_compactionType
	return p
}

func InitEmptyCompactionTypeContext(p *CompactionTypeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_compactionType
}

func (*CompactionTypeContext) IsCompactionTypeContext() {}

func NewCompactionTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompactionTypeContext {
	var p = new(CompactionTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_compactionType

	return p
}

func (s *CompactionTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *CompactionTypeContext) GetCompactType() antlr.Token { return s.compactType }


func (s *CompactionTypeContext) SetCompactType(v antlr.Token) { s.compactType = v }


func (s *CompactionTypeContext) KW_TYPE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TYPE, 0)
}

func (s *CompactionTypeContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(HiveParserStringLiteral, 0)
}

func (s *CompactionTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompactionTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CompactionTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterCompactionType(s)
	}
}

func (s *CompactionTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitCompactionType(s)
	}
}

func (s *CompactionTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitCompactionType(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) CompactionType() (localctx ICompactionTypeContext) {
	localctx = NewCompactionTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 462, HiveParserRULE_compactionType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3066)
		p.Match(HiveParserKW_TYPE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3067)

		var _m = p.Match(HiveParserStringLiteral)

		localctx.(*CompactionTypeContext).compactType = _m
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICompactionStatusContext is an interface to support dynamic dispatch.
type ICompactionStatusContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetStatus returns the status token.
	GetStatus() antlr.Token 


	// SetStatus sets the status token.
	SetStatus(antlr.Token) 


	// Getter signatures
	KW_STATUS() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode

	// IsCompactionStatusContext differentiates from other interfaces.
	IsCompactionStatusContext()
}

type CompactionStatusContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	status antlr.Token
}

func NewEmptyCompactionStatusContext() *CompactionStatusContext {
	var p = new(CompactionStatusContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_compactionStatus
	return p
}

func InitEmptyCompactionStatusContext(p *CompactionStatusContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_compactionStatus
}

func (*CompactionStatusContext) IsCompactionStatusContext() {}

func NewCompactionStatusContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompactionStatusContext {
	var p = new(CompactionStatusContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_compactionStatus

	return p
}

func (s *CompactionStatusContext) GetParser() antlr.Parser { return s.parser }

func (s *CompactionStatusContext) GetStatus() antlr.Token { return s.status }


func (s *CompactionStatusContext) SetStatus(v antlr.Token) { s.status = v }


func (s *CompactionStatusContext) KW_STATUS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_STATUS, 0)
}

func (s *CompactionStatusContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(HiveParserStringLiteral, 0)
}

func (s *CompactionStatusContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompactionStatusContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CompactionStatusContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterCompactionStatus(s)
	}
}

func (s *CompactionStatusContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitCompactionStatus(s)
	}
}

func (s *CompactionStatusContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitCompactionStatus(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) CompactionStatus() (localctx ICompactionStatusContext) {
	localctx = NewCompactionStatusContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 464, HiveParserRULE_compactionStatus)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3069)
		p.Match(HiveParserKW_STATUS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3070)

		var _m = p.Match(HiveParserStringLiteral)

		localctx.(*CompactionStatusContext).status = _m
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlterStatementContext is an interface to support dynamic dispatch.
type IAlterStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTableNameTree returns the tableNameTree rule contexts.
	GetTableNameTree() ITableNameContext


	// SetTableNameTree sets the tableNameTree rule contexts.
	SetTableNameTree(ITableNameContext)


	// Getter signatures
	KW_ALTER() antlr.TerminalNode
	KW_TABLE() antlr.TerminalNode
	TableName() ITableNameContext
	AlterTableStatementSuffix() IAlterTableStatementSuffixContext
	KW_VIEW() antlr.TerminalNode
	AlterViewStatementSuffix() IAlterViewStatementSuffixContext
	KW_MATERIALIZED() antlr.TerminalNode
	AlterMaterializedViewStatementSuffix() IAlterMaterializedViewStatementSuffixContext
	Db_schema() IDb_schemaContext
	AlterDatabaseStatementSuffix() IAlterDatabaseStatementSuffixContext
	KW_DATACONNECTOR() antlr.TerminalNode
	AlterDataConnectorStatementSuffix() IAlterDataConnectorStatementSuffixContext
	KW_AS() antlr.TerminalNode

	// IsAlterStatementContext differentiates from other interfaces.
	IsAlterStatementContext()
}

type AlterStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	tableNameTree ITableNameContext 
}

func NewEmptyAlterStatementContext() *AlterStatementContext {
	var p = new(AlterStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterStatement
	return p
}

func InitEmptyAlterStatementContext(p *AlterStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterStatement
}

func (*AlterStatementContext) IsAlterStatementContext() {}

func NewAlterStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterStatementContext {
	var p = new(AlterStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_alterStatement

	return p
}

func (s *AlterStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterStatementContext) GetTableNameTree() ITableNameContext { return s.tableNameTree }


func (s *AlterStatementContext) SetTableNameTree(v ITableNameContext) { s.tableNameTree = v }


func (s *AlterStatementContext) KW_ALTER() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ALTER, 0)
}

func (s *AlterStatementContext) KW_TABLE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TABLE, 0)
}

func (s *AlterStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *AlterStatementContext) AlterTableStatementSuffix() IAlterTableStatementSuffixContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterTableStatementSuffixContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterTableStatementSuffixContext)
}

func (s *AlterStatementContext) KW_VIEW() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_VIEW, 0)
}

func (s *AlterStatementContext) AlterViewStatementSuffix() IAlterViewStatementSuffixContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterViewStatementSuffixContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterViewStatementSuffixContext)
}

func (s *AlterStatementContext) KW_MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_MATERIALIZED, 0)
}

func (s *AlterStatementContext) AlterMaterializedViewStatementSuffix() IAlterMaterializedViewStatementSuffixContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterMaterializedViewStatementSuffixContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterMaterializedViewStatementSuffixContext)
}

func (s *AlterStatementContext) Db_schema() IDb_schemaContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDb_schemaContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDb_schemaContext)
}

func (s *AlterStatementContext) AlterDatabaseStatementSuffix() IAlterDatabaseStatementSuffixContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterDatabaseStatementSuffixContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterDatabaseStatementSuffixContext)
}

func (s *AlterStatementContext) KW_DATACONNECTOR() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DATACONNECTOR, 0)
}

func (s *AlterStatementContext) AlterDataConnectorStatementSuffix() IAlterDataConnectorStatementSuffixContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterDataConnectorStatementSuffixContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterDataConnectorStatementSuffixContext)
}

func (s *AlterStatementContext) KW_AS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_AS, 0)
}

func (s *AlterStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AlterStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterAlterStatement(s)
	}
}

func (s *AlterStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitAlterStatement(s)
	}
}

func (s *AlterStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitAlterStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) AlterStatement() (localctx IAlterStatementContext) {
	localctx = NewAlterStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 466, HiveParserRULE_alterStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3072)
		p.Match(HiveParserKW_ALTER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(3094)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserKW_TABLE:
		{
			p.SetState(3073)
			p.Match(HiveParserKW_TABLE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3074)
			p.TableName()
		}
		{
			p.SetState(3075)
			p.AlterTableStatementSuffix()
		}


	case HiveParserKW_VIEW:
		{
			p.SetState(3077)
			p.Match(HiveParserKW_VIEW)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3078)
			p.TableName()
		}
		p.SetState(3080)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_AS {
			{
				p.SetState(3079)
				p.Match(HiveParserKW_AS)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(3082)
			p.AlterViewStatementSuffix()
		}


	case HiveParserKW_MATERIALIZED:
		{
			p.SetState(3084)
			p.Match(HiveParserKW_MATERIALIZED)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3085)
			p.Match(HiveParserKW_VIEW)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3086)

			var _x = p.TableName()


			localctx.(*AlterStatementContext).tableNameTree = _x
		}
		{
			p.SetState(3087)
			p.AlterMaterializedViewStatementSuffix()
		}


	case HiveParserKW_DATABASE, HiveParserKW_SCHEMA:
		{
			p.SetState(3089)
			p.Db_schema()
		}
		{
			p.SetState(3090)
			p.AlterDatabaseStatementSuffix()
		}


	case HiveParserKW_DATACONNECTOR:
		{
			p.SetState(3092)
			p.Match(HiveParserKW_DATACONNECTOR)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3093)
			p.AlterDataConnectorStatementSuffix()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlterTableStatementSuffixContext is an interface to support dynamic dispatch.
type IAlterTableStatementSuffixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AlterStatementSuffixRename() IAlterStatementSuffixRenameContext
	AlterStatementSuffixDropPartitions() IAlterStatementSuffixDropPartitionsContext
	AlterStatementSuffixAddPartitions() IAlterStatementSuffixAddPartitionsContext
	AlterStatementSuffixTouch() IAlterStatementSuffixTouchContext
	AlterStatementSuffixArchive() IAlterStatementSuffixArchiveContext
	AlterStatementSuffixUnArchive() IAlterStatementSuffixUnArchiveContext
	AlterStatementSuffixProperties() IAlterStatementSuffixPropertiesContext
	AlterStatementSuffixSkewedby() IAlterStatementSuffixSkewedbyContext
	AlterStatementSuffixExchangePartition() IAlterStatementSuffixExchangePartitionContext
	AlterStatementPartitionKeyType() IAlterStatementPartitionKeyTypeContext
	AlterStatementSuffixDropConstraint() IAlterStatementSuffixDropConstraintContext
	AlterStatementSuffixAddConstraint() IAlterStatementSuffixAddConstraintContext
	AlterTblPartitionStatementSuffix() IAlterTblPartitionStatementSuffixContext
	PartitionSpec() IPartitionSpecContext
	AlterStatementSuffixSetOwner() IAlterStatementSuffixSetOwnerContext
	AlterStatementSuffixSetPartSpec() IAlterStatementSuffixSetPartSpecContext
	AlterStatementSuffixExecute() IAlterStatementSuffixExecuteContext

	// IsAlterTableStatementSuffixContext differentiates from other interfaces.
	IsAlterTableStatementSuffixContext()
}

type AlterTableStatementSuffixContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterTableStatementSuffixContext() *AlterTableStatementSuffixContext {
	var p = new(AlterTableStatementSuffixContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterTableStatementSuffix
	return p
}

func InitEmptyAlterTableStatementSuffixContext(p *AlterTableStatementSuffixContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterTableStatementSuffix
}

func (*AlterTableStatementSuffixContext) IsAlterTableStatementSuffixContext() {}

func NewAlterTableStatementSuffixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterTableStatementSuffixContext {
	var p = new(AlterTableStatementSuffixContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_alterTableStatementSuffix

	return p
}

func (s *AlterTableStatementSuffixContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterTableStatementSuffixContext) AlterStatementSuffixRename() IAlterStatementSuffixRenameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterStatementSuffixRenameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterStatementSuffixRenameContext)
}

func (s *AlterTableStatementSuffixContext) AlterStatementSuffixDropPartitions() IAlterStatementSuffixDropPartitionsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterStatementSuffixDropPartitionsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterStatementSuffixDropPartitionsContext)
}

func (s *AlterTableStatementSuffixContext) AlterStatementSuffixAddPartitions() IAlterStatementSuffixAddPartitionsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterStatementSuffixAddPartitionsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterStatementSuffixAddPartitionsContext)
}

func (s *AlterTableStatementSuffixContext) AlterStatementSuffixTouch() IAlterStatementSuffixTouchContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterStatementSuffixTouchContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterStatementSuffixTouchContext)
}

func (s *AlterTableStatementSuffixContext) AlterStatementSuffixArchive() IAlterStatementSuffixArchiveContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterStatementSuffixArchiveContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterStatementSuffixArchiveContext)
}

func (s *AlterTableStatementSuffixContext) AlterStatementSuffixUnArchive() IAlterStatementSuffixUnArchiveContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterStatementSuffixUnArchiveContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterStatementSuffixUnArchiveContext)
}

func (s *AlterTableStatementSuffixContext) AlterStatementSuffixProperties() IAlterStatementSuffixPropertiesContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterStatementSuffixPropertiesContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterStatementSuffixPropertiesContext)
}

func (s *AlterTableStatementSuffixContext) AlterStatementSuffixSkewedby() IAlterStatementSuffixSkewedbyContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterStatementSuffixSkewedbyContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterStatementSuffixSkewedbyContext)
}

func (s *AlterTableStatementSuffixContext) AlterStatementSuffixExchangePartition() IAlterStatementSuffixExchangePartitionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterStatementSuffixExchangePartitionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterStatementSuffixExchangePartitionContext)
}

func (s *AlterTableStatementSuffixContext) AlterStatementPartitionKeyType() IAlterStatementPartitionKeyTypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterStatementPartitionKeyTypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterStatementPartitionKeyTypeContext)
}

func (s *AlterTableStatementSuffixContext) AlterStatementSuffixDropConstraint() IAlterStatementSuffixDropConstraintContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterStatementSuffixDropConstraintContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterStatementSuffixDropConstraintContext)
}

func (s *AlterTableStatementSuffixContext) AlterStatementSuffixAddConstraint() IAlterStatementSuffixAddConstraintContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterStatementSuffixAddConstraintContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterStatementSuffixAddConstraintContext)
}

func (s *AlterTableStatementSuffixContext) AlterTblPartitionStatementSuffix() IAlterTblPartitionStatementSuffixContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterTblPartitionStatementSuffixContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterTblPartitionStatementSuffixContext)
}

func (s *AlterTableStatementSuffixContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *AlterTableStatementSuffixContext) AlterStatementSuffixSetOwner() IAlterStatementSuffixSetOwnerContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterStatementSuffixSetOwnerContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterStatementSuffixSetOwnerContext)
}

func (s *AlterTableStatementSuffixContext) AlterStatementSuffixSetPartSpec() IAlterStatementSuffixSetPartSpecContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterStatementSuffixSetPartSpecContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterStatementSuffixSetPartSpecContext)
}

func (s *AlterTableStatementSuffixContext) AlterStatementSuffixExecute() IAlterStatementSuffixExecuteContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterStatementSuffixExecuteContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterStatementSuffixExecuteContext)
}

func (s *AlterTableStatementSuffixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableStatementSuffixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AlterTableStatementSuffixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterAlterTableStatementSuffix(s)
	}
}

func (s *AlterTableStatementSuffixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitAlterTableStatementSuffix(s)
	}
}

func (s *AlterTableStatementSuffixContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitAlterTableStatementSuffix(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) AlterTableStatementSuffix() (localctx IAlterTableStatementSuffixContext) {
	localctx = NewAlterTableStatementSuffixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 468, HiveParserRULE_alterTableStatementSuffix)
	p.SetState(3115)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 323, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3096)
			p.AlterStatementSuffixRename()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3097)
			p.AlterStatementSuffixDropPartitions()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3098)
			p.AlterStatementSuffixAddPartitions()
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3099)
			p.AlterStatementSuffixTouch()
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3100)
			p.AlterStatementSuffixArchive()
		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3101)
			p.AlterStatementSuffixUnArchive()
		}


	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(3102)
			p.AlterStatementSuffixProperties()
		}


	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(3103)
			p.AlterStatementSuffixSkewedby()
		}


	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(3104)
			p.AlterStatementSuffixExchangePartition()
		}


	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(3105)
			p.AlterStatementPartitionKeyType()
		}


	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(3106)
			p.AlterStatementSuffixDropConstraint()
		}


	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(3107)
			p.AlterStatementSuffixAddConstraint()
		}


	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(3108)
			p.AlterTblPartitionStatementSuffix()
		}


	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(3109)
			p.PartitionSpec()
		}
		{
			p.SetState(3110)
			p.AlterTblPartitionStatementSuffix()
		}


	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(3112)
			p.AlterStatementSuffixSetOwner()
		}


	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(3113)
			p.AlterStatementSuffixSetPartSpec()
		}


	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(3114)
			p.AlterStatementSuffixExecute()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlterTblPartitionStatementSuffixContext is an interface to support dynamic dispatch.
type IAlterTblPartitionStatementSuffixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AlterStatementSuffixFileFormat() IAlterStatementSuffixFileFormatContext
	AlterStatementSuffixLocation() IAlterStatementSuffixLocationContext
	AlterStatementSuffixMergeFiles() IAlterStatementSuffixMergeFilesContext
	AlterStatementSuffixSerdeProperties() IAlterStatementSuffixSerdePropertiesContext
	AlterStatementSuffixRenamePart() IAlterStatementSuffixRenamePartContext
	AlterStatementSuffixBucketNum() IAlterStatementSuffixBucketNumContext
	AlterTblPartitionStatementSuffixSkewedLocation() IAlterTblPartitionStatementSuffixSkewedLocationContext
	AlterStatementSuffixClusterbySortby() IAlterStatementSuffixClusterbySortbyContext
	AlterStatementSuffixCompact() IAlterStatementSuffixCompactContext
	AlterStatementSuffixUpdateStatsCol() IAlterStatementSuffixUpdateStatsColContext
	AlterStatementSuffixUpdateStats() IAlterStatementSuffixUpdateStatsContext
	AlterStatementSuffixRenameCol() IAlterStatementSuffixRenameColContext
	AlterStatementSuffixAddCol() IAlterStatementSuffixAddColContext
	AlterStatementSuffixUpdateColumns() IAlterStatementSuffixUpdateColumnsContext

	// IsAlterTblPartitionStatementSuffixContext differentiates from other interfaces.
	IsAlterTblPartitionStatementSuffixContext()
}

type AlterTblPartitionStatementSuffixContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterTblPartitionStatementSuffixContext() *AlterTblPartitionStatementSuffixContext {
	var p = new(AlterTblPartitionStatementSuffixContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterTblPartitionStatementSuffix
	return p
}

func InitEmptyAlterTblPartitionStatementSuffixContext(p *AlterTblPartitionStatementSuffixContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterTblPartitionStatementSuffix
}

func (*AlterTblPartitionStatementSuffixContext) IsAlterTblPartitionStatementSuffixContext() {}

func NewAlterTblPartitionStatementSuffixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterTblPartitionStatementSuffixContext {
	var p = new(AlterTblPartitionStatementSuffixContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_alterTblPartitionStatementSuffix

	return p
}

func (s *AlterTblPartitionStatementSuffixContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterTblPartitionStatementSuffixContext) AlterStatementSuffixFileFormat() IAlterStatementSuffixFileFormatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterStatementSuffixFileFormatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterStatementSuffixFileFormatContext)
}

func (s *AlterTblPartitionStatementSuffixContext) AlterStatementSuffixLocation() IAlterStatementSuffixLocationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterStatementSuffixLocationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterStatementSuffixLocationContext)
}

func (s *AlterTblPartitionStatementSuffixContext) AlterStatementSuffixMergeFiles() IAlterStatementSuffixMergeFilesContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterStatementSuffixMergeFilesContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterStatementSuffixMergeFilesContext)
}

func (s *AlterTblPartitionStatementSuffixContext) AlterStatementSuffixSerdeProperties() IAlterStatementSuffixSerdePropertiesContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterStatementSuffixSerdePropertiesContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterStatementSuffixSerdePropertiesContext)
}

func (s *AlterTblPartitionStatementSuffixContext) AlterStatementSuffixRenamePart() IAlterStatementSuffixRenamePartContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterStatementSuffixRenamePartContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterStatementSuffixRenamePartContext)
}

func (s *AlterTblPartitionStatementSuffixContext) AlterStatementSuffixBucketNum() IAlterStatementSuffixBucketNumContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterStatementSuffixBucketNumContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterStatementSuffixBucketNumContext)
}

func (s *AlterTblPartitionStatementSuffixContext) AlterTblPartitionStatementSuffixSkewedLocation() IAlterTblPartitionStatementSuffixSkewedLocationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterTblPartitionStatementSuffixSkewedLocationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterTblPartitionStatementSuffixSkewedLocationContext)
}

func (s *AlterTblPartitionStatementSuffixContext) AlterStatementSuffixClusterbySortby() IAlterStatementSuffixClusterbySortbyContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterStatementSuffixClusterbySortbyContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterStatementSuffixClusterbySortbyContext)
}

func (s *AlterTblPartitionStatementSuffixContext) AlterStatementSuffixCompact() IAlterStatementSuffixCompactContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterStatementSuffixCompactContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterStatementSuffixCompactContext)
}

func (s *AlterTblPartitionStatementSuffixContext) AlterStatementSuffixUpdateStatsCol() IAlterStatementSuffixUpdateStatsColContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterStatementSuffixUpdateStatsColContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterStatementSuffixUpdateStatsColContext)
}

func (s *AlterTblPartitionStatementSuffixContext) AlterStatementSuffixUpdateStats() IAlterStatementSuffixUpdateStatsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterStatementSuffixUpdateStatsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterStatementSuffixUpdateStatsContext)
}

func (s *AlterTblPartitionStatementSuffixContext) AlterStatementSuffixRenameCol() IAlterStatementSuffixRenameColContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterStatementSuffixRenameColContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterStatementSuffixRenameColContext)
}

func (s *AlterTblPartitionStatementSuffixContext) AlterStatementSuffixAddCol() IAlterStatementSuffixAddColContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterStatementSuffixAddColContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterStatementSuffixAddColContext)
}

func (s *AlterTblPartitionStatementSuffixContext) AlterStatementSuffixUpdateColumns() IAlterStatementSuffixUpdateColumnsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterStatementSuffixUpdateColumnsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterStatementSuffixUpdateColumnsContext)
}

func (s *AlterTblPartitionStatementSuffixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTblPartitionStatementSuffixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AlterTblPartitionStatementSuffixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterAlterTblPartitionStatementSuffix(s)
	}
}

func (s *AlterTblPartitionStatementSuffixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitAlterTblPartitionStatementSuffix(s)
	}
}

func (s *AlterTblPartitionStatementSuffixContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitAlterTblPartitionStatementSuffix(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) AlterTblPartitionStatementSuffix() (localctx IAlterTblPartitionStatementSuffixContext) {
	localctx = NewAlterTblPartitionStatementSuffixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 470, HiveParserRULE_alterTblPartitionStatementSuffix)
	p.SetState(3131)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 324, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3117)
			p.AlterStatementSuffixFileFormat()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3118)
			p.AlterStatementSuffixLocation()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3119)
			p.AlterStatementSuffixMergeFiles()
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3120)
			p.AlterStatementSuffixSerdeProperties()
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3121)
			p.AlterStatementSuffixRenamePart()
		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3122)
			p.AlterStatementSuffixBucketNum()
		}


	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(3123)
			p.AlterTblPartitionStatementSuffixSkewedLocation()
		}


	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(3124)
			p.AlterStatementSuffixClusterbySortby()
		}


	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(3125)
			p.AlterStatementSuffixCompact()
		}


	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(3126)
			p.AlterStatementSuffixUpdateStatsCol()
		}


	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(3127)
			p.AlterStatementSuffixUpdateStats()
		}


	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(3128)
			p.AlterStatementSuffixRenameCol()
		}


	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(3129)
			p.AlterStatementSuffixAddCol()
		}


	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(3130)
			p.AlterStatementSuffixUpdateColumns()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlterStatementPartitionKeyTypeContext is an interface to support dynamic dispatch.
type IAlterStatementPartitionKeyTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_PARTITION() antlr.TerminalNode
	KW_COLUMN() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	ColumnNameType() IColumnNameTypeContext
	RPAREN() antlr.TerminalNode

	// IsAlterStatementPartitionKeyTypeContext differentiates from other interfaces.
	IsAlterStatementPartitionKeyTypeContext()
}

type AlterStatementPartitionKeyTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterStatementPartitionKeyTypeContext() *AlterStatementPartitionKeyTypeContext {
	var p = new(AlterStatementPartitionKeyTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterStatementPartitionKeyType
	return p
}

func InitEmptyAlterStatementPartitionKeyTypeContext(p *AlterStatementPartitionKeyTypeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterStatementPartitionKeyType
}

func (*AlterStatementPartitionKeyTypeContext) IsAlterStatementPartitionKeyTypeContext() {}

func NewAlterStatementPartitionKeyTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterStatementPartitionKeyTypeContext {
	var p = new(AlterStatementPartitionKeyTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_alterStatementPartitionKeyType

	return p
}

func (s *AlterStatementPartitionKeyTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterStatementPartitionKeyTypeContext) KW_PARTITION() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_PARTITION, 0)
}

func (s *AlterStatementPartitionKeyTypeContext) KW_COLUMN() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_COLUMN, 0)
}

func (s *AlterStatementPartitionKeyTypeContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserLPAREN, 0)
}

func (s *AlterStatementPartitionKeyTypeContext) ColumnNameType() IColumnNameTypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNameTypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNameTypeContext)
}

func (s *AlterStatementPartitionKeyTypeContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserRPAREN, 0)
}

func (s *AlterStatementPartitionKeyTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterStatementPartitionKeyTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AlterStatementPartitionKeyTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterAlterStatementPartitionKeyType(s)
	}
}

func (s *AlterStatementPartitionKeyTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitAlterStatementPartitionKeyType(s)
	}
}

func (s *AlterStatementPartitionKeyTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitAlterStatementPartitionKeyType(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) AlterStatementPartitionKeyType() (localctx IAlterStatementPartitionKeyTypeContext) {
	localctx = NewAlterStatementPartitionKeyTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 472, HiveParserRULE_alterStatementPartitionKeyType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3133)
		p.Match(HiveParserKW_PARTITION)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3134)
		p.Match(HiveParserKW_COLUMN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3135)
		p.Match(HiveParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3136)
		p.ColumnNameType()
	}
	{
		p.SetState(3137)
		p.Match(HiveParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlterViewStatementSuffixContext is an interface to support dynamic dispatch.
type IAlterViewStatementSuffixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AlterViewSuffixProperties() IAlterViewSuffixPropertiesContext
	AlterStatementSuffixRename() IAlterStatementSuffixRenameContext
	AlterStatementSuffixAddPartitions() IAlterStatementSuffixAddPartitionsContext
	AlterStatementSuffixDropPartitions() IAlterStatementSuffixDropPartitionsContext
	SelectStatementWithCTE() ISelectStatementWithCTEContext

	// IsAlterViewStatementSuffixContext differentiates from other interfaces.
	IsAlterViewStatementSuffixContext()
}

type AlterViewStatementSuffixContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterViewStatementSuffixContext() *AlterViewStatementSuffixContext {
	var p = new(AlterViewStatementSuffixContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterViewStatementSuffix
	return p
}

func InitEmptyAlterViewStatementSuffixContext(p *AlterViewStatementSuffixContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterViewStatementSuffix
}

func (*AlterViewStatementSuffixContext) IsAlterViewStatementSuffixContext() {}

func NewAlterViewStatementSuffixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterViewStatementSuffixContext {
	var p = new(AlterViewStatementSuffixContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_alterViewStatementSuffix

	return p
}

func (s *AlterViewStatementSuffixContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterViewStatementSuffixContext) AlterViewSuffixProperties() IAlterViewSuffixPropertiesContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterViewSuffixPropertiesContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterViewSuffixPropertiesContext)
}

func (s *AlterViewStatementSuffixContext) AlterStatementSuffixRename() IAlterStatementSuffixRenameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterStatementSuffixRenameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterStatementSuffixRenameContext)
}

func (s *AlterViewStatementSuffixContext) AlterStatementSuffixAddPartitions() IAlterStatementSuffixAddPartitionsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterStatementSuffixAddPartitionsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterStatementSuffixAddPartitionsContext)
}

func (s *AlterViewStatementSuffixContext) AlterStatementSuffixDropPartitions() IAlterStatementSuffixDropPartitionsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterStatementSuffixDropPartitionsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterStatementSuffixDropPartitionsContext)
}

func (s *AlterViewStatementSuffixContext) SelectStatementWithCTE() ISelectStatementWithCTEContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementWithCTEContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementWithCTEContext)
}

func (s *AlterViewStatementSuffixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterViewStatementSuffixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AlterViewStatementSuffixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterAlterViewStatementSuffix(s)
	}
}

func (s *AlterViewStatementSuffixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitAlterViewStatementSuffix(s)
	}
}

func (s *AlterViewStatementSuffixContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitAlterViewStatementSuffix(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) AlterViewStatementSuffix() (localctx IAlterViewStatementSuffixContext) {
	localctx = NewAlterViewStatementSuffixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 474, HiveParserRULE_alterViewStatementSuffix)
	p.SetState(3144)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserKW_SET, HiveParserKW_UNSET:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3139)
			p.AlterViewSuffixProperties()
		}


	case HiveParserKW_RENAME:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3140)
			p.AlterStatementSuffixRename()
		}


	case HiveParserKW_ADD:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3141)
			p.AlterStatementSuffixAddPartitions()
		}


	case HiveParserKW_DROP:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3142)
			p.AlterStatementSuffixDropPartitions()
		}


	case HiveParserKW_MAP, HiveParserKW_REDUCE, HiveParserKW_SELECT, HiveParserKW_VALUES, HiveParserKW_WITH, HiveParserLPAREN:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3143)
			p.SelectStatementWithCTE()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlterMaterializedViewStatementSuffixContext is an interface to support dynamic dispatch.
type IAlterMaterializedViewStatementSuffixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AlterMaterializedViewSuffixRewrite() IAlterMaterializedViewSuffixRewriteContext
	AlterMaterializedViewSuffixRebuild() IAlterMaterializedViewSuffixRebuildContext

	// IsAlterMaterializedViewStatementSuffixContext differentiates from other interfaces.
	IsAlterMaterializedViewStatementSuffixContext()
}

type AlterMaterializedViewStatementSuffixContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterMaterializedViewStatementSuffixContext() *AlterMaterializedViewStatementSuffixContext {
	var p = new(AlterMaterializedViewStatementSuffixContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterMaterializedViewStatementSuffix
	return p
}

func InitEmptyAlterMaterializedViewStatementSuffixContext(p *AlterMaterializedViewStatementSuffixContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterMaterializedViewStatementSuffix
}

func (*AlterMaterializedViewStatementSuffixContext) IsAlterMaterializedViewStatementSuffixContext() {}

func NewAlterMaterializedViewStatementSuffixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterMaterializedViewStatementSuffixContext {
	var p = new(AlterMaterializedViewStatementSuffixContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_alterMaterializedViewStatementSuffix

	return p
}

func (s *AlterMaterializedViewStatementSuffixContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterMaterializedViewStatementSuffixContext) AlterMaterializedViewSuffixRewrite() IAlterMaterializedViewSuffixRewriteContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterMaterializedViewSuffixRewriteContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterMaterializedViewSuffixRewriteContext)
}

func (s *AlterMaterializedViewStatementSuffixContext) AlterMaterializedViewSuffixRebuild() IAlterMaterializedViewSuffixRebuildContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterMaterializedViewSuffixRebuildContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterMaterializedViewSuffixRebuildContext)
}

func (s *AlterMaterializedViewStatementSuffixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterMaterializedViewStatementSuffixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AlterMaterializedViewStatementSuffixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterAlterMaterializedViewStatementSuffix(s)
	}
}

func (s *AlterMaterializedViewStatementSuffixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitAlterMaterializedViewStatementSuffix(s)
	}
}

func (s *AlterMaterializedViewStatementSuffixContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitAlterMaterializedViewStatementSuffix(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) AlterMaterializedViewStatementSuffix() (localctx IAlterMaterializedViewStatementSuffixContext) {
	localctx = NewAlterMaterializedViewStatementSuffixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 476, HiveParserRULE_alterMaterializedViewStatementSuffix)
	p.SetState(3148)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserKW_DISABLE, HiveParserKW_ENABLE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3146)
			p.AlterMaterializedViewSuffixRewrite()
		}


	case HiveParserKW_REBUILD:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3147)
			p.AlterMaterializedViewSuffixRebuild()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlterMaterializedViewSuffixRewriteContext is an interface to support dynamic dispatch.
type IAlterMaterializedViewSuffixRewriteContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetMvRewriteFlag returns the mvRewriteFlag rule contexts.
	GetMvRewriteFlag() IRewriteEnabledContext

	// GetMvRewriteFlag2 returns the mvRewriteFlag2 rule contexts.
	GetMvRewriteFlag2() IRewriteDisabledContext


	// SetMvRewriteFlag sets the mvRewriteFlag rule contexts.
	SetMvRewriteFlag(IRewriteEnabledContext)

	// SetMvRewriteFlag2 sets the mvRewriteFlag2 rule contexts.
	SetMvRewriteFlag2(IRewriteDisabledContext)


	// Getter signatures
	RewriteEnabled() IRewriteEnabledContext
	RewriteDisabled() IRewriteDisabledContext

	// IsAlterMaterializedViewSuffixRewriteContext differentiates from other interfaces.
	IsAlterMaterializedViewSuffixRewriteContext()
}

type AlterMaterializedViewSuffixRewriteContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	mvRewriteFlag IRewriteEnabledContext 
	mvRewriteFlag2 IRewriteDisabledContext 
}

func NewEmptyAlterMaterializedViewSuffixRewriteContext() *AlterMaterializedViewSuffixRewriteContext {
	var p = new(AlterMaterializedViewSuffixRewriteContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterMaterializedViewSuffixRewrite
	return p
}

func InitEmptyAlterMaterializedViewSuffixRewriteContext(p *AlterMaterializedViewSuffixRewriteContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterMaterializedViewSuffixRewrite
}

func (*AlterMaterializedViewSuffixRewriteContext) IsAlterMaterializedViewSuffixRewriteContext() {}

func NewAlterMaterializedViewSuffixRewriteContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterMaterializedViewSuffixRewriteContext {
	var p = new(AlterMaterializedViewSuffixRewriteContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_alterMaterializedViewSuffixRewrite

	return p
}

func (s *AlterMaterializedViewSuffixRewriteContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterMaterializedViewSuffixRewriteContext) GetMvRewriteFlag() IRewriteEnabledContext { return s.mvRewriteFlag }

func (s *AlterMaterializedViewSuffixRewriteContext) GetMvRewriteFlag2() IRewriteDisabledContext { return s.mvRewriteFlag2 }


func (s *AlterMaterializedViewSuffixRewriteContext) SetMvRewriteFlag(v IRewriteEnabledContext) { s.mvRewriteFlag = v }

func (s *AlterMaterializedViewSuffixRewriteContext) SetMvRewriteFlag2(v IRewriteDisabledContext) { s.mvRewriteFlag2 = v }


func (s *AlterMaterializedViewSuffixRewriteContext) RewriteEnabled() IRewriteEnabledContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRewriteEnabledContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRewriteEnabledContext)
}

func (s *AlterMaterializedViewSuffixRewriteContext) RewriteDisabled() IRewriteDisabledContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRewriteDisabledContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRewriteDisabledContext)
}

func (s *AlterMaterializedViewSuffixRewriteContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterMaterializedViewSuffixRewriteContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AlterMaterializedViewSuffixRewriteContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterAlterMaterializedViewSuffixRewrite(s)
	}
}

func (s *AlterMaterializedViewSuffixRewriteContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitAlterMaterializedViewSuffixRewrite(s)
	}
}

func (s *AlterMaterializedViewSuffixRewriteContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitAlterMaterializedViewSuffixRewrite(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) AlterMaterializedViewSuffixRewrite() (localctx IAlterMaterializedViewSuffixRewriteContext) {
	localctx = NewAlterMaterializedViewSuffixRewriteContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 478, HiveParserRULE_alterMaterializedViewSuffixRewrite)
	p.SetState(3152)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserKW_ENABLE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3150)

			var _x = p.RewriteEnabled()


			localctx.(*AlterMaterializedViewSuffixRewriteContext).mvRewriteFlag = _x
		}


	case HiveParserKW_DISABLE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3151)

			var _x = p.RewriteDisabled()


			localctx.(*AlterMaterializedViewSuffixRewriteContext).mvRewriteFlag2 = _x
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlterMaterializedViewSuffixRebuildContext is an interface to support dynamic dispatch.
type IAlterMaterializedViewSuffixRebuildContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_REBUILD() antlr.TerminalNode

	// IsAlterMaterializedViewSuffixRebuildContext differentiates from other interfaces.
	IsAlterMaterializedViewSuffixRebuildContext()
}

type AlterMaterializedViewSuffixRebuildContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterMaterializedViewSuffixRebuildContext() *AlterMaterializedViewSuffixRebuildContext {
	var p = new(AlterMaterializedViewSuffixRebuildContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterMaterializedViewSuffixRebuild
	return p
}

func InitEmptyAlterMaterializedViewSuffixRebuildContext(p *AlterMaterializedViewSuffixRebuildContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterMaterializedViewSuffixRebuild
}

func (*AlterMaterializedViewSuffixRebuildContext) IsAlterMaterializedViewSuffixRebuildContext() {}

func NewAlterMaterializedViewSuffixRebuildContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterMaterializedViewSuffixRebuildContext {
	var p = new(AlterMaterializedViewSuffixRebuildContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_alterMaterializedViewSuffixRebuild

	return p
}

func (s *AlterMaterializedViewSuffixRebuildContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterMaterializedViewSuffixRebuildContext) KW_REBUILD() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_REBUILD, 0)
}

func (s *AlterMaterializedViewSuffixRebuildContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterMaterializedViewSuffixRebuildContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AlterMaterializedViewSuffixRebuildContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterAlterMaterializedViewSuffixRebuild(s)
	}
}

func (s *AlterMaterializedViewSuffixRebuildContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitAlterMaterializedViewSuffixRebuild(s)
	}
}

func (s *AlterMaterializedViewSuffixRebuildContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitAlterMaterializedViewSuffixRebuild(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) AlterMaterializedViewSuffixRebuild() (localctx IAlterMaterializedViewSuffixRebuildContext) {
	localctx = NewAlterMaterializedViewSuffixRebuildContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 480, HiveParserRULE_alterMaterializedViewSuffixRebuild)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3154)
		p.Match(HiveParserKW_REBUILD)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlterDatabaseStatementSuffixContext is an interface to support dynamic dispatch.
type IAlterDatabaseStatementSuffixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AlterDatabaseSuffixProperties() IAlterDatabaseSuffixPropertiesContext
	AlterDatabaseSuffixSetOwner() IAlterDatabaseSuffixSetOwnerContext
	AlterDatabaseSuffixSetLocation() IAlterDatabaseSuffixSetLocationContext

	// IsAlterDatabaseStatementSuffixContext differentiates from other interfaces.
	IsAlterDatabaseStatementSuffixContext()
}

type AlterDatabaseStatementSuffixContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterDatabaseStatementSuffixContext() *AlterDatabaseStatementSuffixContext {
	var p = new(AlterDatabaseStatementSuffixContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterDatabaseStatementSuffix
	return p
}

func InitEmptyAlterDatabaseStatementSuffixContext(p *AlterDatabaseStatementSuffixContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterDatabaseStatementSuffix
}

func (*AlterDatabaseStatementSuffixContext) IsAlterDatabaseStatementSuffixContext() {}

func NewAlterDatabaseStatementSuffixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterDatabaseStatementSuffixContext {
	var p = new(AlterDatabaseStatementSuffixContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_alterDatabaseStatementSuffix

	return p
}

func (s *AlterDatabaseStatementSuffixContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterDatabaseStatementSuffixContext) AlterDatabaseSuffixProperties() IAlterDatabaseSuffixPropertiesContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterDatabaseSuffixPropertiesContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterDatabaseSuffixPropertiesContext)
}

func (s *AlterDatabaseStatementSuffixContext) AlterDatabaseSuffixSetOwner() IAlterDatabaseSuffixSetOwnerContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterDatabaseSuffixSetOwnerContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterDatabaseSuffixSetOwnerContext)
}

func (s *AlterDatabaseStatementSuffixContext) AlterDatabaseSuffixSetLocation() IAlterDatabaseSuffixSetLocationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterDatabaseSuffixSetLocationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterDatabaseSuffixSetLocationContext)
}

func (s *AlterDatabaseStatementSuffixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterDatabaseStatementSuffixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AlterDatabaseStatementSuffixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterAlterDatabaseStatementSuffix(s)
	}
}

func (s *AlterDatabaseStatementSuffixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitAlterDatabaseStatementSuffix(s)
	}
}

func (s *AlterDatabaseStatementSuffixContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitAlterDatabaseStatementSuffix(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) AlterDatabaseStatementSuffix() (localctx IAlterDatabaseStatementSuffixContext) {
	localctx = NewAlterDatabaseStatementSuffixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 482, HiveParserRULE_alterDatabaseStatementSuffix)
	p.SetState(3159)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 328, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3156)
			p.AlterDatabaseSuffixProperties()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3157)
			p.AlterDatabaseSuffixSetOwner()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3158)
			p.AlterDatabaseSuffixSetLocation()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlterDatabaseSuffixPropertiesContext is an interface to support dynamic dispatch.
type IAlterDatabaseSuffixPropertiesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IId_Context


	// SetName sets the name rule contexts.
	SetName(IId_Context)


	// Getter signatures
	KW_SET() antlr.TerminalNode
	KW_DBPROPERTIES() antlr.TerminalNode
	DbProperties() IDbPropertiesContext
	Id_() IId_Context

	// IsAlterDatabaseSuffixPropertiesContext differentiates from other interfaces.
	IsAlterDatabaseSuffixPropertiesContext()
}

type AlterDatabaseSuffixPropertiesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name IId_Context 
}

func NewEmptyAlterDatabaseSuffixPropertiesContext() *AlterDatabaseSuffixPropertiesContext {
	var p = new(AlterDatabaseSuffixPropertiesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterDatabaseSuffixProperties
	return p
}

func InitEmptyAlterDatabaseSuffixPropertiesContext(p *AlterDatabaseSuffixPropertiesContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterDatabaseSuffixProperties
}

func (*AlterDatabaseSuffixPropertiesContext) IsAlterDatabaseSuffixPropertiesContext() {}

func NewAlterDatabaseSuffixPropertiesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterDatabaseSuffixPropertiesContext {
	var p = new(AlterDatabaseSuffixPropertiesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_alterDatabaseSuffixProperties

	return p
}

func (s *AlterDatabaseSuffixPropertiesContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterDatabaseSuffixPropertiesContext) GetName() IId_Context { return s.name }


func (s *AlterDatabaseSuffixPropertiesContext) SetName(v IId_Context) { s.name = v }


func (s *AlterDatabaseSuffixPropertiesContext) KW_SET() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SET, 0)
}

func (s *AlterDatabaseSuffixPropertiesContext) KW_DBPROPERTIES() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DBPROPERTIES, 0)
}

func (s *AlterDatabaseSuffixPropertiesContext) DbProperties() IDbPropertiesContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDbPropertiesContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDbPropertiesContext)
}

func (s *AlterDatabaseSuffixPropertiesContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *AlterDatabaseSuffixPropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterDatabaseSuffixPropertiesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AlterDatabaseSuffixPropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterAlterDatabaseSuffixProperties(s)
	}
}

func (s *AlterDatabaseSuffixPropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitAlterDatabaseSuffixProperties(s)
	}
}

func (s *AlterDatabaseSuffixPropertiesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitAlterDatabaseSuffixProperties(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) AlterDatabaseSuffixProperties() (localctx IAlterDatabaseSuffixPropertiesContext) {
	localctx = NewAlterDatabaseSuffixPropertiesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 484, HiveParserRULE_alterDatabaseSuffixProperties)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3161)

		var _x = p.Id_()


		localctx.(*AlterDatabaseSuffixPropertiesContext).name = _x
	}
	{
		p.SetState(3162)
		p.Match(HiveParserKW_SET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3163)
		p.Match(HiveParserKW_DBPROPERTIES)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3164)
		p.DbProperties()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlterDatabaseSuffixSetOwnerContext is an interface to support dynamic dispatch.
type IAlterDatabaseSuffixSetOwnerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDbName returns the dbName rule contexts.
	GetDbName() IId_Context


	// SetDbName sets the dbName rule contexts.
	SetDbName(IId_Context)


	// Getter signatures
	KW_SET() antlr.TerminalNode
	KW_OWNER() antlr.TerminalNode
	PrincipalName() IPrincipalNameContext
	Id_() IId_Context

	// IsAlterDatabaseSuffixSetOwnerContext differentiates from other interfaces.
	IsAlterDatabaseSuffixSetOwnerContext()
}

type AlterDatabaseSuffixSetOwnerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	dbName IId_Context 
}

func NewEmptyAlterDatabaseSuffixSetOwnerContext() *AlterDatabaseSuffixSetOwnerContext {
	var p = new(AlterDatabaseSuffixSetOwnerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterDatabaseSuffixSetOwner
	return p
}

func InitEmptyAlterDatabaseSuffixSetOwnerContext(p *AlterDatabaseSuffixSetOwnerContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterDatabaseSuffixSetOwner
}

func (*AlterDatabaseSuffixSetOwnerContext) IsAlterDatabaseSuffixSetOwnerContext() {}

func NewAlterDatabaseSuffixSetOwnerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterDatabaseSuffixSetOwnerContext {
	var p = new(AlterDatabaseSuffixSetOwnerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_alterDatabaseSuffixSetOwner

	return p
}

func (s *AlterDatabaseSuffixSetOwnerContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterDatabaseSuffixSetOwnerContext) GetDbName() IId_Context { return s.dbName }


func (s *AlterDatabaseSuffixSetOwnerContext) SetDbName(v IId_Context) { s.dbName = v }


func (s *AlterDatabaseSuffixSetOwnerContext) KW_SET() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SET, 0)
}

func (s *AlterDatabaseSuffixSetOwnerContext) KW_OWNER() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_OWNER, 0)
}

func (s *AlterDatabaseSuffixSetOwnerContext) PrincipalName() IPrincipalNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrincipalNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrincipalNameContext)
}

func (s *AlterDatabaseSuffixSetOwnerContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *AlterDatabaseSuffixSetOwnerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterDatabaseSuffixSetOwnerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AlterDatabaseSuffixSetOwnerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterAlterDatabaseSuffixSetOwner(s)
	}
}

func (s *AlterDatabaseSuffixSetOwnerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitAlterDatabaseSuffixSetOwner(s)
	}
}

func (s *AlterDatabaseSuffixSetOwnerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitAlterDatabaseSuffixSetOwner(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) AlterDatabaseSuffixSetOwner() (localctx IAlterDatabaseSuffixSetOwnerContext) {
	localctx = NewAlterDatabaseSuffixSetOwnerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 486, HiveParserRULE_alterDatabaseSuffixSetOwner)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3166)

		var _x = p.Id_()


		localctx.(*AlterDatabaseSuffixSetOwnerContext).dbName = _x
	}
	{
		p.SetState(3167)
		p.Match(HiveParserKW_SET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3168)
		p.Match(HiveParserKW_OWNER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3169)
		p.PrincipalName()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlterDatabaseSuffixSetLocationContext is an interface to support dynamic dispatch.
type IAlterDatabaseSuffixSetLocationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetNewLocation returns the newLocation token.
	GetNewLocation() antlr.Token 


	// SetNewLocation sets the newLocation token.
	SetNewLocation(antlr.Token) 


	// GetDbName returns the dbName rule contexts.
	GetDbName() IId_Context


	// SetDbName sets the dbName rule contexts.
	SetDbName(IId_Context)


	// Getter signatures
	KW_SET() antlr.TerminalNode
	Id_() IId_Context
	KW_LOCATION() antlr.TerminalNode
	KW_MANAGEDLOCATION() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode

	// IsAlterDatabaseSuffixSetLocationContext differentiates from other interfaces.
	IsAlterDatabaseSuffixSetLocationContext()
}

type AlterDatabaseSuffixSetLocationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	dbName IId_Context 
	newLocation antlr.Token
}

func NewEmptyAlterDatabaseSuffixSetLocationContext() *AlterDatabaseSuffixSetLocationContext {
	var p = new(AlterDatabaseSuffixSetLocationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterDatabaseSuffixSetLocation
	return p
}

func InitEmptyAlterDatabaseSuffixSetLocationContext(p *AlterDatabaseSuffixSetLocationContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterDatabaseSuffixSetLocation
}

func (*AlterDatabaseSuffixSetLocationContext) IsAlterDatabaseSuffixSetLocationContext() {}

func NewAlterDatabaseSuffixSetLocationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterDatabaseSuffixSetLocationContext {
	var p = new(AlterDatabaseSuffixSetLocationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_alterDatabaseSuffixSetLocation

	return p
}

func (s *AlterDatabaseSuffixSetLocationContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterDatabaseSuffixSetLocationContext) GetNewLocation() antlr.Token { return s.newLocation }


func (s *AlterDatabaseSuffixSetLocationContext) SetNewLocation(v antlr.Token) { s.newLocation = v }


func (s *AlterDatabaseSuffixSetLocationContext) GetDbName() IId_Context { return s.dbName }


func (s *AlterDatabaseSuffixSetLocationContext) SetDbName(v IId_Context) { s.dbName = v }


func (s *AlterDatabaseSuffixSetLocationContext) KW_SET() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SET, 0)
}

func (s *AlterDatabaseSuffixSetLocationContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *AlterDatabaseSuffixSetLocationContext) KW_LOCATION() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_LOCATION, 0)
}

func (s *AlterDatabaseSuffixSetLocationContext) KW_MANAGEDLOCATION() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_MANAGEDLOCATION, 0)
}

func (s *AlterDatabaseSuffixSetLocationContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(HiveParserStringLiteral, 0)
}

func (s *AlterDatabaseSuffixSetLocationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterDatabaseSuffixSetLocationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AlterDatabaseSuffixSetLocationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterAlterDatabaseSuffixSetLocation(s)
	}
}

func (s *AlterDatabaseSuffixSetLocationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitAlterDatabaseSuffixSetLocation(s)
	}
}

func (s *AlterDatabaseSuffixSetLocationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitAlterDatabaseSuffixSetLocation(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) AlterDatabaseSuffixSetLocation() (localctx IAlterDatabaseSuffixSetLocationContext) {
	localctx = NewAlterDatabaseSuffixSetLocationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 488, HiveParserRULE_alterDatabaseSuffixSetLocation)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3171)

		var _x = p.Id_()


		localctx.(*AlterDatabaseSuffixSetLocationContext).dbName = _x
	}
	{
		p.SetState(3172)
		p.Match(HiveParserKW_SET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3173)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HiveParserKW_LOCATION || _la == HiveParserKW_MANAGEDLOCATION) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(3174)

		var _m = p.Match(HiveParserStringLiteral)

		localctx.(*AlterDatabaseSuffixSetLocationContext).newLocation = _m
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlterDatabaseSuffixSetManagedLocationContext is an interface to support dynamic dispatch.
type IAlterDatabaseSuffixSetManagedLocationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetNewLocation returns the newLocation token.
	GetNewLocation() antlr.Token 


	// SetNewLocation sets the newLocation token.
	SetNewLocation(antlr.Token) 


	// GetDbName returns the dbName rule contexts.
	GetDbName() IId_Context


	// SetDbName sets the dbName rule contexts.
	SetDbName(IId_Context)


	// Getter signatures
	KW_SET() antlr.TerminalNode
	KW_MANAGEDLOCATION() antlr.TerminalNode
	Id_() IId_Context
	StringLiteral() antlr.TerminalNode

	// IsAlterDatabaseSuffixSetManagedLocationContext differentiates from other interfaces.
	IsAlterDatabaseSuffixSetManagedLocationContext()
}

type AlterDatabaseSuffixSetManagedLocationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	dbName IId_Context 
	newLocation antlr.Token
}

func NewEmptyAlterDatabaseSuffixSetManagedLocationContext() *AlterDatabaseSuffixSetManagedLocationContext {
	var p = new(AlterDatabaseSuffixSetManagedLocationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterDatabaseSuffixSetManagedLocation
	return p
}

func InitEmptyAlterDatabaseSuffixSetManagedLocationContext(p *AlterDatabaseSuffixSetManagedLocationContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterDatabaseSuffixSetManagedLocation
}

func (*AlterDatabaseSuffixSetManagedLocationContext) IsAlterDatabaseSuffixSetManagedLocationContext() {}

func NewAlterDatabaseSuffixSetManagedLocationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterDatabaseSuffixSetManagedLocationContext {
	var p = new(AlterDatabaseSuffixSetManagedLocationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_alterDatabaseSuffixSetManagedLocation

	return p
}

func (s *AlterDatabaseSuffixSetManagedLocationContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterDatabaseSuffixSetManagedLocationContext) GetNewLocation() antlr.Token { return s.newLocation }


func (s *AlterDatabaseSuffixSetManagedLocationContext) SetNewLocation(v antlr.Token) { s.newLocation = v }


func (s *AlterDatabaseSuffixSetManagedLocationContext) GetDbName() IId_Context { return s.dbName }


func (s *AlterDatabaseSuffixSetManagedLocationContext) SetDbName(v IId_Context) { s.dbName = v }


func (s *AlterDatabaseSuffixSetManagedLocationContext) KW_SET() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SET, 0)
}

func (s *AlterDatabaseSuffixSetManagedLocationContext) KW_MANAGEDLOCATION() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_MANAGEDLOCATION, 0)
}

func (s *AlterDatabaseSuffixSetManagedLocationContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *AlterDatabaseSuffixSetManagedLocationContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(HiveParserStringLiteral, 0)
}

func (s *AlterDatabaseSuffixSetManagedLocationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterDatabaseSuffixSetManagedLocationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AlterDatabaseSuffixSetManagedLocationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterAlterDatabaseSuffixSetManagedLocation(s)
	}
}

func (s *AlterDatabaseSuffixSetManagedLocationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitAlterDatabaseSuffixSetManagedLocation(s)
	}
}

func (s *AlterDatabaseSuffixSetManagedLocationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitAlterDatabaseSuffixSetManagedLocation(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) AlterDatabaseSuffixSetManagedLocation() (localctx IAlterDatabaseSuffixSetManagedLocationContext) {
	localctx = NewAlterDatabaseSuffixSetManagedLocationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 490, HiveParserRULE_alterDatabaseSuffixSetManagedLocation)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3176)

		var _x = p.Id_()


		localctx.(*AlterDatabaseSuffixSetManagedLocationContext).dbName = _x
	}
	{
		p.SetState(3177)
		p.Match(HiveParserKW_SET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3178)
		p.Match(HiveParserKW_MANAGEDLOCATION)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3179)

		var _m = p.Match(HiveParserStringLiteral)

		localctx.(*AlterDatabaseSuffixSetManagedLocationContext).newLocation = _m
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlterStatementSuffixRenameContext is an interface to support dynamic dispatch.
type IAlterStatementSuffixRenameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_RENAME() antlr.TerminalNode
	KW_TO() antlr.TerminalNode
	TableName() ITableNameContext

	// IsAlterStatementSuffixRenameContext differentiates from other interfaces.
	IsAlterStatementSuffixRenameContext()
}

type AlterStatementSuffixRenameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterStatementSuffixRenameContext() *AlterStatementSuffixRenameContext {
	var p = new(AlterStatementSuffixRenameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterStatementSuffixRename
	return p
}

func InitEmptyAlterStatementSuffixRenameContext(p *AlterStatementSuffixRenameContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterStatementSuffixRename
}

func (*AlterStatementSuffixRenameContext) IsAlterStatementSuffixRenameContext() {}

func NewAlterStatementSuffixRenameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterStatementSuffixRenameContext {
	var p = new(AlterStatementSuffixRenameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_alterStatementSuffixRename

	return p
}

func (s *AlterStatementSuffixRenameContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterStatementSuffixRenameContext) KW_RENAME() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_RENAME, 0)
}

func (s *AlterStatementSuffixRenameContext) KW_TO() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TO, 0)
}

func (s *AlterStatementSuffixRenameContext) TableName() ITableNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *AlterStatementSuffixRenameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterStatementSuffixRenameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AlterStatementSuffixRenameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterAlterStatementSuffixRename(s)
	}
}

func (s *AlterStatementSuffixRenameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitAlterStatementSuffixRename(s)
	}
}

func (s *AlterStatementSuffixRenameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitAlterStatementSuffixRename(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) AlterStatementSuffixRename() (localctx IAlterStatementSuffixRenameContext) {
	localctx = NewAlterStatementSuffixRenameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 492, HiveParserRULE_alterStatementSuffixRename)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3181)
		p.Match(HiveParserKW_RENAME)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3182)
		p.Match(HiveParserKW_TO)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3183)
		p.TableName()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlterStatementSuffixAddColContext is an interface to support dynamic dispatch.
type IAlterStatementSuffixAddColContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetAdd returns the add token.
	GetAdd() antlr.Token 

	// GetReplace returns the replace token.
	GetReplace() antlr.Token 


	// SetAdd sets the add token.
	SetAdd(antlr.Token) 

	// SetReplace sets the replace token.
	SetReplace(antlr.Token) 


	// Getter signatures
	KW_COLUMNS() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	ColumnNameTypeList() IColumnNameTypeListContext
	RPAREN() antlr.TerminalNode
	KW_ADD() antlr.TerminalNode
	KW_REPLACE() antlr.TerminalNode
	RestrictOrCascade() IRestrictOrCascadeContext

	// IsAlterStatementSuffixAddColContext differentiates from other interfaces.
	IsAlterStatementSuffixAddColContext()
}

type AlterStatementSuffixAddColContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	add antlr.Token
	replace antlr.Token
}

func NewEmptyAlterStatementSuffixAddColContext() *AlterStatementSuffixAddColContext {
	var p = new(AlterStatementSuffixAddColContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterStatementSuffixAddCol
	return p
}

func InitEmptyAlterStatementSuffixAddColContext(p *AlterStatementSuffixAddColContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterStatementSuffixAddCol
}

func (*AlterStatementSuffixAddColContext) IsAlterStatementSuffixAddColContext() {}

func NewAlterStatementSuffixAddColContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterStatementSuffixAddColContext {
	var p = new(AlterStatementSuffixAddColContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_alterStatementSuffixAddCol

	return p
}

func (s *AlterStatementSuffixAddColContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterStatementSuffixAddColContext) GetAdd() antlr.Token { return s.add }

func (s *AlterStatementSuffixAddColContext) GetReplace() antlr.Token { return s.replace }


func (s *AlterStatementSuffixAddColContext) SetAdd(v antlr.Token) { s.add = v }

func (s *AlterStatementSuffixAddColContext) SetReplace(v antlr.Token) { s.replace = v }


func (s *AlterStatementSuffixAddColContext) KW_COLUMNS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_COLUMNS, 0)
}

func (s *AlterStatementSuffixAddColContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserLPAREN, 0)
}

func (s *AlterStatementSuffixAddColContext) ColumnNameTypeList() IColumnNameTypeListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNameTypeListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNameTypeListContext)
}

func (s *AlterStatementSuffixAddColContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserRPAREN, 0)
}

func (s *AlterStatementSuffixAddColContext) KW_ADD() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ADD, 0)
}

func (s *AlterStatementSuffixAddColContext) KW_REPLACE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_REPLACE, 0)
}

func (s *AlterStatementSuffixAddColContext) RestrictOrCascade() IRestrictOrCascadeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRestrictOrCascadeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRestrictOrCascadeContext)
}

func (s *AlterStatementSuffixAddColContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterStatementSuffixAddColContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AlterStatementSuffixAddColContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterAlterStatementSuffixAddCol(s)
	}
}

func (s *AlterStatementSuffixAddColContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitAlterStatementSuffixAddCol(s)
	}
}

func (s *AlterStatementSuffixAddColContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitAlterStatementSuffixAddCol(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) AlterStatementSuffixAddCol() (localctx IAlterStatementSuffixAddColContext) {
	localctx = NewAlterStatementSuffixAddColContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 494, HiveParserRULE_alterStatementSuffixAddCol)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3187)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserKW_ADD:
		{
			p.SetState(3185)

			var _m = p.Match(HiveParserKW_ADD)

			localctx.(*AlterStatementSuffixAddColContext).add = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HiveParserKW_REPLACE:
		{
			p.SetState(3186)

			var _m = p.Match(HiveParserKW_REPLACE)

			localctx.(*AlterStatementSuffixAddColContext).replace = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(3189)
		p.Match(HiveParserKW_COLUMNS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3190)
		p.Match(HiveParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3191)
		p.ColumnNameTypeList()
	}
	{
		p.SetState(3192)
		p.Match(HiveParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(3194)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_CASCADE || _la == HiveParserKW_RESTRICT {
		{
			p.SetState(3193)
			p.RestrictOrCascade()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlterStatementSuffixAddConstraintContext is an interface to support dynamic dispatch.
type IAlterStatementSuffixAddConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFk returns the fk rule contexts.
	GetFk() IAlterForeignKeyWithNameContext


	// SetFk sets the fk rule contexts.
	SetFk(IAlterForeignKeyWithNameContext)


	// Getter signatures
	KW_ADD() antlr.TerminalNode
	AlterConstraintWithName() IAlterConstraintWithNameContext
	AlterForeignKeyWithName() IAlterForeignKeyWithNameContext

	// IsAlterStatementSuffixAddConstraintContext differentiates from other interfaces.
	IsAlterStatementSuffixAddConstraintContext()
}

type AlterStatementSuffixAddConstraintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	fk IAlterForeignKeyWithNameContext 
}

func NewEmptyAlterStatementSuffixAddConstraintContext() *AlterStatementSuffixAddConstraintContext {
	var p = new(AlterStatementSuffixAddConstraintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterStatementSuffixAddConstraint
	return p
}

func InitEmptyAlterStatementSuffixAddConstraintContext(p *AlterStatementSuffixAddConstraintContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterStatementSuffixAddConstraint
}

func (*AlterStatementSuffixAddConstraintContext) IsAlterStatementSuffixAddConstraintContext() {}

func NewAlterStatementSuffixAddConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterStatementSuffixAddConstraintContext {
	var p = new(AlterStatementSuffixAddConstraintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_alterStatementSuffixAddConstraint

	return p
}

func (s *AlterStatementSuffixAddConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterStatementSuffixAddConstraintContext) GetFk() IAlterForeignKeyWithNameContext { return s.fk }


func (s *AlterStatementSuffixAddConstraintContext) SetFk(v IAlterForeignKeyWithNameContext) { s.fk = v }


func (s *AlterStatementSuffixAddConstraintContext) KW_ADD() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ADD, 0)
}

func (s *AlterStatementSuffixAddConstraintContext) AlterConstraintWithName() IAlterConstraintWithNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterConstraintWithNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterConstraintWithNameContext)
}

func (s *AlterStatementSuffixAddConstraintContext) AlterForeignKeyWithName() IAlterForeignKeyWithNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterForeignKeyWithNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterForeignKeyWithNameContext)
}

func (s *AlterStatementSuffixAddConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterStatementSuffixAddConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AlterStatementSuffixAddConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterAlterStatementSuffixAddConstraint(s)
	}
}

func (s *AlterStatementSuffixAddConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitAlterStatementSuffixAddConstraint(s)
	}
}

func (s *AlterStatementSuffixAddConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitAlterStatementSuffixAddConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) AlterStatementSuffixAddConstraint() (localctx IAlterStatementSuffixAddConstraintContext) {
	localctx = NewAlterStatementSuffixAddConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 496, HiveParserRULE_alterStatementSuffixAddConstraint)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3196)
		p.Match(HiveParserKW_ADD)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(3199)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 331, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3197)

			var _x = p.AlterForeignKeyWithName()


			localctx.(*AlterStatementSuffixAddConstraintContext).fk = _x
		}


	case 2:
		{
			p.SetState(3198)
			p.AlterConstraintWithName()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlterStatementSuffixUpdateColumnsContext is an interface to support dynamic dispatch.
type IAlterStatementSuffixUpdateColumnsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_UPDATE() antlr.TerminalNode
	KW_COLUMNS() antlr.TerminalNode
	RestrictOrCascade() IRestrictOrCascadeContext

	// IsAlterStatementSuffixUpdateColumnsContext differentiates from other interfaces.
	IsAlterStatementSuffixUpdateColumnsContext()
}

type AlterStatementSuffixUpdateColumnsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterStatementSuffixUpdateColumnsContext() *AlterStatementSuffixUpdateColumnsContext {
	var p = new(AlterStatementSuffixUpdateColumnsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterStatementSuffixUpdateColumns
	return p
}

func InitEmptyAlterStatementSuffixUpdateColumnsContext(p *AlterStatementSuffixUpdateColumnsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterStatementSuffixUpdateColumns
}

func (*AlterStatementSuffixUpdateColumnsContext) IsAlterStatementSuffixUpdateColumnsContext() {}

func NewAlterStatementSuffixUpdateColumnsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterStatementSuffixUpdateColumnsContext {
	var p = new(AlterStatementSuffixUpdateColumnsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_alterStatementSuffixUpdateColumns

	return p
}

func (s *AlterStatementSuffixUpdateColumnsContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterStatementSuffixUpdateColumnsContext) KW_UPDATE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_UPDATE, 0)
}

func (s *AlterStatementSuffixUpdateColumnsContext) KW_COLUMNS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_COLUMNS, 0)
}

func (s *AlterStatementSuffixUpdateColumnsContext) RestrictOrCascade() IRestrictOrCascadeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRestrictOrCascadeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRestrictOrCascadeContext)
}

func (s *AlterStatementSuffixUpdateColumnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterStatementSuffixUpdateColumnsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AlterStatementSuffixUpdateColumnsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterAlterStatementSuffixUpdateColumns(s)
	}
}

func (s *AlterStatementSuffixUpdateColumnsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitAlterStatementSuffixUpdateColumns(s)
	}
}

func (s *AlterStatementSuffixUpdateColumnsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitAlterStatementSuffixUpdateColumns(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) AlterStatementSuffixUpdateColumns() (localctx IAlterStatementSuffixUpdateColumnsContext) {
	localctx = NewAlterStatementSuffixUpdateColumnsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 498, HiveParserRULE_alterStatementSuffixUpdateColumns)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3201)
		p.Match(HiveParserKW_UPDATE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3202)
		p.Match(HiveParserKW_COLUMNS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(3204)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_CASCADE || _la == HiveParserKW_RESTRICT {
		{
			p.SetState(3203)
			p.RestrictOrCascade()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlterStatementSuffixDropConstraintContext is an interface to support dynamic dispatch.
type IAlterStatementSuffixDropConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCName returns the cName rule contexts.
	GetCName() IId_Context


	// SetCName sets the cName rule contexts.
	SetCName(IId_Context)


	// Getter signatures
	KW_DROP() antlr.TerminalNode
	KW_CONSTRAINT() antlr.TerminalNode
	Id_() IId_Context

	// IsAlterStatementSuffixDropConstraintContext differentiates from other interfaces.
	IsAlterStatementSuffixDropConstraintContext()
}

type AlterStatementSuffixDropConstraintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	cName IId_Context 
}

func NewEmptyAlterStatementSuffixDropConstraintContext() *AlterStatementSuffixDropConstraintContext {
	var p = new(AlterStatementSuffixDropConstraintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterStatementSuffixDropConstraint
	return p
}

func InitEmptyAlterStatementSuffixDropConstraintContext(p *AlterStatementSuffixDropConstraintContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterStatementSuffixDropConstraint
}

func (*AlterStatementSuffixDropConstraintContext) IsAlterStatementSuffixDropConstraintContext() {}

func NewAlterStatementSuffixDropConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterStatementSuffixDropConstraintContext {
	var p = new(AlterStatementSuffixDropConstraintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_alterStatementSuffixDropConstraint

	return p
}

func (s *AlterStatementSuffixDropConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterStatementSuffixDropConstraintContext) GetCName() IId_Context { return s.cName }


func (s *AlterStatementSuffixDropConstraintContext) SetCName(v IId_Context) { s.cName = v }


func (s *AlterStatementSuffixDropConstraintContext) KW_DROP() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DROP, 0)
}

func (s *AlterStatementSuffixDropConstraintContext) KW_CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_CONSTRAINT, 0)
}

func (s *AlterStatementSuffixDropConstraintContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *AlterStatementSuffixDropConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterStatementSuffixDropConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AlterStatementSuffixDropConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterAlterStatementSuffixDropConstraint(s)
	}
}

func (s *AlterStatementSuffixDropConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitAlterStatementSuffixDropConstraint(s)
	}
}

func (s *AlterStatementSuffixDropConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitAlterStatementSuffixDropConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) AlterStatementSuffixDropConstraint() (localctx IAlterStatementSuffixDropConstraintContext) {
	localctx = NewAlterStatementSuffixDropConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 500, HiveParserRULE_alterStatementSuffixDropConstraint)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3206)
		p.Match(HiveParserKW_DROP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3207)
		p.Match(HiveParserKW_CONSTRAINT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3208)

		var _x = p.Id_()


		localctx.(*AlterStatementSuffixDropConstraintContext).cName = _x
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlterStatementSuffixRenameColContext is an interface to support dynamic dispatch.
type IAlterStatementSuffixRenameColContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetComment returns the comment token.
	GetComment() antlr.Token 


	// SetComment sets the comment token.
	SetComment(antlr.Token) 


	// GetOldName returns the oldName rule contexts.
	GetOldName() IId_Context

	// GetNewName returns the newName rule contexts.
	GetNewName() IId_Context


	// SetOldName sets the oldName rule contexts.
	SetOldName(IId_Context)

	// SetNewName sets the newName rule contexts.
	SetNewName(IId_Context)


	// Getter signatures
	KW_CHANGE() antlr.TerminalNode
	ColType() IColTypeContext
	AllId_() []IId_Context
	Id_(i int) IId_Context
	KW_COLUMN() antlr.TerminalNode
	AlterColumnConstraint() IAlterColumnConstraintContext
	KW_COMMENT() antlr.TerminalNode
	AlterStatementChangeColPosition() IAlterStatementChangeColPositionContext
	RestrictOrCascade() IRestrictOrCascadeContext
	StringLiteral() antlr.TerminalNode

	// IsAlterStatementSuffixRenameColContext differentiates from other interfaces.
	IsAlterStatementSuffixRenameColContext()
}

type AlterStatementSuffixRenameColContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	oldName IId_Context 
	newName IId_Context 
	comment antlr.Token
}

func NewEmptyAlterStatementSuffixRenameColContext() *AlterStatementSuffixRenameColContext {
	var p = new(AlterStatementSuffixRenameColContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterStatementSuffixRenameCol
	return p
}

func InitEmptyAlterStatementSuffixRenameColContext(p *AlterStatementSuffixRenameColContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterStatementSuffixRenameCol
}

func (*AlterStatementSuffixRenameColContext) IsAlterStatementSuffixRenameColContext() {}

func NewAlterStatementSuffixRenameColContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterStatementSuffixRenameColContext {
	var p = new(AlterStatementSuffixRenameColContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_alterStatementSuffixRenameCol

	return p
}

func (s *AlterStatementSuffixRenameColContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterStatementSuffixRenameColContext) GetComment() antlr.Token { return s.comment }


func (s *AlterStatementSuffixRenameColContext) SetComment(v antlr.Token) { s.comment = v }


func (s *AlterStatementSuffixRenameColContext) GetOldName() IId_Context { return s.oldName }

func (s *AlterStatementSuffixRenameColContext) GetNewName() IId_Context { return s.newName }


func (s *AlterStatementSuffixRenameColContext) SetOldName(v IId_Context) { s.oldName = v }

func (s *AlterStatementSuffixRenameColContext) SetNewName(v IId_Context) { s.newName = v }


func (s *AlterStatementSuffixRenameColContext) KW_CHANGE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_CHANGE, 0)
}

func (s *AlterStatementSuffixRenameColContext) ColType() IColTypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColTypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColTypeContext)
}

func (s *AlterStatementSuffixRenameColContext) AllId_() []IId_Context {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IId_Context); ok {
			len++
		}
	}

	tst := make([]IId_Context, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IId_Context); ok {
			tst[i] = t.(IId_Context)
			i++
		}
	}

	return tst
}

func (s *AlterStatementSuffixRenameColContext) Id_(i int) IId_Context {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *AlterStatementSuffixRenameColContext) KW_COLUMN() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_COLUMN, 0)
}

func (s *AlterStatementSuffixRenameColContext) AlterColumnConstraint() IAlterColumnConstraintContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterColumnConstraintContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterColumnConstraintContext)
}

func (s *AlterStatementSuffixRenameColContext) KW_COMMENT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_COMMENT, 0)
}

func (s *AlterStatementSuffixRenameColContext) AlterStatementChangeColPosition() IAlterStatementChangeColPositionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterStatementChangeColPositionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterStatementChangeColPositionContext)
}

func (s *AlterStatementSuffixRenameColContext) RestrictOrCascade() IRestrictOrCascadeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRestrictOrCascadeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRestrictOrCascadeContext)
}

func (s *AlterStatementSuffixRenameColContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(HiveParserStringLiteral, 0)
}

func (s *AlterStatementSuffixRenameColContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterStatementSuffixRenameColContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AlterStatementSuffixRenameColContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterAlterStatementSuffixRenameCol(s)
	}
}

func (s *AlterStatementSuffixRenameColContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitAlterStatementSuffixRenameCol(s)
	}
}

func (s *AlterStatementSuffixRenameColContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitAlterStatementSuffixRenameCol(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) AlterStatementSuffixRenameCol() (localctx IAlterStatementSuffixRenameColContext) {
	localctx = NewAlterStatementSuffixRenameColContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 502, HiveParserRULE_alterStatementSuffixRenameCol)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3210)
		p.Match(HiveParserKW_CHANGE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(3212)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_COLUMN {
		{
			p.SetState(3211)
			p.Match(HiveParserKW_COLUMN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(3214)

		var _x = p.Id_()


		localctx.(*AlterStatementSuffixRenameColContext).oldName = _x
	}
	{
		p.SetState(3215)

		var _x = p.Id_()


		localctx.(*AlterStatementSuffixRenameColContext).newName = _x
	}
	{
		p.SetState(3216)
		p.ColType()
	}
	p.SetState(3218)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if ((int64((_la - 40)) & ^0x3f) == 0 && ((int64(1) << (_la - 40)) & 1099511660545) != 0) || ((int64((_la - 206)) & ^0x3f) == 0 && ((int64(1) << (_la - 206)) & 9007233614479361) != 0) || _la == HiveParserKW_UNIQUE {
		{
			p.SetState(3217)
			p.AlterColumnConstraint()
		}

	}
	p.SetState(3222)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_COMMENT {
		{
			p.SetState(3220)
			p.Match(HiveParserKW_COMMENT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3221)

			var _m = p.Match(HiveParserStringLiteral)

			localctx.(*AlterStatementSuffixRenameColContext).comment = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	p.SetState(3225)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_AFTER || _la == HiveParserKW_FIRST {
		{
			p.SetState(3224)
			p.AlterStatementChangeColPosition()
		}

	}
	p.SetState(3228)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_CASCADE || _la == HiveParserKW_RESTRICT {
		{
			p.SetState(3227)
			p.RestrictOrCascade()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlterStatementSuffixUpdateStatsColContext is an interface to support dynamic dispatch.
type IAlterStatementSuffixUpdateStatsColContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetComment returns the comment token.
	GetComment() antlr.Token 


	// SetComment sets the comment token.
	SetComment(antlr.Token) 


	// GetColName returns the colName rule contexts.
	GetColName() IId_Context


	// SetColName sets the colName rule contexts.
	SetColName(IId_Context)


	// Getter signatures
	KW_UPDATE() antlr.TerminalNode
	KW_STATISTICS() antlr.TerminalNode
	KW_FOR() antlr.TerminalNode
	KW_SET() antlr.TerminalNode
	TableProperties() ITablePropertiesContext
	Id_() IId_Context
	KW_COLUMN() antlr.TerminalNode
	KW_COMMENT() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode

	// IsAlterStatementSuffixUpdateStatsColContext differentiates from other interfaces.
	IsAlterStatementSuffixUpdateStatsColContext()
}

type AlterStatementSuffixUpdateStatsColContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	colName IId_Context 
	comment antlr.Token
}

func NewEmptyAlterStatementSuffixUpdateStatsColContext() *AlterStatementSuffixUpdateStatsColContext {
	var p = new(AlterStatementSuffixUpdateStatsColContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterStatementSuffixUpdateStatsCol
	return p
}

func InitEmptyAlterStatementSuffixUpdateStatsColContext(p *AlterStatementSuffixUpdateStatsColContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterStatementSuffixUpdateStatsCol
}

func (*AlterStatementSuffixUpdateStatsColContext) IsAlterStatementSuffixUpdateStatsColContext() {}

func NewAlterStatementSuffixUpdateStatsColContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterStatementSuffixUpdateStatsColContext {
	var p = new(AlterStatementSuffixUpdateStatsColContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_alterStatementSuffixUpdateStatsCol

	return p
}

func (s *AlterStatementSuffixUpdateStatsColContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterStatementSuffixUpdateStatsColContext) GetComment() antlr.Token { return s.comment }


func (s *AlterStatementSuffixUpdateStatsColContext) SetComment(v antlr.Token) { s.comment = v }


func (s *AlterStatementSuffixUpdateStatsColContext) GetColName() IId_Context { return s.colName }


func (s *AlterStatementSuffixUpdateStatsColContext) SetColName(v IId_Context) { s.colName = v }


func (s *AlterStatementSuffixUpdateStatsColContext) KW_UPDATE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_UPDATE, 0)
}

func (s *AlterStatementSuffixUpdateStatsColContext) KW_STATISTICS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_STATISTICS, 0)
}

func (s *AlterStatementSuffixUpdateStatsColContext) KW_FOR() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_FOR, 0)
}

func (s *AlterStatementSuffixUpdateStatsColContext) KW_SET() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SET, 0)
}

func (s *AlterStatementSuffixUpdateStatsColContext) TableProperties() ITablePropertiesContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablePropertiesContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablePropertiesContext)
}

func (s *AlterStatementSuffixUpdateStatsColContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *AlterStatementSuffixUpdateStatsColContext) KW_COLUMN() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_COLUMN, 0)
}

func (s *AlterStatementSuffixUpdateStatsColContext) KW_COMMENT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_COMMENT, 0)
}

func (s *AlterStatementSuffixUpdateStatsColContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(HiveParserStringLiteral, 0)
}

func (s *AlterStatementSuffixUpdateStatsColContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterStatementSuffixUpdateStatsColContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AlterStatementSuffixUpdateStatsColContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterAlterStatementSuffixUpdateStatsCol(s)
	}
}

func (s *AlterStatementSuffixUpdateStatsColContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitAlterStatementSuffixUpdateStatsCol(s)
	}
}

func (s *AlterStatementSuffixUpdateStatsColContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitAlterStatementSuffixUpdateStatsCol(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) AlterStatementSuffixUpdateStatsCol() (localctx IAlterStatementSuffixUpdateStatsColContext) {
	localctx = NewAlterStatementSuffixUpdateStatsColContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 504, HiveParserRULE_alterStatementSuffixUpdateStatsCol)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3230)
		p.Match(HiveParserKW_UPDATE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3231)
		p.Match(HiveParserKW_STATISTICS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3232)
		p.Match(HiveParserKW_FOR)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(3234)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_COLUMN {
		{
			p.SetState(3233)
			p.Match(HiveParserKW_COLUMN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(3236)

		var _x = p.Id_()


		localctx.(*AlterStatementSuffixUpdateStatsColContext).colName = _x
	}
	{
		p.SetState(3237)
		p.Match(HiveParserKW_SET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3238)
		p.TableProperties()
	}
	p.SetState(3241)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_COMMENT {
		{
			p.SetState(3239)
			p.Match(HiveParserKW_COMMENT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3240)

			var _m = p.Match(HiveParserStringLiteral)

			localctx.(*AlterStatementSuffixUpdateStatsColContext).comment = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlterStatementSuffixUpdateStatsContext is an interface to support dynamic dispatch.
type IAlterStatementSuffixUpdateStatsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_UPDATE() antlr.TerminalNode
	KW_STATISTICS() antlr.TerminalNode
	KW_SET() antlr.TerminalNode
	TableProperties() ITablePropertiesContext

	// IsAlterStatementSuffixUpdateStatsContext differentiates from other interfaces.
	IsAlterStatementSuffixUpdateStatsContext()
}

type AlterStatementSuffixUpdateStatsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterStatementSuffixUpdateStatsContext() *AlterStatementSuffixUpdateStatsContext {
	var p = new(AlterStatementSuffixUpdateStatsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterStatementSuffixUpdateStats
	return p
}

func InitEmptyAlterStatementSuffixUpdateStatsContext(p *AlterStatementSuffixUpdateStatsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterStatementSuffixUpdateStats
}

func (*AlterStatementSuffixUpdateStatsContext) IsAlterStatementSuffixUpdateStatsContext() {}

func NewAlterStatementSuffixUpdateStatsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterStatementSuffixUpdateStatsContext {
	var p = new(AlterStatementSuffixUpdateStatsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_alterStatementSuffixUpdateStats

	return p
}

func (s *AlterStatementSuffixUpdateStatsContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterStatementSuffixUpdateStatsContext) KW_UPDATE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_UPDATE, 0)
}

func (s *AlterStatementSuffixUpdateStatsContext) KW_STATISTICS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_STATISTICS, 0)
}

func (s *AlterStatementSuffixUpdateStatsContext) KW_SET() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SET, 0)
}

func (s *AlterStatementSuffixUpdateStatsContext) TableProperties() ITablePropertiesContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablePropertiesContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablePropertiesContext)
}

func (s *AlterStatementSuffixUpdateStatsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterStatementSuffixUpdateStatsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AlterStatementSuffixUpdateStatsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterAlterStatementSuffixUpdateStats(s)
	}
}

func (s *AlterStatementSuffixUpdateStatsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitAlterStatementSuffixUpdateStats(s)
	}
}

func (s *AlterStatementSuffixUpdateStatsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitAlterStatementSuffixUpdateStats(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) AlterStatementSuffixUpdateStats() (localctx IAlterStatementSuffixUpdateStatsContext) {
	localctx = NewAlterStatementSuffixUpdateStatsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 506, HiveParserRULE_alterStatementSuffixUpdateStats)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3243)
		p.Match(HiveParserKW_UPDATE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3244)
		p.Match(HiveParserKW_STATISTICS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3245)
		p.Match(HiveParserKW_SET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3246)
		p.TableProperties()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlterStatementChangeColPositionContext is an interface to support dynamic dispatch.
type IAlterStatementChangeColPositionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFirst returns the first token.
	GetFirst() antlr.Token 


	// SetFirst sets the first token.
	SetFirst(antlr.Token) 


	// GetAfterCol returns the afterCol rule contexts.
	GetAfterCol() IId_Context


	// SetAfterCol sets the afterCol rule contexts.
	SetAfterCol(IId_Context)


	// Getter signatures
	KW_FIRST() antlr.TerminalNode
	KW_AFTER() antlr.TerminalNode
	Id_() IId_Context

	// IsAlterStatementChangeColPositionContext differentiates from other interfaces.
	IsAlterStatementChangeColPositionContext()
}

type AlterStatementChangeColPositionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	first antlr.Token
	afterCol IId_Context 
}

func NewEmptyAlterStatementChangeColPositionContext() *AlterStatementChangeColPositionContext {
	var p = new(AlterStatementChangeColPositionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterStatementChangeColPosition
	return p
}

func InitEmptyAlterStatementChangeColPositionContext(p *AlterStatementChangeColPositionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterStatementChangeColPosition
}

func (*AlterStatementChangeColPositionContext) IsAlterStatementChangeColPositionContext() {}

func NewAlterStatementChangeColPositionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterStatementChangeColPositionContext {
	var p = new(AlterStatementChangeColPositionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_alterStatementChangeColPosition

	return p
}

func (s *AlterStatementChangeColPositionContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterStatementChangeColPositionContext) GetFirst() antlr.Token { return s.first }


func (s *AlterStatementChangeColPositionContext) SetFirst(v antlr.Token) { s.first = v }


func (s *AlterStatementChangeColPositionContext) GetAfterCol() IId_Context { return s.afterCol }


func (s *AlterStatementChangeColPositionContext) SetAfterCol(v IId_Context) { s.afterCol = v }


func (s *AlterStatementChangeColPositionContext) KW_FIRST() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_FIRST, 0)
}

func (s *AlterStatementChangeColPositionContext) KW_AFTER() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_AFTER, 0)
}

func (s *AlterStatementChangeColPositionContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *AlterStatementChangeColPositionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterStatementChangeColPositionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AlterStatementChangeColPositionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterAlterStatementChangeColPosition(s)
	}
}

func (s *AlterStatementChangeColPositionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitAlterStatementChangeColPosition(s)
	}
}

func (s *AlterStatementChangeColPositionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitAlterStatementChangeColPosition(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) AlterStatementChangeColPosition() (localctx IAlterStatementChangeColPositionContext) {
	localctx = NewAlterStatementChangeColPositionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 508, HiveParserRULE_alterStatementChangeColPosition)
	p.SetState(3251)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserKW_FIRST:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3248)

			var _m = p.Match(HiveParserKW_FIRST)

			localctx.(*AlterStatementChangeColPositionContext).first = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HiveParserKW_AFTER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3249)
			p.Match(HiveParserKW_AFTER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3250)

			var _x = p.Id_()


			localctx.(*AlterStatementChangeColPositionContext).afterCol = _x
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlterStatementSuffixAddPartitionsContext is an interface to support dynamic dispatch.
type IAlterStatementSuffixAddPartitionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_ADD() antlr.TerminalNode
	IfNotExists() IIfNotExistsContext
	AllAlterStatementSuffixAddPartitionsElement() []IAlterStatementSuffixAddPartitionsElementContext
	AlterStatementSuffixAddPartitionsElement(i int) IAlterStatementSuffixAddPartitionsElementContext

	// IsAlterStatementSuffixAddPartitionsContext differentiates from other interfaces.
	IsAlterStatementSuffixAddPartitionsContext()
}

type AlterStatementSuffixAddPartitionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterStatementSuffixAddPartitionsContext() *AlterStatementSuffixAddPartitionsContext {
	var p = new(AlterStatementSuffixAddPartitionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterStatementSuffixAddPartitions
	return p
}

func InitEmptyAlterStatementSuffixAddPartitionsContext(p *AlterStatementSuffixAddPartitionsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterStatementSuffixAddPartitions
}

func (*AlterStatementSuffixAddPartitionsContext) IsAlterStatementSuffixAddPartitionsContext() {}

func NewAlterStatementSuffixAddPartitionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterStatementSuffixAddPartitionsContext {
	var p = new(AlterStatementSuffixAddPartitionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_alterStatementSuffixAddPartitions

	return p
}

func (s *AlterStatementSuffixAddPartitionsContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterStatementSuffixAddPartitionsContext) KW_ADD() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ADD, 0)
}

func (s *AlterStatementSuffixAddPartitionsContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *AlterStatementSuffixAddPartitionsContext) AllAlterStatementSuffixAddPartitionsElement() []IAlterStatementSuffixAddPartitionsElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAlterStatementSuffixAddPartitionsElementContext); ok {
			len++
		}
	}

	tst := make([]IAlterStatementSuffixAddPartitionsElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAlterStatementSuffixAddPartitionsElementContext); ok {
			tst[i] = t.(IAlterStatementSuffixAddPartitionsElementContext)
			i++
		}
	}

	return tst
}

func (s *AlterStatementSuffixAddPartitionsContext) AlterStatementSuffixAddPartitionsElement(i int) IAlterStatementSuffixAddPartitionsElementContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterStatementSuffixAddPartitionsElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterStatementSuffixAddPartitionsElementContext)
}

func (s *AlterStatementSuffixAddPartitionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterStatementSuffixAddPartitionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AlterStatementSuffixAddPartitionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterAlterStatementSuffixAddPartitions(s)
	}
}

func (s *AlterStatementSuffixAddPartitionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitAlterStatementSuffixAddPartitions(s)
	}
}

func (s *AlterStatementSuffixAddPartitionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitAlterStatementSuffixAddPartitions(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) AlterStatementSuffixAddPartitions() (localctx IAlterStatementSuffixAddPartitionsContext) {
	localctx = NewAlterStatementSuffixAddPartitionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 510, HiveParserRULE_alterStatementSuffixAddPartitions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3253)
		p.Match(HiveParserKW_ADD)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(3255)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_IF {
		{
			p.SetState(3254)
			p.IfNotExists()
		}

	}
	p.SetState(3258)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for ok := true; ok; ok = _la == HiveParserKW_PARTITION {
		{
			p.SetState(3257)
			p.AlterStatementSuffixAddPartitionsElement()
		}


		p.SetState(3260)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlterStatementSuffixAddPartitionsElementContext is an interface to support dynamic dispatch.
type IAlterStatementSuffixAddPartitionsElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PartitionSpec() IPartitionSpecContext
	PartitionLocation() IPartitionLocationContext

	// IsAlterStatementSuffixAddPartitionsElementContext differentiates from other interfaces.
	IsAlterStatementSuffixAddPartitionsElementContext()
}

type AlterStatementSuffixAddPartitionsElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterStatementSuffixAddPartitionsElementContext() *AlterStatementSuffixAddPartitionsElementContext {
	var p = new(AlterStatementSuffixAddPartitionsElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterStatementSuffixAddPartitionsElement
	return p
}

func InitEmptyAlterStatementSuffixAddPartitionsElementContext(p *AlterStatementSuffixAddPartitionsElementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterStatementSuffixAddPartitionsElement
}

func (*AlterStatementSuffixAddPartitionsElementContext) IsAlterStatementSuffixAddPartitionsElementContext() {}

func NewAlterStatementSuffixAddPartitionsElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterStatementSuffixAddPartitionsElementContext {
	var p = new(AlterStatementSuffixAddPartitionsElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_alterStatementSuffixAddPartitionsElement

	return p
}

func (s *AlterStatementSuffixAddPartitionsElementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterStatementSuffixAddPartitionsElementContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *AlterStatementSuffixAddPartitionsElementContext) PartitionLocation() IPartitionLocationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionLocationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionLocationContext)
}

func (s *AlterStatementSuffixAddPartitionsElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterStatementSuffixAddPartitionsElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AlterStatementSuffixAddPartitionsElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterAlterStatementSuffixAddPartitionsElement(s)
	}
}

func (s *AlterStatementSuffixAddPartitionsElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitAlterStatementSuffixAddPartitionsElement(s)
	}
}

func (s *AlterStatementSuffixAddPartitionsElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitAlterStatementSuffixAddPartitionsElement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) AlterStatementSuffixAddPartitionsElement() (localctx IAlterStatementSuffixAddPartitionsElementContext) {
	localctx = NewAlterStatementSuffixAddPartitionsElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 512, HiveParserRULE_alterStatementSuffixAddPartitionsElement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3262)
		p.PartitionSpec()
	}
	p.SetState(3264)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_LOCATION {
		{
			p.SetState(3263)
			p.PartitionLocation()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlterStatementSuffixTouchContext is an interface to support dynamic dispatch.
type IAlterStatementSuffixTouchContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_TOUCH() antlr.TerminalNode
	AllPartitionSpec() []IPartitionSpecContext
	PartitionSpec(i int) IPartitionSpecContext

	// IsAlterStatementSuffixTouchContext differentiates from other interfaces.
	IsAlterStatementSuffixTouchContext()
}

type AlterStatementSuffixTouchContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterStatementSuffixTouchContext() *AlterStatementSuffixTouchContext {
	var p = new(AlterStatementSuffixTouchContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterStatementSuffixTouch
	return p
}

func InitEmptyAlterStatementSuffixTouchContext(p *AlterStatementSuffixTouchContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterStatementSuffixTouch
}

func (*AlterStatementSuffixTouchContext) IsAlterStatementSuffixTouchContext() {}

func NewAlterStatementSuffixTouchContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterStatementSuffixTouchContext {
	var p = new(AlterStatementSuffixTouchContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_alterStatementSuffixTouch

	return p
}

func (s *AlterStatementSuffixTouchContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterStatementSuffixTouchContext) KW_TOUCH() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TOUCH, 0)
}

func (s *AlterStatementSuffixTouchContext) AllPartitionSpec() []IPartitionSpecContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			len++
		}
	}

	tst := make([]IPartitionSpecContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionSpecContext); ok {
			tst[i] = t.(IPartitionSpecContext)
			i++
		}
	}

	return tst
}

func (s *AlterStatementSuffixTouchContext) PartitionSpec(i int) IPartitionSpecContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *AlterStatementSuffixTouchContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterStatementSuffixTouchContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AlterStatementSuffixTouchContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterAlterStatementSuffixTouch(s)
	}
}

func (s *AlterStatementSuffixTouchContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitAlterStatementSuffixTouch(s)
	}
}

func (s *AlterStatementSuffixTouchContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitAlterStatementSuffixTouch(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) AlterStatementSuffixTouch() (localctx IAlterStatementSuffixTouchContext) {
	localctx = NewAlterStatementSuffixTouchContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 514, HiveParserRULE_alterStatementSuffixTouch)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3266)
		p.Match(HiveParserKW_TOUCH)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(3270)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HiveParserKW_PARTITION {
		{
			p.SetState(3267)
			p.PartitionSpec()
		}


		p.SetState(3272)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlterStatementSuffixArchiveContext is an interface to support dynamic dispatch.
type IAlterStatementSuffixArchiveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_ARCHIVE() antlr.TerminalNode
	AllPartitionSpec() []IPartitionSpecContext
	PartitionSpec(i int) IPartitionSpecContext

	// IsAlterStatementSuffixArchiveContext differentiates from other interfaces.
	IsAlterStatementSuffixArchiveContext()
}

type AlterStatementSuffixArchiveContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterStatementSuffixArchiveContext() *AlterStatementSuffixArchiveContext {
	var p = new(AlterStatementSuffixArchiveContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterStatementSuffixArchive
	return p
}

func InitEmptyAlterStatementSuffixArchiveContext(p *AlterStatementSuffixArchiveContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterStatementSuffixArchive
}

func (*AlterStatementSuffixArchiveContext) IsAlterStatementSuffixArchiveContext() {}

func NewAlterStatementSuffixArchiveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterStatementSuffixArchiveContext {
	var p = new(AlterStatementSuffixArchiveContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_alterStatementSuffixArchive

	return p
}

func (s *AlterStatementSuffixArchiveContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterStatementSuffixArchiveContext) KW_ARCHIVE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ARCHIVE, 0)
}

func (s *AlterStatementSuffixArchiveContext) AllPartitionSpec() []IPartitionSpecContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			len++
		}
	}

	tst := make([]IPartitionSpecContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionSpecContext); ok {
			tst[i] = t.(IPartitionSpecContext)
			i++
		}
	}

	return tst
}

func (s *AlterStatementSuffixArchiveContext) PartitionSpec(i int) IPartitionSpecContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *AlterStatementSuffixArchiveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterStatementSuffixArchiveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AlterStatementSuffixArchiveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterAlterStatementSuffixArchive(s)
	}
}

func (s *AlterStatementSuffixArchiveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitAlterStatementSuffixArchive(s)
	}
}

func (s *AlterStatementSuffixArchiveContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitAlterStatementSuffixArchive(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) AlterStatementSuffixArchive() (localctx IAlterStatementSuffixArchiveContext) {
	localctx = NewAlterStatementSuffixArchiveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 516, HiveParserRULE_alterStatementSuffixArchive)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3273)
		p.Match(HiveParserKW_ARCHIVE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(3277)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HiveParserKW_PARTITION {
		{
			p.SetState(3274)
			p.PartitionSpec()
		}


		p.SetState(3279)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlterStatementSuffixUnArchiveContext is an interface to support dynamic dispatch.
type IAlterStatementSuffixUnArchiveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_UNARCHIVE() antlr.TerminalNode
	AllPartitionSpec() []IPartitionSpecContext
	PartitionSpec(i int) IPartitionSpecContext

	// IsAlterStatementSuffixUnArchiveContext differentiates from other interfaces.
	IsAlterStatementSuffixUnArchiveContext()
}

type AlterStatementSuffixUnArchiveContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterStatementSuffixUnArchiveContext() *AlterStatementSuffixUnArchiveContext {
	var p = new(AlterStatementSuffixUnArchiveContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterStatementSuffixUnArchive
	return p
}

func InitEmptyAlterStatementSuffixUnArchiveContext(p *AlterStatementSuffixUnArchiveContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterStatementSuffixUnArchive
}

func (*AlterStatementSuffixUnArchiveContext) IsAlterStatementSuffixUnArchiveContext() {}

func NewAlterStatementSuffixUnArchiveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterStatementSuffixUnArchiveContext {
	var p = new(AlterStatementSuffixUnArchiveContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_alterStatementSuffixUnArchive

	return p
}

func (s *AlterStatementSuffixUnArchiveContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterStatementSuffixUnArchiveContext) KW_UNARCHIVE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_UNARCHIVE, 0)
}

func (s *AlterStatementSuffixUnArchiveContext) AllPartitionSpec() []IPartitionSpecContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			len++
		}
	}

	tst := make([]IPartitionSpecContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionSpecContext); ok {
			tst[i] = t.(IPartitionSpecContext)
			i++
		}
	}

	return tst
}

func (s *AlterStatementSuffixUnArchiveContext) PartitionSpec(i int) IPartitionSpecContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *AlterStatementSuffixUnArchiveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterStatementSuffixUnArchiveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AlterStatementSuffixUnArchiveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterAlterStatementSuffixUnArchive(s)
	}
}

func (s *AlterStatementSuffixUnArchiveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitAlterStatementSuffixUnArchive(s)
	}
}

func (s *AlterStatementSuffixUnArchiveContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitAlterStatementSuffixUnArchive(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) AlterStatementSuffixUnArchive() (localctx IAlterStatementSuffixUnArchiveContext) {
	localctx = NewAlterStatementSuffixUnArchiveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 518, HiveParserRULE_alterStatementSuffixUnArchive)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3280)
		p.Match(HiveParserKW_UNARCHIVE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(3284)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HiveParserKW_PARTITION {
		{
			p.SetState(3281)
			p.PartitionSpec()
		}


		p.SetState(3286)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPartitionLocationContext is an interface to support dynamic dispatch.
type IPartitionLocationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLocn returns the locn token.
	GetLocn() antlr.Token 


	// SetLocn sets the locn token.
	SetLocn(antlr.Token) 


	// Getter signatures
	KW_LOCATION() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode

	// IsPartitionLocationContext differentiates from other interfaces.
	IsPartitionLocationContext()
}

type PartitionLocationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	locn antlr.Token
}

func NewEmptyPartitionLocationContext() *PartitionLocationContext {
	var p = new(PartitionLocationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_partitionLocation
	return p
}

func InitEmptyPartitionLocationContext(p *PartitionLocationContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_partitionLocation
}

func (*PartitionLocationContext) IsPartitionLocationContext() {}

func NewPartitionLocationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionLocationContext {
	var p = new(PartitionLocationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_partitionLocation

	return p
}

func (s *PartitionLocationContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionLocationContext) GetLocn() antlr.Token { return s.locn }


func (s *PartitionLocationContext) SetLocn(v antlr.Token) { s.locn = v }


func (s *PartitionLocationContext) KW_LOCATION() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_LOCATION, 0)
}

func (s *PartitionLocationContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(HiveParserStringLiteral, 0)
}

func (s *PartitionLocationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionLocationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PartitionLocationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterPartitionLocation(s)
	}
}

func (s *PartitionLocationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitPartitionLocation(s)
	}
}

func (s *PartitionLocationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitPartitionLocation(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) PartitionLocation() (localctx IPartitionLocationContext) {
	localctx = NewPartitionLocationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 520, HiveParserRULE_partitionLocation)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3287)
		p.Match(HiveParserKW_LOCATION)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3288)

		var _m = p.Match(HiveParserStringLiteral)

		localctx.(*PartitionLocationContext).locn = _m
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlterStatementSuffixDropPartitionsContext is an interface to support dynamic dispatch.
type IAlterStatementSuffixDropPartitionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_DROP() antlr.TerminalNode
	AllKW_PARTITION() []antlr.TerminalNode
	KW_PARTITION(i int) antlr.TerminalNode
	AllPartitionSelectorSpec() []IPartitionSelectorSpecContext
	PartitionSelectorSpec(i int) IPartitionSelectorSpecContext
	IfExists() IIfExistsContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	KW_PURGE() antlr.TerminalNode
	ReplicationClause() IReplicationClauseContext

	// IsAlterStatementSuffixDropPartitionsContext differentiates from other interfaces.
	IsAlterStatementSuffixDropPartitionsContext()
}

type AlterStatementSuffixDropPartitionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterStatementSuffixDropPartitionsContext() *AlterStatementSuffixDropPartitionsContext {
	var p = new(AlterStatementSuffixDropPartitionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterStatementSuffixDropPartitions
	return p
}

func InitEmptyAlterStatementSuffixDropPartitionsContext(p *AlterStatementSuffixDropPartitionsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterStatementSuffixDropPartitions
}

func (*AlterStatementSuffixDropPartitionsContext) IsAlterStatementSuffixDropPartitionsContext() {}

func NewAlterStatementSuffixDropPartitionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterStatementSuffixDropPartitionsContext {
	var p = new(AlterStatementSuffixDropPartitionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_alterStatementSuffixDropPartitions

	return p
}

func (s *AlterStatementSuffixDropPartitionsContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterStatementSuffixDropPartitionsContext) KW_DROP() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DROP, 0)
}

func (s *AlterStatementSuffixDropPartitionsContext) AllKW_PARTITION() []antlr.TerminalNode {
	return s.GetTokens(HiveParserKW_PARTITION)
}

func (s *AlterStatementSuffixDropPartitionsContext) KW_PARTITION(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserKW_PARTITION, i)
}

func (s *AlterStatementSuffixDropPartitionsContext) AllPartitionSelectorSpec() []IPartitionSelectorSpecContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionSelectorSpecContext); ok {
			len++
		}
	}

	tst := make([]IPartitionSelectorSpecContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionSelectorSpecContext); ok {
			tst[i] = t.(IPartitionSelectorSpecContext)
			i++
		}
	}

	return tst
}

func (s *AlterStatementSuffixDropPartitionsContext) PartitionSelectorSpec(i int) IPartitionSelectorSpecContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSelectorSpecContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSelectorSpecContext)
}

func (s *AlterStatementSuffixDropPartitionsContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *AlterStatementSuffixDropPartitionsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(HiveParserCOMMA)
}

func (s *AlterStatementSuffixDropPartitionsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserCOMMA, i)
}

func (s *AlterStatementSuffixDropPartitionsContext) KW_PURGE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_PURGE, 0)
}

func (s *AlterStatementSuffixDropPartitionsContext) ReplicationClause() IReplicationClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplicationClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplicationClauseContext)
}

func (s *AlterStatementSuffixDropPartitionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterStatementSuffixDropPartitionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AlterStatementSuffixDropPartitionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterAlterStatementSuffixDropPartitions(s)
	}
}

func (s *AlterStatementSuffixDropPartitionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitAlterStatementSuffixDropPartitions(s)
	}
}

func (s *AlterStatementSuffixDropPartitionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitAlterStatementSuffixDropPartitions(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) AlterStatementSuffixDropPartitions() (localctx IAlterStatementSuffixDropPartitionsContext) {
	localctx = NewAlterStatementSuffixDropPartitionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 522, HiveParserRULE_alterStatementSuffixDropPartitions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3290)
		p.Match(HiveParserKW_DROP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(3292)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_IF {
		{
			p.SetState(3291)
			p.IfExists()
		}

	}
	{
		p.SetState(3294)
		p.Match(HiveParserKW_PARTITION)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3295)
		p.PartitionSelectorSpec()
	}
	p.SetState(3301)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HiveParserCOMMA {
		{
			p.SetState(3296)
			p.Match(HiveParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3297)
			p.Match(HiveParserKW_PARTITION)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3298)
			p.PartitionSelectorSpec()
		}


		p.SetState(3303)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(3305)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_PURGE {
		{
			p.SetState(3304)
			p.Match(HiveParserKW_PURGE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	p.SetState(3308)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_FOR {
		{
			p.SetState(3307)
			p.ReplicationClause()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlterStatementSuffixPropertiesContext is an interface to support dynamic dispatch.
type IAlterStatementSuffixPropertiesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_SET() antlr.TerminalNode
	KW_TBLPROPERTIES() antlr.TerminalNode
	TableProperties() ITablePropertiesContext
	KW_UNSET() antlr.TerminalNode
	IfExists() IIfExistsContext

	// IsAlterStatementSuffixPropertiesContext differentiates from other interfaces.
	IsAlterStatementSuffixPropertiesContext()
}

type AlterStatementSuffixPropertiesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterStatementSuffixPropertiesContext() *AlterStatementSuffixPropertiesContext {
	var p = new(AlterStatementSuffixPropertiesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterStatementSuffixProperties
	return p
}

func InitEmptyAlterStatementSuffixPropertiesContext(p *AlterStatementSuffixPropertiesContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterStatementSuffixProperties
}

func (*AlterStatementSuffixPropertiesContext) IsAlterStatementSuffixPropertiesContext() {}

func NewAlterStatementSuffixPropertiesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterStatementSuffixPropertiesContext {
	var p = new(AlterStatementSuffixPropertiesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_alterStatementSuffixProperties

	return p
}

func (s *AlterStatementSuffixPropertiesContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterStatementSuffixPropertiesContext) KW_SET() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SET, 0)
}

func (s *AlterStatementSuffixPropertiesContext) KW_TBLPROPERTIES() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TBLPROPERTIES, 0)
}

func (s *AlterStatementSuffixPropertiesContext) TableProperties() ITablePropertiesContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablePropertiesContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablePropertiesContext)
}

func (s *AlterStatementSuffixPropertiesContext) KW_UNSET() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_UNSET, 0)
}

func (s *AlterStatementSuffixPropertiesContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *AlterStatementSuffixPropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterStatementSuffixPropertiesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AlterStatementSuffixPropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterAlterStatementSuffixProperties(s)
	}
}

func (s *AlterStatementSuffixPropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitAlterStatementSuffixProperties(s)
	}
}

func (s *AlterStatementSuffixPropertiesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitAlterStatementSuffixProperties(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) AlterStatementSuffixProperties() (localctx IAlterStatementSuffixPropertiesContext) {
	localctx = NewAlterStatementSuffixPropertiesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 524, HiveParserRULE_alterStatementSuffixProperties)
	var _la int

	p.SetState(3319)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserKW_SET:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3310)
			p.Match(HiveParserKW_SET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3311)
			p.Match(HiveParserKW_TBLPROPERTIES)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3312)
			p.TableProperties()
		}


	case HiveParserKW_UNSET:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3313)
			p.Match(HiveParserKW_UNSET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3314)
			p.Match(HiveParserKW_TBLPROPERTIES)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(3316)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_IF {
			{
				p.SetState(3315)
				p.IfExists()
			}

		}
		{
			p.SetState(3318)
			p.TableProperties()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlterViewSuffixPropertiesContext is an interface to support dynamic dispatch.
type IAlterViewSuffixPropertiesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_SET() antlr.TerminalNode
	KW_TBLPROPERTIES() antlr.TerminalNode
	TableProperties() ITablePropertiesContext
	KW_UNSET() antlr.TerminalNode
	IfExists() IIfExistsContext

	// IsAlterViewSuffixPropertiesContext differentiates from other interfaces.
	IsAlterViewSuffixPropertiesContext()
}

type AlterViewSuffixPropertiesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterViewSuffixPropertiesContext() *AlterViewSuffixPropertiesContext {
	var p = new(AlterViewSuffixPropertiesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterViewSuffixProperties
	return p
}

func InitEmptyAlterViewSuffixPropertiesContext(p *AlterViewSuffixPropertiesContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterViewSuffixProperties
}

func (*AlterViewSuffixPropertiesContext) IsAlterViewSuffixPropertiesContext() {}

func NewAlterViewSuffixPropertiesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterViewSuffixPropertiesContext {
	var p = new(AlterViewSuffixPropertiesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_alterViewSuffixProperties

	return p
}

func (s *AlterViewSuffixPropertiesContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterViewSuffixPropertiesContext) KW_SET() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SET, 0)
}

func (s *AlterViewSuffixPropertiesContext) KW_TBLPROPERTIES() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TBLPROPERTIES, 0)
}

func (s *AlterViewSuffixPropertiesContext) TableProperties() ITablePropertiesContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablePropertiesContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablePropertiesContext)
}

func (s *AlterViewSuffixPropertiesContext) KW_UNSET() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_UNSET, 0)
}

func (s *AlterViewSuffixPropertiesContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *AlterViewSuffixPropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterViewSuffixPropertiesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AlterViewSuffixPropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterAlterViewSuffixProperties(s)
	}
}

func (s *AlterViewSuffixPropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitAlterViewSuffixProperties(s)
	}
}

func (s *AlterViewSuffixPropertiesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitAlterViewSuffixProperties(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) AlterViewSuffixProperties() (localctx IAlterViewSuffixPropertiesContext) {
	localctx = NewAlterViewSuffixPropertiesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 526, HiveParserRULE_alterViewSuffixProperties)
	var _la int

	p.SetState(3330)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserKW_SET:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3321)
			p.Match(HiveParserKW_SET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3322)
			p.Match(HiveParserKW_TBLPROPERTIES)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3323)
			p.TableProperties()
		}


	case HiveParserKW_UNSET:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3324)
			p.Match(HiveParserKW_UNSET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3325)
			p.Match(HiveParserKW_TBLPROPERTIES)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(3327)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_IF {
			{
				p.SetState(3326)
				p.IfExists()
			}

		}
		{
			p.SetState(3329)
			p.TableProperties()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlterStatementSuffixSerdePropertiesContext is an interface to support dynamic dispatch.
type IAlterStatementSuffixSerdePropertiesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSerdeName returns the serdeName token.
	GetSerdeName() antlr.Token 


	// SetSerdeName sets the serdeName token.
	SetSerdeName(antlr.Token) 


	// Getter signatures
	KW_SET() antlr.TerminalNode
	KW_SERDE() antlr.TerminalNode
	KW_SERDEPROPERTIES() antlr.TerminalNode
	TableProperties() ITablePropertiesContext
	StringLiteral() antlr.TerminalNode
	KW_WITH() antlr.TerminalNode
	KW_UNSET() antlr.TerminalNode

	// IsAlterStatementSuffixSerdePropertiesContext differentiates from other interfaces.
	IsAlterStatementSuffixSerdePropertiesContext()
}

type AlterStatementSuffixSerdePropertiesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	serdeName antlr.Token
}

func NewEmptyAlterStatementSuffixSerdePropertiesContext() *AlterStatementSuffixSerdePropertiesContext {
	var p = new(AlterStatementSuffixSerdePropertiesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterStatementSuffixSerdeProperties
	return p
}

func InitEmptyAlterStatementSuffixSerdePropertiesContext(p *AlterStatementSuffixSerdePropertiesContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterStatementSuffixSerdeProperties
}

func (*AlterStatementSuffixSerdePropertiesContext) IsAlterStatementSuffixSerdePropertiesContext() {}

func NewAlterStatementSuffixSerdePropertiesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterStatementSuffixSerdePropertiesContext {
	var p = new(AlterStatementSuffixSerdePropertiesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_alterStatementSuffixSerdeProperties

	return p
}

func (s *AlterStatementSuffixSerdePropertiesContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterStatementSuffixSerdePropertiesContext) GetSerdeName() antlr.Token { return s.serdeName }


func (s *AlterStatementSuffixSerdePropertiesContext) SetSerdeName(v antlr.Token) { s.serdeName = v }


func (s *AlterStatementSuffixSerdePropertiesContext) KW_SET() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SET, 0)
}

func (s *AlterStatementSuffixSerdePropertiesContext) KW_SERDE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SERDE, 0)
}

func (s *AlterStatementSuffixSerdePropertiesContext) KW_SERDEPROPERTIES() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SERDEPROPERTIES, 0)
}

func (s *AlterStatementSuffixSerdePropertiesContext) TableProperties() ITablePropertiesContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablePropertiesContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablePropertiesContext)
}

func (s *AlterStatementSuffixSerdePropertiesContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(HiveParserStringLiteral, 0)
}

func (s *AlterStatementSuffixSerdePropertiesContext) KW_WITH() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_WITH, 0)
}

func (s *AlterStatementSuffixSerdePropertiesContext) KW_UNSET() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_UNSET, 0)
}

func (s *AlterStatementSuffixSerdePropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterStatementSuffixSerdePropertiesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AlterStatementSuffixSerdePropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterAlterStatementSuffixSerdeProperties(s)
	}
}

func (s *AlterStatementSuffixSerdePropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitAlterStatementSuffixSerdeProperties(s)
	}
}

func (s *AlterStatementSuffixSerdePropertiesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitAlterStatementSuffixSerdeProperties(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) AlterStatementSuffixSerdeProperties() (localctx IAlterStatementSuffixSerdePropertiesContext) {
	localctx = NewAlterStatementSuffixSerdePropertiesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 528, HiveParserRULE_alterStatementSuffixSerdeProperties)
	var _la int

	p.SetState(3347)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserKW_SET:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3332)
			p.Match(HiveParserKW_SET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(3342)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case HiveParserKW_SERDE:
			{
				p.SetState(3333)
				p.Match(HiveParserKW_SERDE)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(3334)

				var _m = p.Match(HiveParserStringLiteral)

				localctx.(*AlterStatementSuffixSerdePropertiesContext).serdeName = _m
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			p.SetState(3338)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == HiveParserKW_WITH {
				{
					p.SetState(3335)
					p.Match(HiveParserKW_WITH)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(3336)
					p.Match(HiveParserKW_SERDEPROPERTIES)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(3337)
					p.TableProperties()
				}

			}


		case HiveParserKW_SERDEPROPERTIES:
			{
				p.SetState(3340)
				p.Match(HiveParserKW_SERDEPROPERTIES)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(3341)
				p.TableProperties()
			}



		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}


	case HiveParserKW_UNSET:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3344)
			p.Match(HiveParserKW_UNSET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3345)
			p.Match(HiveParserKW_SERDEPROPERTIES)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3346)
			p.TableProperties()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITablePartitionPrefixContext is an interface to support dynamic dispatch.
type ITablePartitionPrefixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TableName() ITableNameContext
	PartitionSpec() IPartitionSpecContext

	// IsTablePartitionPrefixContext differentiates from other interfaces.
	IsTablePartitionPrefixContext()
}

type TablePartitionPrefixContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTablePartitionPrefixContext() *TablePartitionPrefixContext {
	var p = new(TablePartitionPrefixContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_tablePartitionPrefix
	return p
}

func InitEmptyTablePartitionPrefixContext(p *TablePartitionPrefixContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_tablePartitionPrefix
}

func (*TablePartitionPrefixContext) IsTablePartitionPrefixContext() {}

func NewTablePartitionPrefixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TablePartitionPrefixContext {
	var p = new(TablePartitionPrefixContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_tablePartitionPrefix

	return p
}

func (s *TablePartitionPrefixContext) GetParser() antlr.Parser { return s.parser }

func (s *TablePartitionPrefixContext) TableName() ITableNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *TablePartitionPrefixContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *TablePartitionPrefixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TablePartitionPrefixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TablePartitionPrefixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterTablePartitionPrefix(s)
	}
}

func (s *TablePartitionPrefixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitTablePartitionPrefix(s)
	}
}

func (s *TablePartitionPrefixContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitTablePartitionPrefix(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) TablePartitionPrefix() (localctx ITablePartitionPrefixContext) {
	localctx = NewTablePartitionPrefixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 530, HiveParserRULE_tablePartitionPrefix)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3349)
		p.TableName()
	}
	p.SetState(3351)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_PARTITION {
		{
			p.SetState(3350)
			p.PartitionSpec()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlterStatementSuffixFileFormatContext is an interface to support dynamic dispatch.
type IAlterStatementSuffixFileFormatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_SET() antlr.TerminalNode
	KW_FILEFORMAT() antlr.TerminalNode
	FileFormat() IFileFormatContext

	// IsAlterStatementSuffixFileFormatContext differentiates from other interfaces.
	IsAlterStatementSuffixFileFormatContext()
}

type AlterStatementSuffixFileFormatContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterStatementSuffixFileFormatContext() *AlterStatementSuffixFileFormatContext {
	var p = new(AlterStatementSuffixFileFormatContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterStatementSuffixFileFormat
	return p
}

func InitEmptyAlterStatementSuffixFileFormatContext(p *AlterStatementSuffixFileFormatContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterStatementSuffixFileFormat
}

func (*AlterStatementSuffixFileFormatContext) IsAlterStatementSuffixFileFormatContext() {}

func NewAlterStatementSuffixFileFormatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterStatementSuffixFileFormatContext {
	var p = new(AlterStatementSuffixFileFormatContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_alterStatementSuffixFileFormat

	return p
}

func (s *AlterStatementSuffixFileFormatContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterStatementSuffixFileFormatContext) KW_SET() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SET, 0)
}

func (s *AlterStatementSuffixFileFormatContext) KW_FILEFORMAT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_FILEFORMAT, 0)
}

func (s *AlterStatementSuffixFileFormatContext) FileFormat() IFileFormatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileFormatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileFormatContext)
}

func (s *AlterStatementSuffixFileFormatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterStatementSuffixFileFormatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AlterStatementSuffixFileFormatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterAlterStatementSuffixFileFormat(s)
	}
}

func (s *AlterStatementSuffixFileFormatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitAlterStatementSuffixFileFormat(s)
	}
}

func (s *AlterStatementSuffixFileFormatContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitAlterStatementSuffixFileFormat(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) AlterStatementSuffixFileFormat() (localctx IAlterStatementSuffixFileFormatContext) {
	localctx = NewAlterStatementSuffixFileFormatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 532, HiveParserRULE_alterStatementSuffixFileFormat)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3353)
		p.Match(HiveParserKW_SET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3354)
		p.Match(HiveParserKW_FILEFORMAT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3355)
		p.FileFormat()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlterStatementSuffixClusterbySortbyContext is an interface to support dynamic dispatch.
type IAlterStatementSuffixClusterbySortbyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_NOT() antlr.TerminalNode
	KW_CLUSTERED() antlr.TerminalNode
	KW_SORTED() antlr.TerminalNode
	TableBuckets() ITableBucketsContext

	// IsAlterStatementSuffixClusterbySortbyContext differentiates from other interfaces.
	IsAlterStatementSuffixClusterbySortbyContext()
}

type AlterStatementSuffixClusterbySortbyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterStatementSuffixClusterbySortbyContext() *AlterStatementSuffixClusterbySortbyContext {
	var p = new(AlterStatementSuffixClusterbySortbyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterStatementSuffixClusterbySortby
	return p
}

func InitEmptyAlterStatementSuffixClusterbySortbyContext(p *AlterStatementSuffixClusterbySortbyContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterStatementSuffixClusterbySortby
}

func (*AlterStatementSuffixClusterbySortbyContext) IsAlterStatementSuffixClusterbySortbyContext() {}

func NewAlterStatementSuffixClusterbySortbyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterStatementSuffixClusterbySortbyContext {
	var p = new(AlterStatementSuffixClusterbySortbyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_alterStatementSuffixClusterbySortby

	return p
}

func (s *AlterStatementSuffixClusterbySortbyContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterStatementSuffixClusterbySortbyContext) KW_NOT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_NOT, 0)
}

func (s *AlterStatementSuffixClusterbySortbyContext) KW_CLUSTERED() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_CLUSTERED, 0)
}

func (s *AlterStatementSuffixClusterbySortbyContext) KW_SORTED() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SORTED, 0)
}

func (s *AlterStatementSuffixClusterbySortbyContext) TableBuckets() ITableBucketsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableBucketsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableBucketsContext)
}

func (s *AlterStatementSuffixClusterbySortbyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterStatementSuffixClusterbySortbyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AlterStatementSuffixClusterbySortbyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterAlterStatementSuffixClusterbySortby(s)
	}
}

func (s *AlterStatementSuffixClusterbySortbyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitAlterStatementSuffixClusterbySortby(s)
	}
}

func (s *AlterStatementSuffixClusterbySortbyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitAlterStatementSuffixClusterbySortby(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) AlterStatementSuffixClusterbySortby() (localctx IAlterStatementSuffixClusterbySortbyContext) {
	localctx = NewAlterStatementSuffixClusterbySortbyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 534, HiveParserRULE_alterStatementSuffixClusterbySortby)
	var _la int

	p.SetState(3360)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserKW_NOT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3357)
			p.Match(HiveParserKW_NOT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3358)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HiveParserKW_CLUSTERED || _la == HiveParserKW_SORTED) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}


	case HiveParserKW_CLUSTERED:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3359)
			p.TableBuckets()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlterTblPartitionStatementSuffixSkewedLocationContext is an interface to support dynamic dispatch.
type IAlterTblPartitionStatementSuffixSkewedLocationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_SET() antlr.TerminalNode
	KW_SKEWED() antlr.TerminalNode
	KW_LOCATION() antlr.TerminalNode
	SkewedLocations() ISkewedLocationsContext

	// IsAlterTblPartitionStatementSuffixSkewedLocationContext differentiates from other interfaces.
	IsAlterTblPartitionStatementSuffixSkewedLocationContext()
}

type AlterTblPartitionStatementSuffixSkewedLocationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterTblPartitionStatementSuffixSkewedLocationContext() *AlterTblPartitionStatementSuffixSkewedLocationContext {
	var p = new(AlterTblPartitionStatementSuffixSkewedLocationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterTblPartitionStatementSuffixSkewedLocation
	return p
}

func InitEmptyAlterTblPartitionStatementSuffixSkewedLocationContext(p *AlterTblPartitionStatementSuffixSkewedLocationContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterTblPartitionStatementSuffixSkewedLocation
}

func (*AlterTblPartitionStatementSuffixSkewedLocationContext) IsAlterTblPartitionStatementSuffixSkewedLocationContext() {}

func NewAlterTblPartitionStatementSuffixSkewedLocationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterTblPartitionStatementSuffixSkewedLocationContext {
	var p = new(AlterTblPartitionStatementSuffixSkewedLocationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_alterTblPartitionStatementSuffixSkewedLocation

	return p
}

func (s *AlterTblPartitionStatementSuffixSkewedLocationContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterTblPartitionStatementSuffixSkewedLocationContext) KW_SET() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SET, 0)
}

func (s *AlterTblPartitionStatementSuffixSkewedLocationContext) KW_SKEWED() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SKEWED, 0)
}

func (s *AlterTblPartitionStatementSuffixSkewedLocationContext) KW_LOCATION() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_LOCATION, 0)
}

func (s *AlterTblPartitionStatementSuffixSkewedLocationContext) SkewedLocations() ISkewedLocationsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISkewedLocationsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISkewedLocationsContext)
}

func (s *AlterTblPartitionStatementSuffixSkewedLocationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTblPartitionStatementSuffixSkewedLocationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AlterTblPartitionStatementSuffixSkewedLocationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterAlterTblPartitionStatementSuffixSkewedLocation(s)
	}
}

func (s *AlterTblPartitionStatementSuffixSkewedLocationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitAlterTblPartitionStatementSuffixSkewedLocation(s)
	}
}

func (s *AlterTblPartitionStatementSuffixSkewedLocationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitAlterTblPartitionStatementSuffixSkewedLocation(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) AlterTblPartitionStatementSuffixSkewedLocation() (localctx IAlterTblPartitionStatementSuffixSkewedLocationContext) {
	localctx = NewAlterTblPartitionStatementSuffixSkewedLocationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 536, HiveParserRULE_alterTblPartitionStatementSuffixSkewedLocation)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3362)
		p.Match(HiveParserKW_SET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3363)
		p.Match(HiveParserKW_SKEWED)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3364)
		p.Match(HiveParserKW_LOCATION)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3365)
		p.SkewedLocations()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISkewedLocationsContext is an interface to support dynamic dispatch.
type ISkewedLocationsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	SkewedLocationsList() ISkewedLocationsListContext
	RPAREN() antlr.TerminalNode

	// IsSkewedLocationsContext differentiates from other interfaces.
	IsSkewedLocationsContext()
}

type SkewedLocationsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySkewedLocationsContext() *SkewedLocationsContext {
	var p = new(SkewedLocationsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_skewedLocations
	return p
}

func InitEmptySkewedLocationsContext(p *SkewedLocationsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_skewedLocations
}

func (*SkewedLocationsContext) IsSkewedLocationsContext() {}

func NewSkewedLocationsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SkewedLocationsContext {
	var p = new(SkewedLocationsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_skewedLocations

	return p
}

func (s *SkewedLocationsContext) GetParser() antlr.Parser { return s.parser }

func (s *SkewedLocationsContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserLPAREN, 0)
}

func (s *SkewedLocationsContext) SkewedLocationsList() ISkewedLocationsListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISkewedLocationsListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISkewedLocationsListContext)
}

func (s *SkewedLocationsContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserRPAREN, 0)
}

func (s *SkewedLocationsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SkewedLocationsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SkewedLocationsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterSkewedLocations(s)
	}
}

func (s *SkewedLocationsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitSkewedLocations(s)
	}
}

func (s *SkewedLocationsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitSkewedLocations(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) SkewedLocations() (localctx ISkewedLocationsContext) {
	localctx = NewSkewedLocationsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 538, HiveParserRULE_skewedLocations)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3367)
		p.Match(HiveParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3368)
		p.SkewedLocationsList()
	}
	{
		p.SetState(3369)
		p.Match(HiveParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISkewedLocationsListContext is an interface to support dynamic dispatch.
type ISkewedLocationsListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSkewedLocationMap() []ISkewedLocationMapContext
	SkewedLocationMap(i int) ISkewedLocationMapContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsSkewedLocationsListContext differentiates from other interfaces.
	IsSkewedLocationsListContext()
}

type SkewedLocationsListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySkewedLocationsListContext() *SkewedLocationsListContext {
	var p = new(SkewedLocationsListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_skewedLocationsList
	return p
}

func InitEmptySkewedLocationsListContext(p *SkewedLocationsListContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_skewedLocationsList
}

func (*SkewedLocationsListContext) IsSkewedLocationsListContext() {}

func NewSkewedLocationsListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SkewedLocationsListContext {
	var p = new(SkewedLocationsListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_skewedLocationsList

	return p
}

func (s *SkewedLocationsListContext) GetParser() antlr.Parser { return s.parser }

func (s *SkewedLocationsListContext) AllSkewedLocationMap() []ISkewedLocationMapContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISkewedLocationMapContext); ok {
			len++
		}
	}

	tst := make([]ISkewedLocationMapContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISkewedLocationMapContext); ok {
			tst[i] = t.(ISkewedLocationMapContext)
			i++
		}
	}

	return tst
}

func (s *SkewedLocationsListContext) SkewedLocationMap(i int) ISkewedLocationMapContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISkewedLocationMapContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISkewedLocationMapContext)
}

func (s *SkewedLocationsListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(HiveParserCOMMA)
}

func (s *SkewedLocationsListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserCOMMA, i)
}

func (s *SkewedLocationsListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SkewedLocationsListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SkewedLocationsListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterSkewedLocationsList(s)
	}
}

func (s *SkewedLocationsListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitSkewedLocationsList(s)
	}
}

func (s *SkewedLocationsListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitSkewedLocationsList(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) SkewedLocationsList() (localctx ISkewedLocationsListContext) {
	localctx = NewSkewedLocationsListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 540, HiveParserRULE_skewedLocationsList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3371)
		p.SkewedLocationMap()
	}
	p.SetState(3376)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HiveParserCOMMA {
		{
			p.SetState(3372)
			p.Match(HiveParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3373)
			p.SkewedLocationMap()
		}


		p.SetState(3378)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISkewedLocationMapContext is an interface to support dynamic dispatch.
type ISkewedLocationMapContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetValue returns the value token.
	GetValue() antlr.Token 


	// SetValue sets the value token.
	SetValue(antlr.Token) 


	// GetKey returns the key rule contexts.
	GetKey() ISkewedValueLocationElementContext


	// SetKey sets the key rule contexts.
	SetKey(ISkewedValueLocationElementContext)


	// Getter signatures
	EQUAL() antlr.TerminalNode
	SkewedValueLocationElement() ISkewedValueLocationElementContext
	StringLiteral() antlr.TerminalNode

	// IsSkewedLocationMapContext differentiates from other interfaces.
	IsSkewedLocationMapContext()
}

type SkewedLocationMapContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	key ISkewedValueLocationElementContext 
	value antlr.Token
}

func NewEmptySkewedLocationMapContext() *SkewedLocationMapContext {
	var p = new(SkewedLocationMapContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_skewedLocationMap
	return p
}

func InitEmptySkewedLocationMapContext(p *SkewedLocationMapContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_skewedLocationMap
}

func (*SkewedLocationMapContext) IsSkewedLocationMapContext() {}

func NewSkewedLocationMapContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SkewedLocationMapContext {
	var p = new(SkewedLocationMapContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_skewedLocationMap

	return p
}

func (s *SkewedLocationMapContext) GetParser() antlr.Parser { return s.parser }

func (s *SkewedLocationMapContext) GetValue() antlr.Token { return s.value }


func (s *SkewedLocationMapContext) SetValue(v antlr.Token) { s.value = v }


func (s *SkewedLocationMapContext) GetKey() ISkewedValueLocationElementContext { return s.key }


func (s *SkewedLocationMapContext) SetKey(v ISkewedValueLocationElementContext) { s.key = v }


func (s *SkewedLocationMapContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(HiveParserEQUAL, 0)
}

func (s *SkewedLocationMapContext) SkewedValueLocationElement() ISkewedValueLocationElementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISkewedValueLocationElementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISkewedValueLocationElementContext)
}

func (s *SkewedLocationMapContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(HiveParserStringLiteral, 0)
}

func (s *SkewedLocationMapContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SkewedLocationMapContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SkewedLocationMapContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterSkewedLocationMap(s)
	}
}

func (s *SkewedLocationMapContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitSkewedLocationMap(s)
	}
}

func (s *SkewedLocationMapContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitSkewedLocationMap(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) SkewedLocationMap() (localctx ISkewedLocationMapContext) {
	localctx = NewSkewedLocationMapContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 542, HiveParserRULE_skewedLocationMap)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3379)

		var _x = p.SkewedValueLocationElement()


		localctx.(*SkewedLocationMapContext).key = _x
	}
	{
		p.SetState(3380)
		p.Match(HiveParserEQUAL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3381)

		var _m = p.Match(HiveParserStringLiteral)

		localctx.(*SkewedLocationMapContext).value = _m
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlterStatementSuffixLocationContext is an interface to support dynamic dispatch.
type IAlterStatementSuffixLocationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetNewLoc returns the newLoc token.
	GetNewLoc() antlr.Token 


	// SetNewLoc sets the newLoc token.
	SetNewLoc(antlr.Token) 


	// Getter signatures
	KW_SET() antlr.TerminalNode
	KW_LOCATION() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode

	// IsAlterStatementSuffixLocationContext differentiates from other interfaces.
	IsAlterStatementSuffixLocationContext()
}

type AlterStatementSuffixLocationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	newLoc antlr.Token
}

func NewEmptyAlterStatementSuffixLocationContext() *AlterStatementSuffixLocationContext {
	var p = new(AlterStatementSuffixLocationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterStatementSuffixLocation
	return p
}

func InitEmptyAlterStatementSuffixLocationContext(p *AlterStatementSuffixLocationContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterStatementSuffixLocation
}

func (*AlterStatementSuffixLocationContext) IsAlterStatementSuffixLocationContext() {}

func NewAlterStatementSuffixLocationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterStatementSuffixLocationContext {
	var p = new(AlterStatementSuffixLocationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_alterStatementSuffixLocation

	return p
}

func (s *AlterStatementSuffixLocationContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterStatementSuffixLocationContext) GetNewLoc() antlr.Token { return s.newLoc }


func (s *AlterStatementSuffixLocationContext) SetNewLoc(v antlr.Token) { s.newLoc = v }


func (s *AlterStatementSuffixLocationContext) KW_SET() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SET, 0)
}

func (s *AlterStatementSuffixLocationContext) KW_LOCATION() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_LOCATION, 0)
}

func (s *AlterStatementSuffixLocationContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(HiveParserStringLiteral, 0)
}

func (s *AlterStatementSuffixLocationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterStatementSuffixLocationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AlterStatementSuffixLocationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterAlterStatementSuffixLocation(s)
	}
}

func (s *AlterStatementSuffixLocationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitAlterStatementSuffixLocation(s)
	}
}

func (s *AlterStatementSuffixLocationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitAlterStatementSuffixLocation(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) AlterStatementSuffixLocation() (localctx IAlterStatementSuffixLocationContext) {
	localctx = NewAlterStatementSuffixLocationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 544, HiveParserRULE_alterStatementSuffixLocation)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3383)
		p.Match(HiveParserKW_SET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3384)
		p.Match(HiveParserKW_LOCATION)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3385)

		var _m = p.Match(HiveParserStringLiteral)

		localctx.(*AlterStatementSuffixLocationContext).newLoc = _m
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlterStatementSuffixSkewedbyContext is an interface to support dynamic dispatch.
type IAlterStatementSuffixSkewedbyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TableSkewed() ITableSkewedContext
	KW_NOT() antlr.TerminalNode
	KW_SKEWED() antlr.TerminalNode
	StoredAsDirs() IStoredAsDirsContext

	// IsAlterStatementSuffixSkewedbyContext differentiates from other interfaces.
	IsAlterStatementSuffixSkewedbyContext()
}

type AlterStatementSuffixSkewedbyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterStatementSuffixSkewedbyContext() *AlterStatementSuffixSkewedbyContext {
	var p = new(AlterStatementSuffixSkewedbyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterStatementSuffixSkewedby
	return p
}

func InitEmptyAlterStatementSuffixSkewedbyContext(p *AlterStatementSuffixSkewedbyContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterStatementSuffixSkewedby
}

func (*AlterStatementSuffixSkewedbyContext) IsAlterStatementSuffixSkewedbyContext() {}

func NewAlterStatementSuffixSkewedbyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterStatementSuffixSkewedbyContext {
	var p = new(AlterStatementSuffixSkewedbyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_alterStatementSuffixSkewedby

	return p
}

func (s *AlterStatementSuffixSkewedbyContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterStatementSuffixSkewedbyContext) TableSkewed() ITableSkewedContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableSkewedContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableSkewedContext)
}

func (s *AlterStatementSuffixSkewedbyContext) KW_NOT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_NOT, 0)
}

func (s *AlterStatementSuffixSkewedbyContext) KW_SKEWED() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SKEWED, 0)
}

func (s *AlterStatementSuffixSkewedbyContext) StoredAsDirs() IStoredAsDirsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStoredAsDirsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStoredAsDirsContext)
}

func (s *AlterStatementSuffixSkewedbyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterStatementSuffixSkewedbyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AlterStatementSuffixSkewedbyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterAlterStatementSuffixSkewedby(s)
	}
}

func (s *AlterStatementSuffixSkewedbyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitAlterStatementSuffixSkewedby(s)
	}
}

func (s *AlterStatementSuffixSkewedbyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitAlterStatementSuffixSkewedby(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) AlterStatementSuffixSkewedby() (localctx IAlterStatementSuffixSkewedbyContext) {
	localctx = NewAlterStatementSuffixSkewedbyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 546, HiveParserRULE_alterStatementSuffixSkewedby)
	p.SetState(3393)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserKW_SKEWED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3387)
			p.TableSkewed()
		}


	case HiveParserKW_NOT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3388)
			p.Match(HiveParserKW_NOT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(3391)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case HiveParserKW_SKEWED:
			{
				p.SetState(3389)
				p.Match(HiveParserKW_SKEWED)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


		case HiveParserKW_STORED:
			{
				p.SetState(3390)
				p.StoredAsDirs()
			}



		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlterStatementSuffixExchangePartitionContext is an interface to support dynamic dispatch.
type IAlterStatementSuffixExchangePartitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetExchangename returns the exchangename rule contexts.
	GetExchangename() ITableNameContext


	// SetExchangename sets the exchangename rule contexts.
	SetExchangename(ITableNameContext)


	// Getter signatures
	KW_EXCHANGE() antlr.TerminalNode
	PartitionSpec() IPartitionSpecContext
	KW_WITH() antlr.TerminalNode
	KW_TABLE() antlr.TerminalNode
	TableName() ITableNameContext

	// IsAlterStatementSuffixExchangePartitionContext differentiates from other interfaces.
	IsAlterStatementSuffixExchangePartitionContext()
}

type AlterStatementSuffixExchangePartitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	exchangename ITableNameContext 
}

func NewEmptyAlterStatementSuffixExchangePartitionContext() *AlterStatementSuffixExchangePartitionContext {
	var p = new(AlterStatementSuffixExchangePartitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterStatementSuffixExchangePartition
	return p
}

func InitEmptyAlterStatementSuffixExchangePartitionContext(p *AlterStatementSuffixExchangePartitionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterStatementSuffixExchangePartition
}

func (*AlterStatementSuffixExchangePartitionContext) IsAlterStatementSuffixExchangePartitionContext() {}

func NewAlterStatementSuffixExchangePartitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterStatementSuffixExchangePartitionContext {
	var p = new(AlterStatementSuffixExchangePartitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_alterStatementSuffixExchangePartition

	return p
}

func (s *AlterStatementSuffixExchangePartitionContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterStatementSuffixExchangePartitionContext) GetExchangename() ITableNameContext { return s.exchangename }


func (s *AlterStatementSuffixExchangePartitionContext) SetExchangename(v ITableNameContext) { s.exchangename = v }


func (s *AlterStatementSuffixExchangePartitionContext) KW_EXCHANGE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_EXCHANGE, 0)
}

func (s *AlterStatementSuffixExchangePartitionContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *AlterStatementSuffixExchangePartitionContext) KW_WITH() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_WITH, 0)
}

func (s *AlterStatementSuffixExchangePartitionContext) KW_TABLE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TABLE, 0)
}

func (s *AlterStatementSuffixExchangePartitionContext) TableName() ITableNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *AlterStatementSuffixExchangePartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterStatementSuffixExchangePartitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AlterStatementSuffixExchangePartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterAlterStatementSuffixExchangePartition(s)
	}
}

func (s *AlterStatementSuffixExchangePartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitAlterStatementSuffixExchangePartition(s)
	}
}

func (s *AlterStatementSuffixExchangePartitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitAlterStatementSuffixExchangePartition(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) AlterStatementSuffixExchangePartition() (localctx IAlterStatementSuffixExchangePartitionContext) {
	localctx = NewAlterStatementSuffixExchangePartitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 548, HiveParserRULE_alterStatementSuffixExchangePartition)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3395)
		p.Match(HiveParserKW_EXCHANGE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3396)
		p.PartitionSpec()
	}
	{
		p.SetState(3397)
		p.Match(HiveParserKW_WITH)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3398)
		p.Match(HiveParserKW_TABLE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3399)

		var _x = p.TableName()


		localctx.(*AlterStatementSuffixExchangePartitionContext).exchangename = _x
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlterStatementSuffixRenamePartContext is an interface to support dynamic dispatch.
type IAlterStatementSuffixRenamePartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_RENAME() antlr.TerminalNode
	KW_TO() antlr.TerminalNode
	PartitionSpec() IPartitionSpecContext

	// IsAlterStatementSuffixRenamePartContext differentiates from other interfaces.
	IsAlterStatementSuffixRenamePartContext()
}

type AlterStatementSuffixRenamePartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterStatementSuffixRenamePartContext() *AlterStatementSuffixRenamePartContext {
	var p = new(AlterStatementSuffixRenamePartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterStatementSuffixRenamePart
	return p
}

func InitEmptyAlterStatementSuffixRenamePartContext(p *AlterStatementSuffixRenamePartContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterStatementSuffixRenamePart
}

func (*AlterStatementSuffixRenamePartContext) IsAlterStatementSuffixRenamePartContext() {}

func NewAlterStatementSuffixRenamePartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterStatementSuffixRenamePartContext {
	var p = new(AlterStatementSuffixRenamePartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_alterStatementSuffixRenamePart

	return p
}

func (s *AlterStatementSuffixRenamePartContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterStatementSuffixRenamePartContext) KW_RENAME() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_RENAME, 0)
}

func (s *AlterStatementSuffixRenamePartContext) KW_TO() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TO, 0)
}

func (s *AlterStatementSuffixRenamePartContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *AlterStatementSuffixRenamePartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterStatementSuffixRenamePartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AlterStatementSuffixRenamePartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterAlterStatementSuffixRenamePart(s)
	}
}

func (s *AlterStatementSuffixRenamePartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitAlterStatementSuffixRenamePart(s)
	}
}

func (s *AlterStatementSuffixRenamePartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitAlterStatementSuffixRenamePart(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) AlterStatementSuffixRenamePart() (localctx IAlterStatementSuffixRenamePartContext) {
	localctx = NewAlterStatementSuffixRenamePartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 550, HiveParserRULE_alterStatementSuffixRenamePart)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3401)
		p.Match(HiveParserKW_RENAME)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3402)
		p.Match(HiveParserKW_TO)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3403)
		p.PartitionSpec()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlterStatementSuffixStatsPartContext is an interface to support dynamic dispatch.
type IAlterStatementSuffixStatsPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetComment returns the comment token.
	GetComment() antlr.Token 


	// SetComment sets the comment token.
	SetComment(antlr.Token) 


	// GetColName returns the colName rule contexts.
	GetColName() IId_Context


	// SetColName sets the colName rule contexts.
	SetColName(IId_Context)


	// Getter signatures
	KW_UPDATE() antlr.TerminalNode
	KW_STATISTICS() antlr.TerminalNode
	KW_FOR() antlr.TerminalNode
	KW_SET() antlr.TerminalNode
	TableProperties() ITablePropertiesContext
	Id_() IId_Context
	KW_COLUMN() antlr.TerminalNode
	KW_COMMENT() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode

	// IsAlterStatementSuffixStatsPartContext differentiates from other interfaces.
	IsAlterStatementSuffixStatsPartContext()
}

type AlterStatementSuffixStatsPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	colName IId_Context 
	comment antlr.Token
}

func NewEmptyAlterStatementSuffixStatsPartContext() *AlterStatementSuffixStatsPartContext {
	var p = new(AlterStatementSuffixStatsPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterStatementSuffixStatsPart
	return p
}

func InitEmptyAlterStatementSuffixStatsPartContext(p *AlterStatementSuffixStatsPartContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterStatementSuffixStatsPart
}

func (*AlterStatementSuffixStatsPartContext) IsAlterStatementSuffixStatsPartContext() {}

func NewAlterStatementSuffixStatsPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterStatementSuffixStatsPartContext {
	var p = new(AlterStatementSuffixStatsPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_alterStatementSuffixStatsPart

	return p
}

func (s *AlterStatementSuffixStatsPartContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterStatementSuffixStatsPartContext) GetComment() antlr.Token { return s.comment }


func (s *AlterStatementSuffixStatsPartContext) SetComment(v antlr.Token) { s.comment = v }


func (s *AlterStatementSuffixStatsPartContext) GetColName() IId_Context { return s.colName }


func (s *AlterStatementSuffixStatsPartContext) SetColName(v IId_Context) { s.colName = v }


func (s *AlterStatementSuffixStatsPartContext) KW_UPDATE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_UPDATE, 0)
}

func (s *AlterStatementSuffixStatsPartContext) KW_STATISTICS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_STATISTICS, 0)
}

func (s *AlterStatementSuffixStatsPartContext) KW_FOR() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_FOR, 0)
}

func (s *AlterStatementSuffixStatsPartContext) KW_SET() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SET, 0)
}

func (s *AlterStatementSuffixStatsPartContext) TableProperties() ITablePropertiesContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablePropertiesContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablePropertiesContext)
}

func (s *AlterStatementSuffixStatsPartContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *AlterStatementSuffixStatsPartContext) KW_COLUMN() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_COLUMN, 0)
}

func (s *AlterStatementSuffixStatsPartContext) KW_COMMENT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_COMMENT, 0)
}

func (s *AlterStatementSuffixStatsPartContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(HiveParserStringLiteral, 0)
}

func (s *AlterStatementSuffixStatsPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterStatementSuffixStatsPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AlterStatementSuffixStatsPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterAlterStatementSuffixStatsPart(s)
	}
}

func (s *AlterStatementSuffixStatsPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitAlterStatementSuffixStatsPart(s)
	}
}

func (s *AlterStatementSuffixStatsPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitAlterStatementSuffixStatsPart(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) AlterStatementSuffixStatsPart() (localctx IAlterStatementSuffixStatsPartContext) {
	localctx = NewAlterStatementSuffixStatsPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 552, HiveParserRULE_alterStatementSuffixStatsPart)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3405)
		p.Match(HiveParserKW_UPDATE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3406)
		p.Match(HiveParserKW_STATISTICS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3407)
		p.Match(HiveParserKW_FOR)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(3409)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_COLUMN {
		{
			p.SetState(3408)
			p.Match(HiveParserKW_COLUMN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(3411)

		var _x = p.Id_()


		localctx.(*AlterStatementSuffixStatsPartContext).colName = _x
	}
	{
		p.SetState(3412)
		p.Match(HiveParserKW_SET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3413)
		p.TableProperties()
	}
	p.SetState(3416)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_COMMENT {
		{
			p.SetState(3414)
			p.Match(HiveParserKW_COMMENT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3415)

			var _m = p.Match(HiveParserStringLiteral)

			localctx.(*AlterStatementSuffixStatsPartContext).comment = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlterStatementSuffixMergeFilesContext is an interface to support dynamic dispatch.
type IAlterStatementSuffixMergeFilesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_CONCATENATE() antlr.TerminalNode

	// IsAlterStatementSuffixMergeFilesContext differentiates from other interfaces.
	IsAlterStatementSuffixMergeFilesContext()
}

type AlterStatementSuffixMergeFilesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterStatementSuffixMergeFilesContext() *AlterStatementSuffixMergeFilesContext {
	var p = new(AlterStatementSuffixMergeFilesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterStatementSuffixMergeFiles
	return p
}

func InitEmptyAlterStatementSuffixMergeFilesContext(p *AlterStatementSuffixMergeFilesContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterStatementSuffixMergeFiles
}

func (*AlterStatementSuffixMergeFilesContext) IsAlterStatementSuffixMergeFilesContext() {}

func NewAlterStatementSuffixMergeFilesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterStatementSuffixMergeFilesContext {
	var p = new(AlterStatementSuffixMergeFilesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_alterStatementSuffixMergeFiles

	return p
}

func (s *AlterStatementSuffixMergeFilesContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterStatementSuffixMergeFilesContext) KW_CONCATENATE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_CONCATENATE, 0)
}

func (s *AlterStatementSuffixMergeFilesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterStatementSuffixMergeFilesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AlterStatementSuffixMergeFilesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterAlterStatementSuffixMergeFiles(s)
	}
}

func (s *AlterStatementSuffixMergeFilesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitAlterStatementSuffixMergeFiles(s)
	}
}

func (s *AlterStatementSuffixMergeFilesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitAlterStatementSuffixMergeFiles(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) AlterStatementSuffixMergeFiles() (localctx IAlterStatementSuffixMergeFilesContext) {
	localctx = NewAlterStatementSuffixMergeFilesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 554, HiveParserRULE_alterStatementSuffixMergeFiles)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3418)
		p.Match(HiveParserKW_CONCATENATE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlterStatementSuffixBucketNumContext is an interface to support dynamic dispatch.
type IAlterStatementSuffixBucketNumContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetNum returns the num token.
	GetNum() antlr.Token 


	// SetNum sets the num token.
	SetNum(antlr.Token) 


	// Getter signatures
	KW_INTO() antlr.TerminalNode
	KW_BUCKETS() antlr.TerminalNode
	Number() antlr.TerminalNode

	// IsAlterStatementSuffixBucketNumContext differentiates from other interfaces.
	IsAlterStatementSuffixBucketNumContext()
}

type AlterStatementSuffixBucketNumContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	num antlr.Token
}

func NewEmptyAlterStatementSuffixBucketNumContext() *AlterStatementSuffixBucketNumContext {
	var p = new(AlterStatementSuffixBucketNumContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterStatementSuffixBucketNum
	return p
}

func InitEmptyAlterStatementSuffixBucketNumContext(p *AlterStatementSuffixBucketNumContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterStatementSuffixBucketNum
}

func (*AlterStatementSuffixBucketNumContext) IsAlterStatementSuffixBucketNumContext() {}

func NewAlterStatementSuffixBucketNumContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterStatementSuffixBucketNumContext {
	var p = new(AlterStatementSuffixBucketNumContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_alterStatementSuffixBucketNum

	return p
}

func (s *AlterStatementSuffixBucketNumContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterStatementSuffixBucketNumContext) GetNum() antlr.Token { return s.num }


func (s *AlterStatementSuffixBucketNumContext) SetNum(v antlr.Token) { s.num = v }


func (s *AlterStatementSuffixBucketNumContext) KW_INTO() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_INTO, 0)
}

func (s *AlterStatementSuffixBucketNumContext) KW_BUCKETS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_BUCKETS, 0)
}

func (s *AlterStatementSuffixBucketNumContext) Number() antlr.TerminalNode {
	return s.GetToken(HiveParserNumber, 0)
}

func (s *AlterStatementSuffixBucketNumContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterStatementSuffixBucketNumContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AlterStatementSuffixBucketNumContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterAlterStatementSuffixBucketNum(s)
	}
}

func (s *AlterStatementSuffixBucketNumContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitAlterStatementSuffixBucketNum(s)
	}
}

func (s *AlterStatementSuffixBucketNumContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitAlterStatementSuffixBucketNum(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) AlterStatementSuffixBucketNum() (localctx IAlterStatementSuffixBucketNumContext) {
	localctx = NewAlterStatementSuffixBucketNumContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 556, HiveParserRULE_alterStatementSuffixBucketNum)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3420)
		p.Match(HiveParserKW_INTO)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3421)

		var _m = p.Match(HiveParserNumber)

		localctx.(*AlterStatementSuffixBucketNumContext).num = _m
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3422)
		p.Match(HiveParserKW_BUCKETS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IBlockingContext is an interface to support dynamic dispatch.
type IBlockingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_AND() antlr.TerminalNode
	KW_WAIT() antlr.TerminalNode

	// IsBlockingContext differentiates from other interfaces.
	IsBlockingContext()
}

type BlockingContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockingContext() *BlockingContext {
	var p = new(BlockingContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_blocking
	return p
}

func InitEmptyBlockingContext(p *BlockingContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_blocking
}

func (*BlockingContext) IsBlockingContext() {}

func NewBlockingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockingContext {
	var p = new(BlockingContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_blocking

	return p
}

func (s *BlockingContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockingContext) KW_AND() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_AND, 0)
}

func (s *BlockingContext) KW_WAIT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_WAIT, 0)
}

func (s *BlockingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *BlockingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterBlocking(s)
	}
}

func (s *BlockingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitBlocking(s)
	}
}

func (s *BlockingContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitBlocking(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) Blocking() (localctx IBlockingContext) {
	localctx = NewBlockingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 558, HiveParserRULE_blocking)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3424)
		p.Match(HiveParserKW_AND)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3425)
		p.Match(HiveParserKW_WAIT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICompactPoolContext is an interface to support dynamic dispatch.
type ICompactPoolContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPoolName returns the poolName token.
	GetPoolName() antlr.Token 


	// SetPoolName sets the poolName token.
	SetPoolName(antlr.Token) 


	// Getter signatures
	KW_POOL() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode

	// IsCompactPoolContext differentiates from other interfaces.
	IsCompactPoolContext()
}

type CompactPoolContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	poolName antlr.Token
}

func NewEmptyCompactPoolContext() *CompactPoolContext {
	var p = new(CompactPoolContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_compactPool
	return p
}

func InitEmptyCompactPoolContext(p *CompactPoolContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_compactPool
}

func (*CompactPoolContext) IsCompactPoolContext() {}

func NewCompactPoolContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompactPoolContext {
	var p = new(CompactPoolContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_compactPool

	return p
}

func (s *CompactPoolContext) GetParser() antlr.Parser { return s.parser }

func (s *CompactPoolContext) GetPoolName() antlr.Token { return s.poolName }


func (s *CompactPoolContext) SetPoolName(v antlr.Token) { s.poolName = v }


func (s *CompactPoolContext) KW_POOL() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_POOL, 0)
}

func (s *CompactPoolContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(HiveParserStringLiteral, 0)
}

func (s *CompactPoolContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompactPoolContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CompactPoolContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterCompactPool(s)
	}
}

func (s *CompactPoolContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitCompactPool(s)
	}
}

func (s *CompactPoolContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitCompactPool(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) CompactPool() (localctx ICompactPoolContext) {
	localctx = NewCompactPoolContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 560, HiveParserRULE_compactPool)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3427)
		p.Match(HiveParserKW_POOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3428)

		var _m = p.Match(HiveParserStringLiteral)

		localctx.(*CompactPoolContext).poolName = _m
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlterStatementSuffixCompactContext is an interface to support dynamic dispatch.
type IAlterStatementSuffixCompactContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCompactType returns the compactType token.
	GetCompactType() antlr.Token 


	// SetCompactType sets the compactType token.
	SetCompactType(antlr.Token) 


	// Getter signatures
	KW_COMPACT() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode
	TableImplBuckets() ITableImplBucketsContext
	Blocking() IBlockingContext
	CompactPool() ICompactPoolContext
	KW_WITH() antlr.TerminalNode
	KW_OVERWRITE() antlr.TerminalNode
	KW_TBLPROPERTIES() antlr.TerminalNode
	TableProperties() ITablePropertiesContext

	// IsAlterStatementSuffixCompactContext differentiates from other interfaces.
	IsAlterStatementSuffixCompactContext()
}

type AlterStatementSuffixCompactContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	compactType antlr.Token
}

func NewEmptyAlterStatementSuffixCompactContext() *AlterStatementSuffixCompactContext {
	var p = new(AlterStatementSuffixCompactContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterStatementSuffixCompact
	return p
}

func InitEmptyAlterStatementSuffixCompactContext(p *AlterStatementSuffixCompactContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterStatementSuffixCompact
}

func (*AlterStatementSuffixCompactContext) IsAlterStatementSuffixCompactContext() {}

func NewAlterStatementSuffixCompactContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterStatementSuffixCompactContext {
	var p = new(AlterStatementSuffixCompactContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_alterStatementSuffixCompact

	return p
}

func (s *AlterStatementSuffixCompactContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterStatementSuffixCompactContext) GetCompactType() antlr.Token { return s.compactType }


func (s *AlterStatementSuffixCompactContext) SetCompactType(v antlr.Token) { s.compactType = v }


func (s *AlterStatementSuffixCompactContext) KW_COMPACT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_COMPACT, 0)
}

func (s *AlterStatementSuffixCompactContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(HiveParserStringLiteral, 0)
}

func (s *AlterStatementSuffixCompactContext) TableImplBuckets() ITableImplBucketsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableImplBucketsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableImplBucketsContext)
}

func (s *AlterStatementSuffixCompactContext) Blocking() IBlockingContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockingContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockingContext)
}

func (s *AlterStatementSuffixCompactContext) CompactPool() ICompactPoolContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompactPoolContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompactPoolContext)
}

func (s *AlterStatementSuffixCompactContext) KW_WITH() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_WITH, 0)
}

func (s *AlterStatementSuffixCompactContext) KW_OVERWRITE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_OVERWRITE, 0)
}

func (s *AlterStatementSuffixCompactContext) KW_TBLPROPERTIES() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TBLPROPERTIES, 0)
}

func (s *AlterStatementSuffixCompactContext) TableProperties() ITablePropertiesContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablePropertiesContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablePropertiesContext)
}

func (s *AlterStatementSuffixCompactContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterStatementSuffixCompactContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AlterStatementSuffixCompactContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterAlterStatementSuffixCompact(s)
	}
}

func (s *AlterStatementSuffixCompactContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitAlterStatementSuffixCompact(s)
	}
}

func (s *AlterStatementSuffixCompactContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitAlterStatementSuffixCompact(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) AlterStatementSuffixCompact() (localctx IAlterStatementSuffixCompactContext) {
	localctx = NewAlterStatementSuffixCompactContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 562, HiveParserRULE_alterStatementSuffixCompact)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3430)
		p.Match(HiveParserKW_COMPACT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3431)

		var _m = p.Match(HiveParserStringLiteral)

		localctx.(*AlterStatementSuffixCompactContext).compactType = _m
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(3433)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_CLUSTERED {
		{
			p.SetState(3432)
			p.TableImplBuckets()
		}

	}
	p.SetState(3436)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_AND {
		{
			p.SetState(3435)
			p.Blocking()
		}

	}
	p.SetState(3439)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_POOL {
		{
			p.SetState(3438)
			p.CompactPool()
		}

	}
	p.SetState(3445)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_WITH {
		{
			p.SetState(3441)
			p.Match(HiveParserKW_WITH)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3442)
			p.Match(HiveParserKW_OVERWRITE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3443)
			p.Match(HiveParserKW_TBLPROPERTIES)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3444)
			p.TableProperties()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlterStatementSuffixSetOwnerContext is an interface to support dynamic dispatch.
type IAlterStatementSuffixSetOwnerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_SET() antlr.TerminalNode
	KW_OWNER() antlr.TerminalNode
	PrincipalName() IPrincipalNameContext

	// IsAlterStatementSuffixSetOwnerContext differentiates from other interfaces.
	IsAlterStatementSuffixSetOwnerContext()
}

type AlterStatementSuffixSetOwnerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterStatementSuffixSetOwnerContext() *AlterStatementSuffixSetOwnerContext {
	var p = new(AlterStatementSuffixSetOwnerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterStatementSuffixSetOwner
	return p
}

func InitEmptyAlterStatementSuffixSetOwnerContext(p *AlterStatementSuffixSetOwnerContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterStatementSuffixSetOwner
}

func (*AlterStatementSuffixSetOwnerContext) IsAlterStatementSuffixSetOwnerContext() {}

func NewAlterStatementSuffixSetOwnerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterStatementSuffixSetOwnerContext {
	var p = new(AlterStatementSuffixSetOwnerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_alterStatementSuffixSetOwner

	return p
}

func (s *AlterStatementSuffixSetOwnerContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterStatementSuffixSetOwnerContext) KW_SET() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SET, 0)
}

func (s *AlterStatementSuffixSetOwnerContext) KW_OWNER() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_OWNER, 0)
}

func (s *AlterStatementSuffixSetOwnerContext) PrincipalName() IPrincipalNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrincipalNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrincipalNameContext)
}

func (s *AlterStatementSuffixSetOwnerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterStatementSuffixSetOwnerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AlterStatementSuffixSetOwnerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterAlterStatementSuffixSetOwner(s)
	}
}

func (s *AlterStatementSuffixSetOwnerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitAlterStatementSuffixSetOwner(s)
	}
}

func (s *AlterStatementSuffixSetOwnerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitAlterStatementSuffixSetOwner(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) AlterStatementSuffixSetOwner() (localctx IAlterStatementSuffixSetOwnerContext) {
	localctx = NewAlterStatementSuffixSetOwnerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 564, HiveParserRULE_alterStatementSuffixSetOwner)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3447)
		p.Match(HiveParserKW_SET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3448)
		p.Match(HiveParserKW_OWNER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3449)
		p.PrincipalName()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlterStatementSuffixSetPartSpecContext is an interface to support dynamic dispatch.
type IAlterStatementSuffixSetPartSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSpec returns the spec rule contexts.
	GetSpec() IPartitionTransformSpecContext


	// SetSpec sets the spec rule contexts.
	SetSpec(IPartitionTransformSpecContext)


	// Getter signatures
	KW_SET() antlr.TerminalNode
	KW_PARTITION() antlr.TerminalNode
	KW_SPEC() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	PartitionTransformSpec() IPartitionTransformSpecContext

	// IsAlterStatementSuffixSetPartSpecContext differentiates from other interfaces.
	IsAlterStatementSuffixSetPartSpecContext()
}

type AlterStatementSuffixSetPartSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	spec IPartitionTransformSpecContext 
}

func NewEmptyAlterStatementSuffixSetPartSpecContext() *AlterStatementSuffixSetPartSpecContext {
	var p = new(AlterStatementSuffixSetPartSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterStatementSuffixSetPartSpec
	return p
}

func InitEmptyAlterStatementSuffixSetPartSpecContext(p *AlterStatementSuffixSetPartSpecContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterStatementSuffixSetPartSpec
}

func (*AlterStatementSuffixSetPartSpecContext) IsAlterStatementSuffixSetPartSpecContext() {}

func NewAlterStatementSuffixSetPartSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterStatementSuffixSetPartSpecContext {
	var p = new(AlterStatementSuffixSetPartSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_alterStatementSuffixSetPartSpec

	return p
}

func (s *AlterStatementSuffixSetPartSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterStatementSuffixSetPartSpecContext) GetSpec() IPartitionTransformSpecContext { return s.spec }


func (s *AlterStatementSuffixSetPartSpecContext) SetSpec(v IPartitionTransformSpecContext) { s.spec = v }


func (s *AlterStatementSuffixSetPartSpecContext) KW_SET() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SET, 0)
}

func (s *AlterStatementSuffixSetPartSpecContext) KW_PARTITION() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_PARTITION, 0)
}

func (s *AlterStatementSuffixSetPartSpecContext) KW_SPEC() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SPEC, 0)
}

func (s *AlterStatementSuffixSetPartSpecContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserLPAREN, 0)
}

func (s *AlterStatementSuffixSetPartSpecContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserRPAREN, 0)
}

func (s *AlterStatementSuffixSetPartSpecContext) PartitionTransformSpec() IPartitionTransformSpecContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionTransformSpecContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionTransformSpecContext)
}

func (s *AlterStatementSuffixSetPartSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterStatementSuffixSetPartSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AlterStatementSuffixSetPartSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterAlterStatementSuffixSetPartSpec(s)
	}
}

func (s *AlterStatementSuffixSetPartSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitAlterStatementSuffixSetPartSpec(s)
	}
}

func (s *AlterStatementSuffixSetPartSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitAlterStatementSuffixSetPartSpec(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) AlterStatementSuffixSetPartSpec() (localctx IAlterStatementSuffixSetPartSpecContext) {
	localctx = NewAlterStatementSuffixSetPartSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 566, HiveParserRULE_alterStatementSuffixSetPartSpec)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3451)
		p.Match(HiveParserKW_SET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3452)
		p.Match(HiveParserKW_PARTITION)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3453)
		p.Match(HiveParserKW_SPEC)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3454)
		p.Match(HiveParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3455)

		var _x = p.PartitionTransformSpec()


		localctx.(*AlterStatementSuffixSetPartSpecContext).spec = _x
	}
	{
		p.SetState(3456)
		p.Match(HiveParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlterStatementSuffixExecuteContext is an interface to support dynamic dispatch.
type IAlterStatementSuffixExecuteContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRollbackParam returns the rollbackParam token.
	GetRollbackParam() antlr.Token 

	// GetExpireParam returns the expireParam token.
	GetExpireParam() antlr.Token 

	// GetSnapshotParam returns the snapshotParam token.
	GetSnapshotParam() antlr.Token 


	// SetRollbackParam sets the rollbackParam token.
	SetRollbackParam(antlr.Token) 

	// SetExpireParam sets the expireParam token.
	SetExpireParam(antlr.Token) 

	// SetSnapshotParam sets the snapshotParam token.
	SetSnapshotParam(antlr.Token) 


	// Getter signatures
	KW_EXECUTE() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	KW_ROLLBACK() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	KW_EXPIRE_SNAPSHOTS() antlr.TerminalNode
	KW_SET_CURRENT_SNAPSHOT() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode
	Number() antlr.TerminalNode

	// IsAlterStatementSuffixExecuteContext differentiates from other interfaces.
	IsAlterStatementSuffixExecuteContext()
}

type AlterStatementSuffixExecuteContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	rollbackParam antlr.Token
	expireParam antlr.Token
	snapshotParam antlr.Token
}

func NewEmptyAlterStatementSuffixExecuteContext() *AlterStatementSuffixExecuteContext {
	var p = new(AlterStatementSuffixExecuteContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterStatementSuffixExecute
	return p
}

func InitEmptyAlterStatementSuffixExecuteContext(p *AlterStatementSuffixExecuteContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterStatementSuffixExecute
}

func (*AlterStatementSuffixExecuteContext) IsAlterStatementSuffixExecuteContext() {}

func NewAlterStatementSuffixExecuteContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterStatementSuffixExecuteContext {
	var p = new(AlterStatementSuffixExecuteContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_alterStatementSuffixExecute

	return p
}

func (s *AlterStatementSuffixExecuteContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterStatementSuffixExecuteContext) GetRollbackParam() antlr.Token { return s.rollbackParam }

func (s *AlterStatementSuffixExecuteContext) GetExpireParam() antlr.Token { return s.expireParam }

func (s *AlterStatementSuffixExecuteContext) GetSnapshotParam() antlr.Token { return s.snapshotParam }


func (s *AlterStatementSuffixExecuteContext) SetRollbackParam(v antlr.Token) { s.rollbackParam = v }

func (s *AlterStatementSuffixExecuteContext) SetExpireParam(v antlr.Token) { s.expireParam = v }

func (s *AlterStatementSuffixExecuteContext) SetSnapshotParam(v antlr.Token) { s.snapshotParam = v }


func (s *AlterStatementSuffixExecuteContext) KW_EXECUTE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_EXECUTE, 0)
}

func (s *AlterStatementSuffixExecuteContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserRPAREN, 0)
}

func (s *AlterStatementSuffixExecuteContext) KW_ROLLBACK() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ROLLBACK, 0)
}

func (s *AlterStatementSuffixExecuteContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserLPAREN, 0)
}

func (s *AlterStatementSuffixExecuteContext) KW_EXPIRE_SNAPSHOTS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_EXPIRE_SNAPSHOTS, 0)
}

func (s *AlterStatementSuffixExecuteContext) KW_SET_CURRENT_SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SET_CURRENT_SNAPSHOT, 0)
}

func (s *AlterStatementSuffixExecuteContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(HiveParserStringLiteral, 0)
}

func (s *AlterStatementSuffixExecuteContext) Number() antlr.TerminalNode {
	return s.GetToken(HiveParserNumber, 0)
}

func (s *AlterStatementSuffixExecuteContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterStatementSuffixExecuteContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AlterStatementSuffixExecuteContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterAlterStatementSuffixExecute(s)
	}
}

func (s *AlterStatementSuffixExecuteContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitAlterStatementSuffixExecute(s)
	}
}

func (s *AlterStatementSuffixExecuteContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitAlterStatementSuffixExecute(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) AlterStatementSuffixExecute() (localctx IAlterStatementSuffixExecuteContext) {
	localctx = NewAlterStatementSuffixExecuteContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 568, HiveParserRULE_alterStatementSuffixExecute)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3458)
		p.Match(HiveParserKW_EXECUTE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(3468)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserKW_ROLLBACK:
		{
			p.SetState(3459)
			p.Match(HiveParserKW_ROLLBACK)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3460)
			p.Match(HiveParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3461)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*AlterStatementSuffixExecuteContext).rollbackParam = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == HiveParserStringLiteral || _la == HiveParserNumber) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*AlterStatementSuffixExecuteContext).rollbackParam = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}


	case HiveParserKW_EXPIRE_SNAPSHOTS:
		{
			p.SetState(3462)
			p.Match(HiveParserKW_EXPIRE_SNAPSHOTS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3463)
			p.Match(HiveParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3464)

			var _m = p.Match(HiveParserStringLiteral)

			localctx.(*AlterStatementSuffixExecuteContext).expireParam = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HiveParserKW_SET_CURRENT_SNAPSHOT:
		{
			p.SetState(3465)
			p.Match(HiveParserKW_SET_CURRENT_SNAPSHOT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3466)
			p.Match(HiveParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3467)

			var _m = p.Match(HiveParserNumber)

			localctx.(*AlterStatementSuffixExecuteContext).snapshotParam = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(3470)
		p.Match(HiveParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFileFormatContext is an interface to support dynamic dispatch.
type IFileFormatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetInFmt returns the inFmt token.
	GetInFmt() antlr.Token 

	// GetOutFmt returns the outFmt token.
	GetOutFmt() antlr.Token 

	// GetSerdeCls returns the serdeCls token.
	GetSerdeCls() antlr.Token 

	// GetInDriver returns the inDriver token.
	GetInDriver() antlr.Token 

	// GetOutDriver returns the outDriver token.
	GetOutDriver() antlr.Token 


	// SetInFmt sets the inFmt token.
	SetInFmt(antlr.Token) 

	// SetOutFmt sets the outFmt token.
	SetOutFmt(antlr.Token) 

	// SetSerdeCls sets the serdeCls token.
	SetSerdeCls(antlr.Token) 

	// SetInDriver sets the inDriver token.
	SetInDriver(antlr.Token) 

	// SetOutDriver sets the outDriver token.
	SetOutDriver(antlr.Token) 


	// GetGenericSpec returns the genericSpec rule contexts.
	GetGenericSpec() IId_Context


	// SetGenericSpec sets the genericSpec rule contexts.
	SetGenericSpec(IId_Context)


	// Getter signatures
	KW_INPUTFORMAT() antlr.TerminalNode
	KW_OUTPUTFORMAT() antlr.TerminalNode
	KW_SERDE() antlr.TerminalNode
	AllStringLiteral() []antlr.TerminalNode
	StringLiteral(i int) antlr.TerminalNode
	KW_INPUTDRIVER() antlr.TerminalNode
	KW_OUTPUTDRIVER() antlr.TerminalNode
	Id_() IId_Context

	// IsFileFormatContext differentiates from other interfaces.
	IsFileFormatContext()
}

type FileFormatContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	inFmt antlr.Token
	outFmt antlr.Token
	serdeCls antlr.Token
	inDriver antlr.Token
	outDriver antlr.Token
	genericSpec IId_Context 
}

func NewEmptyFileFormatContext() *FileFormatContext {
	var p = new(FileFormatContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_fileFormat
	return p
}

func InitEmptyFileFormatContext(p *FileFormatContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_fileFormat
}

func (*FileFormatContext) IsFileFormatContext() {}

func NewFileFormatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FileFormatContext {
	var p = new(FileFormatContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_fileFormat

	return p
}

func (s *FileFormatContext) GetParser() antlr.Parser { return s.parser }

func (s *FileFormatContext) GetInFmt() antlr.Token { return s.inFmt }

func (s *FileFormatContext) GetOutFmt() antlr.Token { return s.outFmt }

func (s *FileFormatContext) GetSerdeCls() antlr.Token { return s.serdeCls }

func (s *FileFormatContext) GetInDriver() antlr.Token { return s.inDriver }

func (s *FileFormatContext) GetOutDriver() antlr.Token { return s.outDriver }


func (s *FileFormatContext) SetInFmt(v antlr.Token) { s.inFmt = v }

func (s *FileFormatContext) SetOutFmt(v antlr.Token) { s.outFmt = v }

func (s *FileFormatContext) SetSerdeCls(v antlr.Token) { s.serdeCls = v }

func (s *FileFormatContext) SetInDriver(v antlr.Token) { s.inDriver = v }

func (s *FileFormatContext) SetOutDriver(v antlr.Token) { s.outDriver = v }


func (s *FileFormatContext) GetGenericSpec() IId_Context { return s.genericSpec }


func (s *FileFormatContext) SetGenericSpec(v IId_Context) { s.genericSpec = v }


func (s *FileFormatContext) KW_INPUTFORMAT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_INPUTFORMAT, 0)
}

func (s *FileFormatContext) KW_OUTPUTFORMAT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_OUTPUTFORMAT, 0)
}

func (s *FileFormatContext) KW_SERDE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SERDE, 0)
}

func (s *FileFormatContext) AllStringLiteral() []antlr.TerminalNode {
	return s.GetTokens(HiveParserStringLiteral)
}

func (s *FileFormatContext) StringLiteral(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserStringLiteral, i)
}

func (s *FileFormatContext) KW_INPUTDRIVER() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_INPUTDRIVER, 0)
}

func (s *FileFormatContext) KW_OUTPUTDRIVER() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_OUTPUTDRIVER, 0)
}

func (s *FileFormatContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *FileFormatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FileFormatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *FileFormatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterFileFormat(s)
	}
}

func (s *FileFormatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitFileFormat(s)
	}
}

func (s *FileFormatContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitFileFormat(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) FileFormat() (localctx IFileFormatContext) {
	localctx = NewFileFormatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 570, HiveParserRULE_fileFormat)
	var _la int

	p.SetState(3485)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 371, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3472)
			p.Match(HiveParserKW_INPUTFORMAT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3473)

			var _m = p.Match(HiveParserStringLiteral)

			localctx.(*FileFormatContext).inFmt = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3474)
			p.Match(HiveParserKW_OUTPUTFORMAT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3475)

			var _m = p.Match(HiveParserStringLiteral)

			localctx.(*FileFormatContext).outFmt = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3476)
			p.Match(HiveParserKW_SERDE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3477)

			var _m = p.Match(HiveParserStringLiteral)

			localctx.(*FileFormatContext).serdeCls = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(3482)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_INPUTDRIVER {
			{
				p.SetState(3478)
				p.Match(HiveParserKW_INPUTDRIVER)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(3479)

				var _m = p.Match(HiveParserStringLiteral)

				localctx.(*FileFormatContext).inDriver = _m
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(3480)
				p.Match(HiveParserKW_OUTPUTDRIVER)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(3481)

				var _m = p.Match(HiveParserStringLiteral)

				localctx.(*FileFormatContext).outDriver = _m
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3484)

			var _x = p.Id_()


			localctx.(*FileFormatContext).genericSpec = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlterDataConnectorStatementSuffixContext is an interface to support dynamic dispatch.
type IAlterDataConnectorStatementSuffixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AlterDataConnectorSuffixProperties() IAlterDataConnectorSuffixPropertiesContext
	AlterDataConnectorSuffixSetOwner() IAlterDataConnectorSuffixSetOwnerContext
	AlterDataConnectorSuffixSetUrl() IAlterDataConnectorSuffixSetUrlContext

	// IsAlterDataConnectorStatementSuffixContext differentiates from other interfaces.
	IsAlterDataConnectorStatementSuffixContext()
}

type AlterDataConnectorStatementSuffixContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterDataConnectorStatementSuffixContext() *AlterDataConnectorStatementSuffixContext {
	var p = new(AlterDataConnectorStatementSuffixContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterDataConnectorStatementSuffix
	return p
}

func InitEmptyAlterDataConnectorStatementSuffixContext(p *AlterDataConnectorStatementSuffixContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterDataConnectorStatementSuffix
}

func (*AlterDataConnectorStatementSuffixContext) IsAlterDataConnectorStatementSuffixContext() {}

func NewAlterDataConnectorStatementSuffixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterDataConnectorStatementSuffixContext {
	var p = new(AlterDataConnectorStatementSuffixContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_alterDataConnectorStatementSuffix

	return p
}

func (s *AlterDataConnectorStatementSuffixContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterDataConnectorStatementSuffixContext) AlterDataConnectorSuffixProperties() IAlterDataConnectorSuffixPropertiesContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterDataConnectorSuffixPropertiesContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterDataConnectorSuffixPropertiesContext)
}

func (s *AlterDataConnectorStatementSuffixContext) AlterDataConnectorSuffixSetOwner() IAlterDataConnectorSuffixSetOwnerContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterDataConnectorSuffixSetOwnerContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterDataConnectorSuffixSetOwnerContext)
}

func (s *AlterDataConnectorStatementSuffixContext) AlterDataConnectorSuffixSetUrl() IAlterDataConnectorSuffixSetUrlContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterDataConnectorSuffixSetUrlContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterDataConnectorSuffixSetUrlContext)
}

func (s *AlterDataConnectorStatementSuffixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterDataConnectorStatementSuffixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AlterDataConnectorStatementSuffixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterAlterDataConnectorStatementSuffix(s)
	}
}

func (s *AlterDataConnectorStatementSuffixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitAlterDataConnectorStatementSuffix(s)
	}
}

func (s *AlterDataConnectorStatementSuffixContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitAlterDataConnectorStatementSuffix(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) AlterDataConnectorStatementSuffix() (localctx IAlterDataConnectorStatementSuffixContext) {
	localctx = NewAlterDataConnectorStatementSuffixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 572, HiveParserRULE_alterDataConnectorStatementSuffix)
	p.SetState(3490)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 372, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3487)
			p.AlterDataConnectorSuffixProperties()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3488)
			p.AlterDataConnectorSuffixSetOwner()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3489)
			p.AlterDataConnectorSuffixSetUrl()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlterDataConnectorSuffixPropertiesContext is an interface to support dynamic dispatch.
type IAlterDataConnectorSuffixPropertiesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IId_Context


	// SetName sets the name rule contexts.
	SetName(IId_Context)


	// Getter signatures
	KW_SET() antlr.TerminalNode
	KW_DCPROPERTIES() antlr.TerminalNode
	DcProperties() IDcPropertiesContext
	Id_() IId_Context

	// IsAlterDataConnectorSuffixPropertiesContext differentiates from other interfaces.
	IsAlterDataConnectorSuffixPropertiesContext()
}

type AlterDataConnectorSuffixPropertiesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name IId_Context 
}

func NewEmptyAlterDataConnectorSuffixPropertiesContext() *AlterDataConnectorSuffixPropertiesContext {
	var p = new(AlterDataConnectorSuffixPropertiesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterDataConnectorSuffixProperties
	return p
}

func InitEmptyAlterDataConnectorSuffixPropertiesContext(p *AlterDataConnectorSuffixPropertiesContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterDataConnectorSuffixProperties
}

func (*AlterDataConnectorSuffixPropertiesContext) IsAlterDataConnectorSuffixPropertiesContext() {}

func NewAlterDataConnectorSuffixPropertiesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterDataConnectorSuffixPropertiesContext {
	var p = new(AlterDataConnectorSuffixPropertiesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_alterDataConnectorSuffixProperties

	return p
}

func (s *AlterDataConnectorSuffixPropertiesContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterDataConnectorSuffixPropertiesContext) GetName() IId_Context { return s.name }


func (s *AlterDataConnectorSuffixPropertiesContext) SetName(v IId_Context) { s.name = v }


func (s *AlterDataConnectorSuffixPropertiesContext) KW_SET() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SET, 0)
}

func (s *AlterDataConnectorSuffixPropertiesContext) KW_DCPROPERTIES() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DCPROPERTIES, 0)
}

func (s *AlterDataConnectorSuffixPropertiesContext) DcProperties() IDcPropertiesContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDcPropertiesContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDcPropertiesContext)
}

func (s *AlterDataConnectorSuffixPropertiesContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *AlterDataConnectorSuffixPropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterDataConnectorSuffixPropertiesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AlterDataConnectorSuffixPropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterAlterDataConnectorSuffixProperties(s)
	}
}

func (s *AlterDataConnectorSuffixPropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitAlterDataConnectorSuffixProperties(s)
	}
}

func (s *AlterDataConnectorSuffixPropertiesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitAlterDataConnectorSuffixProperties(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) AlterDataConnectorSuffixProperties() (localctx IAlterDataConnectorSuffixPropertiesContext) {
	localctx = NewAlterDataConnectorSuffixPropertiesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 574, HiveParserRULE_alterDataConnectorSuffixProperties)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3492)

		var _x = p.Id_()


		localctx.(*AlterDataConnectorSuffixPropertiesContext).name = _x
	}
	{
		p.SetState(3493)
		p.Match(HiveParserKW_SET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3494)
		p.Match(HiveParserKW_DCPROPERTIES)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3495)
		p.DcProperties()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlterDataConnectorSuffixSetOwnerContext is an interface to support dynamic dispatch.
type IAlterDataConnectorSuffixSetOwnerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDcName returns the dcName rule contexts.
	GetDcName() IId_Context


	// SetDcName sets the dcName rule contexts.
	SetDcName(IId_Context)


	// Getter signatures
	KW_SET() antlr.TerminalNode
	KW_OWNER() antlr.TerminalNode
	PrincipalName() IPrincipalNameContext
	Id_() IId_Context

	// IsAlterDataConnectorSuffixSetOwnerContext differentiates from other interfaces.
	IsAlterDataConnectorSuffixSetOwnerContext()
}

type AlterDataConnectorSuffixSetOwnerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	dcName IId_Context 
}

func NewEmptyAlterDataConnectorSuffixSetOwnerContext() *AlterDataConnectorSuffixSetOwnerContext {
	var p = new(AlterDataConnectorSuffixSetOwnerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterDataConnectorSuffixSetOwner
	return p
}

func InitEmptyAlterDataConnectorSuffixSetOwnerContext(p *AlterDataConnectorSuffixSetOwnerContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterDataConnectorSuffixSetOwner
}

func (*AlterDataConnectorSuffixSetOwnerContext) IsAlterDataConnectorSuffixSetOwnerContext() {}

func NewAlterDataConnectorSuffixSetOwnerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterDataConnectorSuffixSetOwnerContext {
	var p = new(AlterDataConnectorSuffixSetOwnerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_alterDataConnectorSuffixSetOwner

	return p
}

func (s *AlterDataConnectorSuffixSetOwnerContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterDataConnectorSuffixSetOwnerContext) GetDcName() IId_Context { return s.dcName }


func (s *AlterDataConnectorSuffixSetOwnerContext) SetDcName(v IId_Context) { s.dcName = v }


func (s *AlterDataConnectorSuffixSetOwnerContext) KW_SET() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SET, 0)
}

func (s *AlterDataConnectorSuffixSetOwnerContext) KW_OWNER() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_OWNER, 0)
}

func (s *AlterDataConnectorSuffixSetOwnerContext) PrincipalName() IPrincipalNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrincipalNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrincipalNameContext)
}

func (s *AlterDataConnectorSuffixSetOwnerContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *AlterDataConnectorSuffixSetOwnerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterDataConnectorSuffixSetOwnerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AlterDataConnectorSuffixSetOwnerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterAlterDataConnectorSuffixSetOwner(s)
	}
}

func (s *AlterDataConnectorSuffixSetOwnerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitAlterDataConnectorSuffixSetOwner(s)
	}
}

func (s *AlterDataConnectorSuffixSetOwnerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitAlterDataConnectorSuffixSetOwner(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) AlterDataConnectorSuffixSetOwner() (localctx IAlterDataConnectorSuffixSetOwnerContext) {
	localctx = NewAlterDataConnectorSuffixSetOwnerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 576, HiveParserRULE_alterDataConnectorSuffixSetOwner)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3497)

		var _x = p.Id_()


		localctx.(*AlterDataConnectorSuffixSetOwnerContext).dcName = _x
	}
	{
		p.SetState(3498)
		p.Match(HiveParserKW_SET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3499)
		p.Match(HiveParserKW_OWNER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3500)
		p.PrincipalName()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlterDataConnectorSuffixSetUrlContext is an interface to support dynamic dispatch.
type IAlterDataConnectorSuffixSetUrlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetNewUri returns the newUri token.
	GetNewUri() antlr.Token 


	// SetNewUri sets the newUri token.
	SetNewUri(antlr.Token) 


	// GetDcName returns the dcName rule contexts.
	GetDcName() IId_Context


	// SetDcName sets the dcName rule contexts.
	SetDcName(IId_Context)


	// Getter signatures
	KW_SET() antlr.TerminalNode
	KW_URL() antlr.TerminalNode
	Id_() IId_Context
	StringLiteral() antlr.TerminalNode

	// IsAlterDataConnectorSuffixSetUrlContext differentiates from other interfaces.
	IsAlterDataConnectorSuffixSetUrlContext()
}

type AlterDataConnectorSuffixSetUrlContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	dcName IId_Context 
	newUri antlr.Token
}

func NewEmptyAlterDataConnectorSuffixSetUrlContext() *AlterDataConnectorSuffixSetUrlContext {
	var p = new(AlterDataConnectorSuffixSetUrlContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterDataConnectorSuffixSetUrl
	return p
}

func InitEmptyAlterDataConnectorSuffixSetUrlContext(p *AlterDataConnectorSuffixSetUrlContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterDataConnectorSuffixSetUrl
}

func (*AlterDataConnectorSuffixSetUrlContext) IsAlterDataConnectorSuffixSetUrlContext() {}

func NewAlterDataConnectorSuffixSetUrlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterDataConnectorSuffixSetUrlContext {
	var p = new(AlterDataConnectorSuffixSetUrlContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_alterDataConnectorSuffixSetUrl

	return p
}

func (s *AlterDataConnectorSuffixSetUrlContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterDataConnectorSuffixSetUrlContext) GetNewUri() antlr.Token { return s.newUri }


func (s *AlterDataConnectorSuffixSetUrlContext) SetNewUri(v antlr.Token) { s.newUri = v }


func (s *AlterDataConnectorSuffixSetUrlContext) GetDcName() IId_Context { return s.dcName }


func (s *AlterDataConnectorSuffixSetUrlContext) SetDcName(v IId_Context) { s.dcName = v }


func (s *AlterDataConnectorSuffixSetUrlContext) KW_SET() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SET, 0)
}

func (s *AlterDataConnectorSuffixSetUrlContext) KW_URL() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_URL, 0)
}

func (s *AlterDataConnectorSuffixSetUrlContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *AlterDataConnectorSuffixSetUrlContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(HiveParserStringLiteral, 0)
}

func (s *AlterDataConnectorSuffixSetUrlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterDataConnectorSuffixSetUrlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AlterDataConnectorSuffixSetUrlContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterAlterDataConnectorSuffixSetUrl(s)
	}
}

func (s *AlterDataConnectorSuffixSetUrlContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitAlterDataConnectorSuffixSetUrl(s)
	}
}

func (s *AlterDataConnectorSuffixSetUrlContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitAlterDataConnectorSuffixSetUrl(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) AlterDataConnectorSuffixSetUrl() (localctx IAlterDataConnectorSuffixSetUrlContext) {
	localctx = NewAlterDataConnectorSuffixSetUrlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 578, HiveParserRULE_alterDataConnectorSuffixSetUrl)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3502)

		var _x = p.Id_()


		localctx.(*AlterDataConnectorSuffixSetUrlContext).dcName = _x
	}
	{
		p.SetState(3503)
		p.Match(HiveParserKW_SET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3504)
		p.Match(HiveParserKW_URL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3505)

		var _m = p.Match(HiveParserStringLiteral)

		localctx.(*AlterDataConnectorSuffixSetUrlContext).newUri = _m
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ILikeTableOrFileContext is an interface to support dynamic dispatch.
type ILikeTableOrFileContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetUri returns the uri token.
	GetUri() antlr.Token 


	// SetUri sets the uri token.
	SetUri(antlr.Token) 


	// GetFormat returns the format rule contexts.
	GetFormat() IId_Context

	// GetLikeName returns the likeName rule contexts.
	GetLikeName() ITableNameContext


	// SetFormat sets the format rule contexts.
	SetFormat(IId_Context)

	// SetLikeName sets the likeName rule contexts.
	SetLikeName(ITableNameContext)


	// Getter signatures
	KW_LIKE() antlr.TerminalNode
	KW_FILE() antlr.TerminalNode
	Id_() IId_Context
	StringLiteral() antlr.TerminalNode
	TableName() ITableNameContext

	// IsLikeTableOrFileContext differentiates from other interfaces.
	IsLikeTableOrFileContext()
}

type LikeTableOrFileContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	format IId_Context 
	uri antlr.Token
	likeName ITableNameContext 
}

func NewEmptyLikeTableOrFileContext() *LikeTableOrFileContext {
	var p = new(LikeTableOrFileContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_likeTableOrFile
	return p
}

func InitEmptyLikeTableOrFileContext(p *LikeTableOrFileContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_likeTableOrFile
}

func (*LikeTableOrFileContext) IsLikeTableOrFileContext() {}

func NewLikeTableOrFileContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LikeTableOrFileContext {
	var p = new(LikeTableOrFileContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_likeTableOrFile

	return p
}

func (s *LikeTableOrFileContext) GetParser() antlr.Parser { return s.parser }

func (s *LikeTableOrFileContext) GetUri() antlr.Token { return s.uri }


func (s *LikeTableOrFileContext) SetUri(v antlr.Token) { s.uri = v }


func (s *LikeTableOrFileContext) GetFormat() IId_Context { return s.format }

func (s *LikeTableOrFileContext) GetLikeName() ITableNameContext { return s.likeName }


func (s *LikeTableOrFileContext) SetFormat(v IId_Context) { s.format = v }

func (s *LikeTableOrFileContext) SetLikeName(v ITableNameContext) { s.likeName = v }


func (s *LikeTableOrFileContext) KW_LIKE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_LIKE, 0)
}

func (s *LikeTableOrFileContext) KW_FILE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_FILE, 0)
}

func (s *LikeTableOrFileContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *LikeTableOrFileContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(HiveParserStringLiteral, 0)
}

func (s *LikeTableOrFileContext) TableName() ITableNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *LikeTableOrFileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LikeTableOrFileContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *LikeTableOrFileContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterLikeTableOrFile(s)
	}
}

func (s *LikeTableOrFileContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitLikeTableOrFile(s)
	}
}

func (s *LikeTableOrFileContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitLikeTableOrFile(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) LikeTableOrFile() (localctx ILikeTableOrFileContext) {
	localctx = NewLikeTableOrFileContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 580, HiveParserRULE_likeTableOrFile)
	p.SetState(3516)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 373, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3507)
			p.Match(HiveParserKW_LIKE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3508)
			p.Match(HiveParserKW_FILE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3509)
			p.Match(HiveParserKW_LIKE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3510)
			p.Match(HiveParserKW_FILE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3511)

			var _x = p.Id_()


			localctx.(*LikeTableOrFileContext).format = _x
		}
		{
			p.SetState(3512)

			var _m = p.Match(HiveParserStringLiteral)

			localctx.(*LikeTableOrFileContext).uri = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3514)
			p.Match(HiveParserKW_LIKE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3515)

			var _x = p.TableName()


			localctx.(*LikeTableOrFileContext).likeName = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreateTableStatementContext is an interface to support dynamic dispatch.
type ICreateTableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTemp returns the temp token.
	GetTemp() antlr.Token 

	// GetTrans returns the trans token.
	GetTrans() antlr.Token 

	// GetExt returns the ext token.
	GetExt() antlr.Token 

	// GetMgd returns the mgd token.
	GetMgd() antlr.Token 


	// SetTemp sets the temp token.
	SetTemp(antlr.Token) 

	// SetTrans sets the trans token.
	SetTrans(antlr.Token) 

	// SetExt sets the ext token.
	SetExt(antlr.Token) 

	// SetMgd sets the mgd token.
	SetMgd(antlr.Token) 


	// GetName returns the name rule contexts.
	GetName() ITableNameContext


	// SetName sets the name rule contexts.
	SetName(ITableNameContext)


	// Getter signatures
	KW_CREATE() antlr.TerminalNode
	KW_TABLE() antlr.TerminalNode
	TableName() ITableNameContext
	LikeTableOrFile() ILikeTableOrFileContext
	IfNotExists() IIfNotExistsContext
	KW_TEMPORARY() antlr.TerminalNode
	KW_TRANSACTIONAL() antlr.TerminalNode
	KW_EXTERNAL() antlr.TerminalNode
	CreateTablePartitionSpec() ICreateTablePartitionSpecContext
	TableRowFormat() ITableRowFormatContext
	TableFileFormat() ITableFileFormatContext
	TableLocation() ITableLocationContext
	TablePropertiesPrefixed() ITablePropertiesPrefixedContext
	LPAREN() antlr.TerminalNode
	ColumnNameTypeOrConstraintList() IColumnNameTypeOrConstraintListContext
	RPAREN() antlr.TerminalNode
	TableComment() ITableCommentContext
	TableBuckets() ITableBucketsContext
	TableSkewed() ITableSkewedContext
	KW_AS() antlr.TerminalNode
	SelectStatementWithCTE() ISelectStatementWithCTEContext
	KW_MANAGED() antlr.TerminalNode

	// IsCreateTableStatementContext differentiates from other interfaces.
	IsCreateTableStatementContext()
}

type CreateTableStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	temp antlr.Token
	trans antlr.Token
	ext antlr.Token
	name ITableNameContext 
	mgd antlr.Token
}

func NewEmptyCreateTableStatementContext() *CreateTableStatementContext {
	var p = new(CreateTableStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_createTableStatement
	return p
}

func InitEmptyCreateTableStatementContext(p *CreateTableStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_createTableStatement
}

func (*CreateTableStatementContext) IsCreateTableStatementContext() {}

func NewCreateTableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateTableStatementContext {
	var p = new(CreateTableStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_createTableStatement

	return p
}

func (s *CreateTableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateTableStatementContext) GetTemp() antlr.Token { return s.temp }

func (s *CreateTableStatementContext) GetTrans() antlr.Token { return s.trans }

func (s *CreateTableStatementContext) GetExt() antlr.Token { return s.ext }

func (s *CreateTableStatementContext) GetMgd() antlr.Token { return s.mgd }


func (s *CreateTableStatementContext) SetTemp(v antlr.Token) { s.temp = v }

func (s *CreateTableStatementContext) SetTrans(v antlr.Token) { s.trans = v }

func (s *CreateTableStatementContext) SetExt(v antlr.Token) { s.ext = v }

func (s *CreateTableStatementContext) SetMgd(v antlr.Token) { s.mgd = v }


func (s *CreateTableStatementContext) GetName() ITableNameContext { return s.name }


func (s *CreateTableStatementContext) SetName(v ITableNameContext) { s.name = v }


func (s *CreateTableStatementContext) KW_CREATE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_CREATE, 0)
}

func (s *CreateTableStatementContext) KW_TABLE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TABLE, 0)
}

func (s *CreateTableStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *CreateTableStatementContext) LikeTableOrFile() ILikeTableOrFileContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILikeTableOrFileContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILikeTableOrFileContext)
}

func (s *CreateTableStatementContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *CreateTableStatementContext) KW_TEMPORARY() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TEMPORARY, 0)
}

func (s *CreateTableStatementContext) KW_TRANSACTIONAL() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TRANSACTIONAL, 0)
}

func (s *CreateTableStatementContext) KW_EXTERNAL() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_EXTERNAL, 0)
}

func (s *CreateTableStatementContext) CreateTablePartitionSpec() ICreateTablePartitionSpecContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateTablePartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateTablePartitionSpecContext)
}

func (s *CreateTableStatementContext) TableRowFormat() ITableRowFormatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableRowFormatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableRowFormatContext)
}

func (s *CreateTableStatementContext) TableFileFormat() ITableFileFormatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableFileFormatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableFileFormatContext)
}

func (s *CreateTableStatementContext) TableLocation() ITableLocationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableLocationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableLocationContext)
}

func (s *CreateTableStatementContext) TablePropertiesPrefixed() ITablePropertiesPrefixedContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablePropertiesPrefixedContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablePropertiesPrefixedContext)
}

func (s *CreateTableStatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserLPAREN, 0)
}

func (s *CreateTableStatementContext) ColumnNameTypeOrConstraintList() IColumnNameTypeOrConstraintListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNameTypeOrConstraintListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNameTypeOrConstraintListContext)
}

func (s *CreateTableStatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserRPAREN, 0)
}

func (s *CreateTableStatementContext) TableComment() ITableCommentContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableCommentContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableCommentContext)
}

func (s *CreateTableStatementContext) TableBuckets() ITableBucketsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableBucketsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableBucketsContext)
}

func (s *CreateTableStatementContext) TableSkewed() ITableSkewedContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableSkewedContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableSkewedContext)
}

func (s *CreateTableStatementContext) KW_AS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_AS, 0)
}

func (s *CreateTableStatementContext) SelectStatementWithCTE() ISelectStatementWithCTEContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementWithCTEContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementWithCTEContext)
}

func (s *CreateTableStatementContext) KW_MANAGED() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_MANAGED, 0)
}

func (s *CreateTableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CreateTableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterCreateTableStatement(s)
	}
}

func (s *CreateTableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitCreateTableStatement(s)
	}
}

func (s *CreateTableStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitCreateTableStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) CreateTableStatement() (localctx ICreateTableStatementContext) {
	localctx = NewCreateTableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 582, HiveParserRULE_createTableStatement)
	var _la int

	p.SetState(3641)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 410, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3518)
			p.Match(HiveParserKW_CREATE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(3520)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_TEMPORARY {
			{
				p.SetState(3519)

				var _m = p.Match(HiveParserKW_TEMPORARY)

				localctx.(*CreateTableStatementContext).temp = _m
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		p.SetState(3523)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_TRANSACTIONAL {
			{
				p.SetState(3522)

				var _m = p.Match(HiveParserKW_TRANSACTIONAL)

				localctx.(*CreateTableStatementContext).trans = _m
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		p.SetState(3526)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_EXTERNAL {
			{
				p.SetState(3525)

				var _m = p.Match(HiveParserKW_EXTERNAL)

				localctx.(*CreateTableStatementContext).ext = _m
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(3528)
			p.Match(HiveParserKW_TABLE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(3530)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_IF {
			{
				p.SetState(3529)
				p.IfNotExists()
			}

		}
		{
			p.SetState(3532)

			var _x = p.TableName()


			localctx.(*CreateTableStatementContext).name = _x
		}
		p.SetState(3583)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case HiveParserKW_LIKE:
			{
				p.SetState(3533)
				p.LikeTableOrFile()
			}
			p.SetState(3535)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == HiveParserKW_PARTITIONED {
				{
					p.SetState(3534)
					p.CreateTablePartitionSpec()
				}

			}
			p.SetState(3538)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == HiveParserKW_ROW {
				{
					p.SetState(3537)
					p.TableRowFormat()
				}

			}
			p.SetState(3541)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == HiveParserKW_STORED {
				{
					p.SetState(3540)
					p.TableFileFormat()
				}

			}
			p.SetState(3544)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == HiveParserKW_LOCATION {
				{
					p.SetState(3543)
					p.TableLocation()
				}

			}
			p.SetState(3547)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == HiveParserKW_TBLPROPERTIES {
				{
					p.SetState(3546)
					p.TablePropertiesPrefixed()
				}

			}


		case HiveParserEOF, HiveParserKW_AS, HiveParserKW_CLUSTERED, HiveParserKW_COMMENT, HiveParserKW_LOCATION, HiveParserKW_PARTITIONED, HiveParserKW_ROW, HiveParserKW_SKEWED, HiveParserKW_STORED, HiveParserKW_TBLPROPERTIES, HiveParserLPAREN:
			p.SetState(3553)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == HiveParserLPAREN {
				{
					p.SetState(3549)
					p.Match(HiveParserLPAREN)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(3550)
					p.ColumnNameTypeOrConstraintList()
				}
				{
					p.SetState(3551)
					p.Match(HiveParserRPAREN)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}

			}
			p.SetState(3556)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == HiveParserKW_COMMENT {
				{
					p.SetState(3555)
					p.TableComment()
				}

			}
			p.SetState(3559)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == HiveParserKW_PARTITIONED {
				{
					p.SetState(3558)
					p.CreateTablePartitionSpec()
				}

			}
			p.SetState(3562)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == HiveParserKW_CLUSTERED {
				{
					p.SetState(3561)
					p.TableBuckets()
				}

			}
			p.SetState(3565)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == HiveParserKW_SKEWED {
				{
					p.SetState(3564)
					p.TableSkewed()
				}

			}
			p.SetState(3568)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == HiveParserKW_ROW {
				{
					p.SetState(3567)
					p.TableRowFormat()
				}

			}
			p.SetState(3571)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == HiveParserKW_STORED {
				{
					p.SetState(3570)
					p.TableFileFormat()
				}

			}
			p.SetState(3574)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == HiveParserKW_LOCATION {
				{
					p.SetState(3573)
					p.TableLocation()
				}

			}
			p.SetState(3577)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == HiveParserKW_TBLPROPERTIES {
				{
					p.SetState(3576)
					p.TablePropertiesPrefixed()
				}

			}
			p.SetState(3581)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == HiveParserKW_AS {
				{
					p.SetState(3579)
					p.Match(HiveParserKW_AS)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(3580)
					p.SelectStatementWithCTE()
				}

			}



		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3585)
			p.Match(HiveParserKW_CREATE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3586)

			var _m = p.Match(HiveParserKW_MANAGED)

			localctx.(*CreateTableStatementContext).mgd = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3587)
			p.Match(HiveParserKW_TABLE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(3589)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_IF {
			{
				p.SetState(3588)
				p.IfNotExists()
			}

		}
		{
			p.SetState(3591)

			var _x = p.TableName()


			localctx.(*CreateTableStatementContext).name = _x
		}
		p.SetState(3639)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case HiveParserKW_LIKE:
			{
				p.SetState(3592)
				p.LikeTableOrFile()
			}
			p.SetState(3594)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == HiveParserKW_ROW {
				{
					p.SetState(3593)
					p.TableRowFormat()
				}

			}
			p.SetState(3597)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == HiveParserKW_STORED {
				{
					p.SetState(3596)
					p.TableFileFormat()
				}

			}
			p.SetState(3600)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == HiveParserKW_LOCATION {
				{
					p.SetState(3599)
					p.TableLocation()
				}

			}
			p.SetState(3603)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == HiveParserKW_TBLPROPERTIES {
				{
					p.SetState(3602)
					p.TablePropertiesPrefixed()
				}

			}


		case HiveParserEOF, HiveParserKW_AS, HiveParserKW_CLUSTERED, HiveParserKW_COMMENT, HiveParserKW_LOCATION, HiveParserKW_PARTITIONED, HiveParserKW_ROW, HiveParserKW_SKEWED, HiveParserKW_STORED, HiveParserKW_TBLPROPERTIES, HiveParserLPAREN:
			p.SetState(3609)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == HiveParserLPAREN {
				{
					p.SetState(3605)
					p.Match(HiveParserLPAREN)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(3606)
					p.ColumnNameTypeOrConstraintList()
				}
				{
					p.SetState(3607)
					p.Match(HiveParserRPAREN)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}

			}
			p.SetState(3612)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == HiveParserKW_COMMENT {
				{
					p.SetState(3611)
					p.TableComment()
				}

			}
			p.SetState(3615)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == HiveParserKW_PARTITIONED {
				{
					p.SetState(3614)
					p.CreateTablePartitionSpec()
				}

			}
			p.SetState(3618)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == HiveParserKW_CLUSTERED {
				{
					p.SetState(3617)
					p.TableBuckets()
				}

			}
			p.SetState(3621)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == HiveParserKW_SKEWED {
				{
					p.SetState(3620)
					p.TableSkewed()
				}

			}
			p.SetState(3624)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == HiveParserKW_ROW {
				{
					p.SetState(3623)
					p.TableRowFormat()
				}

			}
			p.SetState(3627)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == HiveParserKW_STORED {
				{
					p.SetState(3626)
					p.TableFileFormat()
				}

			}
			p.SetState(3630)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == HiveParserKW_LOCATION {
				{
					p.SetState(3629)
					p.TableLocation()
				}

			}
			p.SetState(3633)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == HiveParserKW_TBLPROPERTIES {
				{
					p.SetState(3632)
					p.TablePropertiesPrefixed()
				}

			}
			p.SetState(3637)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == HiveParserKW_AS {
				{
					p.SetState(3635)
					p.Match(HiveParserKW_AS)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(3636)
					p.SelectStatementWithCTE()
				}

			}



		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreateDataConnectorStatementContext is an interface to support dynamic dispatch.
type ICreateDataConnectorStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IId_Context

	// GetDcprops returns the dcprops rule contexts.
	GetDcprops() IDcPropertiesContext


	// SetName sets the name rule contexts.
	SetName(IId_Context)

	// SetDcprops sets the dcprops rule contexts.
	SetDcprops(IDcPropertiesContext)


	// Getter signatures
	KW_CREATE() antlr.TerminalNode
	KW_DATACONNECTOR() antlr.TerminalNode
	DataConnectorType() IDataConnectorTypeContext
	DataConnectorUrl() IDataConnectorUrlContext
	Id_() IId_Context
	IfNotExists() IIfNotExistsContext
	DataConnectorComment() IDataConnectorCommentContext
	KW_WITH() antlr.TerminalNode
	KW_DCPROPERTIES() antlr.TerminalNode
	DcProperties() IDcPropertiesContext

	// IsCreateDataConnectorStatementContext differentiates from other interfaces.
	IsCreateDataConnectorStatementContext()
}

type CreateDataConnectorStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name IId_Context 
	dcprops IDcPropertiesContext 
}

func NewEmptyCreateDataConnectorStatementContext() *CreateDataConnectorStatementContext {
	var p = new(CreateDataConnectorStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_createDataConnectorStatement
	return p
}

func InitEmptyCreateDataConnectorStatementContext(p *CreateDataConnectorStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_createDataConnectorStatement
}

func (*CreateDataConnectorStatementContext) IsCreateDataConnectorStatementContext() {}

func NewCreateDataConnectorStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateDataConnectorStatementContext {
	var p = new(CreateDataConnectorStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_createDataConnectorStatement

	return p
}

func (s *CreateDataConnectorStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateDataConnectorStatementContext) GetName() IId_Context { return s.name }

func (s *CreateDataConnectorStatementContext) GetDcprops() IDcPropertiesContext { return s.dcprops }


func (s *CreateDataConnectorStatementContext) SetName(v IId_Context) { s.name = v }

func (s *CreateDataConnectorStatementContext) SetDcprops(v IDcPropertiesContext) { s.dcprops = v }


func (s *CreateDataConnectorStatementContext) KW_CREATE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_CREATE, 0)
}

func (s *CreateDataConnectorStatementContext) KW_DATACONNECTOR() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DATACONNECTOR, 0)
}

func (s *CreateDataConnectorStatementContext) DataConnectorType() IDataConnectorTypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataConnectorTypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataConnectorTypeContext)
}

func (s *CreateDataConnectorStatementContext) DataConnectorUrl() IDataConnectorUrlContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataConnectorUrlContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataConnectorUrlContext)
}

func (s *CreateDataConnectorStatementContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *CreateDataConnectorStatementContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *CreateDataConnectorStatementContext) DataConnectorComment() IDataConnectorCommentContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataConnectorCommentContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataConnectorCommentContext)
}

func (s *CreateDataConnectorStatementContext) KW_WITH() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_WITH, 0)
}

func (s *CreateDataConnectorStatementContext) KW_DCPROPERTIES() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DCPROPERTIES, 0)
}

func (s *CreateDataConnectorStatementContext) DcProperties() IDcPropertiesContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDcPropertiesContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDcPropertiesContext)
}

func (s *CreateDataConnectorStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateDataConnectorStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CreateDataConnectorStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterCreateDataConnectorStatement(s)
	}
}

func (s *CreateDataConnectorStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitCreateDataConnectorStatement(s)
	}
}

func (s *CreateDataConnectorStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitCreateDataConnectorStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) CreateDataConnectorStatement() (localctx ICreateDataConnectorStatementContext) {
	localctx = NewCreateDataConnectorStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 584, HiveParserRULE_createDataConnectorStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3643)
		p.Match(HiveParserKW_CREATE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3644)
		p.Match(HiveParserKW_DATACONNECTOR)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(3646)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_IF {
		{
			p.SetState(3645)
			p.IfNotExists()
		}

	}
	{
		p.SetState(3648)

		var _x = p.Id_()


		localctx.(*CreateDataConnectorStatementContext).name = _x
	}
	{
		p.SetState(3649)
		p.DataConnectorType()
	}
	{
		p.SetState(3650)
		p.DataConnectorUrl()
	}
	p.SetState(3652)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_COMMENT {
		{
			p.SetState(3651)
			p.DataConnectorComment()
		}

	}
	p.SetState(3657)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_WITH {
		{
			p.SetState(3654)
			p.Match(HiveParserKW_WITH)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3655)
			p.Match(HiveParserKW_DCPROPERTIES)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3656)

			var _x = p.DcProperties()


			localctx.(*CreateDataConnectorStatementContext).dcprops = _x
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDataConnectorCommentContext is an interface to support dynamic dispatch.
type IDataConnectorCommentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetComment returns the comment token.
	GetComment() antlr.Token 


	// SetComment sets the comment token.
	SetComment(antlr.Token) 


	// Getter signatures
	KW_COMMENT() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode

	// IsDataConnectorCommentContext differentiates from other interfaces.
	IsDataConnectorCommentContext()
}

type DataConnectorCommentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	comment antlr.Token
}

func NewEmptyDataConnectorCommentContext() *DataConnectorCommentContext {
	var p = new(DataConnectorCommentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_dataConnectorComment
	return p
}

func InitEmptyDataConnectorCommentContext(p *DataConnectorCommentContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_dataConnectorComment
}

func (*DataConnectorCommentContext) IsDataConnectorCommentContext() {}

func NewDataConnectorCommentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataConnectorCommentContext {
	var p = new(DataConnectorCommentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_dataConnectorComment

	return p
}

func (s *DataConnectorCommentContext) GetParser() antlr.Parser { return s.parser }

func (s *DataConnectorCommentContext) GetComment() antlr.Token { return s.comment }


func (s *DataConnectorCommentContext) SetComment(v antlr.Token) { s.comment = v }


func (s *DataConnectorCommentContext) KW_COMMENT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_COMMENT, 0)
}

func (s *DataConnectorCommentContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(HiveParserStringLiteral, 0)
}

func (s *DataConnectorCommentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataConnectorCommentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DataConnectorCommentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterDataConnectorComment(s)
	}
}

func (s *DataConnectorCommentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitDataConnectorComment(s)
	}
}

func (s *DataConnectorCommentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitDataConnectorComment(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) DataConnectorComment() (localctx IDataConnectorCommentContext) {
	localctx = NewDataConnectorCommentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 586, HiveParserRULE_dataConnectorComment)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3659)
		p.Match(HiveParserKW_COMMENT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3660)

		var _m = p.Match(HiveParserStringLiteral)

		localctx.(*DataConnectorCommentContext).comment = _m
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDataConnectorUrlContext is an interface to support dynamic dispatch.
type IDataConnectorUrlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetUrl returns the url token.
	GetUrl() antlr.Token 


	// SetUrl sets the url token.
	SetUrl(antlr.Token) 


	// Getter signatures
	KW_URL() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode

	// IsDataConnectorUrlContext differentiates from other interfaces.
	IsDataConnectorUrlContext()
}

type DataConnectorUrlContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	url antlr.Token
}

func NewEmptyDataConnectorUrlContext() *DataConnectorUrlContext {
	var p = new(DataConnectorUrlContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_dataConnectorUrl
	return p
}

func InitEmptyDataConnectorUrlContext(p *DataConnectorUrlContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_dataConnectorUrl
}

func (*DataConnectorUrlContext) IsDataConnectorUrlContext() {}

func NewDataConnectorUrlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataConnectorUrlContext {
	var p = new(DataConnectorUrlContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_dataConnectorUrl

	return p
}

func (s *DataConnectorUrlContext) GetParser() antlr.Parser { return s.parser }

func (s *DataConnectorUrlContext) GetUrl() antlr.Token { return s.url }


func (s *DataConnectorUrlContext) SetUrl(v antlr.Token) { s.url = v }


func (s *DataConnectorUrlContext) KW_URL() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_URL, 0)
}

func (s *DataConnectorUrlContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(HiveParserStringLiteral, 0)
}

func (s *DataConnectorUrlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataConnectorUrlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DataConnectorUrlContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterDataConnectorUrl(s)
	}
}

func (s *DataConnectorUrlContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitDataConnectorUrl(s)
	}
}

func (s *DataConnectorUrlContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitDataConnectorUrl(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) DataConnectorUrl() (localctx IDataConnectorUrlContext) {
	localctx = NewDataConnectorUrlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 588, HiveParserRULE_dataConnectorUrl)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3662)
		p.Match(HiveParserKW_URL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3663)

		var _m = p.Match(HiveParserStringLiteral)

		localctx.(*DataConnectorUrlContext).url = _m
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDataConnectorTypeContext is an interface to support dynamic dispatch.
type IDataConnectorTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDcType returns the dcType token.
	GetDcType() antlr.Token 


	// SetDcType sets the dcType token.
	SetDcType(antlr.Token) 


	// Getter signatures
	KW_TYPE() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode

	// IsDataConnectorTypeContext differentiates from other interfaces.
	IsDataConnectorTypeContext()
}

type DataConnectorTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	dcType antlr.Token
}

func NewEmptyDataConnectorTypeContext() *DataConnectorTypeContext {
	var p = new(DataConnectorTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_dataConnectorType
	return p
}

func InitEmptyDataConnectorTypeContext(p *DataConnectorTypeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_dataConnectorType
}

func (*DataConnectorTypeContext) IsDataConnectorTypeContext() {}

func NewDataConnectorTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataConnectorTypeContext {
	var p = new(DataConnectorTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_dataConnectorType

	return p
}

func (s *DataConnectorTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *DataConnectorTypeContext) GetDcType() antlr.Token { return s.dcType }


func (s *DataConnectorTypeContext) SetDcType(v antlr.Token) { s.dcType = v }


func (s *DataConnectorTypeContext) KW_TYPE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TYPE, 0)
}

func (s *DataConnectorTypeContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(HiveParserStringLiteral, 0)
}

func (s *DataConnectorTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataConnectorTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DataConnectorTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterDataConnectorType(s)
	}
}

func (s *DataConnectorTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitDataConnectorType(s)
	}
}

func (s *DataConnectorTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitDataConnectorType(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) DataConnectorType() (localctx IDataConnectorTypeContext) {
	localctx = NewDataConnectorTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 590, HiveParserRULE_dataConnectorType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3665)
		p.Match(HiveParserKW_TYPE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3666)

		var _m = p.Match(HiveParserStringLiteral)

		localctx.(*DataConnectorTypeContext).dcType = _m
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDcPropertiesContext is an interface to support dynamic dispatch.
type IDcPropertiesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	DbPropertiesList() IDbPropertiesListContext
	RPAREN() antlr.TerminalNode

	// IsDcPropertiesContext differentiates from other interfaces.
	IsDcPropertiesContext()
}

type DcPropertiesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDcPropertiesContext() *DcPropertiesContext {
	var p = new(DcPropertiesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_dcProperties
	return p
}

func InitEmptyDcPropertiesContext(p *DcPropertiesContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_dcProperties
}

func (*DcPropertiesContext) IsDcPropertiesContext() {}

func NewDcPropertiesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DcPropertiesContext {
	var p = new(DcPropertiesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_dcProperties

	return p
}

func (s *DcPropertiesContext) GetParser() antlr.Parser { return s.parser }

func (s *DcPropertiesContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserLPAREN, 0)
}

func (s *DcPropertiesContext) DbPropertiesList() IDbPropertiesListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDbPropertiesListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDbPropertiesListContext)
}

func (s *DcPropertiesContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserRPAREN, 0)
}

func (s *DcPropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DcPropertiesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DcPropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterDcProperties(s)
	}
}

func (s *DcPropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitDcProperties(s)
	}
}

func (s *DcPropertiesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitDcProperties(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) DcProperties() (localctx IDcPropertiesContext) {
	localctx = NewDcPropertiesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 592, HiveParserRULE_dcProperties)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3668)
		p.Match(HiveParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3669)
		p.DbPropertiesList()
	}
	{
		p.SetState(3670)
		p.Match(HiveParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDropDataConnectorStatementContext is an interface to support dynamic dispatch.
type IDropDataConnectorStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_DROP() antlr.TerminalNode
	KW_DATACONNECTOR() antlr.TerminalNode
	Id_() IId_Context
	IfExists() IIfExistsContext

	// IsDropDataConnectorStatementContext differentiates from other interfaces.
	IsDropDataConnectorStatementContext()
}

type DropDataConnectorStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropDataConnectorStatementContext() *DropDataConnectorStatementContext {
	var p = new(DropDataConnectorStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_dropDataConnectorStatement
	return p
}

func InitEmptyDropDataConnectorStatementContext(p *DropDataConnectorStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_dropDataConnectorStatement
}

func (*DropDataConnectorStatementContext) IsDropDataConnectorStatementContext() {}

func NewDropDataConnectorStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropDataConnectorStatementContext {
	var p = new(DropDataConnectorStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_dropDataConnectorStatement

	return p
}

func (s *DropDataConnectorStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropDataConnectorStatementContext) KW_DROP() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DROP, 0)
}

func (s *DropDataConnectorStatementContext) KW_DATACONNECTOR() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DATACONNECTOR, 0)
}

func (s *DropDataConnectorStatementContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *DropDataConnectorStatementContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropDataConnectorStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropDataConnectorStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DropDataConnectorStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterDropDataConnectorStatement(s)
	}
}

func (s *DropDataConnectorStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitDropDataConnectorStatement(s)
	}
}

func (s *DropDataConnectorStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitDropDataConnectorStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) DropDataConnectorStatement() (localctx IDropDataConnectorStatementContext) {
	localctx = NewDropDataConnectorStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 594, HiveParserRULE_dropDataConnectorStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3672)
		p.Match(HiveParserKW_DROP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3673)
		p.Match(HiveParserKW_DATACONNECTOR)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(3675)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_IF {
		{
			p.SetState(3674)
			p.IfExists()
		}

	}
	{
		p.SetState(3677)
		p.Id_()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITableAllColumnsContext is an interface to support dynamic dispatch.
type ITableAllColumnsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STAR() antlr.TerminalNode
	TableName() ITableNameContext
	DOT() antlr.TerminalNode

	// IsTableAllColumnsContext differentiates from other interfaces.
	IsTableAllColumnsContext()
}

type TableAllColumnsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableAllColumnsContext() *TableAllColumnsContext {
	var p = new(TableAllColumnsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_tableAllColumns
	return p
}

func InitEmptyTableAllColumnsContext(p *TableAllColumnsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_tableAllColumns
}

func (*TableAllColumnsContext) IsTableAllColumnsContext() {}

func NewTableAllColumnsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableAllColumnsContext {
	var p = new(TableAllColumnsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_tableAllColumns

	return p
}

func (s *TableAllColumnsContext) GetParser() antlr.Parser { return s.parser }

func (s *TableAllColumnsContext) STAR() antlr.TerminalNode {
	return s.GetToken(HiveParserSTAR, 0)
}

func (s *TableAllColumnsContext) TableName() ITableNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *TableAllColumnsContext) DOT() antlr.TerminalNode {
	return s.GetToken(HiveParserDOT, 0)
}

func (s *TableAllColumnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableAllColumnsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TableAllColumnsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterTableAllColumns(s)
	}
}

func (s *TableAllColumnsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitTableAllColumns(s)
	}
}

func (s *TableAllColumnsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitTableAllColumns(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) TableAllColumns() (localctx ITableAllColumnsContext) {
	localctx = NewTableAllColumnsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 596, HiveParserRULE_tableAllColumns)
	p.SetState(3684)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserSTAR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3679)
			p.Match(HiveParserSTAR)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HiveParserKW_ABORT, HiveParserKW_ACTIVATE, HiveParserKW_ACTIVE, HiveParserKW_ADD, HiveParserKW_ADMIN, HiveParserKW_AFTER, HiveParserKW_ALLOC_FRACTION, HiveParserKW_ANALYZE, HiveParserKW_ARCHIVE, HiveParserKW_ASC, HiveParserKW_AST, HiveParserKW_AT, HiveParserKW_AUTOCOMMIT, HiveParserKW_BATCH, HiveParserKW_BEFORE, HiveParserKW_BUCKET, HiveParserKW_BUCKETS, HiveParserKW_CACHE, HiveParserKW_CASCADE, HiveParserKW_CBO, HiveParserKW_CHANGE, HiveParserKW_CHECK, HiveParserKW_CLUSTER, HiveParserKW_CLUSTERED, HiveParserKW_CLUSTERSTATUS, HiveParserKW_COLLECTION, HiveParserKW_COLUMNS, HiveParserKW_COMMENT, HiveParserKW_COMPACT, HiveParserKW_COMPACTIONS, HiveParserKW_COMPUTE, HiveParserKW_CONCATENATE, HiveParserKW_CONTINUE, HiveParserKW_COST, HiveParserKW_CRON, HiveParserKW_DATA, HiveParserKW_DATABASES, HiveParserKW_DATETIME, HiveParserKW_DAY, HiveParserKW_DAYOFWEEK, HiveParserKW_DBPROPERTIES, HiveParserKW_DCPROPERTIES, HiveParserKW_DEBUG, HiveParserKW_DEFAULT, HiveParserKW_DEFERRED, HiveParserKW_DEFINED, HiveParserKW_DELIMITED, HiveParserKW_DEPENDENCY, HiveParserKW_DESC, HiveParserKW_DETAIL, HiveParserKW_DIRECTORIES, HiveParserKW_DIRECTORY, HiveParserKW_DISABLE, HiveParserKW_DISTRIBUTE, HiveParserKW_DISTRIBUTED, HiveParserKW_DO, HiveParserKW_DOW, HiveParserKW_DUMP, HiveParserKW_ELEM_TYPE, HiveParserKW_ENABLE, HiveParserKW_ENFORCED, HiveParserKW_ESCAPED, HiveParserKW_EVERY, HiveParserKW_EXCLUSIVE, HiveParserKW_EXECUTE, HiveParserKW_EXECUTED, HiveParserKW_EXPIRE_SNAPSHOTS, HiveParserKW_EXPLAIN, HiveParserKW_EXPORT, HiveParserKW_EXPRESSION, HiveParserKW_FIELDS, HiveParserKW_FILE, HiveParserKW_FILEFORMAT, HiveParserKW_FIRST, HiveParserKW_FORMAT, HiveParserKW_FORMATTED, HiveParserKW_FUNCTIONS, HiveParserKW_HOLD_DDLTIME, HiveParserKW_HOUR, HiveParserKW_IDXPROPERTIES, HiveParserKW_IGNORE, HiveParserKW_INDEX, HiveParserKW_INDEXES, HiveParserKW_INPATH, HiveParserKW_INPUTDRIVER, HiveParserKW_INPUTFORMAT, HiveParserKW_ISOLATION, HiveParserKW_ITEMS, HiveParserKW_JAR, HiveParserKW_JOINCOST, HiveParserKW_KEY, HiveParserKW_KEYS, HiveParserKW_KEY_TYPE, HiveParserKW_KILL, HiveParserKW_LAST, HiveParserKW_LEVEL, HiveParserKW_LIMIT, HiveParserKW_LINES, HiveParserKW_LOAD, HiveParserKW_LOCATION, HiveParserKW_LOCK, HiveParserKW_LOCKS, HiveParserKW_LOGICAL, HiveParserKW_LONG, HiveParserKW_MANAGED, HiveParserKW_MANAGEDLOCATION, HiveParserKW_MANAGEMENT, HiveParserKW_MAPJOIN, HiveParserKW_MAPPING, HiveParserKW_MATCHED, HiveParserKW_MATERIALIZED, HiveParserKW_METADATA, HiveParserKW_MINUTE, HiveParserKW_MONTH, HiveParserKW_MOVE, HiveParserKW_MSCK, HiveParserKW_NORELY, HiveParserKW_NOSCAN, HiveParserKW_NOVALIDATE, HiveParserKW_NO_DROP, HiveParserKW_NULLS, HiveParserKW_OFFLINE, HiveParserKW_OFFSET, HiveParserKW_OPERATOR, HiveParserKW_OPTION, HiveParserKW_OUTPUTDRIVER, HiveParserKW_OUTPUTFORMAT, HiveParserKW_OVERWRITE, HiveParserKW_OWNER, HiveParserKW_PARTITIONED, HiveParserKW_PARTITIONS, HiveParserKW_PATH, HiveParserKW_PLAN, HiveParserKW_PLANS, HiveParserKW_PLUS, HiveParserKW_POOL, HiveParserKW_PRINCIPALS, HiveParserKW_PROTECTION, HiveParserKW_PURGE, HiveParserKW_QUARTER, HiveParserKW_QUERY, HiveParserKW_QUERY_PARALLELISM, HiveParserKW_READ, HiveParserKW_READONLY, HiveParserKW_REBUILD, HiveParserKW_RECORDREADER, HiveParserKW_RECORDWRITER, HiveParserKW_RELOAD, HiveParserKW_RELY, HiveParserKW_REMOTE, HiveParserKW_RENAME, HiveParserKW_REOPTIMIZATION, HiveParserKW_REPAIR, HiveParserKW_REPL, HiveParserKW_REPLACE, HiveParserKW_REPLICATION, HiveParserKW_RESOURCE, HiveParserKW_RESPECT, HiveParserKW_RESTRICT, HiveParserKW_REWRITE, HiveParserKW_ROLE, HiveParserKW_ROLES, HiveParserKW_SCHEDULED, HiveParserKW_SCHEDULING_POLICY, HiveParserKW_SCHEMA, HiveParserKW_SCHEMAS, HiveParserKW_SECOND, HiveParserKW_SEMI, HiveParserKW_SERDE, HiveParserKW_SERDEPROPERTIES, HiveParserKW_SERVER, HiveParserKW_SETS, HiveParserKW_SET_CURRENT_SNAPSHOT, HiveParserKW_SHARED, HiveParserKW_SHOW, HiveParserKW_SHOW_DATABASE, HiveParserKW_SKEWED, HiveParserKW_SNAPSHOT, HiveParserKW_SORT, HiveParserKW_SORTED, HiveParserKW_SPEC, HiveParserKW_SSL, HiveParserKW_STATISTICS, HiveParserKW_STATUS, HiveParserKW_STORED, HiveParserKW_STREAMTABLE, HiveParserKW_STRING, HiveParserKW_STRUCT, HiveParserKW_SUMMARY, HiveParserKW_SYSTEM_TIME, HiveParserKW_SYSTEM_VERSION, HiveParserKW_TABLES, HiveParserKW_TBLPROPERTIES, HiveParserKW_TEMPORARY, HiveParserKW_TERMINATED, HiveParserKW_TIMESTAMPTZ, HiveParserKW_TINYINT, HiveParserKW_TOUCH, HiveParserKW_TRANSACTION, HiveParserKW_TRANSACTIONAL, HiveParserKW_TRANSACTIONS, HiveParserKW_TRIM, HiveParserKW_TYPE, HiveParserKW_UNARCHIVE, HiveParserKW_UNDO, HiveParserKW_UNIONTYPE, HiveParserKW_UNKNOWN, HiveParserKW_UNLOCK, HiveParserKW_UNMANAGED, HiveParserKW_UNSET, HiveParserKW_UNSIGNED, HiveParserKW_URI, HiveParserKW_URL, HiveParserKW_USE, HiveParserKW_UTC, HiveParserKW_UTCTIMESTAMP, HiveParserKW_VALIDATE, HiveParserKW_VALUE_TYPE, HiveParserKW_VECTORIZATION, HiveParserKW_VIEW, HiveParserKW_VIEWS, HiveParserKW_WAIT, HiveParserKW_WEEK, HiveParserKW_WHILE, HiveParserKW_WITHIN, HiveParserKW_WORK, HiveParserKW_WORKLOAD, HiveParserKW_WRITE, HiveParserKW_YEAR, HiveParserKW_ZONE, HiveParserIdentifier:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3680)
			p.TableName()
		}
		{
			p.SetState(3681)
			p.Match(HiveParserDOT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3682)
			p.Match(HiveParserSTAR)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITableOrColumnContext is an interface to support dynamic dispatch.
type ITableOrColumnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Id_() IId_Context

	// IsTableOrColumnContext differentiates from other interfaces.
	IsTableOrColumnContext()
}

type TableOrColumnContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableOrColumnContext() *TableOrColumnContext {
	var p = new(TableOrColumnContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_tableOrColumn
	return p
}

func InitEmptyTableOrColumnContext(p *TableOrColumnContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_tableOrColumn
}

func (*TableOrColumnContext) IsTableOrColumnContext() {}

func NewTableOrColumnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableOrColumnContext {
	var p = new(TableOrColumnContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_tableOrColumn

	return p
}

func (s *TableOrColumnContext) GetParser() antlr.Parser { return s.parser }

func (s *TableOrColumnContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *TableOrColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOrColumnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TableOrColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterTableOrColumn(s)
	}
}

func (s *TableOrColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitTableOrColumn(s)
	}
}

func (s *TableOrColumnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitTableOrColumn(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) TableOrColumn() (localctx ITableOrColumnContext) {
	localctx = NewTableOrColumnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 598, HiveParserRULE_tableOrColumn)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3686)
		p.Id_()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDefaultValueContext is an interface to support dynamic dispatch.
type IDefaultValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_DEFAULT() antlr.TerminalNode

	// IsDefaultValueContext differentiates from other interfaces.
	IsDefaultValueContext()
}

type DefaultValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefaultValueContext() *DefaultValueContext {
	var p = new(DefaultValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_defaultValue
	return p
}

func InitEmptyDefaultValueContext(p *DefaultValueContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_defaultValue
}

func (*DefaultValueContext) IsDefaultValueContext() {}

func NewDefaultValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefaultValueContext {
	var p = new(DefaultValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_defaultValue

	return p
}

func (s *DefaultValueContext) GetParser() antlr.Parser { return s.parser }

func (s *DefaultValueContext) KW_DEFAULT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DEFAULT, 0)
}

func (s *DefaultValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DefaultValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterDefaultValue(s)
	}
}

func (s *DefaultValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitDefaultValue(s)
	}
}

func (s *DefaultValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitDefaultValue(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) DefaultValue() (localctx IDefaultValueContext) {
	localctx = NewDefaultValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 600, HiveParserRULE_defaultValue)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3688)
		p.Match(HiveParserKW_DEFAULT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExpressionListContext is an interface to support dynamic dispatch.
type IExpressionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsExpressionListContext differentiates from other interfaces.
	IsExpressionListContext()
}

type ExpressionListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionListContext() *ExpressionListContext {
	var p = new(ExpressionListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_expressionList
	return p
}

func InitEmptyExpressionListContext(p *ExpressionListContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_expressionList
}

func (*ExpressionListContext) IsExpressionListContext() {}

func NewExpressionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionListContext {
	var p = new(ExpressionListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_expressionList

	return p
}

func (s *ExpressionListContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionListContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionListContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(HiveParserCOMMA)
}

func (s *ExpressionListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserCOMMA, i)
}

func (s *ExpressionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ExpressionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterExpressionList(s)
	}
}

func (s *ExpressionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitExpressionList(s)
	}
}

func (s *ExpressionListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitExpressionList(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ExpressionList() (localctx IExpressionListContext) {
	localctx = NewExpressionListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 602, HiveParserRULE_expressionList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3690)
		p.Expression()
	}
	p.SetState(3695)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HiveParserCOMMA {
		{
			p.SetState(3691)
			p.Match(HiveParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3692)
			p.Expression()
		}


		p.SetState(3697)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAliasListContext is an interface to support dynamic dispatch.
type IAliasListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllId_() []IId_Context
	Id_(i int) IId_Context
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsAliasListContext differentiates from other interfaces.
	IsAliasListContext()
}

type AliasListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAliasListContext() *AliasListContext {
	var p = new(AliasListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_aliasList
	return p
}

func InitEmptyAliasListContext(p *AliasListContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_aliasList
}

func (*AliasListContext) IsAliasListContext() {}

func NewAliasListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AliasListContext {
	var p = new(AliasListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_aliasList

	return p
}

func (s *AliasListContext) GetParser() antlr.Parser { return s.parser }

func (s *AliasListContext) AllId_() []IId_Context {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IId_Context); ok {
			len++
		}
	}

	tst := make([]IId_Context, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IId_Context); ok {
			tst[i] = t.(IId_Context)
			i++
		}
	}

	return tst
}

func (s *AliasListContext) Id_(i int) IId_Context {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *AliasListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(HiveParserCOMMA)
}

func (s *AliasListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserCOMMA, i)
}

func (s *AliasListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AliasListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AliasListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterAliasList(s)
	}
}

func (s *AliasListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitAliasList(s)
	}
}

func (s *AliasListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitAliasList(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) AliasList() (localctx IAliasListContext) {
	localctx = NewAliasListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 604, HiveParserRULE_aliasList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3698)
		p.Id_()
	}
	p.SetState(3703)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HiveParserCOMMA {
		{
			p.SetState(3699)
			p.Match(HiveParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3700)
			p.Id_()
		}


		p.SetState(3705)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFromClauseContext is an interface to support dynamic dispatch.
type IFromClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_FROM() antlr.TerminalNode
	FromSource() IFromSourceContext

	// IsFromClauseContext differentiates from other interfaces.
	IsFromClauseContext()
}

type FromClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFromClauseContext() *FromClauseContext {
	var p = new(FromClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_fromClause
	return p
}

func InitEmptyFromClauseContext(p *FromClauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_fromClause
}

func (*FromClauseContext) IsFromClauseContext() {}

func NewFromClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FromClauseContext {
	var p = new(FromClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_fromClause

	return p
}

func (s *FromClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *FromClauseContext) KW_FROM() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_FROM, 0)
}

func (s *FromClauseContext) FromSource() IFromSourceContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromSourceContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromSourceContext)
}

func (s *FromClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FromClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *FromClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterFromClause(s)
	}
}

func (s *FromClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitFromClause(s)
	}
}

func (s *FromClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitFromClause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) FromClause() (localctx IFromClauseContext) {
	localctx = NewFromClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 606, HiveParserRULE_fromClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3706)
		p.Match(HiveParserKW_FROM)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3707)
		p.FromSource()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFromSourceContext is an interface to support dynamic dispatch.
type IFromSourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UniqueJoinToken() IUniqueJoinTokenContext
	AllUniqueJoinSource() []IUniqueJoinSourceContext
	UniqueJoinSource(i int) IUniqueJoinSourceContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	JoinSource() IJoinSourceContext

	// IsFromSourceContext differentiates from other interfaces.
	IsFromSourceContext()
}

type FromSourceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFromSourceContext() *FromSourceContext {
	var p = new(FromSourceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_fromSource
	return p
}

func InitEmptyFromSourceContext(p *FromSourceContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_fromSource
}

func (*FromSourceContext) IsFromSourceContext() {}

func NewFromSourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FromSourceContext {
	var p = new(FromSourceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_fromSource

	return p
}

func (s *FromSourceContext) GetParser() antlr.Parser { return s.parser }

func (s *FromSourceContext) UniqueJoinToken() IUniqueJoinTokenContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUniqueJoinTokenContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUniqueJoinTokenContext)
}

func (s *FromSourceContext) AllUniqueJoinSource() []IUniqueJoinSourceContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUniqueJoinSourceContext); ok {
			len++
		}
	}

	tst := make([]IUniqueJoinSourceContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUniqueJoinSourceContext); ok {
			tst[i] = t.(IUniqueJoinSourceContext)
			i++
		}
	}

	return tst
}

func (s *FromSourceContext) UniqueJoinSource(i int) IUniqueJoinSourceContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUniqueJoinSourceContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUniqueJoinSourceContext)
}

func (s *FromSourceContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(HiveParserCOMMA)
}

func (s *FromSourceContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserCOMMA, i)
}

func (s *FromSourceContext) JoinSource() IJoinSourceContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinSourceContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinSourceContext)
}

func (s *FromSourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FromSourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *FromSourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterFromSource(s)
	}
}

func (s *FromSourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitFromSource(s)
	}
}

func (s *FromSourceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitFromSource(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) FromSource() (localctx IFromSourceContext) {
	localctx = NewFromSourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 608, HiveParserRULE_fromSource)
	var _la int

	p.SetState(3718)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserKW_UNIQUEJOIN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3709)
			p.UniqueJoinToken()
		}
		{
			p.SetState(3710)
			p.UniqueJoinSource()
		}
		p.SetState(3713)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for ok := true; ok; ok = _la == HiveParserCOMMA {
			{
				p.SetState(3711)
				p.Match(HiveParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(3712)
				p.UniqueJoinSource()
			}


			p.SetState(3715)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}


	case HiveParserKW_ABORT, HiveParserKW_ACTIVATE, HiveParserKW_ACTIVE, HiveParserKW_ADD, HiveParserKW_ADMIN, HiveParserKW_AFTER, HiveParserKW_ALLOC_FRACTION, HiveParserKW_ANALYZE, HiveParserKW_ARCHIVE, HiveParserKW_ASC, HiveParserKW_AST, HiveParserKW_AT, HiveParserKW_AUTOCOMMIT, HiveParserKW_BATCH, HiveParserKW_BEFORE, HiveParserKW_BUCKET, HiveParserKW_BUCKETS, HiveParserKW_CACHE, HiveParserKW_CASCADE, HiveParserKW_CBO, HiveParserKW_CHANGE, HiveParserKW_CHECK, HiveParserKW_CLUSTER, HiveParserKW_CLUSTERED, HiveParserKW_CLUSTERSTATUS, HiveParserKW_COLLECTION, HiveParserKW_COLUMNS, HiveParserKW_COMMENT, HiveParserKW_COMPACT, HiveParserKW_COMPACTIONS, HiveParserKW_COMPUTE, HiveParserKW_CONCATENATE, HiveParserKW_CONTINUE, HiveParserKW_COST, HiveParserKW_CRON, HiveParserKW_DATA, HiveParserKW_DATABASES, HiveParserKW_DATETIME, HiveParserKW_DAY, HiveParserKW_DAYOFWEEK, HiveParserKW_DBPROPERTIES, HiveParserKW_DCPROPERTIES, HiveParserKW_DEBUG, HiveParserKW_DEFAULT, HiveParserKW_DEFERRED, HiveParserKW_DEFINED, HiveParserKW_DELIMITED, HiveParserKW_DEPENDENCY, HiveParserKW_DESC, HiveParserKW_DETAIL, HiveParserKW_DIRECTORIES, HiveParserKW_DIRECTORY, HiveParserKW_DISABLE, HiveParserKW_DISTRIBUTE, HiveParserKW_DISTRIBUTED, HiveParserKW_DO, HiveParserKW_DOW, HiveParserKW_DUMP, HiveParserKW_ELEM_TYPE, HiveParserKW_ENABLE, HiveParserKW_ENFORCED, HiveParserKW_ESCAPED, HiveParserKW_EVERY, HiveParserKW_EXCLUSIVE, HiveParserKW_EXECUTE, HiveParserKW_EXECUTED, HiveParserKW_EXPIRE_SNAPSHOTS, HiveParserKW_EXPLAIN, HiveParserKW_EXPORT, HiveParserKW_EXPRESSION, HiveParserKW_FIELDS, HiveParserKW_FILE, HiveParserKW_FILEFORMAT, HiveParserKW_FIRST, HiveParserKW_FORMAT, HiveParserKW_FORMATTED, HiveParserKW_FUNCTIONS, HiveParserKW_HOLD_DDLTIME, HiveParserKW_HOUR, HiveParserKW_IDXPROPERTIES, HiveParserKW_IGNORE, HiveParserKW_INDEX, HiveParserKW_INDEXES, HiveParserKW_INPATH, HiveParserKW_INPUTDRIVER, HiveParserKW_INPUTFORMAT, HiveParserKW_ISOLATION, HiveParserKW_ITEMS, HiveParserKW_JAR, HiveParserKW_JOINCOST, HiveParserKW_KEY, HiveParserKW_KEYS, HiveParserKW_KEY_TYPE, HiveParserKW_KILL, HiveParserKW_LAST, HiveParserKW_LEVEL, HiveParserKW_LIMIT, HiveParserKW_LINES, HiveParserKW_LOAD, HiveParserKW_LOCATION, HiveParserKW_LOCK, HiveParserKW_LOCKS, HiveParserKW_LOGICAL, HiveParserKW_LONG, HiveParserKW_MANAGED, HiveParserKW_MANAGEDLOCATION, HiveParserKW_MANAGEMENT, HiveParserKW_MAPJOIN, HiveParserKW_MAPPING, HiveParserKW_MATCHED, HiveParserKW_MATERIALIZED, HiveParserKW_METADATA, HiveParserKW_MINUTE, HiveParserKW_MONTH, HiveParserKW_MOVE, HiveParserKW_MSCK, HiveParserKW_NORELY, HiveParserKW_NOSCAN, HiveParserKW_NOVALIDATE, HiveParserKW_NO_DROP, HiveParserKW_NULLS, HiveParserKW_OFFLINE, HiveParserKW_OFFSET, HiveParserKW_OPERATOR, HiveParserKW_OPTION, HiveParserKW_OUTPUTDRIVER, HiveParserKW_OUTPUTFORMAT, HiveParserKW_OVERWRITE, HiveParserKW_OWNER, HiveParserKW_PARTITIONED, HiveParserKW_PARTITIONS, HiveParserKW_PATH, HiveParserKW_PLAN, HiveParserKW_PLANS, HiveParserKW_PLUS, HiveParserKW_POOL, HiveParserKW_PRINCIPALS, HiveParserKW_PROTECTION, HiveParserKW_PURGE, HiveParserKW_QUARTER, HiveParserKW_QUERY, HiveParserKW_QUERY_PARALLELISM, HiveParserKW_READ, HiveParserKW_READONLY, HiveParserKW_REBUILD, HiveParserKW_RECORDREADER, HiveParserKW_RECORDWRITER, HiveParserKW_RELOAD, HiveParserKW_RELY, HiveParserKW_REMOTE, HiveParserKW_RENAME, HiveParserKW_REOPTIMIZATION, HiveParserKW_REPAIR, HiveParserKW_REPL, HiveParserKW_REPLACE, HiveParserKW_REPLICATION, HiveParserKW_RESOURCE, HiveParserKW_RESPECT, HiveParserKW_RESTRICT, HiveParserKW_REWRITE, HiveParserKW_ROLE, HiveParserKW_ROLES, HiveParserKW_SCHEDULED, HiveParserKW_SCHEDULING_POLICY, HiveParserKW_SCHEMA, HiveParserKW_SCHEMAS, HiveParserKW_SECOND, HiveParserKW_SEMI, HiveParserKW_SERDE, HiveParserKW_SERDEPROPERTIES, HiveParserKW_SERVER, HiveParserKW_SETS, HiveParserKW_SET_CURRENT_SNAPSHOT, HiveParserKW_SHARED, HiveParserKW_SHOW, HiveParserKW_SHOW_DATABASE, HiveParserKW_SKEWED, HiveParserKW_SNAPSHOT, HiveParserKW_SORT, HiveParserKW_SORTED, HiveParserKW_SPEC, HiveParserKW_SSL, HiveParserKW_STATISTICS, HiveParserKW_STATUS, HiveParserKW_STORED, HiveParserKW_STREAMTABLE, HiveParserKW_STRING, HiveParserKW_STRUCT, HiveParserKW_SUMMARY, HiveParserKW_SYSTEM_TIME, HiveParserKW_SYSTEM_VERSION, HiveParserKW_TABLE, HiveParserKW_TABLES, HiveParserKW_TBLPROPERTIES, HiveParserKW_TEMPORARY, HiveParserKW_TERMINATED, HiveParserKW_TIMESTAMPTZ, HiveParserKW_TINYINT, HiveParserKW_TOUCH, HiveParserKW_TRANSACTION, HiveParserKW_TRANSACTIONAL, HiveParserKW_TRANSACTIONS, HiveParserKW_TRIM, HiveParserKW_TYPE, HiveParserKW_UNARCHIVE, HiveParserKW_UNDO, HiveParserKW_UNIONTYPE, HiveParserKW_UNKNOWN, HiveParserKW_UNLOCK, HiveParserKW_UNMANAGED, HiveParserKW_UNSET, HiveParserKW_UNSIGNED, HiveParserKW_URI, HiveParserKW_URL, HiveParserKW_USE, HiveParserKW_UTC, HiveParserKW_UTCTIMESTAMP, HiveParserKW_VALIDATE, HiveParserKW_VALUE_TYPE, HiveParserKW_VECTORIZATION, HiveParserKW_VIEW, HiveParserKW_VIEWS, HiveParserKW_WAIT, HiveParserKW_WEEK, HiveParserKW_WHILE, HiveParserKW_WITHIN, HiveParserKW_WORK, HiveParserKW_WORKLOAD, HiveParserKW_WRITE, HiveParserKW_YEAR, HiveParserKW_ZONE, HiveParserLPAREN, HiveParserIdentifier:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3717)
			p.JoinSource()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAtomjoinSourceContext is an interface to support dynamic dispatch.
type IAtomjoinSourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TableSource() ITableSourceContext
	AllLateralView() []ILateralViewContext
	LateralView(i int) ILateralViewContext
	VirtualTableSource() IVirtualTableSourceContext
	SubQuerySource() ISubQuerySourceContext
	PartitionedTableFunction() IPartitionedTableFunctionContext
	LPAREN() antlr.TerminalNode
	JoinSource() IJoinSourceContext
	RPAREN() antlr.TerminalNode

	// IsAtomjoinSourceContext differentiates from other interfaces.
	IsAtomjoinSourceContext()
}

type AtomjoinSourceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtomjoinSourceContext() *AtomjoinSourceContext {
	var p = new(AtomjoinSourceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_atomjoinSource
	return p
}

func InitEmptyAtomjoinSourceContext(p *AtomjoinSourceContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_atomjoinSource
}

func (*AtomjoinSourceContext) IsAtomjoinSourceContext() {}

func NewAtomjoinSourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtomjoinSourceContext {
	var p = new(AtomjoinSourceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_atomjoinSource

	return p
}

func (s *AtomjoinSourceContext) GetParser() antlr.Parser { return s.parser }

func (s *AtomjoinSourceContext) TableSource() ITableSourceContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableSourceContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableSourceContext)
}

func (s *AtomjoinSourceContext) AllLateralView() []ILateralViewContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILateralViewContext); ok {
			len++
		}
	}

	tst := make([]ILateralViewContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILateralViewContext); ok {
			tst[i] = t.(ILateralViewContext)
			i++
		}
	}

	return tst
}

func (s *AtomjoinSourceContext) LateralView(i int) ILateralViewContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILateralViewContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILateralViewContext)
}

func (s *AtomjoinSourceContext) VirtualTableSource() IVirtualTableSourceContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVirtualTableSourceContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVirtualTableSourceContext)
}

func (s *AtomjoinSourceContext) SubQuerySource() ISubQuerySourceContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubQuerySourceContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubQuerySourceContext)
}

func (s *AtomjoinSourceContext) PartitionedTableFunction() IPartitionedTableFunctionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionedTableFunctionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionedTableFunctionContext)
}

func (s *AtomjoinSourceContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserLPAREN, 0)
}

func (s *AtomjoinSourceContext) JoinSource() IJoinSourceContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinSourceContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinSourceContext)
}

func (s *AtomjoinSourceContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserRPAREN, 0)
}

func (s *AtomjoinSourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtomjoinSourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AtomjoinSourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterAtomjoinSource(s)
	}
}

func (s *AtomjoinSourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitAtomjoinSource(s)
	}
}

func (s *AtomjoinSourceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitAtomjoinSource(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) AtomjoinSource() (localctx IAtomjoinSourceContext) {
	localctx = NewAtomjoinSourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 610, HiveParserRULE_atomjoinSource)
	var _alt int

	p.SetState(3752)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 424, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3720)
			p.TableSource()
		}
		p.SetState(3724)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 420, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(3721)
					p.LateralView()
				}


			}
			p.SetState(3726)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 420, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3727)
			p.VirtualTableSource()
		}
		p.SetState(3731)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 421, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(3728)
					p.LateralView()
				}


			}
			p.SetState(3733)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 421, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3734)
			p.SubQuerySource()
		}
		p.SetState(3738)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 422, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(3735)
					p.LateralView()
				}


			}
			p.SetState(3740)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 422, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3741)
			p.PartitionedTableFunction()
		}
		p.SetState(3745)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 423, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(3742)
					p.LateralView()
				}


			}
			p.SetState(3747)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 423, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3748)
			p.Match(HiveParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3749)
			p.JoinSource()
		}
		{
			p.SetState(3750)
			p.Match(HiveParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IJoinSourceContext is an interface to support dynamic dispatch.
type IJoinSourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AtomjoinSource() IAtomjoinSourceContext
	AllJoinToken() []IJoinTokenContext
	JoinToken(i int) IJoinTokenContext
	AllJoinSourcePart() []IJoinSourcePartContext
	JoinSourcePart(i int) IJoinSourcePartContext
	AllKW_ON() []antlr.TerminalNode
	KW_ON(i int) antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllKW_USING() []antlr.TerminalNode
	KW_USING(i int) antlr.TerminalNode
	AllColumnParenthesesList() []IColumnParenthesesListContext
	ColumnParenthesesList(i int) IColumnParenthesesListContext

	// IsJoinSourceContext differentiates from other interfaces.
	IsJoinSourceContext()
}

type JoinSourceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinSourceContext() *JoinSourceContext {
	var p = new(JoinSourceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_joinSource
	return p
}

func InitEmptyJoinSourceContext(p *JoinSourceContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_joinSource
}

func (*JoinSourceContext) IsJoinSourceContext() {}

func NewJoinSourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinSourceContext {
	var p = new(JoinSourceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_joinSource

	return p
}

func (s *JoinSourceContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinSourceContext) AtomjoinSource() IAtomjoinSourceContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAtomjoinSourceContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAtomjoinSourceContext)
}

func (s *JoinSourceContext) AllJoinToken() []IJoinTokenContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IJoinTokenContext); ok {
			len++
		}
	}

	tst := make([]IJoinTokenContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IJoinTokenContext); ok {
			tst[i] = t.(IJoinTokenContext)
			i++
		}
	}

	return tst
}

func (s *JoinSourceContext) JoinToken(i int) IJoinTokenContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinTokenContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinTokenContext)
}

func (s *JoinSourceContext) AllJoinSourcePart() []IJoinSourcePartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IJoinSourcePartContext); ok {
			len++
		}
	}

	tst := make([]IJoinSourcePartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IJoinSourcePartContext); ok {
			tst[i] = t.(IJoinSourcePartContext)
			i++
		}
	}

	return tst
}

func (s *JoinSourceContext) JoinSourcePart(i int) IJoinSourcePartContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinSourcePartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinSourcePartContext)
}

func (s *JoinSourceContext) AllKW_ON() []antlr.TerminalNode {
	return s.GetTokens(HiveParserKW_ON)
}

func (s *JoinSourceContext) KW_ON(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ON, i)
}

func (s *JoinSourceContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *JoinSourceContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *JoinSourceContext) AllKW_USING() []antlr.TerminalNode {
	return s.GetTokens(HiveParserKW_USING)
}

func (s *JoinSourceContext) KW_USING(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserKW_USING, i)
}

func (s *JoinSourceContext) AllColumnParenthesesList() []IColumnParenthesesListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnParenthesesListContext); ok {
			len++
		}
	}

	tst := make([]IColumnParenthesesListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnParenthesesListContext); ok {
			tst[i] = t.(IColumnParenthesesListContext)
			i++
		}
	}

	return tst
}

func (s *JoinSourceContext) ColumnParenthesesList(i int) IColumnParenthesesListContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnParenthesesListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnParenthesesListContext)
}

func (s *JoinSourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinSourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *JoinSourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterJoinSource(s)
	}
}

func (s *JoinSourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitJoinSource(s)
	}
}

func (s *JoinSourceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitJoinSource(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) JoinSource() (localctx IJoinSourceContext) {
	localctx = NewJoinSourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 612, HiveParserRULE_joinSource)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3754)
		p.AtomjoinSource()
	}
	p.SetState(3765)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HiveParserKW_CROSS || ((int64((_la - 135)) & ^0x3f) == 0 && ((int64(1) << (_la - 135)) & 275414843393) != 0) || _la == HiveParserKW_RIGHT || _la == HiveParserCOMMA {
		{
			p.SetState(3755)
			p.JoinToken()
		}
		{
			p.SetState(3756)
			p.JoinSourcePart()
		}
		p.SetState(3761)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case HiveParserKW_ON:
			{
				p.SetState(3757)
				p.Match(HiveParserKW_ON)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(3758)
				p.Expression()
			}


		case HiveParserKW_USING:
			{
				p.SetState(3759)
				p.Match(HiveParserKW_USING)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(3760)
				p.ColumnParenthesesList()
			}


		case HiveParserEOF, HiveParserKW_CLUSTER, HiveParserKW_CROSS, HiveParserKW_DISTRIBUTE, HiveParserKW_EXCEPT, HiveParserKW_FULL, HiveParserKW_GROUP, HiveParserKW_HAVING, HiveParserKW_INNER, HiveParserKW_INSERT, HiveParserKW_INTERSECT, HiveParserKW_JOIN, HiveParserKW_LEFT, HiveParserKW_LIMIT, HiveParserKW_MAP, HiveParserKW_MINUS, HiveParserKW_ORDER, HiveParserKW_QUALIFY, HiveParserKW_REDUCE, HiveParserKW_RIGHT, HiveParserKW_SELECT, HiveParserKW_SORT, HiveParserKW_UNION, HiveParserKW_WHERE, HiveParserKW_WINDOW, HiveParserCOMMA, HiveParserRPAREN:



		default:
		}


		p.SetState(3767)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IJoinSourcePartContext is an interface to support dynamic dispatch.
type IJoinSourcePartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TableSource() ITableSourceContext
	VirtualTableSource() IVirtualTableSourceContext
	SubQuerySource() ISubQuerySourceContext
	PartitionedTableFunction() IPartitionedTableFunctionContext
	AllLateralView() []ILateralViewContext
	LateralView(i int) ILateralViewContext

	// IsJoinSourcePartContext differentiates from other interfaces.
	IsJoinSourcePartContext()
}

type JoinSourcePartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinSourcePartContext() *JoinSourcePartContext {
	var p = new(JoinSourcePartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_joinSourcePart
	return p
}

func InitEmptyJoinSourcePartContext(p *JoinSourcePartContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_joinSourcePart
}

func (*JoinSourcePartContext) IsJoinSourcePartContext() {}

func NewJoinSourcePartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinSourcePartContext {
	var p = new(JoinSourcePartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_joinSourcePart

	return p
}

func (s *JoinSourcePartContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinSourcePartContext) TableSource() ITableSourceContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableSourceContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableSourceContext)
}

func (s *JoinSourcePartContext) VirtualTableSource() IVirtualTableSourceContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVirtualTableSourceContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVirtualTableSourceContext)
}

func (s *JoinSourcePartContext) SubQuerySource() ISubQuerySourceContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubQuerySourceContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubQuerySourceContext)
}

func (s *JoinSourcePartContext) PartitionedTableFunction() IPartitionedTableFunctionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionedTableFunctionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionedTableFunctionContext)
}

func (s *JoinSourcePartContext) AllLateralView() []ILateralViewContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILateralViewContext); ok {
			len++
		}
	}

	tst := make([]ILateralViewContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILateralViewContext); ok {
			tst[i] = t.(ILateralViewContext)
			i++
		}
	}

	return tst
}

func (s *JoinSourcePartContext) LateralView(i int) ILateralViewContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILateralViewContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILateralViewContext)
}

func (s *JoinSourcePartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinSourcePartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *JoinSourcePartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterJoinSourcePart(s)
	}
}

func (s *JoinSourcePartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitJoinSourcePart(s)
	}
}

func (s *JoinSourcePartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitJoinSourcePart(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) JoinSourcePart() (localctx IJoinSourcePartContext) {
	localctx = NewJoinSourcePartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 614, HiveParserRULE_joinSourcePart)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3772)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 427, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3768)
			p.TableSource()
		}


	case 2:
		{
			p.SetState(3769)
			p.VirtualTableSource()
		}


	case 3:
		{
			p.SetState(3770)
			p.SubQuerySource()
		}


	case 4:
		{
			p.SetState(3771)
			p.PartitionedTableFunction()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(3777)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 428, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3774)
				p.LateralView()
			}


		}
		p.SetState(3779)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 428, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IUniqueJoinSourceContext is an interface to support dynamic dispatch.
type IUniqueJoinSourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UniqueJoinTableSource() IUniqueJoinTableSourceContext
	UniqueJoinExpr() IUniqueJoinExprContext
	KW_PRESERVE() antlr.TerminalNode

	// IsUniqueJoinSourceContext differentiates from other interfaces.
	IsUniqueJoinSourceContext()
}

type UniqueJoinSourceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUniqueJoinSourceContext() *UniqueJoinSourceContext {
	var p = new(UniqueJoinSourceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_uniqueJoinSource
	return p
}

func InitEmptyUniqueJoinSourceContext(p *UniqueJoinSourceContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_uniqueJoinSource
}

func (*UniqueJoinSourceContext) IsUniqueJoinSourceContext() {}

func NewUniqueJoinSourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UniqueJoinSourceContext {
	var p = new(UniqueJoinSourceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_uniqueJoinSource

	return p
}

func (s *UniqueJoinSourceContext) GetParser() antlr.Parser { return s.parser }

func (s *UniqueJoinSourceContext) UniqueJoinTableSource() IUniqueJoinTableSourceContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUniqueJoinTableSourceContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUniqueJoinTableSourceContext)
}

func (s *UniqueJoinSourceContext) UniqueJoinExpr() IUniqueJoinExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUniqueJoinExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUniqueJoinExprContext)
}

func (s *UniqueJoinSourceContext) KW_PRESERVE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_PRESERVE, 0)
}

func (s *UniqueJoinSourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UniqueJoinSourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *UniqueJoinSourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterUniqueJoinSource(s)
	}
}

func (s *UniqueJoinSourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitUniqueJoinSource(s)
	}
}

func (s *UniqueJoinSourceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitUniqueJoinSource(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) UniqueJoinSource() (localctx IUniqueJoinSourceContext) {
	localctx = NewUniqueJoinSourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 616, HiveParserRULE_uniqueJoinSource)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3781)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_PRESERVE {
		{
			p.SetState(3780)
			p.Match(HiveParserKW_PRESERVE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(3783)
		p.UniqueJoinTableSource()
	}
	{
		p.SetState(3784)
		p.UniqueJoinExpr()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IUniqueJoinExprContext is an interface to support dynamic dispatch.
type IUniqueJoinExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	ExpressionList() IExpressionListContext
	RPAREN() antlr.TerminalNode

	// IsUniqueJoinExprContext differentiates from other interfaces.
	IsUniqueJoinExprContext()
}

type UniqueJoinExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUniqueJoinExprContext() *UniqueJoinExprContext {
	var p = new(UniqueJoinExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_uniqueJoinExpr
	return p
}

func InitEmptyUniqueJoinExprContext(p *UniqueJoinExprContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_uniqueJoinExpr
}

func (*UniqueJoinExprContext) IsUniqueJoinExprContext() {}

func NewUniqueJoinExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UniqueJoinExprContext {
	var p = new(UniqueJoinExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_uniqueJoinExpr

	return p
}

func (s *UniqueJoinExprContext) GetParser() antlr.Parser { return s.parser }

func (s *UniqueJoinExprContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserLPAREN, 0)
}

func (s *UniqueJoinExprContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *UniqueJoinExprContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserRPAREN, 0)
}

func (s *UniqueJoinExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UniqueJoinExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *UniqueJoinExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterUniqueJoinExpr(s)
	}
}

func (s *UniqueJoinExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitUniqueJoinExpr(s)
	}
}

func (s *UniqueJoinExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitUniqueJoinExpr(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) UniqueJoinExpr() (localctx IUniqueJoinExprContext) {
	localctx = NewUniqueJoinExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 618, HiveParserRULE_uniqueJoinExpr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3786)
		p.Match(HiveParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3787)
		p.ExpressionList()
	}
	{
		p.SetState(3788)
		p.Match(HiveParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IUniqueJoinTokenContext is an interface to support dynamic dispatch.
type IUniqueJoinTokenContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_UNIQUEJOIN() antlr.TerminalNode

	// IsUniqueJoinTokenContext differentiates from other interfaces.
	IsUniqueJoinTokenContext()
}

type UniqueJoinTokenContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUniqueJoinTokenContext() *UniqueJoinTokenContext {
	var p = new(UniqueJoinTokenContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_uniqueJoinToken
	return p
}

func InitEmptyUniqueJoinTokenContext(p *UniqueJoinTokenContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_uniqueJoinToken
}

func (*UniqueJoinTokenContext) IsUniqueJoinTokenContext() {}

func NewUniqueJoinTokenContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UniqueJoinTokenContext {
	var p = new(UniqueJoinTokenContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_uniqueJoinToken

	return p
}

func (s *UniqueJoinTokenContext) GetParser() antlr.Parser { return s.parser }

func (s *UniqueJoinTokenContext) KW_UNIQUEJOIN() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_UNIQUEJOIN, 0)
}

func (s *UniqueJoinTokenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UniqueJoinTokenContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *UniqueJoinTokenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterUniqueJoinToken(s)
	}
}

func (s *UniqueJoinTokenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitUniqueJoinToken(s)
	}
}

func (s *UniqueJoinTokenContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitUniqueJoinToken(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) UniqueJoinToken() (localctx IUniqueJoinTokenContext) {
	localctx = NewUniqueJoinTokenContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 620, HiveParserRULE_uniqueJoinToken)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3790)
		p.Match(HiveParserKW_UNIQUEJOIN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IJoinTokenContext is an interface to support dynamic dispatch.
type IJoinTokenContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COMMA() antlr.TerminalNode
	KW_JOIN() antlr.TerminalNode
	KW_INNER() antlr.TerminalNode
	KW_CROSS() antlr.TerminalNode
	KW_LEFT() antlr.TerminalNode
	KW_RIGHT() antlr.TerminalNode
	KW_FULL() antlr.TerminalNode
	KW_OUTER() antlr.TerminalNode
	KW_SEMI() antlr.TerminalNode
	KW_ANTI() antlr.TerminalNode

	// IsJoinTokenContext differentiates from other interfaces.
	IsJoinTokenContext()
}

type JoinTokenContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinTokenContext() *JoinTokenContext {
	var p = new(JoinTokenContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_joinToken
	return p
}

func InitEmptyJoinTokenContext(p *JoinTokenContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_joinToken
}

func (*JoinTokenContext) IsJoinTokenContext() {}

func NewJoinTokenContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinTokenContext {
	var p = new(JoinTokenContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_joinToken

	return p
}

func (s *JoinTokenContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinTokenContext) COMMA() antlr.TerminalNode {
	return s.GetToken(HiveParserCOMMA, 0)
}

func (s *JoinTokenContext) KW_JOIN() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_JOIN, 0)
}

func (s *JoinTokenContext) KW_INNER() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_INNER, 0)
}

func (s *JoinTokenContext) KW_CROSS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_CROSS, 0)
}

func (s *JoinTokenContext) KW_LEFT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_LEFT, 0)
}

func (s *JoinTokenContext) KW_RIGHT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_RIGHT, 0)
}

func (s *JoinTokenContext) KW_FULL() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_FULL, 0)
}

func (s *JoinTokenContext) KW_OUTER() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_OUTER, 0)
}

func (s *JoinTokenContext) KW_SEMI() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SEMI, 0)
}

func (s *JoinTokenContext) KW_ANTI() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ANTI, 0)
}

func (s *JoinTokenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinTokenContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *JoinTokenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterJoinToken(s)
	}
}

func (s *JoinTokenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitJoinToken(s)
	}
}

func (s *JoinTokenContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitJoinToken(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) JoinToken() (localctx IJoinTokenContext) {
	localctx = NewJoinTokenContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 622, HiveParserRULE_joinToken)
	var _la int

	p.SetState(3806)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserCOMMA:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3792)
			p.Match(HiveParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HiveParserKW_CROSS, HiveParserKW_FULL, HiveParserKW_INNER, HiveParserKW_JOIN, HiveParserKW_LEFT, HiveParserKW_RIGHT:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(3803)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case HiveParserKW_INNER:
			{
				p.SetState(3793)
				p.Match(HiveParserKW_INNER)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


		case HiveParserKW_CROSS:
			{
				p.SetState(3794)
				p.Match(HiveParserKW_CROSS)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


		case HiveParserKW_FULL, HiveParserKW_RIGHT:
			{
				p.SetState(3795)
				_la = p.GetTokenStream().LA(1)

				if !(_la == HiveParserKW_FULL || _la == HiveParserKW_RIGHT) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			p.SetState(3797)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == HiveParserKW_OUTER {
				{
					p.SetState(3796)
					p.Match(HiveParserKW_OUTER)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}

			}


		case HiveParserKW_LEFT:
			{
				p.SetState(3799)
				p.Match(HiveParserKW_LEFT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			p.SetState(3801)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == HiveParserKW_ANTI || _la == HiveParserKW_OUTER || _la == HiveParserKW_SEMI {
				{
					p.SetState(3800)
					_la = p.GetTokenStream().LA(1)

					if !(_la == HiveParserKW_ANTI || _la == HiveParserKW_OUTER || _la == HiveParserKW_SEMI) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}


		case HiveParserKW_JOIN:



		default:
		}
		{
			p.SetState(3805)
			p.Match(HiveParserKW_JOIN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ILateralViewContext is an interface to support dynamic dispatch.
type ILateralViewContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_LATERAL() antlr.TerminalNode
	KW_VIEW() antlr.TerminalNode
	KW_OUTER() antlr.TerminalNode
	Function_() IFunction_Context
	TableAlias() ITableAliasContext
	KW_AS() antlr.TerminalNode
	AllId_() []IId_Context
	Id_(i int) IId_Context
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	KW_TABLE() antlr.TerminalNode
	AllLPAREN() []antlr.TerminalNode
	LPAREN(i int) antlr.TerminalNode
	ValuesClause() IValuesClauseContext
	AllRPAREN() []antlr.TerminalNode
	RPAREN(i int) antlr.TerminalNode

	// IsLateralViewContext differentiates from other interfaces.
	IsLateralViewContext()
}

type LateralViewContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLateralViewContext() *LateralViewContext {
	var p = new(LateralViewContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_lateralView
	return p
}

func InitEmptyLateralViewContext(p *LateralViewContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_lateralView
}

func (*LateralViewContext) IsLateralViewContext() {}

func NewLateralViewContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LateralViewContext {
	var p = new(LateralViewContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_lateralView

	return p
}

func (s *LateralViewContext) GetParser() antlr.Parser { return s.parser }

func (s *LateralViewContext) KW_LATERAL() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_LATERAL, 0)
}

func (s *LateralViewContext) KW_VIEW() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_VIEW, 0)
}

func (s *LateralViewContext) KW_OUTER() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_OUTER, 0)
}

func (s *LateralViewContext) Function_() IFunction_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunction_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunction_Context)
}

func (s *LateralViewContext) TableAlias() ITableAliasContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableAliasContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableAliasContext)
}

func (s *LateralViewContext) KW_AS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_AS, 0)
}

func (s *LateralViewContext) AllId_() []IId_Context {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IId_Context); ok {
			len++
		}
	}

	tst := make([]IId_Context, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IId_Context); ok {
			tst[i] = t.(IId_Context)
			i++
		}
	}

	return tst
}

func (s *LateralViewContext) Id_(i int) IId_Context {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *LateralViewContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(HiveParserCOMMA)
}

func (s *LateralViewContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserCOMMA, i)
}

func (s *LateralViewContext) KW_TABLE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TABLE, 0)
}

func (s *LateralViewContext) AllLPAREN() []antlr.TerminalNode {
	return s.GetTokens(HiveParserLPAREN)
}

func (s *LateralViewContext) LPAREN(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserLPAREN, i)
}

func (s *LateralViewContext) ValuesClause() IValuesClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValuesClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValuesClauseContext)
}

func (s *LateralViewContext) AllRPAREN() []antlr.TerminalNode {
	return s.GetTokens(HiveParserRPAREN)
}

func (s *LateralViewContext) RPAREN(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserRPAREN, i)
}

func (s *LateralViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LateralViewContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *LateralViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterLateralView(s)
	}
}

func (s *LateralViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitLateralView(s)
	}
}

func (s *LateralViewContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitLateralView(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) LateralView() (localctx ILateralViewContext) {
	localctx = NewLateralViewContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 624, HiveParserRULE_lateralView)
	var _la int

	var _alt int

	p.SetState(3865)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 443, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3808)
			p.Match(HiveParserKW_LATERAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3809)
			p.Match(HiveParserKW_VIEW)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3810)
			p.Match(HiveParserKW_OUTER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3811)
			p.Function_()
		}
		{
			p.SetState(3812)
			p.TableAlias()
		}
		p.SetState(3822)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_AS {
			{
				p.SetState(3813)
				p.Match(HiveParserKW_AS)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(3814)
				p.Id_()
			}
			p.SetState(3819)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 434, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(3815)
						p.Match(HiveParserCOMMA)
						if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
						}
					}
					{
						p.SetState(3816)
						p.Id_()
					}


				}
				p.SetState(3821)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
			    	goto errorExit
			    }
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 434, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
			}

		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(3825)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserCOMMA {
			{
				p.SetState(3824)
				p.Match(HiveParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(3827)
			p.Match(HiveParserKW_LATERAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(3863)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case HiveParserKW_VIEW:
			{
				p.SetState(3828)
				p.Match(HiveParserKW_VIEW)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(3829)
				p.Function_()
			}
			{
				p.SetState(3830)
				p.TableAlias()
			}
			p.SetState(3840)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == HiveParserKW_AS {
				{
					p.SetState(3831)
					p.Match(HiveParserKW_AS)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(3832)
					p.Id_()
				}
				p.SetState(3837)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 437, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(3833)
							p.Match(HiveParserCOMMA)
							if p.HasError() {
									// Recognition error - abort rule
									goto errorExit
							}
						}
						{
							p.SetState(3834)
							p.Id_()
						}


					}
					p.SetState(3839)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
				    	goto errorExit
				    }
					_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 437, p.GetParserRuleContext())
					if p.HasError() {
						goto errorExit
					}
				}

			}


		case HiveParserKW_TABLE:
			{
				p.SetState(3842)
				p.Match(HiveParserKW_TABLE)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(3843)
				p.Match(HiveParserLPAREN)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(3844)
				p.ValuesClause()
			}
			{
				p.SetState(3845)
				p.Match(HiveParserRPAREN)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			p.SetState(3847)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == HiveParserKW_AS {
				{
					p.SetState(3846)
					p.Match(HiveParserKW_AS)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}

			}
			{
				p.SetState(3849)
				p.TableAlias()
			}
			p.SetState(3861)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == HiveParserLPAREN {
				{
					p.SetState(3850)
					p.Match(HiveParserLPAREN)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(3851)
					p.Id_()
				}
				p.SetState(3856)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)


				for _la == HiveParserCOMMA {
					{
						p.SetState(3852)
						p.Match(HiveParserCOMMA)
						if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
						}
					}
					{
						p.SetState(3853)
						p.Id_()
					}


					p.SetState(3858)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
				    	goto errorExit
				    }
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(3859)
					p.Match(HiveParserRPAREN)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}

			}



		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITableAliasContext is an interface to support dynamic dispatch.
type ITableAliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Id_() IId_Context

	// IsTableAliasContext differentiates from other interfaces.
	IsTableAliasContext()
}

type TableAliasContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableAliasContext() *TableAliasContext {
	var p = new(TableAliasContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_tableAlias
	return p
}

func InitEmptyTableAliasContext(p *TableAliasContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_tableAlias
}

func (*TableAliasContext) IsTableAliasContext() {}

func NewTableAliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableAliasContext {
	var p = new(TableAliasContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_tableAlias

	return p
}

func (s *TableAliasContext) GetParser() antlr.Parser { return s.parser }

func (s *TableAliasContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *TableAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableAliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TableAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterTableAlias(s)
	}
}

func (s *TableAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitTableAlias(s)
	}
}

func (s *TableAliasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitTableAlias(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) TableAlias() (localctx ITableAliasContext) {
	localctx = NewTableAliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 626, HiveParserRULE_tableAlias)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3867)
		p.Id_()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITableBucketSampleContext is an interface to support dynamic dispatch.
type ITableBucketSampleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetNumerator returns the numerator token.
	GetNumerator() antlr.Token 

	// GetDenominator returns the denominator token.
	GetDenominator() antlr.Token 


	// SetNumerator sets the numerator token.
	SetNumerator(antlr.Token) 

	// SetDenominator sets the denominator token.
	SetDenominator(antlr.Token) 


	// Get_expression returns the _expression rule contexts.
	Get_expression() IExpressionContext


	// Set_expression sets the _expression rule contexts.
	Set_expression(IExpressionContext)


	// GetExpr returns the expr rule context list.
	GetExpr() []IExpressionContext


	// SetExpr sets the expr rule context list.
	SetExpr([]IExpressionContext) 


	// Getter signatures
	KW_TABLESAMPLE() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	KW_BUCKET() antlr.TerminalNode
	KW_OUT() antlr.TerminalNode
	KW_OF() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	AllNumber() []antlr.TerminalNode
	Number(i int) antlr.TerminalNode
	KW_ON() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTableBucketSampleContext differentiates from other interfaces.
	IsTableBucketSampleContext()
}

type TableBucketSampleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	numerator antlr.Token
	denominator antlr.Token
	_expression IExpressionContext 
	expr []IExpressionContext
}

func NewEmptyTableBucketSampleContext() *TableBucketSampleContext {
	var p = new(TableBucketSampleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_tableBucketSample
	return p
}

func InitEmptyTableBucketSampleContext(p *TableBucketSampleContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_tableBucketSample
}

func (*TableBucketSampleContext) IsTableBucketSampleContext() {}

func NewTableBucketSampleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableBucketSampleContext {
	var p = new(TableBucketSampleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_tableBucketSample

	return p
}

func (s *TableBucketSampleContext) GetParser() antlr.Parser { return s.parser }

func (s *TableBucketSampleContext) GetNumerator() antlr.Token { return s.numerator }

func (s *TableBucketSampleContext) GetDenominator() antlr.Token { return s.denominator }


func (s *TableBucketSampleContext) SetNumerator(v antlr.Token) { s.numerator = v }

func (s *TableBucketSampleContext) SetDenominator(v antlr.Token) { s.denominator = v }


func (s *TableBucketSampleContext) Get_expression() IExpressionContext { return s._expression }


func (s *TableBucketSampleContext) Set_expression(v IExpressionContext) { s._expression = v }


func (s *TableBucketSampleContext) GetExpr() []IExpressionContext { return s.expr }


func (s *TableBucketSampleContext) SetExpr(v []IExpressionContext) { s.expr = v }


func (s *TableBucketSampleContext) KW_TABLESAMPLE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TABLESAMPLE, 0)
}

func (s *TableBucketSampleContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserLPAREN, 0)
}

func (s *TableBucketSampleContext) KW_BUCKET() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_BUCKET, 0)
}

func (s *TableBucketSampleContext) KW_OUT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_OUT, 0)
}

func (s *TableBucketSampleContext) KW_OF() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_OF, 0)
}

func (s *TableBucketSampleContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserRPAREN, 0)
}

func (s *TableBucketSampleContext) AllNumber() []antlr.TerminalNode {
	return s.GetTokens(HiveParserNumber)
}

func (s *TableBucketSampleContext) Number(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserNumber, i)
}

func (s *TableBucketSampleContext) KW_ON() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ON, 0)
}

func (s *TableBucketSampleContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *TableBucketSampleContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TableBucketSampleContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(HiveParserCOMMA)
}

func (s *TableBucketSampleContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserCOMMA, i)
}

func (s *TableBucketSampleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableBucketSampleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TableBucketSampleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterTableBucketSample(s)
	}
}

func (s *TableBucketSampleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitTableBucketSample(s)
	}
}

func (s *TableBucketSampleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitTableBucketSample(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) TableBucketSample() (localctx ITableBucketSampleContext) {
	localctx = NewTableBucketSampleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 628, HiveParserRULE_tableBucketSample)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3869)
		p.Match(HiveParserKW_TABLESAMPLE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3870)
		p.Match(HiveParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3871)
		p.Match(HiveParserKW_BUCKET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3872)

		var _m = p.Match(HiveParserNumber)

		localctx.(*TableBucketSampleContext).numerator = _m
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3873)
		p.Match(HiveParserKW_OUT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3874)
		p.Match(HiveParserKW_OF)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3875)

		var _m = p.Match(HiveParserNumber)

		localctx.(*TableBucketSampleContext).denominator = _m
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(3885)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_ON {
		{
			p.SetState(3876)
			p.Match(HiveParserKW_ON)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3877)

			var _x = p.Expression()


			localctx.(*TableBucketSampleContext)._expression = _x
		}
		localctx.(*TableBucketSampleContext).expr = append(localctx.(*TableBucketSampleContext).expr, localctx.(*TableBucketSampleContext)._expression)
		p.SetState(3882)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == HiveParserCOMMA {
			{
				p.SetState(3878)
				p.Match(HiveParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(3879)

				var _x = p.Expression()


				localctx.(*TableBucketSampleContext)._expression = _x
			}
			localctx.(*TableBucketSampleContext).expr = append(localctx.(*TableBucketSampleContext).expr, localctx.(*TableBucketSampleContext)._expression)


			p.SetState(3884)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(3887)
		p.Match(HiveParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISplitSampleContext is an interface to support dynamic dispatch.
type ISplitSampleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_TABLESAMPLE() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	Number() antlr.TerminalNode
	ByteLengthLiteral() antlr.TerminalNode
	KW_PERCENT() antlr.TerminalNode
	KW_ROWS() antlr.TerminalNode

	// IsSplitSampleContext differentiates from other interfaces.
	IsSplitSampleContext()
}

type SplitSampleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySplitSampleContext() *SplitSampleContext {
	var p = new(SplitSampleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_splitSample
	return p
}

func InitEmptySplitSampleContext(p *SplitSampleContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_splitSample
}

func (*SplitSampleContext) IsSplitSampleContext() {}

func NewSplitSampleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SplitSampleContext {
	var p = new(SplitSampleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_splitSample

	return p
}

func (s *SplitSampleContext) GetParser() antlr.Parser { return s.parser }

func (s *SplitSampleContext) KW_TABLESAMPLE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TABLESAMPLE, 0)
}

func (s *SplitSampleContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserLPAREN, 0)
}

func (s *SplitSampleContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserRPAREN, 0)
}

func (s *SplitSampleContext) Number() antlr.TerminalNode {
	return s.GetToken(HiveParserNumber, 0)
}

func (s *SplitSampleContext) ByteLengthLiteral() antlr.TerminalNode {
	return s.GetToken(HiveParserByteLengthLiteral, 0)
}

func (s *SplitSampleContext) KW_PERCENT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_PERCENT, 0)
}

func (s *SplitSampleContext) KW_ROWS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ROWS, 0)
}

func (s *SplitSampleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SplitSampleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SplitSampleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterSplitSample(s)
	}
}

func (s *SplitSampleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitSplitSample(s)
	}
}

func (s *SplitSampleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitSplitSample(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) SplitSample() (localctx ISplitSampleContext) {
	localctx = NewSplitSampleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 630, HiveParserRULE_splitSample)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3889)
		p.Match(HiveParserKW_TABLESAMPLE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3890)
		p.Match(HiveParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(3894)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserNumber:
		{
			p.SetState(3891)
			p.Match(HiveParserNumber)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3892)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HiveParserKW_PERCENT || _la == HiveParserKW_ROWS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}


	case HiveParserByteLengthLiteral:
		{
			p.SetState(3893)
			p.Match(HiveParserByteLengthLiteral)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(3896)
		p.Match(HiveParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITableSampleContext is an interface to support dynamic dispatch.
type ITableSampleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TableBucketSample() ITableBucketSampleContext
	SplitSample() ISplitSampleContext

	// IsTableSampleContext differentiates from other interfaces.
	IsTableSampleContext()
}

type TableSampleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableSampleContext() *TableSampleContext {
	var p = new(TableSampleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_tableSample
	return p
}

func InitEmptyTableSampleContext(p *TableSampleContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_tableSample
}

func (*TableSampleContext) IsTableSampleContext() {}

func NewTableSampleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableSampleContext {
	var p = new(TableSampleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_tableSample

	return p
}

func (s *TableSampleContext) GetParser() antlr.Parser { return s.parser }

func (s *TableSampleContext) TableBucketSample() ITableBucketSampleContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableBucketSampleContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableBucketSampleContext)
}

func (s *TableSampleContext) SplitSample() ISplitSampleContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISplitSampleContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISplitSampleContext)
}

func (s *TableSampleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableSampleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TableSampleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterTableSample(s)
	}
}

func (s *TableSampleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitTableSample(s)
	}
}

func (s *TableSampleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitTableSample(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) TableSample() (localctx ITableSampleContext) {
	localctx = NewTableSampleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 632, HiveParserRULE_tableSample)
	p.SetState(3900)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 447, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3898)
			p.TableBucketSample()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3899)
			p.SplitSample()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITableSourceContext is an interface to support dynamic dispatch.
type ITableSourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTabname returns the tabname rule contexts.
	GetTabname() ITableNameContext

	// GetProps returns the props rule contexts.
	GetProps() ITablePropertiesContext

	// GetTs returns the ts rule contexts.
	GetTs() ITableSampleContext

	// GetAsOf returns the asOf rule contexts.
	GetAsOf() IAsOfClauseContext

	// GetAlias returns the alias rule contexts.
	GetAlias() IId_Context


	// SetTabname sets the tabname rule contexts.
	SetTabname(ITableNameContext)

	// SetProps sets the props rule contexts.
	SetProps(ITablePropertiesContext)

	// SetTs sets the ts rule contexts.
	SetTs(ITableSampleContext)

	// SetAsOf sets the asOf rule contexts.
	SetAsOf(IAsOfClauseContext)

	// SetAlias sets the alias rule contexts.
	SetAlias(IId_Context)


	// Getter signatures
	TableName() ITableNameContext
	TableProperties() ITablePropertiesContext
	TableSample() ITableSampleContext
	AsOfClause() IAsOfClauseContext
	Id_() IId_Context
	KW_AS() antlr.TerminalNode

	// IsTableSourceContext differentiates from other interfaces.
	IsTableSourceContext()
}

type TableSourceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	tabname ITableNameContext 
	props ITablePropertiesContext 
	ts ITableSampleContext 
	asOf IAsOfClauseContext 
	alias IId_Context 
}

func NewEmptyTableSourceContext() *TableSourceContext {
	var p = new(TableSourceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_tableSource
	return p
}

func InitEmptyTableSourceContext(p *TableSourceContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_tableSource
}

func (*TableSourceContext) IsTableSourceContext() {}

func NewTableSourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableSourceContext {
	var p = new(TableSourceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_tableSource

	return p
}

func (s *TableSourceContext) GetParser() antlr.Parser { return s.parser }

func (s *TableSourceContext) GetTabname() ITableNameContext { return s.tabname }

func (s *TableSourceContext) GetProps() ITablePropertiesContext { return s.props }

func (s *TableSourceContext) GetTs() ITableSampleContext { return s.ts }

func (s *TableSourceContext) GetAsOf() IAsOfClauseContext { return s.asOf }

func (s *TableSourceContext) GetAlias() IId_Context { return s.alias }


func (s *TableSourceContext) SetTabname(v ITableNameContext) { s.tabname = v }

func (s *TableSourceContext) SetProps(v ITablePropertiesContext) { s.props = v }

func (s *TableSourceContext) SetTs(v ITableSampleContext) { s.ts = v }

func (s *TableSourceContext) SetAsOf(v IAsOfClauseContext) { s.asOf = v }

func (s *TableSourceContext) SetAlias(v IId_Context) { s.alias = v }


func (s *TableSourceContext) TableName() ITableNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *TableSourceContext) TableProperties() ITablePropertiesContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablePropertiesContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablePropertiesContext)
}

func (s *TableSourceContext) TableSample() ITableSampleContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableSampleContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableSampleContext)
}

func (s *TableSourceContext) AsOfClause() IAsOfClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAsOfClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAsOfClauseContext)
}

func (s *TableSourceContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *TableSourceContext) KW_AS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_AS, 0)
}

func (s *TableSourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableSourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TableSourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterTableSource(s)
	}
}

func (s *TableSourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitTableSource(s)
	}
}

func (s *TableSourceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitTableSource(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) TableSource() (localctx ITableSourceContext) {
	localctx = NewTableSourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 634, HiveParserRULE_tableSource)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3902)

		var _x = p.TableName()


		localctx.(*TableSourceContext).tabname = _x
	}
	p.SetState(3904)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserLPAREN {
		{
			p.SetState(3903)

			var _x = p.TableProperties()


			localctx.(*TableSourceContext).props = _x
		}

	}
	p.SetState(3907)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_TABLESAMPLE {
		{
			p.SetState(3906)

			var _x = p.TableSample()


			localctx.(*TableSourceContext).ts = _x
		}

	}
	p.SetState(3910)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_FOR {
		{
			p.SetState(3909)

			var _x = p.AsOfClause()


			localctx.(*TableSourceContext).asOf = _x
		}

	}
	p.SetState(3916)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 452, p.GetParserRuleContext()) == 1 {
		p.SetState(3913)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_AS {
			{
				p.SetState(3912)
				p.Match(HiveParserKW_AS)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(3915)

			var _x = p.Id_()


			localctx.(*TableSourceContext).alias = _x
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAsOfClauseContext is an interface to support dynamic dispatch.
type IAsOfClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetAsOfVersion returns the asOfVersion token.
	GetAsOfVersion() antlr.Token 


	// SetAsOfVersion sets the asOfVersion token.
	SetAsOfVersion(antlr.Token) 


	// GetAsOfTime returns the asOfTime rule contexts.
	GetAsOfTime() IExpressionContext


	// SetAsOfTime sets the asOfTime rule contexts.
	SetAsOfTime(IExpressionContext)


	// Getter signatures
	AllKW_FOR() []antlr.TerminalNode
	KW_FOR(i int) antlr.TerminalNode
	KW_SYSTEM_TIME() antlr.TerminalNode
	KW_AS() antlr.TerminalNode
	KW_OF() antlr.TerminalNode
	KW_SYSTEM_VERSION() antlr.TerminalNode
	Expression() IExpressionContext
	Number() antlr.TerminalNode

	// IsAsOfClauseContext differentiates from other interfaces.
	IsAsOfClauseContext()
}

type AsOfClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	asOfTime IExpressionContext 
	asOfVersion antlr.Token
}

func NewEmptyAsOfClauseContext() *AsOfClauseContext {
	var p = new(AsOfClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_asOfClause
	return p
}

func InitEmptyAsOfClauseContext(p *AsOfClauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_asOfClause
}

func (*AsOfClauseContext) IsAsOfClauseContext() {}

func NewAsOfClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AsOfClauseContext {
	var p = new(AsOfClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_asOfClause

	return p
}

func (s *AsOfClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AsOfClauseContext) GetAsOfVersion() antlr.Token { return s.asOfVersion }


func (s *AsOfClauseContext) SetAsOfVersion(v antlr.Token) { s.asOfVersion = v }


func (s *AsOfClauseContext) GetAsOfTime() IExpressionContext { return s.asOfTime }


func (s *AsOfClauseContext) SetAsOfTime(v IExpressionContext) { s.asOfTime = v }


func (s *AsOfClauseContext) AllKW_FOR() []antlr.TerminalNode {
	return s.GetTokens(HiveParserKW_FOR)
}

func (s *AsOfClauseContext) KW_FOR(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserKW_FOR, i)
}

func (s *AsOfClauseContext) KW_SYSTEM_TIME() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SYSTEM_TIME, 0)
}

func (s *AsOfClauseContext) KW_AS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_AS, 0)
}

func (s *AsOfClauseContext) KW_OF() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_OF, 0)
}

func (s *AsOfClauseContext) KW_SYSTEM_VERSION() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SYSTEM_VERSION, 0)
}

func (s *AsOfClauseContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AsOfClauseContext) Number() antlr.TerminalNode {
	return s.GetToken(HiveParserNumber, 0)
}

func (s *AsOfClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AsOfClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AsOfClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterAsOfClause(s)
	}
}

func (s *AsOfClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitAsOfClause(s)
	}
}

func (s *AsOfClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitAsOfClause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) AsOfClause() (localctx IAsOfClauseContext) {
	localctx = NewAsOfClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 636, HiveParserRULE_asOfClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3918)
		p.Match(HiveParserKW_FOR)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(3928)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserKW_SYSTEM_TIME:
		{
			p.SetState(3919)
			p.Match(HiveParserKW_SYSTEM_TIME)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3920)
			p.Match(HiveParserKW_AS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3921)
			p.Match(HiveParserKW_OF)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3922)

			var _x = p.Expression()


			localctx.(*AsOfClauseContext).asOfTime = _x
		}


	case HiveParserKW_FOR:
		{
			p.SetState(3923)
			p.Match(HiveParserKW_FOR)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3924)
			p.Match(HiveParserKW_SYSTEM_VERSION)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3925)
			p.Match(HiveParserKW_AS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3926)
			p.Match(HiveParserKW_OF)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3927)

			var _m = p.Match(HiveParserNumber)

			localctx.(*AsOfClauseContext).asOfVersion = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IUniqueJoinTableSourceContext is an interface to support dynamic dispatch.
type IUniqueJoinTableSourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTabname returns the tabname rule contexts.
	GetTabname() ITableNameContext

	// GetTs returns the ts rule contexts.
	GetTs() ITableSampleContext

	// GetAlias returns the alias rule contexts.
	GetAlias() IId_Context


	// SetTabname sets the tabname rule contexts.
	SetTabname(ITableNameContext)

	// SetTs sets the ts rule contexts.
	SetTs(ITableSampleContext)

	// SetAlias sets the alias rule contexts.
	SetAlias(IId_Context)


	// Getter signatures
	TableName() ITableNameContext
	TableSample() ITableSampleContext
	Id_() IId_Context
	KW_AS() antlr.TerminalNode

	// IsUniqueJoinTableSourceContext differentiates from other interfaces.
	IsUniqueJoinTableSourceContext()
}

type UniqueJoinTableSourceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	tabname ITableNameContext 
	ts ITableSampleContext 
	alias IId_Context 
}

func NewEmptyUniqueJoinTableSourceContext() *UniqueJoinTableSourceContext {
	var p = new(UniqueJoinTableSourceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_uniqueJoinTableSource
	return p
}

func InitEmptyUniqueJoinTableSourceContext(p *UniqueJoinTableSourceContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_uniqueJoinTableSource
}

func (*UniqueJoinTableSourceContext) IsUniqueJoinTableSourceContext() {}

func NewUniqueJoinTableSourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UniqueJoinTableSourceContext {
	var p = new(UniqueJoinTableSourceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_uniqueJoinTableSource

	return p
}

func (s *UniqueJoinTableSourceContext) GetParser() antlr.Parser { return s.parser }

func (s *UniqueJoinTableSourceContext) GetTabname() ITableNameContext { return s.tabname }

func (s *UniqueJoinTableSourceContext) GetTs() ITableSampleContext { return s.ts }

func (s *UniqueJoinTableSourceContext) GetAlias() IId_Context { return s.alias }


func (s *UniqueJoinTableSourceContext) SetTabname(v ITableNameContext) { s.tabname = v }

func (s *UniqueJoinTableSourceContext) SetTs(v ITableSampleContext) { s.ts = v }

func (s *UniqueJoinTableSourceContext) SetAlias(v IId_Context) { s.alias = v }


func (s *UniqueJoinTableSourceContext) TableName() ITableNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *UniqueJoinTableSourceContext) TableSample() ITableSampleContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableSampleContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableSampleContext)
}

func (s *UniqueJoinTableSourceContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *UniqueJoinTableSourceContext) KW_AS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_AS, 0)
}

func (s *UniqueJoinTableSourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UniqueJoinTableSourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *UniqueJoinTableSourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterUniqueJoinTableSource(s)
	}
}

func (s *UniqueJoinTableSourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitUniqueJoinTableSource(s)
	}
}

func (s *UniqueJoinTableSourceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitUniqueJoinTableSource(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) UniqueJoinTableSource() (localctx IUniqueJoinTableSourceContext) {
	localctx = NewUniqueJoinTableSourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 638, HiveParserRULE_uniqueJoinTableSource)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3930)

		var _x = p.TableName()


		localctx.(*UniqueJoinTableSourceContext).tabname = _x
	}
	p.SetState(3932)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_TABLESAMPLE {
		{
			p.SetState(3931)

			var _x = p.TableSample()


			localctx.(*UniqueJoinTableSourceContext).ts = _x
		}

	}
	p.SetState(3938)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 808078815591826814) != 0) || ((int64((_la - 66)) & ^0x3f) == 0 && ((int64(1) << (_la - 66)) & 1083038567331911621) != 0) || ((int64((_la - 132)) & ^0x3f) == 0 && ((int64(1) << (_la - 132)) & 8916819943869537315) != 0) || ((int64((_la - 196)) & ^0x3f) == 0 && ((int64(1) << (_la - 196)) & 4159991143015340909) != 0) || ((int64((_la - 261)) & ^0x3f) == 0 && ((int64(1) << (_la - 261)) & 8484708576009596927) != 0) || ((int64((_la - 328)) & ^0x3f) == 0 && ((int64(1) << (_la - 328)) & 17776728909112555) != 0) || _la == HiveParserIdentifier {
		p.SetState(3935)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_AS {
			{
				p.SetState(3934)
				p.Match(HiveParserKW_AS)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(3937)

			var _x = p.Id_()


			localctx.(*UniqueJoinTableSourceContext).alias = _x
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITableNameContext is an interface to support dynamic dispatch.
type ITableNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IId_Context

	// GetTab returns the tab rule contexts.
	GetTab() IId_Context

	// GetMeta returns the meta rule contexts.
	GetMeta() IId_Context


	// SetDb sets the db rule contexts.
	SetDb(IId_Context)

	// SetTab sets the tab rule contexts.
	SetTab(IId_Context)

	// SetMeta sets the meta rule contexts.
	SetMeta(IId_Context)


	// Getter signatures
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode
	AllId_() []IId_Context
	Id_(i int) IId_Context

	// IsTableNameContext differentiates from other interfaces.
	IsTableNameContext()
}

type TableNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	db IId_Context 
	tab IId_Context 
	meta IId_Context 
}

func NewEmptyTableNameContext() *TableNameContext {
	var p = new(TableNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_tableName
	return p
}

func InitEmptyTableNameContext(p *TableNameContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_tableName
}

func (*TableNameContext) IsTableNameContext() {}

func NewTableNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableNameContext {
	var p = new(TableNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_tableName

	return p
}

func (s *TableNameContext) GetParser() antlr.Parser { return s.parser }

func (s *TableNameContext) GetDb() IId_Context { return s.db }

func (s *TableNameContext) GetTab() IId_Context { return s.tab }

func (s *TableNameContext) GetMeta() IId_Context { return s.meta }


func (s *TableNameContext) SetDb(v IId_Context) { s.db = v }

func (s *TableNameContext) SetTab(v IId_Context) { s.tab = v }

func (s *TableNameContext) SetMeta(v IId_Context) { s.meta = v }


func (s *TableNameContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(HiveParserDOT)
}

func (s *TableNameContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserDOT, i)
}

func (s *TableNameContext) AllId_() []IId_Context {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IId_Context); ok {
			len++
		}
	}

	tst := make([]IId_Context, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IId_Context); ok {
			tst[i] = t.(IId_Context)
			i++
		}
	}

	return tst
}

func (s *TableNameContext) Id_(i int) IId_Context {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *TableNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TableNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterTableName(s)
	}
}

func (s *TableNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitTableName(s)
	}
}

func (s *TableNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitTableName(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) TableName() (localctx ITableNameContext) {
	localctx = NewTableNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 640, HiveParserRULE_tableName)
	p.SetState(3948)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 458, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3940)

			var _x = p.Id_()


			localctx.(*TableNameContext).db = _x
		}
		{
			p.SetState(3941)
			p.Match(HiveParserDOT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3942)

			var _x = p.Id_()


			localctx.(*TableNameContext).tab = _x
		}
		p.SetState(3945)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 457, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3943)
				p.Match(HiveParserDOT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(3944)

				var _x = p.Id_()


				localctx.(*TableNameContext).meta = _x
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3947)

			var _x = p.Id_()


			localctx.(*TableNameContext).tab = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IViewNameContext is an interface to support dynamic dispatch.
type IViewNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IId_Context

	// GetView returns the view rule contexts.
	GetView() IId_Context


	// SetDb sets the db rule contexts.
	SetDb(IId_Context)

	// SetView sets the view rule contexts.
	SetView(IId_Context)


	// Getter signatures
	AllId_() []IId_Context
	Id_(i int) IId_Context
	DOT() antlr.TerminalNode

	// IsViewNameContext differentiates from other interfaces.
	IsViewNameContext()
}

type ViewNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	db IId_Context 
	view IId_Context 
}

func NewEmptyViewNameContext() *ViewNameContext {
	var p = new(ViewNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_viewName
	return p
}

func InitEmptyViewNameContext(p *ViewNameContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_viewName
}

func (*ViewNameContext) IsViewNameContext() {}

func NewViewNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ViewNameContext {
	var p = new(ViewNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_viewName

	return p
}

func (s *ViewNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ViewNameContext) GetDb() IId_Context { return s.db }

func (s *ViewNameContext) GetView() IId_Context { return s.view }


func (s *ViewNameContext) SetDb(v IId_Context) { s.db = v }

func (s *ViewNameContext) SetView(v IId_Context) { s.view = v }


func (s *ViewNameContext) AllId_() []IId_Context {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IId_Context); ok {
			len++
		}
	}

	tst := make([]IId_Context, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IId_Context); ok {
			tst[i] = t.(IId_Context)
			i++
		}
	}

	return tst
}

func (s *ViewNameContext) Id_(i int) IId_Context {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *ViewNameContext) DOT() antlr.TerminalNode {
	return s.GetToken(HiveParserDOT, 0)
}

func (s *ViewNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ViewNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ViewNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterViewName(s)
	}
}

func (s *ViewNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitViewName(s)
	}
}

func (s *ViewNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitViewName(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ViewName() (localctx IViewNameContext) {
	localctx = NewViewNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 642, HiveParserRULE_viewName)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(3953)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 459, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3950)

			var _x = p.Id_()


			localctx.(*ViewNameContext).db = _x
		}
		{
			p.SetState(3951)
			p.Match(HiveParserDOT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(3955)

		var _x = p.Id_()


		localctx.(*ViewNameContext).view = _x
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISubQuerySourceContext is an interface to support dynamic dispatch.
type ISubQuerySourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	QueryStatementExpression() IQueryStatementExpressionContext
	RPAREN() antlr.TerminalNode
	Id_() IId_Context
	KW_AS() antlr.TerminalNode

	// IsSubQuerySourceContext differentiates from other interfaces.
	IsSubQuerySourceContext()
}

type SubQuerySourceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubQuerySourceContext() *SubQuerySourceContext {
	var p = new(SubQuerySourceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_subQuerySource
	return p
}

func InitEmptySubQuerySourceContext(p *SubQuerySourceContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_subQuerySource
}

func (*SubQuerySourceContext) IsSubQuerySourceContext() {}

func NewSubQuerySourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubQuerySourceContext {
	var p = new(SubQuerySourceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_subQuerySource

	return p
}

func (s *SubQuerySourceContext) GetParser() antlr.Parser { return s.parser }

func (s *SubQuerySourceContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserLPAREN, 0)
}

func (s *SubQuerySourceContext) QueryStatementExpression() IQueryStatementExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryStatementExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryStatementExpressionContext)
}

func (s *SubQuerySourceContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserRPAREN, 0)
}

func (s *SubQuerySourceContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *SubQuerySourceContext) KW_AS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_AS, 0)
}

func (s *SubQuerySourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubQuerySourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SubQuerySourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterSubQuerySource(s)
	}
}

func (s *SubQuerySourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitSubQuerySource(s)
	}
}

func (s *SubQuerySourceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitSubQuerySource(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) SubQuerySource() (localctx ISubQuerySourceContext) {
	localctx = NewSubQuerySourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 644, HiveParserRULE_subQuerySource)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3957)
		p.Match(HiveParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3958)
		p.QueryStatementExpression()
	}
	{
		p.SetState(3959)
		p.Match(HiveParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(3961)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_AS {
		{
			p.SetState(3960)
			p.Match(HiveParserKW_AS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(3963)
		p.Id_()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPartitioningSpecContext is an interface to support dynamic dispatch.
type IPartitioningSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PartitionByClause() IPartitionByClauseContext
	OrderByClause() IOrderByClauseContext
	DistributeByClause() IDistributeByClauseContext
	SortByClause() ISortByClauseContext
	ClusterByClause() IClusterByClauseContext

	// IsPartitioningSpecContext differentiates from other interfaces.
	IsPartitioningSpecContext()
}

type PartitioningSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitioningSpecContext() *PartitioningSpecContext {
	var p = new(PartitioningSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_partitioningSpec
	return p
}

func InitEmptyPartitioningSpecContext(p *PartitioningSpecContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_partitioningSpec
}

func (*PartitioningSpecContext) IsPartitioningSpecContext() {}

func NewPartitioningSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitioningSpecContext {
	var p = new(PartitioningSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_partitioningSpec

	return p
}

func (s *PartitioningSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitioningSpecContext) PartitionByClause() IPartitionByClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionByClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionByClauseContext)
}

func (s *PartitioningSpecContext) OrderByClause() IOrderByClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByClauseContext)
}

func (s *PartitioningSpecContext) DistributeByClause() IDistributeByClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDistributeByClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDistributeByClauseContext)
}

func (s *PartitioningSpecContext) SortByClause() ISortByClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortByClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortByClauseContext)
}

func (s *PartitioningSpecContext) ClusterByClause() IClusterByClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClusterByClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClusterByClauseContext)
}

func (s *PartitioningSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitioningSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PartitioningSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterPartitioningSpec(s)
	}
}

func (s *PartitioningSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitPartitioningSpec(s)
	}
}

func (s *PartitioningSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitPartitioningSpec(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) PartitioningSpec() (localctx IPartitioningSpecContext) {
	localctx = NewPartitioningSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 646, HiveParserRULE_partitioningSpec)
	var _la int

	p.SetState(3976)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserKW_PARTITION:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3965)
			p.PartitionByClause()
		}
		p.SetState(3967)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_ORDER {
			{
				p.SetState(3966)
				p.OrderByClause()
			}

		}


	case HiveParserKW_ORDER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3969)
			p.OrderByClause()
		}


	case HiveParserKW_DISTRIBUTE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3970)
			p.DistributeByClause()
		}
		p.SetState(3972)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_SORT {
			{
				p.SetState(3971)
				p.SortByClause()
			}

		}


	case HiveParserKW_SORT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3974)
			p.SortByClause()
		}


	case HiveParserKW_CLUSTER:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3975)
			p.ClusterByClause()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPartitionTableFunctionSourceContext is an interface to support dynamic dispatch.
type IPartitionTableFunctionSourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SubQuerySource() ISubQuerySourceContext
	TableSource() ITableSourceContext
	PartitionedTableFunction() IPartitionedTableFunctionContext

	// IsPartitionTableFunctionSourceContext differentiates from other interfaces.
	IsPartitionTableFunctionSourceContext()
}

type PartitionTableFunctionSourceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionTableFunctionSourceContext() *PartitionTableFunctionSourceContext {
	var p = new(PartitionTableFunctionSourceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_partitionTableFunctionSource
	return p
}

func InitEmptyPartitionTableFunctionSourceContext(p *PartitionTableFunctionSourceContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_partitionTableFunctionSource
}

func (*PartitionTableFunctionSourceContext) IsPartitionTableFunctionSourceContext() {}

func NewPartitionTableFunctionSourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionTableFunctionSourceContext {
	var p = new(PartitionTableFunctionSourceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_partitionTableFunctionSource

	return p
}

func (s *PartitionTableFunctionSourceContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionTableFunctionSourceContext) SubQuerySource() ISubQuerySourceContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubQuerySourceContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubQuerySourceContext)
}

func (s *PartitionTableFunctionSourceContext) TableSource() ITableSourceContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableSourceContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableSourceContext)
}

func (s *PartitionTableFunctionSourceContext) PartitionedTableFunction() IPartitionedTableFunctionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionedTableFunctionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionedTableFunctionContext)
}

func (s *PartitionTableFunctionSourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionTableFunctionSourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PartitionTableFunctionSourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterPartitionTableFunctionSource(s)
	}
}

func (s *PartitionTableFunctionSourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitPartitionTableFunctionSource(s)
	}
}

func (s *PartitionTableFunctionSourceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitPartitionTableFunctionSource(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) PartitionTableFunctionSource() (localctx IPartitionTableFunctionSourceContext) {
	localctx = NewPartitionTableFunctionSourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 648, HiveParserRULE_partitionTableFunctionSource)
	p.SetState(3981)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 464, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3978)
			p.SubQuerySource()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3979)
			p.TableSource()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3980)
			p.PartitionedTableFunction()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPartitionedTableFunctionContext is an interface to support dynamic dispatch.
type IPartitionedTableFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetN returns the n rule contexts.
	GetN() IId_Context

	// GetPtfsrc returns the ptfsrc rule contexts.
	GetPtfsrc() IPartitionTableFunctionSourceContext

	// GetSpec returns the spec rule contexts.
	GetSpec() IPartitioningSpecContext

	// GetAlias returns the alias rule contexts.
	GetAlias() IId_Context


	// SetN sets the n rule contexts.
	SetN(IId_Context)

	// SetPtfsrc sets the ptfsrc rule contexts.
	SetPtfsrc(IPartitionTableFunctionSourceContext)

	// SetSpec sets the spec rule contexts.
	SetSpec(IPartitioningSpecContext)

	// SetAlias sets the alias rule contexts.
	SetAlias(IId_Context)


	// Getter signatures
	AllLPAREN() []antlr.TerminalNode
	LPAREN(i int) antlr.TerminalNode
	KW_ON() antlr.TerminalNode
	AllRPAREN() []antlr.TerminalNode
	RPAREN(i int) antlr.TerminalNode
	AllId_() []IId_Context
	Id_(i int) IId_Context
	PartitionTableFunctionSource() IPartitionTableFunctionSourceContext
	AllIdentifier() []antlr.TerminalNode
	Identifier(i int) antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	PartitioningSpec() IPartitioningSpecContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPartitionedTableFunctionContext differentiates from other interfaces.
	IsPartitionedTableFunctionContext()
}

type PartitionedTableFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	n IId_Context 
	ptfsrc IPartitionTableFunctionSourceContext 
	spec IPartitioningSpecContext 
	alias IId_Context 
}

func NewEmptyPartitionedTableFunctionContext() *PartitionedTableFunctionContext {
	var p = new(PartitionedTableFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_partitionedTableFunction
	return p
}

func InitEmptyPartitionedTableFunctionContext(p *PartitionedTableFunctionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_partitionedTableFunction
}

func (*PartitionedTableFunctionContext) IsPartitionedTableFunctionContext() {}

func NewPartitionedTableFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionedTableFunctionContext {
	var p = new(PartitionedTableFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_partitionedTableFunction

	return p
}

func (s *PartitionedTableFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionedTableFunctionContext) GetN() IId_Context { return s.n }

func (s *PartitionedTableFunctionContext) GetPtfsrc() IPartitionTableFunctionSourceContext { return s.ptfsrc }

func (s *PartitionedTableFunctionContext) GetSpec() IPartitioningSpecContext { return s.spec }

func (s *PartitionedTableFunctionContext) GetAlias() IId_Context { return s.alias }


func (s *PartitionedTableFunctionContext) SetN(v IId_Context) { s.n = v }

func (s *PartitionedTableFunctionContext) SetPtfsrc(v IPartitionTableFunctionSourceContext) { s.ptfsrc = v }

func (s *PartitionedTableFunctionContext) SetSpec(v IPartitioningSpecContext) { s.spec = v }

func (s *PartitionedTableFunctionContext) SetAlias(v IId_Context) { s.alias = v }


func (s *PartitionedTableFunctionContext) AllLPAREN() []antlr.TerminalNode {
	return s.GetTokens(HiveParserLPAREN)
}

func (s *PartitionedTableFunctionContext) LPAREN(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserLPAREN, i)
}

func (s *PartitionedTableFunctionContext) KW_ON() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ON, 0)
}

func (s *PartitionedTableFunctionContext) AllRPAREN() []antlr.TerminalNode {
	return s.GetTokens(HiveParserRPAREN)
}

func (s *PartitionedTableFunctionContext) RPAREN(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserRPAREN, i)
}

func (s *PartitionedTableFunctionContext) AllId_() []IId_Context {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IId_Context); ok {
			len++
		}
	}

	tst := make([]IId_Context, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IId_Context); ok {
			tst[i] = t.(IId_Context)
			i++
		}
	}

	return tst
}

func (s *PartitionedTableFunctionContext) Id_(i int) IId_Context {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *PartitionedTableFunctionContext) PartitionTableFunctionSource() IPartitionTableFunctionSourceContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionTableFunctionSourceContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionTableFunctionSourceContext)
}

func (s *PartitionedTableFunctionContext) AllIdentifier() []antlr.TerminalNode {
	return s.GetTokens(HiveParserIdentifier)
}

func (s *PartitionedTableFunctionContext) Identifier(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserIdentifier, i)
}

func (s *PartitionedTableFunctionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *PartitionedTableFunctionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PartitionedTableFunctionContext) PartitioningSpec() IPartitioningSpecContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitioningSpecContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitioningSpecContext)
}

func (s *PartitionedTableFunctionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(HiveParserCOMMA)
}

func (s *PartitionedTableFunctionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserCOMMA, i)
}

func (s *PartitionedTableFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionedTableFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PartitionedTableFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterPartitionedTableFunction(s)
	}
}

func (s *PartitionedTableFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitPartitionedTableFunction(s)
	}
}

func (s *PartitionedTableFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitPartitionedTableFunction(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) PartitionedTableFunction() (localctx IPartitionedTableFunctionContext) {
	localctx = NewPartitionedTableFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 650, HiveParserRULE_partitionedTableFunction)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3983)

		var _x = p.Id_()


		localctx.(*PartitionedTableFunctionContext).n = _x
	}
	{
		p.SetState(3984)
		p.Match(HiveParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3985)
		p.Match(HiveParserKW_ON)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3986)

		var _x = p.PartitionTableFunctionSource()


		localctx.(*PartitionedTableFunctionContext).ptfsrc = _x
	}
	p.SetState(3988)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_CLUSTER || _la == HiveParserKW_DISTRIBUTE || _la == HiveParserKW_ORDER || _la == HiveParserKW_PARTITION || _la == HiveParserKW_SORT {
		{
			p.SetState(3987)

			var _x = p.PartitioningSpec()


			localctx.(*PartitionedTableFunctionContext).spec = _x
		}

	}
	p.SetState(4005)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserIdentifier {
		{
			p.SetState(3990)
			p.Match(HiveParserIdentifier)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3991)
			p.Match(HiveParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3992)
			p.Expression()
		}
		{
			p.SetState(3993)
			p.Match(HiveParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(4002)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == HiveParserCOMMA {
			{
				p.SetState(3994)
				p.Match(HiveParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(3995)
				p.Match(HiveParserIdentifier)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(3996)
				p.Match(HiveParserLPAREN)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(3997)
				p.Expression()
			}
			{
				p.SetState(3998)
				p.Match(HiveParserRPAREN)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


			p.SetState(4004)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(4007)
		p.Match(HiveParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(4009)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 468, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4008)

			var _x = p.Id_()


			localctx.(*PartitionedTableFunctionContext).alias = _x
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IWhereClauseContext is an interface to support dynamic dispatch.
type IWhereClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_WHERE() antlr.TerminalNode
	SearchCondition() ISearchConditionContext

	// IsWhereClauseContext differentiates from other interfaces.
	IsWhereClauseContext()
}

type WhereClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhereClauseContext() *WhereClauseContext {
	var p = new(WhereClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_whereClause
	return p
}

func InitEmptyWhereClauseContext(p *WhereClauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_whereClause
}

func (*WhereClauseContext) IsWhereClauseContext() {}

func NewWhereClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhereClauseContext {
	var p = new(WhereClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_whereClause

	return p
}

func (s *WhereClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WhereClauseContext) KW_WHERE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_WHERE, 0)
}

func (s *WhereClauseContext) SearchCondition() ISearchConditionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISearchConditionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISearchConditionContext)
}

func (s *WhereClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhereClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *WhereClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterWhereClause(s)
	}
}

func (s *WhereClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitWhereClause(s)
	}
}

func (s *WhereClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitWhereClause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) WhereClause() (localctx IWhereClauseContext) {
	localctx = NewWhereClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 652, HiveParserRULE_whereClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4011)
		p.Match(HiveParserKW_WHERE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4012)
		p.SearchCondition()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISearchConditionContext is an interface to support dynamic dispatch.
type ISearchConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext

	// IsSearchConditionContext differentiates from other interfaces.
	IsSearchConditionContext()
}

type SearchConditionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySearchConditionContext() *SearchConditionContext {
	var p = new(SearchConditionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_searchCondition
	return p
}

func InitEmptySearchConditionContext(p *SearchConditionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_searchCondition
}

func (*SearchConditionContext) IsSearchConditionContext() {}

func NewSearchConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SearchConditionContext {
	var p = new(SearchConditionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_searchCondition

	return p
}

func (s *SearchConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *SearchConditionContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SearchConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SearchConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SearchConditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterSearchCondition(s)
	}
}

func (s *SearchConditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitSearchCondition(s)
	}
}

func (s *SearchConditionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitSearchCondition(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) SearchCondition() (localctx ISearchConditionContext) {
	localctx = NewSearchConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 654, HiveParserRULE_searchCondition)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4014)
		p.Expression()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IValuesSourceContext is an interface to support dynamic dispatch.
type IValuesSourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ValuesClause() IValuesClauseContext

	// IsValuesSourceContext differentiates from other interfaces.
	IsValuesSourceContext()
}

type ValuesSourceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValuesSourceContext() *ValuesSourceContext {
	var p = new(ValuesSourceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_valuesSource
	return p
}

func InitEmptyValuesSourceContext(p *ValuesSourceContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_valuesSource
}

func (*ValuesSourceContext) IsValuesSourceContext() {}

func NewValuesSourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValuesSourceContext {
	var p = new(ValuesSourceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_valuesSource

	return p
}

func (s *ValuesSourceContext) GetParser() antlr.Parser { return s.parser }

func (s *ValuesSourceContext) ValuesClause() IValuesClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValuesClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValuesClauseContext)
}

func (s *ValuesSourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValuesSourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ValuesSourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterValuesSource(s)
	}
}

func (s *ValuesSourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitValuesSource(s)
	}
}

func (s *ValuesSourceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitValuesSource(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ValuesSource() (localctx IValuesSourceContext) {
	localctx = NewValuesSourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 656, HiveParserRULE_valuesSource)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4016)
		p.ValuesClause()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IValuesClauseContext is an interface to support dynamic dispatch.
type IValuesClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_VALUES() antlr.TerminalNode
	ValuesTableConstructor() IValuesTableConstructorContext

	// IsValuesClauseContext differentiates from other interfaces.
	IsValuesClauseContext()
}

type ValuesClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValuesClauseContext() *ValuesClauseContext {
	var p = new(ValuesClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_valuesClause
	return p
}

func InitEmptyValuesClauseContext(p *ValuesClauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_valuesClause
}

func (*ValuesClauseContext) IsValuesClauseContext() {}

func NewValuesClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValuesClauseContext {
	var p = new(ValuesClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_valuesClause

	return p
}

func (s *ValuesClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ValuesClauseContext) KW_VALUES() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_VALUES, 0)
}

func (s *ValuesClauseContext) ValuesTableConstructor() IValuesTableConstructorContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValuesTableConstructorContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValuesTableConstructorContext)
}

func (s *ValuesClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValuesClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ValuesClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterValuesClause(s)
	}
}

func (s *ValuesClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitValuesClause(s)
	}
}

func (s *ValuesClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitValuesClause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ValuesClause() (localctx IValuesClauseContext) {
	localctx = NewValuesClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 658, HiveParserRULE_valuesClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4018)
		p.Match(HiveParserKW_VALUES)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4019)
		p.ValuesTableConstructor()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IValuesTableConstructorContext is an interface to support dynamic dispatch.
type IValuesTableConstructorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllValueRowConstructor() []IValueRowConstructorContext
	ValueRowConstructor(i int) IValueRowConstructorContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	FirstValueRowConstructor() IFirstValueRowConstructorContext

	// IsValuesTableConstructorContext differentiates from other interfaces.
	IsValuesTableConstructorContext()
}

type ValuesTableConstructorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValuesTableConstructorContext() *ValuesTableConstructorContext {
	var p = new(ValuesTableConstructorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_valuesTableConstructor
	return p
}

func InitEmptyValuesTableConstructorContext(p *ValuesTableConstructorContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_valuesTableConstructor
}

func (*ValuesTableConstructorContext) IsValuesTableConstructorContext() {}

func NewValuesTableConstructorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValuesTableConstructorContext {
	var p = new(ValuesTableConstructorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_valuesTableConstructor

	return p
}

func (s *ValuesTableConstructorContext) GetParser() antlr.Parser { return s.parser }

func (s *ValuesTableConstructorContext) AllValueRowConstructor() []IValueRowConstructorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueRowConstructorContext); ok {
			len++
		}
	}

	tst := make([]IValueRowConstructorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueRowConstructorContext); ok {
			tst[i] = t.(IValueRowConstructorContext)
			i++
		}
	}

	return tst
}

func (s *ValuesTableConstructorContext) ValueRowConstructor(i int) IValueRowConstructorContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueRowConstructorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueRowConstructorContext)
}

func (s *ValuesTableConstructorContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(HiveParserCOMMA)
}

func (s *ValuesTableConstructorContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserCOMMA, i)
}

func (s *ValuesTableConstructorContext) FirstValueRowConstructor() IFirstValueRowConstructorContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFirstValueRowConstructorContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFirstValueRowConstructorContext)
}

func (s *ValuesTableConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValuesTableConstructorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ValuesTableConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterValuesTableConstructor(s)
	}
}

func (s *ValuesTableConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitValuesTableConstructor(s)
	}
}

func (s *ValuesTableConstructorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitValuesTableConstructor(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ValuesTableConstructor() (localctx IValuesTableConstructorContext) {
	localctx = NewValuesTableConstructorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 660, HiveParserRULE_valuesTableConstructor)
	var _la int

	p.SetState(4037)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 471, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4021)
			p.ValueRowConstructor()
		}
		p.SetState(4026)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == HiveParserCOMMA {
			{
				p.SetState(4022)
				p.Match(HiveParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(4023)
				p.ValueRowConstructor()
			}


			p.SetState(4028)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4029)
			p.FirstValueRowConstructor()
		}
		p.SetState(4034)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == HiveParserCOMMA {
			{
				p.SetState(4030)
				p.Match(HiveParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(4031)
				p.ValueRowConstructor()
			}


			p.SetState(4036)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IValueRowConstructorContext is an interface to support dynamic dispatch.
type IValueRowConstructorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ExpressionsInParenthesis() IExpressionsInParenthesisContext

	// IsValueRowConstructorContext differentiates from other interfaces.
	IsValueRowConstructorContext()
}

type ValueRowConstructorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueRowConstructorContext() *ValueRowConstructorContext {
	var p = new(ValueRowConstructorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_valueRowConstructor
	return p
}

func InitEmptyValueRowConstructorContext(p *ValueRowConstructorContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_valueRowConstructor
}

func (*ValueRowConstructorContext) IsValueRowConstructorContext() {}

func NewValueRowConstructorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueRowConstructorContext {
	var p = new(ValueRowConstructorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_valueRowConstructor

	return p
}

func (s *ValueRowConstructorContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueRowConstructorContext) ExpressionsInParenthesis() IExpressionsInParenthesisContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionsInParenthesisContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionsInParenthesisContext)
}

func (s *ValueRowConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueRowConstructorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ValueRowConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterValueRowConstructor(s)
	}
}

func (s *ValueRowConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitValueRowConstructor(s)
	}
}

func (s *ValueRowConstructorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitValueRowConstructor(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ValueRowConstructor() (localctx IValueRowConstructorContext) {
	localctx = NewValueRowConstructorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 662, HiveParserRULE_valueRowConstructor)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4039)
		p.ExpressionsInParenthesis()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFirstValueRowConstructorContext is an interface to support dynamic dispatch.
type IFirstValueRowConstructorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	FirstExpressionsWithAlias() IFirstExpressionsWithAliasContext
	RPAREN() antlr.TerminalNode

	// IsFirstValueRowConstructorContext differentiates from other interfaces.
	IsFirstValueRowConstructorContext()
}

type FirstValueRowConstructorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFirstValueRowConstructorContext() *FirstValueRowConstructorContext {
	var p = new(FirstValueRowConstructorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_firstValueRowConstructor
	return p
}

func InitEmptyFirstValueRowConstructorContext(p *FirstValueRowConstructorContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_firstValueRowConstructor
}

func (*FirstValueRowConstructorContext) IsFirstValueRowConstructorContext() {}

func NewFirstValueRowConstructorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FirstValueRowConstructorContext {
	var p = new(FirstValueRowConstructorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_firstValueRowConstructor

	return p
}

func (s *FirstValueRowConstructorContext) GetParser() antlr.Parser { return s.parser }

func (s *FirstValueRowConstructorContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserLPAREN, 0)
}

func (s *FirstValueRowConstructorContext) FirstExpressionsWithAlias() IFirstExpressionsWithAliasContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFirstExpressionsWithAliasContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFirstExpressionsWithAliasContext)
}

func (s *FirstValueRowConstructorContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserRPAREN, 0)
}

func (s *FirstValueRowConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FirstValueRowConstructorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *FirstValueRowConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterFirstValueRowConstructor(s)
	}
}

func (s *FirstValueRowConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitFirstValueRowConstructor(s)
	}
}

func (s *FirstValueRowConstructorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitFirstValueRowConstructor(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) FirstValueRowConstructor() (localctx IFirstValueRowConstructorContext) {
	localctx = NewFirstValueRowConstructorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 664, HiveParserRULE_firstValueRowConstructor)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4041)
		p.Match(HiveParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4042)
		p.FirstExpressionsWithAlias()
	}
	{
		p.SetState(4043)
		p.Match(HiveParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IVirtualTableSourceContext is an interface to support dynamic dispatch.
type IVirtualTableSourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_TABLE() antlr.TerminalNode
	AllLPAREN() []antlr.TerminalNode
	LPAREN(i int) antlr.TerminalNode
	ValuesClause() IValuesClauseContext
	AllRPAREN() []antlr.TerminalNode
	RPAREN(i int) antlr.TerminalNode
	TableAlias() ITableAliasContext
	KW_AS() antlr.TerminalNode
	AllId_() []IId_Context
	Id_(i int) IId_Context
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsVirtualTableSourceContext differentiates from other interfaces.
	IsVirtualTableSourceContext()
}

type VirtualTableSourceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVirtualTableSourceContext() *VirtualTableSourceContext {
	var p = new(VirtualTableSourceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_virtualTableSource
	return p
}

func InitEmptyVirtualTableSourceContext(p *VirtualTableSourceContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_virtualTableSource
}

func (*VirtualTableSourceContext) IsVirtualTableSourceContext() {}

func NewVirtualTableSourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VirtualTableSourceContext {
	var p = new(VirtualTableSourceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_virtualTableSource

	return p
}

func (s *VirtualTableSourceContext) GetParser() antlr.Parser { return s.parser }

func (s *VirtualTableSourceContext) KW_TABLE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TABLE, 0)
}

func (s *VirtualTableSourceContext) AllLPAREN() []antlr.TerminalNode {
	return s.GetTokens(HiveParserLPAREN)
}

func (s *VirtualTableSourceContext) LPAREN(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserLPAREN, i)
}

func (s *VirtualTableSourceContext) ValuesClause() IValuesClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValuesClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValuesClauseContext)
}

func (s *VirtualTableSourceContext) AllRPAREN() []antlr.TerminalNode {
	return s.GetTokens(HiveParserRPAREN)
}

func (s *VirtualTableSourceContext) RPAREN(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserRPAREN, i)
}

func (s *VirtualTableSourceContext) TableAlias() ITableAliasContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableAliasContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableAliasContext)
}

func (s *VirtualTableSourceContext) KW_AS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_AS, 0)
}

func (s *VirtualTableSourceContext) AllId_() []IId_Context {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IId_Context); ok {
			len++
		}
	}

	tst := make([]IId_Context, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IId_Context); ok {
			tst[i] = t.(IId_Context)
			i++
		}
	}

	return tst
}

func (s *VirtualTableSourceContext) Id_(i int) IId_Context {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *VirtualTableSourceContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(HiveParserCOMMA)
}

func (s *VirtualTableSourceContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserCOMMA, i)
}

func (s *VirtualTableSourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VirtualTableSourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *VirtualTableSourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterVirtualTableSource(s)
	}
}

func (s *VirtualTableSourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitVirtualTableSource(s)
	}
}

func (s *VirtualTableSourceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitVirtualTableSource(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) VirtualTableSource() (localctx IVirtualTableSourceContext) {
	localctx = NewVirtualTableSourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 666, HiveParserRULE_virtualTableSource)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4045)
		p.Match(HiveParserKW_TABLE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4046)
		p.Match(HiveParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4047)
		p.ValuesClause()
	}
	{
		p.SetState(4048)
		p.Match(HiveParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(4050)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_AS {
		{
			p.SetState(4049)
			p.Match(HiveParserKW_AS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(4052)
		p.TableAlias()
	}
	p.SetState(4062)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserLPAREN {
		{
			p.SetState(4053)
			p.Match(HiveParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4054)
			p.Id_()
		}
		p.SetState(4059)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == HiveParserCOMMA {
			{
				p.SetState(4055)
				p.Match(HiveParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(4056)
				p.Id_()
			}


			p.SetState(4061)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(4064)
		p.Match(HiveParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISelectClauseContext is an interface to support dynamic dispatch.
type ISelectClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_SELECT() antlr.TerminalNode
	SelectList() ISelectListContext
	KW_TRANSFORM() antlr.TerminalNode
	SelectTrfmClause() ISelectTrfmClauseContext
	QUERY_HINT() antlr.TerminalNode
	All_distinct() IAll_distinctContext
	TrfmClause() ITrfmClauseContext

	// IsSelectClauseContext differentiates from other interfaces.
	IsSelectClauseContext()
}

type SelectClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectClauseContext() *SelectClauseContext {
	var p = new(SelectClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_selectClause
	return p
}

func InitEmptySelectClauseContext(p *SelectClauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_selectClause
}

func (*SelectClauseContext) IsSelectClauseContext() {}

func NewSelectClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectClauseContext {
	var p = new(SelectClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_selectClause

	return p
}

func (s *SelectClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectClauseContext) KW_SELECT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SELECT, 0)
}

func (s *SelectClauseContext) SelectList() ISelectListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectListContext)
}

func (s *SelectClauseContext) KW_TRANSFORM() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TRANSFORM, 0)
}

func (s *SelectClauseContext) SelectTrfmClause() ISelectTrfmClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectTrfmClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectTrfmClauseContext)
}

func (s *SelectClauseContext) QUERY_HINT() antlr.TerminalNode {
	return s.GetToken(HiveParserQUERY_HINT, 0)
}

func (s *SelectClauseContext) All_distinct() IAll_distinctContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAll_distinctContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAll_distinctContext)
}

func (s *SelectClauseContext) TrfmClause() ITrfmClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITrfmClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITrfmClauseContext)
}

func (s *SelectClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SelectClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterSelectClause(s)
	}
}

func (s *SelectClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitSelectClause(s)
	}
}

func (s *SelectClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitSelectClause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) SelectClause() (localctx ISelectClauseContext) {
	localctx = NewSelectClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 668, HiveParserRULE_selectClause)
	var _la int

	p.SetState(4079)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserKW_SELECT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4066)
			p.Match(HiveParserKW_SELECT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(4068)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserQUERY_HINT {
			{
				p.SetState(4067)
				p.Match(HiveParserQUERY_HINT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		p.SetState(4076)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case HiveParserKW_ABORT, HiveParserKW_ACTIVATE, HiveParserKW_ACTIVE, HiveParserKW_ADD, HiveParserKW_ADMIN, HiveParserKW_AFTER, HiveParserKW_ALL, HiveParserKW_ALLOC_FRACTION, HiveParserKW_ANALYZE, HiveParserKW_ARCHIVE, HiveParserKW_ARRAY, HiveParserKW_ASC, HiveParserKW_AST, HiveParserKW_AT, HiveParserKW_AUTOCOMMIT, HiveParserKW_BATCH, HiveParserKW_BEFORE, HiveParserKW_BIGINT, HiveParserKW_BINARY, HiveParserKW_BOOLEAN, HiveParserKW_BUCKET, HiveParserKW_BUCKETS, HiveParserKW_CACHE, HiveParserKW_CASCADE, HiveParserKW_CASE, HiveParserKW_CAST, HiveParserKW_CBO, HiveParserKW_CHANGE, HiveParserKW_CHECK, HiveParserKW_CLUSTER, HiveParserKW_CLUSTERED, HiveParserKW_CLUSTERSTATUS, HiveParserKW_COLLECTION, HiveParserKW_COLUMNS, HiveParserKW_COMMENT, HiveParserKW_COMPACT, HiveParserKW_COMPACTIONS, HiveParserKW_COMPUTE, HiveParserKW_CONCATENATE, HiveParserKW_CONTINUE, HiveParserKW_COST, HiveParserKW_CRON, HiveParserKW_CURRENT_DATE, HiveParserKW_CURRENT_TIMESTAMP, HiveParserKW_DATA, HiveParserKW_DATABASES, HiveParserKW_DATE, HiveParserKW_DATETIME, HiveParserKW_DAY, HiveParserKW_DAYOFWEEK, HiveParserKW_DBPROPERTIES, HiveParserKW_DCPROPERTIES, HiveParserKW_DEBUG, HiveParserKW_DEFAULT, HiveParserKW_DEFERRED, HiveParserKW_DEFINED, HiveParserKW_DELIMITED, HiveParserKW_DEPENDENCY, HiveParserKW_DESC, HiveParserKW_DETAIL, HiveParserKW_DIRECTORIES, HiveParserKW_DIRECTORY, HiveParserKW_DISABLE, HiveParserKW_DISTINCT, HiveParserKW_DISTRIBUTE, HiveParserKW_DISTRIBUTED, HiveParserKW_DO, HiveParserKW_DOUBLE, HiveParserKW_DOW, HiveParserKW_DUMP, HiveParserKW_ELEM_TYPE, HiveParserKW_ENABLE, HiveParserKW_ENFORCED, HiveParserKW_ESCAPED, HiveParserKW_EVERY, HiveParserKW_EXCLUSIVE, HiveParserKW_EXECUTE, HiveParserKW_EXECUTED, HiveParserKW_EXISTS, HiveParserKW_EXPIRE_SNAPSHOTS, HiveParserKW_EXPLAIN, HiveParserKW_EXPORT, HiveParserKW_EXPRESSION, HiveParserKW_EXTRACT, HiveParserKW_FALSE, HiveParserKW_FIELDS, HiveParserKW_FILE, HiveParserKW_FILEFORMAT, HiveParserKW_FIRST, HiveParserKW_FLOAT, HiveParserKW_FLOOR, HiveParserKW_FORMAT, HiveParserKW_FORMATTED, HiveParserKW_FUNCTIONS, HiveParserKW_GROUPING, HiveParserKW_HOLD_DDLTIME, HiveParserKW_HOUR, HiveParserKW_IDXPROPERTIES, HiveParserKW_IF, HiveParserKW_IGNORE, HiveParserKW_INDEX, HiveParserKW_INDEXES, HiveParserKW_INPATH, HiveParserKW_INPUTDRIVER, HiveParserKW_INPUTFORMAT, HiveParserKW_INT, HiveParserKW_INTERVAL, HiveParserKW_ISOLATION, HiveParserKW_ITEMS, HiveParserKW_JAR, HiveParserKW_JOINCOST, HiveParserKW_KEY, HiveParserKW_KEYS, HiveParserKW_KEY_TYPE, HiveParserKW_KILL, HiveParserKW_LAST, HiveParserKW_LEVEL, HiveParserKW_LIMIT, HiveParserKW_LINES, HiveParserKW_LOAD, HiveParserKW_LOCATION, HiveParserKW_LOCK, HiveParserKW_LOCKS, HiveParserKW_LOGICAL, HiveParserKW_LONG, HiveParserKW_MANAGED, HiveParserKW_MANAGEDLOCATION, HiveParserKW_MANAGEMENT, HiveParserKW_MAP, HiveParserKW_MAPJOIN, HiveParserKW_MAPPING, HiveParserKW_MATCHED, HiveParserKW_MATERIALIZED, HiveParserKW_METADATA, HiveParserKW_MINUTE, HiveParserKW_MONTH, HiveParserKW_MOVE, HiveParserKW_MSCK, HiveParserKW_NORELY, HiveParserKW_NOSCAN, HiveParserKW_NOT, HiveParserKW_NOVALIDATE, HiveParserKW_NO_DROP, HiveParserKW_NULL, HiveParserKW_NULLS, HiveParserKW_OFFLINE, HiveParserKW_OFFSET, HiveParserKW_OPERATOR, HiveParserKW_OPTION, HiveParserKW_OUTPUTDRIVER, HiveParserKW_OUTPUTFORMAT, HiveParserKW_OVERWRITE, HiveParserKW_OWNER, HiveParserKW_PARTITIONED, HiveParserKW_PARTITIONS, HiveParserKW_PATH, HiveParserKW_PLAN, HiveParserKW_PLANS, HiveParserKW_PLUS, HiveParserKW_POOL, HiveParserKW_PRINCIPALS, HiveParserKW_PROTECTION, HiveParserKW_PURGE, HiveParserKW_QUARTER, HiveParserKW_QUERY, HiveParserKW_QUERY_PARALLELISM, HiveParserKW_READ, HiveParserKW_READONLY, HiveParserKW_REAL, HiveParserKW_REBUILD, HiveParserKW_RECORDREADER, HiveParserKW_RECORDWRITER, HiveParserKW_RELOAD, HiveParserKW_RELY, HiveParserKW_REMOTE, HiveParserKW_RENAME, HiveParserKW_REOPTIMIZATION, HiveParserKW_REPAIR, HiveParserKW_REPL, HiveParserKW_REPLACE, HiveParserKW_REPLICATION, HiveParserKW_RESOURCE, HiveParserKW_RESPECT, HiveParserKW_RESTRICT, HiveParserKW_REWRITE, HiveParserKW_ROLE, HiveParserKW_ROLES, HiveParserKW_SCHEDULED, HiveParserKW_SCHEDULING_POLICY, HiveParserKW_SCHEMA, HiveParserKW_SCHEMAS, HiveParserKW_SECOND, HiveParserKW_SEMI, HiveParserKW_SERDE, HiveParserKW_SERDEPROPERTIES, HiveParserKW_SERVER, HiveParserKW_SETS, HiveParserKW_SET_CURRENT_SNAPSHOT, HiveParserKW_SHARED, HiveParserKW_SHOW, HiveParserKW_SHOW_DATABASE, HiveParserKW_SKEWED, HiveParserKW_SMALLINT, HiveParserKW_SNAPSHOT, HiveParserKW_SORT, HiveParserKW_SORTED, HiveParserKW_SPEC, HiveParserKW_SSL, HiveParserKW_STATISTICS, HiveParserKW_STATUS, HiveParserKW_STORED, HiveParserKW_STREAMTABLE, HiveParserKW_STRING, HiveParserKW_STRUCT, HiveParserKW_SUMMARY, HiveParserKW_SYSTEM_TIME, HiveParserKW_SYSTEM_VERSION, HiveParserKW_TABLES, HiveParserKW_TBLPROPERTIES, HiveParserKW_TEMPORARY, HiveParserKW_TERMINATED, HiveParserKW_TIMESTAMP, HiveParserKW_TIMESTAMPLOCALTZ, HiveParserKW_TIMESTAMPTZ, HiveParserKW_TINYINT, HiveParserKW_TOUCH, HiveParserKW_TRANSACTION, HiveParserKW_TRANSACTIONAL, HiveParserKW_TRANSACTIONS, HiveParserKW_TRIM, HiveParserKW_TRUE, HiveParserKW_TYPE, HiveParserKW_UNARCHIVE, HiveParserKW_UNDO, HiveParserKW_UNIONTYPE, HiveParserKW_UNKNOWN, HiveParserKW_UNLOCK, HiveParserKW_UNMANAGED, HiveParserKW_UNSET, HiveParserKW_UNSIGNED, HiveParserKW_URI, HiveParserKW_URL, HiveParserKW_USE, HiveParserKW_UTC, HiveParserKW_UTCTIMESTAMP, HiveParserKW_VALIDATE, HiveParserKW_VALUE_TYPE, HiveParserKW_VECTORIZATION, HiveParserKW_VIEW, HiveParserKW_VIEWS, HiveParserKW_WAIT, HiveParserKW_WEEK, HiveParserKW_WHILE, HiveParserKW_WITHIN, HiveParserKW_WORK, HiveParserKW_WORKLOAD, HiveParserKW_WRITE, HiveParserKW_YEAR, HiveParserKW_ZONE, HiveParserLPAREN, HiveParserPLUS, HiveParserMINUS, HiveParserSTAR, HiveParserTILDE, HiveParserQUESTION, HiveParserStringLiteral, HiveParserIntegralLiteral, HiveParserNumberLiteral, HiveParserNumber, HiveParserIdentifier, HiveParserCharSetName:
			p.SetState(4071)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == HiveParserKW_ALL || _la == HiveParserKW_DISTINCT {
				{
					p.SetState(4070)
					p.All_distinct()
				}

			}
			{
				p.SetState(4073)
				p.SelectList()
			}


		case HiveParserKW_TRANSFORM:
			{
				p.SetState(4074)
				p.Match(HiveParserKW_TRANSFORM)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(4075)
				p.SelectTrfmClause()
			}



		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}


	case HiveParserKW_MAP, HiveParserKW_REDUCE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4078)
			p.TrfmClause()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAll_distinctContext is an interface to support dynamic dispatch.
type IAll_distinctContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_ALL() antlr.TerminalNode
	KW_DISTINCT() antlr.TerminalNode

	// IsAll_distinctContext differentiates from other interfaces.
	IsAll_distinctContext()
}

type All_distinctContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAll_distinctContext() *All_distinctContext {
	var p = new(All_distinctContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_all_distinct
	return p
}

func InitEmptyAll_distinctContext(p *All_distinctContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_all_distinct
}

func (*All_distinctContext) IsAll_distinctContext() {}

func NewAll_distinctContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *All_distinctContext {
	var p = new(All_distinctContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_all_distinct

	return p
}

func (s *All_distinctContext) GetParser() antlr.Parser { return s.parser }

func (s *All_distinctContext) KW_ALL() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ALL, 0)
}

func (s *All_distinctContext) KW_DISTINCT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DISTINCT, 0)
}

func (s *All_distinctContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *All_distinctContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *All_distinctContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterAll_distinct(s)
	}
}

func (s *All_distinctContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitAll_distinct(s)
	}
}

func (s *All_distinctContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitAll_distinct(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) All_distinct() (localctx IAll_distinctContext) {
	localctx = NewAll_distinctContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 670, HiveParserRULE_all_distinct)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4081)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HiveParserKW_ALL || _la == HiveParserKW_DISTINCT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISelectListContext is an interface to support dynamic dispatch.
type ISelectListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSelectItem() []ISelectItemContext
	SelectItem(i int) ISelectItemContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsSelectListContext differentiates from other interfaces.
	IsSelectListContext()
}

type SelectListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectListContext() *SelectListContext {
	var p = new(SelectListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_selectList
	return p
}

func InitEmptySelectListContext(p *SelectListContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_selectList
}

func (*SelectListContext) IsSelectListContext() {}

func NewSelectListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectListContext {
	var p = new(SelectListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_selectList

	return p
}

func (s *SelectListContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectListContext) AllSelectItem() []ISelectItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelectItemContext); ok {
			len++
		}
	}

	tst := make([]ISelectItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelectItemContext); ok {
			tst[i] = t.(ISelectItemContext)
			i++
		}
	}

	return tst
}

func (s *SelectListContext) SelectItem(i int) ISelectItemContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectItemContext)
}

func (s *SelectListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(HiveParserCOMMA)
}

func (s *SelectListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserCOMMA, i)
}

func (s *SelectListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SelectListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterSelectList(s)
	}
}

func (s *SelectListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitSelectList(s)
	}
}

func (s *SelectListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitSelectList(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) SelectList() (localctx ISelectListContext) {
	localctx = NewSelectListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 672, HiveParserRULE_selectList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4083)
		p.SelectItem()
	}
	p.SetState(4088)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 479, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4084)
				p.Match(HiveParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(4085)
				p.SelectItem()
			}


		}
		p.SetState(4090)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 479, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISelectTrfmClauseContext is an interface to support dynamic dispatch.
type ISelectTrfmClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLPAREN() []antlr.TerminalNode
	LPAREN(i int) antlr.TerminalNode
	SelectExpressionList() ISelectExpressionListContext
	AllRPAREN() []antlr.TerminalNode
	RPAREN(i int) antlr.TerminalNode
	AllRowFormat() []IRowFormatContext
	RowFormat(i int) IRowFormatContext
	RecordWriter() IRecordWriterContext
	KW_USING() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode
	RecordReader() IRecordReaderContext
	KW_AS() antlr.TerminalNode
	AliasList() IAliasListContext
	ColumnNameTypeList() IColumnNameTypeListContext

	// IsSelectTrfmClauseContext differentiates from other interfaces.
	IsSelectTrfmClauseContext()
}

type SelectTrfmClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectTrfmClauseContext() *SelectTrfmClauseContext {
	var p = new(SelectTrfmClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_selectTrfmClause
	return p
}

func InitEmptySelectTrfmClauseContext(p *SelectTrfmClauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_selectTrfmClause
}

func (*SelectTrfmClauseContext) IsSelectTrfmClauseContext() {}

func NewSelectTrfmClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectTrfmClauseContext {
	var p = new(SelectTrfmClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_selectTrfmClause

	return p
}

func (s *SelectTrfmClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectTrfmClauseContext) AllLPAREN() []antlr.TerminalNode {
	return s.GetTokens(HiveParserLPAREN)
}

func (s *SelectTrfmClauseContext) LPAREN(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserLPAREN, i)
}

func (s *SelectTrfmClauseContext) SelectExpressionList() ISelectExpressionListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectExpressionListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectExpressionListContext)
}

func (s *SelectTrfmClauseContext) AllRPAREN() []antlr.TerminalNode {
	return s.GetTokens(HiveParserRPAREN)
}

func (s *SelectTrfmClauseContext) RPAREN(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserRPAREN, i)
}

func (s *SelectTrfmClauseContext) AllRowFormat() []IRowFormatContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRowFormatContext); ok {
			len++
		}
	}

	tst := make([]IRowFormatContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRowFormatContext); ok {
			tst[i] = t.(IRowFormatContext)
			i++
		}
	}

	return tst
}

func (s *SelectTrfmClauseContext) RowFormat(i int) IRowFormatContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRowFormatContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRowFormatContext)
}

func (s *SelectTrfmClauseContext) RecordWriter() IRecordWriterContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordWriterContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordWriterContext)
}

func (s *SelectTrfmClauseContext) KW_USING() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_USING, 0)
}

func (s *SelectTrfmClauseContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(HiveParserStringLiteral, 0)
}

func (s *SelectTrfmClauseContext) RecordReader() IRecordReaderContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordReaderContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordReaderContext)
}

func (s *SelectTrfmClauseContext) KW_AS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_AS, 0)
}

func (s *SelectTrfmClauseContext) AliasList() IAliasListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAliasListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAliasListContext)
}

func (s *SelectTrfmClauseContext) ColumnNameTypeList() IColumnNameTypeListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNameTypeListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNameTypeListContext)
}

func (s *SelectTrfmClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectTrfmClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SelectTrfmClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterSelectTrfmClause(s)
	}
}

func (s *SelectTrfmClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitSelectTrfmClause(s)
	}
}

func (s *SelectTrfmClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitSelectTrfmClause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) SelectTrfmClause() (localctx ISelectTrfmClauseContext) {
	localctx = NewSelectTrfmClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 674, HiveParserRULE_selectTrfmClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4091)
		p.Match(HiveParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4092)
		p.SelectExpressionList()
	}
	{
		p.SetState(4093)
		p.Match(HiveParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4094)
		p.RowFormat()
	}
	{
		p.SetState(4095)
		p.RecordWriter()
	}
	{
		p.SetState(4096)
		p.Match(HiveParserKW_USING)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4097)
		p.Match(HiveParserStringLiteral)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(4110)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_AS {
		{
			p.SetState(4098)
			p.Match(HiveParserKW_AS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(4108)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 481, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(4099)
				p.Match(HiveParserLPAREN)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			p.SetState(4102)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 480, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(4100)
					p.AliasList()
				}


			case 2:
				{
					p.SetState(4101)
					p.ColumnNameTypeList()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}
			{
				p.SetState(4104)
				p.Match(HiveParserRPAREN)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


		case 2:
			{
				p.SetState(4106)
				p.AliasList()
			}


		case 3:
			{
				p.SetState(4107)
				p.ColumnNameTypeList()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	}
	{
		p.SetState(4112)
		p.RowFormat()
	}
	{
		p.SetState(4113)
		p.RecordReader()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISelectItemContext is an interface to support dynamic dispatch.
type ISelectItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TableAllColumns() ITableAllColumnsContext
	Expression() IExpressionContext
	AllId_() []IId_Context
	Id_(i int) IId_Context
	KW_AS() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsSelectItemContext differentiates from other interfaces.
	IsSelectItemContext()
}

type SelectItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectItemContext() *SelectItemContext {
	var p = new(SelectItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_selectItem
	return p
}

func InitEmptySelectItemContext(p *SelectItemContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_selectItem
}

func (*SelectItemContext) IsSelectItemContext() {}

func NewSelectItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectItemContext {
	var p = new(SelectItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_selectItem

	return p
}

func (s *SelectItemContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectItemContext) TableAllColumns() ITableAllColumnsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableAllColumnsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableAllColumnsContext)
}

func (s *SelectItemContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SelectItemContext) AllId_() []IId_Context {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IId_Context); ok {
			len++
		}
	}

	tst := make([]IId_Context, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IId_Context); ok {
			tst[i] = t.(IId_Context)
			i++
		}
	}

	return tst
}

func (s *SelectItemContext) Id_(i int) IId_Context {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *SelectItemContext) KW_AS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_AS, 0)
}

func (s *SelectItemContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserLPAREN, 0)
}

func (s *SelectItemContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserRPAREN, 0)
}

func (s *SelectItemContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(HiveParserCOMMA)
}

func (s *SelectItemContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserCOMMA, i)
}

func (s *SelectItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SelectItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterSelectItem(s)
	}
}

func (s *SelectItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitSelectItem(s)
	}
}

func (s *SelectItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitSelectItem(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) SelectItem() (localctx ISelectItemContext) {
	localctx = NewSelectItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 676, HiveParserRULE_selectItem)
	var _la int

	p.SetState(4135)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 486, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4115)
			p.TableAllColumns()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4116)
			p.Expression()
		}
		p.SetState(4133)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 485, p.GetParserRuleContext()) == 1 {
			p.SetState(4118)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == HiveParserKW_AS {
				{
					p.SetState(4117)
					p.Match(HiveParserKW_AS)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}

			}
			{
				p.SetState(4120)
				p.Id_()
			}

			} else if p.HasError() { // JIM
				goto errorExit} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 485, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(4121)
				p.Match(HiveParserKW_AS)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(4122)
				p.Match(HiveParserLPAREN)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(4123)
				p.Id_()
			}
			p.SetState(4128)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			for _la == HiveParserCOMMA {
				{
					p.SetState(4124)
					p.Match(HiveParserCOMMA)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(4125)
					p.Id_()
				}


				p.SetState(4130)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
			    	goto errorExit
			    }
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(4131)
				p.Match(HiveParserRPAREN)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITrfmClauseContext is an interface to support dynamic dispatch.
type ITrfmClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SelectExpressionList() ISelectExpressionListContext
	AllRowFormat() []IRowFormatContext
	RowFormat(i int) IRowFormatContext
	RecordWriter() IRecordWriterContext
	KW_USING() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode
	RecordReader() IRecordReaderContext
	KW_MAP() antlr.TerminalNode
	KW_REDUCE() antlr.TerminalNode
	KW_AS() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	AliasList() IAliasListContext
	ColumnNameTypeList() IColumnNameTypeListContext

	// IsTrfmClauseContext differentiates from other interfaces.
	IsTrfmClauseContext()
}

type TrfmClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTrfmClauseContext() *TrfmClauseContext {
	var p = new(TrfmClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_trfmClause
	return p
}

func InitEmptyTrfmClauseContext(p *TrfmClauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_trfmClause
}

func (*TrfmClauseContext) IsTrfmClauseContext() {}

func NewTrfmClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TrfmClauseContext {
	var p = new(TrfmClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_trfmClause

	return p
}

func (s *TrfmClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *TrfmClauseContext) SelectExpressionList() ISelectExpressionListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectExpressionListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectExpressionListContext)
}

func (s *TrfmClauseContext) AllRowFormat() []IRowFormatContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRowFormatContext); ok {
			len++
		}
	}

	tst := make([]IRowFormatContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRowFormatContext); ok {
			tst[i] = t.(IRowFormatContext)
			i++
		}
	}

	return tst
}

func (s *TrfmClauseContext) RowFormat(i int) IRowFormatContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRowFormatContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRowFormatContext)
}

func (s *TrfmClauseContext) RecordWriter() IRecordWriterContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordWriterContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordWriterContext)
}

func (s *TrfmClauseContext) KW_USING() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_USING, 0)
}

func (s *TrfmClauseContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(HiveParserStringLiteral, 0)
}

func (s *TrfmClauseContext) RecordReader() IRecordReaderContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordReaderContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordReaderContext)
}

func (s *TrfmClauseContext) KW_MAP() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_MAP, 0)
}

func (s *TrfmClauseContext) KW_REDUCE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_REDUCE, 0)
}

func (s *TrfmClauseContext) KW_AS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_AS, 0)
}

func (s *TrfmClauseContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserLPAREN, 0)
}

func (s *TrfmClauseContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserRPAREN, 0)
}

func (s *TrfmClauseContext) AliasList() IAliasListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAliasListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAliasListContext)
}

func (s *TrfmClauseContext) ColumnNameTypeList() IColumnNameTypeListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNameTypeListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNameTypeListContext)
}

func (s *TrfmClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TrfmClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TrfmClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterTrfmClause(s)
	}
}

func (s *TrfmClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitTrfmClause(s)
	}
}

func (s *TrfmClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitTrfmClause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) TrfmClause() (localctx ITrfmClauseContext) {
	localctx = NewTrfmClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 678, HiveParserRULE_trfmClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4137)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HiveParserKW_MAP || _la == HiveParserKW_REDUCE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(4138)
		p.SelectExpressionList()
	}
	{
		p.SetState(4139)
		p.RowFormat()
	}
	{
		p.SetState(4140)
		p.RecordWriter()
	}
	{
		p.SetState(4141)
		p.Match(HiveParserKW_USING)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4142)
		p.Match(HiveParserStringLiteral)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(4155)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_AS {
		{
			p.SetState(4143)
			p.Match(HiveParserKW_AS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(4153)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 488, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(4144)
				p.Match(HiveParserLPAREN)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			p.SetState(4147)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 487, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(4145)
					p.AliasList()
				}


			case 2:
				{
					p.SetState(4146)
					p.ColumnNameTypeList()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}
			{
				p.SetState(4149)
				p.Match(HiveParserRPAREN)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


		case 2:
			{
				p.SetState(4151)
				p.AliasList()
			}


		case 3:
			{
				p.SetState(4152)
				p.ColumnNameTypeList()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	}
	{
		p.SetState(4157)
		p.RowFormat()
	}
	{
		p.SetState(4158)
		p.RecordReader()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISelectExpressionContext is an interface to support dynamic dispatch.
type ISelectExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TableAllColumns() ITableAllColumnsContext
	Expression() IExpressionContext

	// IsSelectExpressionContext differentiates from other interfaces.
	IsSelectExpressionContext()
}

type SelectExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectExpressionContext() *SelectExpressionContext {
	var p = new(SelectExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_selectExpression
	return p
}

func InitEmptySelectExpressionContext(p *SelectExpressionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_selectExpression
}

func (*SelectExpressionContext) IsSelectExpressionContext() {}

func NewSelectExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectExpressionContext {
	var p = new(SelectExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_selectExpression

	return p
}

func (s *SelectExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectExpressionContext) TableAllColumns() ITableAllColumnsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableAllColumnsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableAllColumnsContext)
}

func (s *SelectExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SelectExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SelectExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterSelectExpression(s)
	}
}

func (s *SelectExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitSelectExpression(s)
	}
}

func (s *SelectExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitSelectExpression(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) SelectExpression() (localctx ISelectExpressionContext) {
	localctx = NewSelectExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 680, HiveParserRULE_selectExpression)
	p.SetState(4162)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 490, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4160)
			p.TableAllColumns()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4161)
			p.Expression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISelectExpressionListContext is an interface to support dynamic dispatch.
type ISelectExpressionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSelectExpression() []ISelectExpressionContext
	SelectExpression(i int) ISelectExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsSelectExpressionListContext differentiates from other interfaces.
	IsSelectExpressionListContext()
}

type SelectExpressionListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectExpressionListContext() *SelectExpressionListContext {
	var p = new(SelectExpressionListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_selectExpressionList
	return p
}

func InitEmptySelectExpressionListContext(p *SelectExpressionListContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_selectExpressionList
}

func (*SelectExpressionListContext) IsSelectExpressionListContext() {}

func NewSelectExpressionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectExpressionListContext {
	var p = new(SelectExpressionListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_selectExpressionList

	return p
}

func (s *SelectExpressionListContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectExpressionListContext) AllSelectExpression() []ISelectExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelectExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISelectExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelectExpressionContext); ok {
			tst[i] = t.(ISelectExpressionContext)
			i++
		}
	}

	return tst
}

func (s *SelectExpressionListContext) SelectExpression(i int) ISelectExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectExpressionContext)
}

func (s *SelectExpressionListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(HiveParserCOMMA)
}

func (s *SelectExpressionListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserCOMMA, i)
}

func (s *SelectExpressionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectExpressionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SelectExpressionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterSelectExpressionList(s)
	}
}

func (s *SelectExpressionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitSelectExpressionList(s)
	}
}

func (s *SelectExpressionListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitSelectExpressionList(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) SelectExpressionList() (localctx ISelectExpressionListContext) {
	localctx = NewSelectExpressionListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 682, HiveParserRULE_selectExpressionList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4164)
		p.SelectExpression()
	}
	p.SetState(4169)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HiveParserCOMMA {
		{
			p.SetState(4165)
			p.Match(HiveParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4166)
			p.SelectExpression()
		}


		p.SetState(4171)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IWindow_clauseContext is an interface to support dynamic dispatch.
type IWindow_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_WINDOW() antlr.TerminalNode
	AllWindow_defn() []IWindow_defnContext
	Window_defn(i int) IWindow_defnContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsWindow_clauseContext differentiates from other interfaces.
	IsWindow_clauseContext()
}

type Window_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindow_clauseContext() *Window_clauseContext {
	var p = new(Window_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_window_clause
	return p
}

func InitEmptyWindow_clauseContext(p *Window_clauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_window_clause
}

func (*Window_clauseContext) IsWindow_clauseContext() {}

func NewWindow_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Window_clauseContext {
	var p = new(Window_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_window_clause

	return p
}

func (s *Window_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Window_clauseContext) KW_WINDOW() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_WINDOW, 0)
}

func (s *Window_clauseContext) AllWindow_defn() []IWindow_defnContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWindow_defnContext); ok {
			len++
		}
	}

	tst := make([]IWindow_defnContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWindow_defnContext); ok {
			tst[i] = t.(IWindow_defnContext)
			i++
		}
	}

	return tst
}

func (s *Window_clauseContext) Window_defn(i int) IWindow_defnContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindow_defnContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindow_defnContext)
}

func (s *Window_clauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(HiveParserCOMMA)
}

func (s *Window_clauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserCOMMA, i)
}

func (s *Window_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Window_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Window_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterWindow_clause(s)
	}
}

func (s *Window_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitWindow_clause(s)
	}
}

func (s *Window_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitWindow_clause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) Window_clause() (localctx IWindow_clauseContext) {
	localctx = NewWindow_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 684, HiveParserRULE_window_clause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4172)
		p.Match(HiveParserKW_WINDOW)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4173)
		p.Window_defn()
	}
	p.SetState(4178)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HiveParserCOMMA {
		{
			p.SetState(4174)
			p.Match(HiveParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4175)
			p.Window_defn()
		}


		p.SetState(4180)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IWindow_defnContext is an interface to support dynamic dispatch.
type IWindow_defnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Id_() IId_Context
	KW_AS() antlr.TerminalNode
	Window_specification() IWindow_specificationContext

	// IsWindow_defnContext differentiates from other interfaces.
	IsWindow_defnContext()
}

type Window_defnContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindow_defnContext() *Window_defnContext {
	var p = new(Window_defnContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_window_defn
	return p
}

func InitEmptyWindow_defnContext(p *Window_defnContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_window_defn
}

func (*Window_defnContext) IsWindow_defnContext() {}

func NewWindow_defnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Window_defnContext {
	var p = new(Window_defnContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_window_defn

	return p
}

func (s *Window_defnContext) GetParser() antlr.Parser { return s.parser }

func (s *Window_defnContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *Window_defnContext) KW_AS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_AS, 0)
}

func (s *Window_defnContext) Window_specification() IWindow_specificationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindow_specificationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindow_specificationContext)
}

func (s *Window_defnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Window_defnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Window_defnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterWindow_defn(s)
	}
}

func (s *Window_defnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitWindow_defn(s)
	}
}

func (s *Window_defnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitWindow_defn(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) Window_defn() (localctx IWindow_defnContext) {
	localctx = NewWindow_defnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 686, HiveParserRULE_window_defn)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4181)
		p.Id_()
	}
	{
		p.SetState(4182)
		p.Match(HiveParserKW_AS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4183)
		p.Window_specification()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IWindow_specificationContext is an interface to support dynamic dispatch.
type IWindow_specificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Id_() IId_Context
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	PartitioningSpec() IPartitioningSpecContext
	Window_frame() IWindow_frameContext

	// IsWindow_specificationContext differentiates from other interfaces.
	IsWindow_specificationContext()
}

type Window_specificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindow_specificationContext() *Window_specificationContext {
	var p = new(Window_specificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_window_specification
	return p
}

func InitEmptyWindow_specificationContext(p *Window_specificationContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_window_specification
}

func (*Window_specificationContext) IsWindow_specificationContext() {}

func NewWindow_specificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Window_specificationContext {
	var p = new(Window_specificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_window_specification

	return p
}

func (s *Window_specificationContext) GetParser() antlr.Parser { return s.parser }

func (s *Window_specificationContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *Window_specificationContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserLPAREN, 0)
}

func (s *Window_specificationContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserRPAREN, 0)
}

func (s *Window_specificationContext) PartitioningSpec() IPartitioningSpecContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitioningSpecContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitioningSpecContext)
}

func (s *Window_specificationContext) Window_frame() IWindow_frameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindow_frameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindow_frameContext)
}

func (s *Window_specificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Window_specificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Window_specificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterWindow_specification(s)
	}
}

func (s *Window_specificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitWindow_specification(s)
	}
}

func (s *Window_specificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitWindow_specification(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) Window_specification() (localctx IWindow_specificationContext) {
	localctx = NewWindow_specificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 688, HiveParserRULE_window_specification)
	var _la int

	p.SetState(4197)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserKW_ABORT, HiveParserKW_ACTIVATE, HiveParserKW_ACTIVE, HiveParserKW_ADD, HiveParserKW_ADMIN, HiveParserKW_AFTER, HiveParserKW_ALLOC_FRACTION, HiveParserKW_ANALYZE, HiveParserKW_ARCHIVE, HiveParserKW_ASC, HiveParserKW_AST, HiveParserKW_AT, HiveParserKW_AUTOCOMMIT, HiveParserKW_BATCH, HiveParserKW_BEFORE, HiveParserKW_BUCKET, HiveParserKW_BUCKETS, HiveParserKW_CACHE, HiveParserKW_CASCADE, HiveParserKW_CBO, HiveParserKW_CHANGE, HiveParserKW_CHECK, HiveParserKW_CLUSTER, HiveParserKW_CLUSTERED, HiveParserKW_CLUSTERSTATUS, HiveParserKW_COLLECTION, HiveParserKW_COLUMNS, HiveParserKW_COMMENT, HiveParserKW_COMPACT, HiveParserKW_COMPACTIONS, HiveParserKW_COMPUTE, HiveParserKW_CONCATENATE, HiveParserKW_CONTINUE, HiveParserKW_COST, HiveParserKW_CRON, HiveParserKW_DATA, HiveParserKW_DATABASES, HiveParserKW_DATETIME, HiveParserKW_DAY, HiveParserKW_DAYOFWEEK, HiveParserKW_DBPROPERTIES, HiveParserKW_DCPROPERTIES, HiveParserKW_DEBUG, HiveParserKW_DEFAULT, HiveParserKW_DEFERRED, HiveParserKW_DEFINED, HiveParserKW_DELIMITED, HiveParserKW_DEPENDENCY, HiveParserKW_DESC, HiveParserKW_DETAIL, HiveParserKW_DIRECTORIES, HiveParserKW_DIRECTORY, HiveParserKW_DISABLE, HiveParserKW_DISTRIBUTE, HiveParserKW_DISTRIBUTED, HiveParserKW_DO, HiveParserKW_DOW, HiveParserKW_DUMP, HiveParserKW_ELEM_TYPE, HiveParserKW_ENABLE, HiveParserKW_ENFORCED, HiveParserKW_ESCAPED, HiveParserKW_EVERY, HiveParserKW_EXCLUSIVE, HiveParserKW_EXECUTE, HiveParserKW_EXECUTED, HiveParserKW_EXPIRE_SNAPSHOTS, HiveParserKW_EXPLAIN, HiveParserKW_EXPORT, HiveParserKW_EXPRESSION, HiveParserKW_FIELDS, HiveParserKW_FILE, HiveParserKW_FILEFORMAT, HiveParserKW_FIRST, HiveParserKW_FORMAT, HiveParserKW_FORMATTED, HiveParserKW_FUNCTIONS, HiveParserKW_HOLD_DDLTIME, HiveParserKW_HOUR, HiveParserKW_IDXPROPERTIES, HiveParserKW_IGNORE, HiveParserKW_INDEX, HiveParserKW_INDEXES, HiveParserKW_INPATH, HiveParserKW_INPUTDRIVER, HiveParserKW_INPUTFORMAT, HiveParserKW_ISOLATION, HiveParserKW_ITEMS, HiveParserKW_JAR, HiveParserKW_JOINCOST, HiveParserKW_KEY, HiveParserKW_KEYS, HiveParserKW_KEY_TYPE, HiveParserKW_KILL, HiveParserKW_LAST, HiveParserKW_LEVEL, HiveParserKW_LIMIT, HiveParserKW_LINES, HiveParserKW_LOAD, HiveParserKW_LOCATION, HiveParserKW_LOCK, HiveParserKW_LOCKS, HiveParserKW_LOGICAL, HiveParserKW_LONG, HiveParserKW_MANAGED, HiveParserKW_MANAGEDLOCATION, HiveParserKW_MANAGEMENT, HiveParserKW_MAPJOIN, HiveParserKW_MAPPING, HiveParserKW_MATCHED, HiveParserKW_MATERIALIZED, HiveParserKW_METADATA, HiveParserKW_MINUTE, HiveParserKW_MONTH, HiveParserKW_MOVE, HiveParserKW_MSCK, HiveParserKW_NORELY, HiveParserKW_NOSCAN, HiveParserKW_NOVALIDATE, HiveParserKW_NO_DROP, HiveParserKW_NULLS, HiveParserKW_OFFLINE, HiveParserKW_OFFSET, HiveParserKW_OPERATOR, HiveParserKW_OPTION, HiveParserKW_OUTPUTDRIVER, HiveParserKW_OUTPUTFORMAT, HiveParserKW_OVERWRITE, HiveParserKW_OWNER, HiveParserKW_PARTITIONED, HiveParserKW_PARTITIONS, HiveParserKW_PATH, HiveParserKW_PLAN, HiveParserKW_PLANS, HiveParserKW_PLUS, HiveParserKW_POOL, HiveParserKW_PRINCIPALS, HiveParserKW_PROTECTION, HiveParserKW_PURGE, HiveParserKW_QUARTER, HiveParserKW_QUERY, HiveParserKW_QUERY_PARALLELISM, HiveParserKW_READ, HiveParserKW_READONLY, HiveParserKW_REBUILD, HiveParserKW_RECORDREADER, HiveParserKW_RECORDWRITER, HiveParserKW_RELOAD, HiveParserKW_RELY, HiveParserKW_REMOTE, HiveParserKW_RENAME, HiveParserKW_REOPTIMIZATION, HiveParserKW_REPAIR, HiveParserKW_REPL, HiveParserKW_REPLACE, HiveParserKW_REPLICATION, HiveParserKW_RESOURCE, HiveParserKW_RESPECT, HiveParserKW_RESTRICT, HiveParserKW_REWRITE, HiveParserKW_ROLE, HiveParserKW_ROLES, HiveParserKW_SCHEDULED, HiveParserKW_SCHEDULING_POLICY, HiveParserKW_SCHEMA, HiveParserKW_SCHEMAS, HiveParserKW_SECOND, HiveParserKW_SEMI, HiveParserKW_SERDE, HiveParserKW_SERDEPROPERTIES, HiveParserKW_SERVER, HiveParserKW_SETS, HiveParserKW_SET_CURRENT_SNAPSHOT, HiveParserKW_SHARED, HiveParserKW_SHOW, HiveParserKW_SHOW_DATABASE, HiveParserKW_SKEWED, HiveParserKW_SNAPSHOT, HiveParserKW_SORT, HiveParserKW_SORTED, HiveParserKW_SPEC, HiveParserKW_SSL, HiveParserKW_STATISTICS, HiveParserKW_STATUS, HiveParserKW_STORED, HiveParserKW_STREAMTABLE, HiveParserKW_STRING, HiveParserKW_STRUCT, HiveParserKW_SUMMARY, HiveParserKW_SYSTEM_TIME, HiveParserKW_SYSTEM_VERSION, HiveParserKW_TABLES, HiveParserKW_TBLPROPERTIES, HiveParserKW_TEMPORARY, HiveParserKW_TERMINATED, HiveParserKW_TIMESTAMPTZ, HiveParserKW_TINYINT, HiveParserKW_TOUCH, HiveParserKW_TRANSACTION, HiveParserKW_TRANSACTIONAL, HiveParserKW_TRANSACTIONS, HiveParserKW_TRIM, HiveParserKW_TYPE, HiveParserKW_UNARCHIVE, HiveParserKW_UNDO, HiveParserKW_UNIONTYPE, HiveParserKW_UNKNOWN, HiveParserKW_UNLOCK, HiveParserKW_UNMANAGED, HiveParserKW_UNSET, HiveParserKW_UNSIGNED, HiveParserKW_URI, HiveParserKW_URL, HiveParserKW_USE, HiveParserKW_UTC, HiveParserKW_UTCTIMESTAMP, HiveParserKW_VALIDATE, HiveParserKW_VALUE_TYPE, HiveParserKW_VECTORIZATION, HiveParserKW_VIEW, HiveParserKW_VIEWS, HiveParserKW_WAIT, HiveParserKW_WEEK, HiveParserKW_WHILE, HiveParserKW_WITHIN, HiveParserKW_WORK, HiveParserKW_WORKLOAD, HiveParserKW_WRITE, HiveParserKW_YEAR, HiveParserKW_ZONE, HiveParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4185)
			p.Id_()
		}


	case HiveParserLPAREN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4186)
			p.Match(HiveParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(4188)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 493, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4187)
				p.Id_()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		p.SetState(4191)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_CLUSTER || _la == HiveParserKW_DISTRIBUTE || _la == HiveParserKW_ORDER || _la == HiveParserKW_PARTITION || _la == HiveParserKW_SORT {
			{
				p.SetState(4190)
				p.PartitioningSpec()
			}

		}
		p.SetState(4194)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_RANGE || _la == HiveParserKW_ROWS {
			{
				p.SetState(4193)
				p.Window_frame()
			}

		}
		{
			p.SetState(4196)
			p.Match(HiveParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IWindow_frameContext is an interface to support dynamic dispatch.
type IWindow_frameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Window_range_expression() IWindow_range_expressionContext
	Window_value_expression() IWindow_value_expressionContext

	// IsWindow_frameContext differentiates from other interfaces.
	IsWindow_frameContext()
}

type Window_frameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindow_frameContext() *Window_frameContext {
	var p = new(Window_frameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_window_frame
	return p
}

func InitEmptyWindow_frameContext(p *Window_frameContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_window_frame
}

func (*Window_frameContext) IsWindow_frameContext() {}

func NewWindow_frameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Window_frameContext {
	var p = new(Window_frameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_window_frame

	return p
}

func (s *Window_frameContext) GetParser() antlr.Parser { return s.parser }

func (s *Window_frameContext) Window_range_expression() IWindow_range_expressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindow_range_expressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindow_range_expressionContext)
}

func (s *Window_frameContext) Window_value_expression() IWindow_value_expressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindow_value_expressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindow_value_expressionContext)
}

func (s *Window_frameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Window_frameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Window_frameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterWindow_frame(s)
	}
}

func (s *Window_frameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitWindow_frame(s)
	}
}

func (s *Window_frameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitWindow_frame(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) Window_frame() (localctx IWindow_frameContext) {
	localctx = NewWindow_frameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 690, HiveParserRULE_window_frame)
	p.SetState(4201)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserKW_ROWS:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4199)
			p.Window_range_expression()
		}


	case HiveParserKW_RANGE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4200)
			p.Window_value_expression()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IWindow_range_expressionContext is an interface to support dynamic dispatch.
type IWindow_range_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_ROWS() antlr.TerminalNode
	Window_frame_start_boundary() IWindow_frame_start_boundaryContext
	KW_BETWEEN() antlr.TerminalNode
	AllWindow_frame_boundary() []IWindow_frame_boundaryContext
	Window_frame_boundary(i int) IWindow_frame_boundaryContext
	KW_AND() antlr.TerminalNode

	// IsWindow_range_expressionContext differentiates from other interfaces.
	IsWindow_range_expressionContext()
}

type Window_range_expressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindow_range_expressionContext() *Window_range_expressionContext {
	var p = new(Window_range_expressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_window_range_expression
	return p
}

func InitEmptyWindow_range_expressionContext(p *Window_range_expressionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_window_range_expression
}

func (*Window_range_expressionContext) IsWindow_range_expressionContext() {}

func NewWindow_range_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Window_range_expressionContext {
	var p = new(Window_range_expressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_window_range_expression

	return p
}

func (s *Window_range_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Window_range_expressionContext) KW_ROWS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ROWS, 0)
}

func (s *Window_range_expressionContext) Window_frame_start_boundary() IWindow_frame_start_boundaryContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindow_frame_start_boundaryContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindow_frame_start_boundaryContext)
}

func (s *Window_range_expressionContext) KW_BETWEEN() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_BETWEEN, 0)
}

func (s *Window_range_expressionContext) AllWindow_frame_boundary() []IWindow_frame_boundaryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWindow_frame_boundaryContext); ok {
			len++
		}
	}

	tst := make([]IWindow_frame_boundaryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWindow_frame_boundaryContext); ok {
			tst[i] = t.(IWindow_frame_boundaryContext)
			i++
		}
	}

	return tst
}

func (s *Window_range_expressionContext) Window_frame_boundary(i int) IWindow_frame_boundaryContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindow_frame_boundaryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindow_frame_boundaryContext)
}

func (s *Window_range_expressionContext) KW_AND() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_AND, 0)
}

func (s *Window_range_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Window_range_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Window_range_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterWindow_range_expression(s)
	}
}

func (s *Window_range_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitWindow_range_expression(s)
	}
}

func (s *Window_range_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitWindow_range_expression(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) Window_range_expression() (localctx IWindow_range_expressionContext) {
	localctx = NewWindow_range_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 692, HiveParserRULE_window_range_expression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4203)
		p.Match(HiveParserKW_ROWS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(4210)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserKW_CURRENT, HiveParserKW_UNBOUNDED, HiveParserNumber:
		{
			p.SetState(4204)
			p.Window_frame_start_boundary()
		}


	case HiveParserKW_BETWEEN:
		{
			p.SetState(4205)
			p.Match(HiveParserKW_BETWEEN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4206)
			p.Window_frame_boundary()
		}
		{
			p.SetState(4207)
			p.Match(HiveParserKW_AND)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4208)
			p.Window_frame_boundary()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IWindow_value_expressionContext is an interface to support dynamic dispatch.
type IWindow_value_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_RANGE() antlr.TerminalNode
	Window_frame_start_boundary() IWindow_frame_start_boundaryContext
	KW_BETWEEN() antlr.TerminalNode
	AllWindow_frame_boundary() []IWindow_frame_boundaryContext
	Window_frame_boundary(i int) IWindow_frame_boundaryContext
	KW_AND() antlr.TerminalNode

	// IsWindow_value_expressionContext differentiates from other interfaces.
	IsWindow_value_expressionContext()
}

type Window_value_expressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindow_value_expressionContext() *Window_value_expressionContext {
	var p = new(Window_value_expressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_window_value_expression
	return p
}

func InitEmptyWindow_value_expressionContext(p *Window_value_expressionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_window_value_expression
}

func (*Window_value_expressionContext) IsWindow_value_expressionContext() {}

func NewWindow_value_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Window_value_expressionContext {
	var p = new(Window_value_expressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_window_value_expression

	return p
}

func (s *Window_value_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Window_value_expressionContext) KW_RANGE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_RANGE, 0)
}

func (s *Window_value_expressionContext) Window_frame_start_boundary() IWindow_frame_start_boundaryContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindow_frame_start_boundaryContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindow_frame_start_boundaryContext)
}

func (s *Window_value_expressionContext) KW_BETWEEN() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_BETWEEN, 0)
}

func (s *Window_value_expressionContext) AllWindow_frame_boundary() []IWindow_frame_boundaryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWindow_frame_boundaryContext); ok {
			len++
		}
	}

	tst := make([]IWindow_frame_boundaryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWindow_frame_boundaryContext); ok {
			tst[i] = t.(IWindow_frame_boundaryContext)
			i++
		}
	}

	return tst
}

func (s *Window_value_expressionContext) Window_frame_boundary(i int) IWindow_frame_boundaryContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindow_frame_boundaryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindow_frame_boundaryContext)
}

func (s *Window_value_expressionContext) KW_AND() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_AND, 0)
}

func (s *Window_value_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Window_value_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Window_value_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterWindow_value_expression(s)
	}
}

func (s *Window_value_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitWindow_value_expression(s)
	}
}

func (s *Window_value_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitWindow_value_expression(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) Window_value_expression() (localctx IWindow_value_expressionContext) {
	localctx = NewWindow_value_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 694, HiveParserRULE_window_value_expression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4212)
		p.Match(HiveParserKW_RANGE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(4219)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserKW_CURRENT, HiveParserKW_UNBOUNDED, HiveParserNumber:
		{
			p.SetState(4213)
			p.Window_frame_start_boundary()
		}


	case HiveParserKW_BETWEEN:
		{
			p.SetState(4214)
			p.Match(HiveParserKW_BETWEEN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4215)
			p.Window_frame_boundary()
		}
		{
			p.SetState(4216)
			p.Match(HiveParserKW_AND)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4217)
			p.Window_frame_boundary()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IWindow_frame_start_boundaryContext is an interface to support dynamic dispatch.
type IWindow_frame_start_boundaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_UNBOUNDED() antlr.TerminalNode
	KW_PRECEDING() antlr.TerminalNode
	KW_CURRENT() antlr.TerminalNode
	KW_ROW() antlr.TerminalNode
	Number() antlr.TerminalNode

	// IsWindow_frame_start_boundaryContext differentiates from other interfaces.
	IsWindow_frame_start_boundaryContext()
}

type Window_frame_start_boundaryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindow_frame_start_boundaryContext() *Window_frame_start_boundaryContext {
	var p = new(Window_frame_start_boundaryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_window_frame_start_boundary
	return p
}

func InitEmptyWindow_frame_start_boundaryContext(p *Window_frame_start_boundaryContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_window_frame_start_boundary
}

func (*Window_frame_start_boundaryContext) IsWindow_frame_start_boundaryContext() {}

func NewWindow_frame_start_boundaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Window_frame_start_boundaryContext {
	var p = new(Window_frame_start_boundaryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_window_frame_start_boundary

	return p
}

func (s *Window_frame_start_boundaryContext) GetParser() antlr.Parser { return s.parser }

func (s *Window_frame_start_boundaryContext) KW_UNBOUNDED() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_UNBOUNDED, 0)
}

func (s *Window_frame_start_boundaryContext) KW_PRECEDING() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_PRECEDING, 0)
}

func (s *Window_frame_start_boundaryContext) KW_CURRENT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_CURRENT, 0)
}

func (s *Window_frame_start_boundaryContext) KW_ROW() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ROW, 0)
}

func (s *Window_frame_start_boundaryContext) Number() antlr.TerminalNode {
	return s.GetToken(HiveParserNumber, 0)
}

func (s *Window_frame_start_boundaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Window_frame_start_boundaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Window_frame_start_boundaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterWindow_frame_start_boundary(s)
	}
}

func (s *Window_frame_start_boundaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitWindow_frame_start_boundary(s)
	}
}

func (s *Window_frame_start_boundaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitWindow_frame_start_boundary(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) Window_frame_start_boundary() (localctx IWindow_frame_start_boundaryContext) {
	localctx = NewWindow_frame_start_boundaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 696, HiveParserRULE_window_frame_start_boundary)
	p.SetState(4227)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserKW_UNBOUNDED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4221)
			p.Match(HiveParserKW_UNBOUNDED)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4222)
			p.Match(HiveParserKW_PRECEDING)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HiveParserKW_CURRENT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4223)
			p.Match(HiveParserKW_CURRENT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4224)
			p.Match(HiveParserKW_ROW)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HiveParserNumber:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4225)
			p.Match(HiveParserNumber)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4226)
			p.Match(HiveParserKW_PRECEDING)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IWindow_frame_boundaryContext is an interface to support dynamic dispatch.
type IWindow_frame_boundaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_UNBOUNDED() antlr.TerminalNode
	Number() antlr.TerminalNode
	KW_PRECEDING() antlr.TerminalNode
	KW_FOLLOWING() antlr.TerminalNode
	KW_CURRENT() antlr.TerminalNode
	KW_ROW() antlr.TerminalNode

	// IsWindow_frame_boundaryContext differentiates from other interfaces.
	IsWindow_frame_boundaryContext()
}

type Window_frame_boundaryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindow_frame_boundaryContext() *Window_frame_boundaryContext {
	var p = new(Window_frame_boundaryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_window_frame_boundary
	return p
}

func InitEmptyWindow_frame_boundaryContext(p *Window_frame_boundaryContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_window_frame_boundary
}

func (*Window_frame_boundaryContext) IsWindow_frame_boundaryContext() {}

func NewWindow_frame_boundaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Window_frame_boundaryContext {
	var p = new(Window_frame_boundaryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_window_frame_boundary

	return p
}

func (s *Window_frame_boundaryContext) GetParser() antlr.Parser { return s.parser }

func (s *Window_frame_boundaryContext) KW_UNBOUNDED() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_UNBOUNDED, 0)
}

func (s *Window_frame_boundaryContext) Number() antlr.TerminalNode {
	return s.GetToken(HiveParserNumber, 0)
}

func (s *Window_frame_boundaryContext) KW_PRECEDING() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_PRECEDING, 0)
}

func (s *Window_frame_boundaryContext) KW_FOLLOWING() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_FOLLOWING, 0)
}

func (s *Window_frame_boundaryContext) KW_CURRENT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_CURRENT, 0)
}

func (s *Window_frame_boundaryContext) KW_ROW() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ROW, 0)
}

func (s *Window_frame_boundaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Window_frame_boundaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Window_frame_boundaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterWindow_frame_boundary(s)
	}
}

func (s *Window_frame_boundaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitWindow_frame_boundary(s)
	}
}

func (s *Window_frame_boundaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitWindow_frame_boundary(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) Window_frame_boundary() (localctx IWindow_frame_boundaryContext) {
	localctx = NewWindow_frame_boundaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 698, HiveParserRULE_window_frame_boundary)
	var _la int

	p.SetState(4233)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserKW_UNBOUNDED, HiveParserNumber:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4229)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HiveParserKW_UNBOUNDED || _la == HiveParserNumber) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(4230)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HiveParserKW_FOLLOWING || _la == HiveParserKW_PRECEDING) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}


	case HiveParserKW_CURRENT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4231)
			p.Match(HiveParserKW_CURRENT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4232)
			p.Match(HiveParserKW_ROW)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IGroupByClauseContext is an interface to support dynamic dispatch.
type IGroupByClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_GROUP() antlr.TerminalNode
	KW_BY() antlr.TerminalNode
	Groupby_expression() IGroupby_expressionContext

	// IsGroupByClauseContext differentiates from other interfaces.
	IsGroupByClauseContext()
}

type GroupByClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupByClauseContext() *GroupByClauseContext {
	var p = new(GroupByClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_groupByClause
	return p
}

func InitEmptyGroupByClauseContext(p *GroupByClauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_groupByClause
}

func (*GroupByClauseContext) IsGroupByClauseContext() {}

func NewGroupByClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupByClauseContext {
	var p = new(GroupByClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_groupByClause

	return p
}

func (s *GroupByClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupByClauseContext) KW_GROUP() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_GROUP, 0)
}

func (s *GroupByClauseContext) KW_BY() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_BY, 0)
}

func (s *GroupByClauseContext) Groupby_expression() IGroupby_expressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupby_expressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupby_expressionContext)
}

func (s *GroupByClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupByClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *GroupByClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterGroupByClause(s)
	}
}

func (s *GroupByClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitGroupByClause(s)
	}
}

func (s *GroupByClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitGroupByClause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) GroupByClause() (localctx IGroupByClauseContext) {
	localctx = NewGroupByClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 700, HiveParserRULE_groupByClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4235)
		p.Match(HiveParserKW_GROUP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4236)
		p.Match(HiveParserKW_BY)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4237)
		p.Groupby_expression()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IGroupby_expressionContext is an interface to support dynamic dispatch.
type IGroupby_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RollupStandard() IRollupStandardContext
	RollupOldSyntax() IRollupOldSyntaxContext
	GroupByEmpty() IGroupByEmptyContext

	// IsGroupby_expressionContext differentiates from other interfaces.
	IsGroupby_expressionContext()
}

type Groupby_expressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupby_expressionContext() *Groupby_expressionContext {
	var p = new(Groupby_expressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_groupby_expression
	return p
}

func InitEmptyGroupby_expressionContext(p *Groupby_expressionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_groupby_expression
}

func (*Groupby_expressionContext) IsGroupby_expressionContext() {}

func NewGroupby_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Groupby_expressionContext {
	var p = new(Groupby_expressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_groupby_expression

	return p
}

func (s *Groupby_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Groupby_expressionContext) RollupStandard() IRollupStandardContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRollupStandardContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRollupStandardContext)
}

func (s *Groupby_expressionContext) RollupOldSyntax() IRollupOldSyntaxContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRollupOldSyntaxContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRollupOldSyntaxContext)
}

func (s *Groupby_expressionContext) GroupByEmpty() IGroupByEmptyContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupByEmptyContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupByEmptyContext)
}

func (s *Groupby_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Groupby_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Groupby_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterGroupby_expression(s)
	}
}

func (s *Groupby_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitGroupby_expression(s)
	}
}

func (s *Groupby_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitGroupby_expression(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) Groupby_expression() (localctx IGroupby_expressionContext) {
	localctx = NewGroupby_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 702, HiveParserRULE_groupby_expression)
	p.SetState(4242)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 502, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4239)
			p.RollupStandard()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4240)
			p.RollupOldSyntax()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4241)
			p.GroupByEmpty()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IGroupByEmptyContext is an interface to support dynamic dispatch.
type IGroupByEmptyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode

	// IsGroupByEmptyContext differentiates from other interfaces.
	IsGroupByEmptyContext()
}

type GroupByEmptyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupByEmptyContext() *GroupByEmptyContext {
	var p = new(GroupByEmptyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_groupByEmpty
	return p
}

func InitEmptyGroupByEmptyContext(p *GroupByEmptyContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_groupByEmpty
}

func (*GroupByEmptyContext) IsGroupByEmptyContext() {}

func NewGroupByEmptyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupByEmptyContext {
	var p = new(GroupByEmptyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_groupByEmpty

	return p
}

func (s *GroupByEmptyContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupByEmptyContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserLPAREN, 0)
}

func (s *GroupByEmptyContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserRPAREN, 0)
}

func (s *GroupByEmptyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupByEmptyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *GroupByEmptyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterGroupByEmpty(s)
	}
}

func (s *GroupByEmptyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitGroupByEmpty(s)
	}
}

func (s *GroupByEmptyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitGroupByEmpty(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) GroupByEmpty() (localctx IGroupByEmptyContext) {
	localctx = NewGroupByEmptyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 704, HiveParserRULE_groupByEmpty)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4244)
		p.Match(HiveParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4245)
		p.Match(HiveParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRollupStandardContext is an interface to support dynamic dispatch.
type IRollupStandardContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRollup returns the rollup token.
	GetRollup() antlr.Token 

	// GetCube returns the cube token.
	GetCube() antlr.Token 


	// SetRollup sets the rollup token.
	SetRollup(antlr.Token) 

	// SetCube sets the cube token.
	SetCube(antlr.Token) 


	// Getter signatures
	LPAREN() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	RPAREN() antlr.TerminalNode
	KW_ROLLUP() antlr.TerminalNode
	KW_CUBE() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsRollupStandardContext differentiates from other interfaces.
	IsRollupStandardContext()
}

type RollupStandardContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	rollup antlr.Token
	cube antlr.Token
}

func NewEmptyRollupStandardContext() *RollupStandardContext {
	var p = new(RollupStandardContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_rollupStandard
	return p
}

func InitEmptyRollupStandardContext(p *RollupStandardContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_rollupStandard
}

func (*RollupStandardContext) IsRollupStandardContext() {}

func NewRollupStandardContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RollupStandardContext {
	var p = new(RollupStandardContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_rollupStandard

	return p
}

func (s *RollupStandardContext) GetParser() antlr.Parser { return s.parser }

func (s *RollupStandardContext) GetRollup() antlr.Token { return s.rollup }

func (s *RollupStandardContext) GetCube() antlr.Token { return s.cube }


func (s *RollupStandardContext) SetRollup(v antlr.Token) { s.rollup = v }

func (s *RollupStandardContext) SetCube(v antlr.Token) { s.cube = v }


func (s *RollupStandardContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserLPAREN, 0)
}

func (s *RollupStandardContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *RollupStandardContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *RollupStandardContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserRPAREN, 0)
}

func (s *RollupStandardContext) KW_ROLLUP() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ROLLUP, 0)
}

func (s *RollupStandardContext) KW_CUBE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_CUBE, 0)
}

func (s *RollupStandardContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(HiveParserCOMMA)
}

func (s *RollupStandardContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserCOMMA, i)
}

func (s *RollupStandardContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RollupStandardContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *RollupStandardContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterRollupStandard(s)
	}
}

func (s *RollupStandardContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitRollupStandard(s)
	}
}

func (s *RollupStandardContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitRollupStandard(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) RollupStandard() (localctx IRollupStandardContext) {
	localctx = NewRollupStandardContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 706, HiveParserRULE_rollupStandard)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4249)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserKW_ROLLUP:
		{
			p.SetState(4247)

			var _m = p.Match(HiveParserKW_ROLLUP)

			localctx.(*RollupStandardContext).rollup = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HiveParserKW_CUBE:
		{
			p.SetState(4248)

			var _m = p.Match(HiveParserKW_CUBE)

			localctx.(*RollupStandardContext).cube = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(4251)
		p.Match(HiveParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4252)
		p.Expression()
	}
	p.SetState(4257)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HiveParserCOMMA {
		{
			p.SetState(4253)
			p.Match(HiveParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4254)
			p.Expression()
		}


		p.SetState(4259)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(4260)
		p.Match(HiveParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRollupOldSyntaxContext is an interface to support dynamic dispatch.
type IRollupOldSyntaxContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRollup returns the rollup token.
	GetRollup() antlr.Token 

	// GetCube returns the cube token.
	GetCube() antlr.Token 

	// GetSets returns the sets token.
	GetSets() antlr.Token 


	// SetRollup sets the rollup token.
	SetRollup(antlr.Token) 

	// SetCube sets the cube token.
	SetCube(antlr.Token) 

	// SetSets sets the sets token.
	SetSets(antlr.Token) 


	// GetExpr returns the expr rule contexts.
	GetExpr() IExpressionsNotInParenthesisContext


	// SetExpr sets the expr rule contexts.
	SetExpr(IExpressionsNotInParenthesisContext)


	// Getter signatures
	ExpressionsNotInParenthesis() IExpressionsNotInParenthesisContext
	KW_ROLLUP() antlr.TerminalNode
	KW_CUBE() antlr.TerminalNode
	KW_SETS() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	AllGroupingSetExpression() []IGroupingSetExpressionContext
	GroupingSetExpression(i int) IGroupingSetExpressionContext
	RPAREN() antlr.TerminalNode
	KW_WITH() antlr.TerminalNode
	KW_GROUPING() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsRollupOldSyntaxContext differentiates from other interfaces.
	IsRollupOldSyntaxContext()
}

type RollupOldSyntaxContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	expr IExpressionsNotInParenthesisContext 
	rollup antlr.Token
	cube antlr.Token
	sets antlr.Token
}

func NewEmptyRollupOldSyntaxContext() *RollupOldSyntaxContext {
	var p = new(RollupOldSyntaxContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_rollupOldSyntax
	return p
}

func InitEmptyRollupOldSyntaxContext(p *RollupOldSyntaxContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_rollupOldSyntax
}

func (*RollupOldSyntaxContext) IsRollupOldSyntaxContext() {}

func NewRollupOldSyntaxContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RollupOldSyntaxContext {
	var p = new(RollupOldSyntaxContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_rollupOldSyntax

	return p
}

func (s *RollupOldSyntaxContext) GetParser() antlr.Parser { return s.parser }

func (s *RollupOldSyntaxContext) GetRollup() antlr.Token { return s.rollup }

func (s *RollupOldSyntaxContext) GetCube() antlr.Token { return s.cube }

func (s *RollupOldSyntaxContext) GetSets() antlr.Token { return s.sets }


func (s *RollupOldSyntaxContext) SetRollup(v antlr.Token) { s.rollup = v }

func (s *RollupOldSyntaxContext) SetCube(v antlr.Token) { s.cube = v }

func (s *RollupOldSyntaxContext) SetSets(v antlr.Token) { s.sets = v }


func (s *RollupOldSyntaxContext) GetExpr() IExpressionsNotInParenthesisContext { return s.expr }


func (s *RollupOldSyntaxContext) SetExpr(v IExpressionsNotInParenthesisContext) { s.expr = v }


func (s *RollupOldSyntaxContext) ExpressionsNotInParenthesis() IExpressionsNotInParenthesisContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionsNotInParenthesisContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionsNotInParenthesisContext)
}

func (s *RollupOldSyntaxContext) KW_ROLLUP() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ROLLUP, 0)
}

func (s *RollupOldSyntaxContext) KW_CUBE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_CUBE, 0)
}

func (s *RollupOldSyntaxContext) KW_SETS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SETS, 0)
}

func (s *RollupOldSyntaxContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserLPAREN, 0)
}

func (s *RollupOldSyntaxContext) AllGroupingSetExpression() []IGroupingSetExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGroupingSetExpressionContext); ok {
			len++
		}
	}

	tst := make([]IGroupingSetExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGroupingSetExpressionContext); ok {
			tst[i] = t.(IGroupingSetExpressionContext)
			i++
		}
	}

	return tst
}

func (s *RollupOldSyntaxContext) GroupingSetExpression(i int) IGroupingSetExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupingSetExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupingSetExpressionContext)
}

func (s *RollupOldSyntaxContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserRPAREN, 0)
}

func (s *RollupOldSyntaxContext) KW_WITH() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_WITH, 0)
}

func (s *RollupOldSyntaxContext) KW_GROUPING() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_GROUPING, 0)
}

func (s *RollupOldSyntaxContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(HiveParserCOMMA)
}

func (s *RollupOldSyntaxContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserCOMMA, i)
}

func (s *RollupOldSyntaxContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RollupOldSyntaxContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *RollupOldSyntaxContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterRollupOldSyntax(s)
	}
}

func (s *RollupOldSyntaxContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitRollupOldSyntax(s)
	}
}

func (s *RollupOldSyntaxContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitRollupOldSyntax(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) RollupOldSyntax() (localctx IRollupOldSyntaxContext) {
	localctx = NewRollupOldSyntaxContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 708, HiveParserRULE_rollupOldSyntax)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4262)

		var _x = p.ExpressionsNotInParenthesis()


		localctx.(*RollupOldSyntaxContext).expr = _x
	}
	p.SetState(4267)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 505, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4263)

			var _m = p.Match(HiveParserKW_WITH)

			localctx.(*RollupOldSyntaxContext).rollup = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4264)
			p.Match(HiveParserKW_ROLLUP)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 505, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(4265)

			var _m = p.Match(HiveParserKW_WITH)

			localctx.(*RollupOldSyntaxContext).cube = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4266)
			p.Match(HiveParserKW_CUBE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	p.SetState(4282)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_GROUPING {
		{
			p.SetState(4269)

			var _m = p.Match(HiveParserKW_GROUPING)

			localctx.(*RollupOldSyntaxContext).sets = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4270)
			p.Match(HiveParserKW_SETS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4271)
			p.Match(HiveParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4272)
			p.GroupingSetExpression()
		}
		p.SetState(4277)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == HiveParserCOMMA {
			{
				p.SetState(4273)
				p.Match(HiveParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(4274)
				p.GroupingSetExpression()
			}


			p.SetState(4279)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(4280)
			p.Match(HiveParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IGroupingSetExpressionContext is an interface to support dynamic dispatch.
type IGroupingSetExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GroupingSetExpressionMultiple() IGroupingSetExpressionMultipleContext
	GroupingExpressionSingle() IGroupingExpressionSingleContext

	// IsGroupingSetExpressionContext differentiates from other interfaces.
	IsGroupingSetExpressionContext()
}

type GroupingSetExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupingSetExpressionContext() *GroupingSetExpressionContext {
	var p = new(GroupingSetExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_groupingSetExpression
	return p
}

func InitEmptyGroupingSetExpressionContext(p *GroupingSetExpressionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_groupingSetExpression
}

func (*GroupingSetExpressionContext) IsGroupingSetExpressionContext() {}

func NewGroupingSetExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupingSetExpressionContext {
	var p = new(GroupingSetExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_groupingSetExpression

	return p
}

func (s *GroupingSetExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupingSetExpressionContext) GroupingSetExpressionMultiple() IGroupingSetExpressionMultipleContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupingSetExpressionMultipleContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupingSetExpressionMultipleContext)
}

func (s *GroupingSetExpressionContext) GroupingExpressionSingle() IGroupingExpressionSingleContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupingExpressionSingleContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupingExpressionSingleContext)
}

func (s *GroupingSetExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupingSetExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *GroupingSetExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterGroupingSetExpression(s)
	}
}

func (s *GroupingSetExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitGroupingSetExpression(s)
	}
}

func (s *GroupingSetExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitGroupingSetExpression(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) GroupingSetExpression() (localctx IGroupingSetExpressionContext) {
	localctx = NewGroupingSetExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 710, HiveParserRULE_groupingSetExpression)
	p.SetState(4286)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 508, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4284)
			p.GroupingSetExpressionMultiple()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4285)
			p.GroupingExpressionSingle()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IGroupingSetExpressionMultipleContext is an interface to support dynamic dispatch.
type IGroupingSetExpressionMultipleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsGroupingSetExpressionMultipleContext differentiates from other interfaces.
	IsGroupingSetExpressionMultipleContext()
}

type GroupingSetExpressionMultipleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupingSetExpressionMultipleContext() *GroupingSetExpressionMultipleContext {
	var p = new(GroupingSetExpressionMultipleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_groupingSetExpressionMultiple
	return p
}

func InitEmptyGroupingSetExpressionMultipleContext(p *GroupingSetExpressionMultipleContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_groupingSetExpressionMultiple
}

func (*GroupingSetExpressionMultipleContext) IsGroupingSetExpressionMultipleContext() {}

func NewGroupingSetExpressionMultipleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupingSetExpressionMultipleContext {
	var p = new(GroupingSetExpressionMultipleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_groupingSetExpressionMultiple

	return p
}

func (s *GroupingSetExpressionMultipleContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupingSetExpressionMultipleContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserLPAREN, 0)
}

func (s *GroupingSetExpressionMultipleContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserRPAREN, 0)
}

func (s *GroupingSetExpressionMultipleContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *GroupingSetExpressionMultipleContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *GroupingSetExpressionMultipleContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(HiveParserCOMMA)
}

func (s *GroupingSetExpressionMultipleContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserCOMMA, i)
}

func (s *GroupingSetExpressionMultipleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupingSetExpressionMultipleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *GroupingSetExpressionMultipleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterGroupingSetExpressionMultiple(s)
	}
}

func (s *GroupingSetExpressionMultipleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitGroupingSetExpressionMultiple(s)
	}
}

func (s *GroupingSetExpressionMultipleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitGroupingSetExpressionMultiple(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) GroupingSetExpressionMultiple() (localctx IGroupingSetExpressionMultipleContext) {
	localctx = NewGroupingSetExpressionMultipleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 712, HiveParserRULE_groupingSetExpressionMultiple)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4288)
		p.Match(HiveParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(4290)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & -8415293117714037378) != 0) || ((int64((_la - 64)) & ^0x3f) == 0 && ((int64(1) << (_la - 64)) & -171163878771171435) != 0) || ((int64((_la - 132)) & ^0x3f) == 0 && ((int64(1) << (_la - 132)) & 9205050320105143587) != 0) || ((int64((_la - 196)) & ^0x3f) == 0 && ((int64(1) << (_la - 196)) & 4448221519167061869) != 0) || ((int64((_la - 261)) & ^0x3f) == 0 && ((int64(1) << (_la - 261)) & 8484709125765410815) != 0) || ((int64((_la - 326)) & ^0x3f) == 0 && ((int64(1) << (_la - 326)) & 1224028420243305391) != 0) || ((int64((_la - 400)) & ^0x3f) == 0 && ((int64(1) << (_la - 400)) & 971843) != 0) {
		{
			p.SetState(4289)
			p.Expression()
		}

	}
	p.SetState(4296)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HiveParserCOMMA {
		{
			p.SetState(4292)
			p.Match(HiveParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4293)
			p.Expression()
		}


		p.SetState(4298)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(4299)
		p.Match(HiveParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IGroupingExpressionSingleContext is an interface to support dynamic dispatch.
type IGroupingExpressionSingleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext

	// IsGroupingExpressionSingleContext differentiates from other interfaces.
	IsGroupingExpressionSingleContext()
}

type GroupingExpressionSingleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupingExpressionSingleContext() *GroupingExpressionSingleContext {
	var p = new(GroupingExpressionSingleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_groupingExpressionSingle
	return p
}

func InitEmptyGroupingExpressionSingleContext(p *GroupingExpressionSingleContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_groupingExpressionSingle
}

func (*GroupingExpressionSingleContext) IsGroupingExpressionSingleContext() {}

func NewGroupingExpressionSingleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupingExpressionSingleContext {
	var p = new(GroupingExpressionSingleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_groupingExpressionSingle

	return p
}

func (s *GroupingExpressionSingleContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupingExpressionSingleContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *GroupingExpressionSingleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupingExpressionSingleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *GroupingExpressionSingleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterGroupingExpressionSingle(s)
	}
}

func (s *GroupingExpressionSingleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitGroupingExpressionSingle(s)
	}
}

func (s *GroupingExpressionSingleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitGroupingExpressionSingle(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) GroupingExpressionSingle() (localctx IGroupingExpressionSingleContext) {
	localctx = NewGroupingExpressionSingleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 714, HiveParserRULE_groupingExpressionSingle)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4301)
		p.Expression()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IHavingClauseContext is an interface to support dynamic dispatch.
type IHavingClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_HAVING() antlr.TerminalNode
	HavingCondition() IHavingConditionContext

	// IsHavingClauseContext differentiates from other interfaces.
	IsHavingClauseContext()
}

type HavingClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHavingClauseContext() *HavingClauseContext {
	var p = new(HavingClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_havingClause
	return p
}

func InitEmptyHavingClauseContext(p *HavingClauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_havingClause
}

func (*HavingClauseContext) IsHavingClauseContext() {}

func NewHavingClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HavingClauseContext {
	var p = new(HavingClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_havingClause

	return p
}

func (s *HavingClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *HavingClauseContext) KW_HAVING() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_HAVING, 0)
}

func (s *HavingClauseContext) HavingCondition() IHavingConditionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHavingConditionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHavingConditionContext)
}

func (s *HavingClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HavingClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *HavingClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterHavingClause(s)
	}
}

func (s *HavingClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitHavingClause(s)
	}
}

func (s *HavingClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitHavingClause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) HavingClause() (localctx IHavingClauseContext) {
	localctx = NewHavingClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 716, HiveParserRULE_havingClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4303)
		p.Match(HiveParserKW_HAVING)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4304)
		p.HavingCondition()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IQualifyClauseContext is an interface to support dynamic dispatch.
type IQualifyClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_QUALIFY() antlr.TerminalNode
	Expression() IExpressionContext

	// IsQualifyClauseContext differentiates from other interfaces.
	IsQualifyClauseContext()
}

type QualifyClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifyClauseContext() *QualifyClauseContext {
	var p = new(QualifyClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_qualifyClause
	return p
}

func InitEmptyQualifyClauseContext(p *QualifyClauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_qualifyClause
}

func (*QualifyClauseContext) IsQualifyClauseContext() {}

func NewQualifyClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifyClauseContext {
	var p = new(QualifyClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_qualifyClause

	return p
}

func (s *QualifyClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifyClauseContext) KW_QUALIFY() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_QUALIFY, 0)
}

func (s *QualifyClauseContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *QualifyClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifyClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *QualifyClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterQualifyClause(s)
	}
}

func (s *QualifyClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitQualifyClause(s)
	}
}

func (s *QualifyClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitQualifyClause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) QualifyClause() (localctx IQualifyClauseContext) {
	localctx = NewQualifyClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 718, HiveParserRULE_qualifyClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4306)
		p.Match(HiveParserKW_QUALIFY)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4307)
		p.Expression()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IHavingConditionContext is an interface to support dynamic dispatch.
type IHavingConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext

	// IsHavingConditionContext differentiates from other interfaces.
	IsHavingConditionContext()
}

type HavingConditionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHavingConditionContext() *HavingConditionContext {
	var p = new(HavingConditionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_havingCondition
	return p
}

func InitEmptyHavingConditionContext(p *HavingConditionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_havingCondition
}

func (*HavingConditionContext) IsHavingConditionContext() {}

func NewHavingConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HavingConditionContext {
	var p = new(HavingConditionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_havingCondition

	return p
}

func (s *HavingConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *HavingConditionContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *HavingConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HavingConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *HavingConditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterHavingCondition(s)
	}
}

func (s *HavingConditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitHavingCondition(s)
	}
}

func (s *HavingConditionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitHavingCondition(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) HavingCondition() (localctx IHavingConditionContext) {
	localctx = NewHavingConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 720, HiveParserRULE_havingCondition)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4309)
		p.Expression()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExpressionsInParenthesisContext is an interface to support dynamic dispatch.
type IExpressionsInParenthesisContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	ExpressionsNotInParenthesis() IExpressionsNotInParenthesisContext
	RPAREN() antlr.TerminalNode

	// IsExpressionsInParenthesisContext differentiates from other interfaces.
	IsExpressionsInParenthesisContext()
}

type ExpressionsInParenthesisContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionsInParenthesisContext() *ExpressionsInParenthesisContext {
	var p = new(ExpressionsInParenthesisContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_expressionsInParenthesis
	return p
}

func InitEmptyExpressionsInParenthesisContext(p *ExpressionsInParenthesisContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_expressionsInParenthesis
}

func (*ExpressionsInParenthesisContext) IsExpressionsInParenthesisContext() {}

func NewExpressionsInParenthesisContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionsInParenthesisContext {
	var p = new(ExpressionsInParenthesisContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_expressionsInParenthesis

	return p
}

func (s *ExpressionsInParenthesisContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionsInParenthesisContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserLPAREN, 0)
}

func (s *ExpressionsInParenthesisContext) ExpressionsNotInParenthesis() IExpressionsNotInParenthesisContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionsNotInParenthesisContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionsNotInParenthesisContext)
}

func (s *ExpressionsInParenthesisContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserRPAREN, 0)
}

func (s *ExpressionsInParenthesisContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionsInParenthesisContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ExpressionsInParenthesisContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterExpressionsInParenthesis(s)
	}
}

func (s *ExpressionsInParenthesisContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitExpressionsInParenthesis(s)
	}
}

func (s *ExpressionsInParenthesisContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitExpressionsInParenthesis(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ExpressionsInParenthesis() (localctx IExpressionsInParenthesisContext) {
	localctx = NewExpressionsInParenthesisContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 722, HiveParserRULE_expressionsInParenthesis)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4311)
		p.Match(HiveParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4312)
		p.ExpressionsNotInParenthesis()
	}
	{
		p.SetState(4313)
		p.Match(HiveParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExpressionsNotInParenthesisContext is an interface to support dynamic dispatch.
type IExpressionsNotInParenthesisContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFirst returns the first rule contexts.
	GetFirst() IExpressionOrDefaultContext

	// GetMore returns the more rule contexts.
	GetMore() IExpressionPartContext


	// SetFirst sets the first rule contexts.
	SetFirst(IExpressionOrDefaultContext)

	// SetMore sets the more rule contexts.
	SetMore(IExpressionPartContext)


	// Getter signatures
	ExpressionOrDefault() IExpressionOrDefaultContext
	ExpressionPart() IExpressionPartContext

	// IsExpressionsNotInParenthesisContext differentiates from other interfaces.
	IsExpressionsNotInParenthesisContext()
}

type ExpressionsNotInParenthesisContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	first IExpressionOrDefaultContext 
	more IExpressionPartContext 
}

func NewEmptyExpressionsNotInParenthesisContext() *ExpressionsNotInParenthesisContext {
	var p = new(ExpressionsNotInParenthesisContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_expressionsNotInParenthesis
	return p
}

func InitEmptyExpressionsNotInParenthesisContext(p *ExpressionsNotInParenthesisContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_expressionsNotInParenthesis
}

func (*ExpressionsNotInParenthesisContext) IsExpressionsNotInParenthesisContext() {}

func NewExpressionsNotInParenthesisContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionsNotInParenthesisContext {
	var p = new(ExpressionsNotInParenthesisContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_expressionsNotInParenthesis

	return p
}

func (s *ExpressionsNotInParenthesisContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionsNotInParenthesisContext) GetFirst() IExpressionOrDefaultContext { return s.first }

func (s *ExpressionsNotInParenthesisContext) GetMore() IExpressionPartContext { return s.more }


func (s *ExpressionsNotInParenthesisContext) SetFirst(v IExpressionOrDefaultContext) { s.first = v }

func (s *ExpressionsNotInParenthesisContext) SetMore(v IExpressionPartContext) { s.more = v }


func (s *ExpressionsNotInParenthesisContext) ExpressionOrDefault() IExpressionOrDefaultContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionOrDefaultContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionOrDefaultContext)
}

func (s *ExpressionsNotInParenthesisContext) ExpressionPart() IExpressionPartContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionPartContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionPartContext)
}

func (s *ExpressionsNotInParenthesisContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionsNotInParenthesisContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ExpressionsNotInParenthesisContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterExpressionsNotInParenthesis(s)
	}
}

func (s *ExpressionsNotInParenthesisContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitExpressionsNotInParenthesis(s)
	}
}

func (s *ExpressionsNotInParenthesisContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitExpressionsNotInParenthesis(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ExpressionsNotInParenthesis() (localctx IExpressionsNotInParenthesisContext) {
	localctx = NewExpressionsNotInParenthesisContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 724, HiveParserRULE_expressionsNotInParenthesis)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4315)

		var _x = p.ExpressionOrDefault()


		localctx.(*ExpressionsNotInParenthesisContext).first = _x
	}
	p.SetState(4317)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserCOMMA {
		{
			p.SetState(4316)

			var _x = p.ExpressionPart()


			localctx.(*ExpressionsNotInParenthesisContext).more = _x
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExpressionPartContext is an interface to support dynamic dispatch.
type IExpressionPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	AllExpressionOrDefault() []IExpressionOrDefaultContext
	ExpressionOrDefault(i int) IExpressionOrDefaultContext

	// IsExpressionPartContext differentiates from other interfaces.
	IsExpressionPartContext()
}

type ExpressionPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionPartContext() *ExpressionPartContext {
	var p = new(ExpressionPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_expressionPart
	return p
}

func InitEmptyExpressionPartContext(p *ExpressionPartContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_expressionPart
}

func (*ExpressionPartContext) IsExpressionPartContext() {}

func NewExpressionPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionPartContext {
	var p = new(ExpressionPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_expressionPart

	return p
}

func (s *ExpressionPartContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionPartContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(HiveParserCOMMA)
}

func (s *ExpressionPartContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserCOMMA, i)
}

func (s *ExpressionPartContext) AllExpressionOrDefault() []IExpressionOrDefaultContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionOrDefaultContext); ok {
			len++
		}
	}

	tst := make([]IExpressionOrDefaultContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionOrDefaultContext); ok {
			tst[i] = t.(IExpressionOrDefaultContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionPartContext) ExpressionOrDefault(i int) IExpressionOrDefaultContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionOrDefaultContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionOrDefaultContext)
}

func (s *ExpressionPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ExpressionPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterExpressionPart(s)
	}
}

func (s *ExpressionPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitExpressionPart(s)
	}
}

func (s *ExpressionPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitExpressionPart(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ExpressionPart() (localctx IExpressionPartContext) {
	localctx = NewExpressionPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 726, HiveParserRULE_expressionPart)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4321)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for ok := true; ok; ok = _la == HiveParserCOMMA {
		{
			p.SetState(4319)
			p.Match(HiveParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4320)
			p.ExpressionOrDefault()
		}


		p.SetState(4323)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExpressionOrDefaultContext is an interface to support dynamic dispatch.
type IExpressionOrDefaultContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DefaultValue() IDefaultValueContext
	Expression() IExpressionContext

	// IsExpressionOrDefaultContext differentiates from other interfaces.
	IsExpressionOrDefaultContext()
}

type ExpressionOrDefaultContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionOrDefaultContext() *ExpressionOrDefaultContext {
	var p = new(ExpressionOrDefaultContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_expressionOrDefault
	return p
}

func InitEmptyExpressionOrDefaultContext(p *ExpressionOrDefaultContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_expressionOrDefault
}

func (*ExpressionOrDefaultContext) IsExpressionOrDefaultContext() {}

func NewExpressionOrDefaultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionOrDefaultContext {
	var p = new(ExpressionOrDefaultContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_expressionOrDefault

	return p
}

func (s *ExpressionOrDefaultContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionOrDefaultContext) DefaultValue() IDefaultValueContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefaultValueContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefaultValueContext)
}

func (s *ExpressionOrDefaultContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionOrDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionOrDefaultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ExpressionOrDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterExpressionOrDefault(s)
	}
}

func (s *ExpressionOrDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitExpressionOrDefault(s)
	}
}

func (s *ExpressionOrDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitExpressionOrDefault(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ExpressionOrDefault() (localctx IExpressionOrDefaultContext) {
	localctx = NewExpressionOrDefaultContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 728, HiveParserRULE_expressionOrDefault)
	p.SetState(4327)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 513, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4325)
			p.DefaultValue()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4326)
			p.Expression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFirstExpressionsWithAliasContext is an interface to support dynamic dispatch.
type IFirstExpressionsWithAliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFirst returns the first rule contexts.
	GetFirst() IExpressionContext

	// GetColAlias returns the colAlias rule contexts.
	GetColAlias() IId_Context


	// SetFirst sets the first rule contexts.
	SetFirst(IExpressionContext)

	// SetColAlias sets the colAlias rule contexts.
	SetColAlias(IId_Context)


	// Getter signatures
	Expression() IExpressionContext
	KW_AS() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	AllExpressionWithAlias() []IExpressionWithAliasContext
	ExpressionWithAlias(i int) IExpressionWithAliasContext
	Id_() IId_Context

	// IsFirstExpressionsWithAliasContext differentiates from other interfaces.
	IsFirstExpressionsWithAliasContext()
}

type FirstExpressionsWithAliasContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	first IExpressionContext 
	colAlias IId_Context 
}

func NewEmptyFirstExpressionsWithAliasContext() *FirstExpressionsWithAliasContext {
	var p = new(FirstExpressionsWithAliasContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_firstExpressionsWithAlias
	return p
}

func InitEmptyFirstExpressionsWithAliasContext(p *FirstExpressionsWithAliasContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_firstExpressionsWithAlias
}

func (*FirstExpressionsWithAliasContext) IsFirstExpressionsWithAliasContext() {}

func NewFirstExpressionsWithAliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FirstExpressionsWithAliasContext {
	var p = new(FirstExpressionsWithAliasContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_firstExpressionsWithAlias

	return p
}

func (s *FirstExpressionsWithAliasContext) GetParser() antlr.Parser { return s.parser }

func (s *FirstExpressionsWithAliasContext) GetFirst() IExpressionContext { return s.first }

func (s *FirstExpressionsWithAliasContext) GetColAlias() IId_Context { return s.colAlias }


func (s *FirstExpressionsWithAliasContext) SetFirst(v IExpressionContext) { s.first = v }

func (s *FirstExpressionsWithAliasContext) SetColAlias(v IId_Context) { s.colAlias = v }


func (s *FirstExpressionsWithAliasContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FirstExpressionsWithAliasContext) KW_AS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_AS, 0)
}

func (s *FirstExpressionsWithAliasContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(HiveParserCOMMA)
}

func (s *FirstExpressionsWithAliasContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserCOMMA, i)
}

func (s *FirstExpressionsWithAliasContext) AllExpressionWithAlias() []IExpressionWithAliasContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionWithAliasContext); ok {
			len++
		}
	}

	tst := make([]IExpressionWithAliasContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionWithAliasContext); ok {
			tst[i] = t.(IExpressionWithAliasContext)
			i++
		}
	}

	return tst
}

func (s *FirstExpressionsWithAliasContext) ExpressionWithAlias(i int) IExpressionWithAliasContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionWithAliasContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionWithAliasContext)
}

func (s *FirstExpressionsWithAliasContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *FirstExpressionsWithAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FirstExpressionsWithAliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *FirstExpressionsWithAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterFirstExpressionsWithAlias(s)
	}
}

func (s *FirstExpressionsWithAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitFirstExpressionsWithAlias(s)
	}
}

func (s *FirstExpressionsWithAliasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitFirstExpressionsWithAlias(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) FirstExpressionsWithAlias() (localctx IFirstExpressionsWithAliasContext) {
	localctx = NewFirstExpressionsWithAliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 730, HiveParserRULE_firstExpressionsWithAlias)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4329)

		var _x = p.Expression()


		localctx.(*FirstExpressionsWithAliasContext).first = _x
	}
	p.SetState(4331)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_AS {
		{
			p.SetState(4330)
			p.Match(HiveParserKW_AS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	p.SetState(4334)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 808078815591695742) != 0) || ((int64((_la - 66)) & ^0x3f) == 0 && ((int64(1) << (_la - 66)) & 1083038567331911621) != 0) || ((int64((_la - 132)) & ^0x3f) == 0 && ((int64(1) << (_la - 132)) & 8916819943869537315) != 0) || ((int64((_la - 196)) & ^0x3f) == 0 && ((int64(1) << (_la - 196)) & 4159991143015340909) != 0) || ((int64((_la - 261)) & ^0x3f) == 0 && ((int64(1) << (_la - 261)) & 8484708576009596927) != 0) || ((int64((_la - 328)) & ^0x3f) == 0 && ((int64(1) << (_la - 328)) & 17776728909112555) != 0) || _la == HiveParserIdentifier {
		{
			p.SetState(4333)

			var _x = p.Id_()


			localctx.(*FirstExpressionsWithAliasContext).colAlias = _x
		}

	}
	p.SetState(4340)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HiveParserCOMMA {
		{
			p.SetState(4336)
			p.Match(HiveParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4337)
			p.ExpressionWithAlias()
		}


		p.SetState(4342)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExpressionWithAliasContext is an interface to support dynamic dispatch.
type IExpressionWithAliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetAlias returns the alias rule contexts.
	GetAlias() IId_Context


	// SetAlias sets the alias rule contexts.
	SetAlias(IId_Context)


	// Getter signatures
	Expression() IExpressionContext
	KW_AS() antlr.TerminalNode
	Id_() IId_Context

	// IsExpressionWithAliasContext differentiates from other interfaces.
	IsExpressionWithAliasContext()
}

type ExpressionWithAliasContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	alias IId_Context 
}

func NewEmptyExpressionWithAliasContext() *ExpressionWithAliasContext {
	var p = new(ExpressionWithAliasContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_expressionWithAlias
	return p
}

func InitEmptyExpressionWithAliasContext(p *ExpressionWithAliasContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_expressionWithAlias
}

func (*ExpressionWithAliasContext) IsExpressionWithAliasContext() {}

func NewExpressionWithAliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionWithAliasContext {
	var p = new(ExpressionWithAliasContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_expressionWithAlias

	return p
}

func (s *ExpressionWithAliasContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionWithAliasContext) GetAlias() IId_Context { return s.alias }


func (s *ExpressionWithAliasContext) SetAlias(v IId_Context) { s.alias = v }


func (s *ExpressionWithAliasContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionWithAliasContext) KW_AS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_AS, 0)
}

func (s *ExpressionWithAliasContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *ExpressionWithAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionWithAliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ExpressionWithAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterExpressionWithAlias(s)
	}
}

func (s *ExpressionWithAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitExpressionWithAlias(s)
	}
}

func (s *ExpressionWithAliasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitExpressionWithAlias(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ExpressionWithAlias() (localctx IExpressionWithAliasContext) {
	localctx = NewExpressionWithAliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 732, HiveParserRULE_expressionWithAlias)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4343)
		p.Expression()
	}
	p.SetState(4345)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_AS {
		{
			p.SetState(4344)
			p.Match(HiveParserKW_AS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	p.SetState(4348)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 808078815591695742) != 0) || ((int64((_la - 66)) & ^0x3f) == 0 && ((int64(1) << (_la - 66)) & 1083038567331911621) != 0) || ((int64((_la - 132)) & ^0x3f) == 0 && ((int64(1) << (_la - 132)) & 8916819943869537315) != 0) || ((int64((_la - 196)) & ^0x3f) == 0 && ((int64(1) << (_la - 196)) & 4159991143015340909) != 0) || ((int64((_la - 261)) & ^0x3f) == 0 && ((int64(1) << (_la - 261)) & 8484708576009596927) != 0) || ((int64((_la - 328)) & ^0x3f) == 0 && ((int64(1) << (_la - 328)) & 17776728909112555) != 0) || _la == HiveParserIdentifier {
		{
			p.SetState(4347)

			var _x = p.Id_()


			localctx.(*ExpressionWithAliasContext).alias = _x
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExpressionsContext is an interface to support dynamic dispatch.
type IExpressionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ExpressionsInParenthesis() IExpressionsInParenthesisContext
	ExpressionsNotInParenthesis() IExpressionsNotInParenthesisContext

	// IsExpressionsContext differentiates from other interfaces.
	IsExpressionsContext()
}

type ExpressionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionsContext() *ExpressionsContext {
	var p = new(ExpressionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_expressions
	return p
}

func InitEmptyExpressionsContext(p *ExpressionsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_expressions
}

func (*ExpressionsContext) IsExpressionsContext() {}

func NewExpressionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionsContext {
	var p = new(ExpressionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_expressions

	return p
}

func (s *ExpressionsContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionsContext) ExpressionsInParenthesis() IExpressionsInParenthesisContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionsInParenthesisContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionsInParenthesisContext)
}

func (s *ExpressionsContext) ExpressionsNotInParenthesis() IExpressionsNotInParenthesisContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionsNotInParenthesisContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionsNotInParenthesisContext)
}

func (s *ExpressionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ExpressionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterExpressions(s)
	}
}

func (s *ExpressionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitExpressions(s)
	}
}

func (s *ExpressionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitExpressions(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) Expressions() (localctx IExpressionsContext) {
	localctx = NewExpressionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 734, HiveParserRULE_expressions)
	p.SetState(4352)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 519, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4350)
			p.ExpressionsInParenthesis()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4351)
			p.ExpressionsNotInParenthesis()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IColumnRefOrderInParenthesisContext is an interface to support dynamic dispatch.
type IColumnRefOrderInParenthesisContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	AllColumnRefOrder() []IColumnRefOrderContext
	ColumnRefOrder(i int) IColumnRefOrderContext
	RPAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsColumnRefOrderInParenthesisContext differentiates from other interfaces.
	IsColumnRefOrderInParenthesisContext()
}

type ColumnRefOrderInParenthesisContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnRefOrderInParenthesisContext() *ColumnRefOrderInParenthesisContext {
	var p = new(ColumnRefOrderInParenthesisContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_columnRefOrderInParenthesis
	return p
}

func InitEmptyColumnRefOrderInParenthesisContext(p *ColumnRefOrderInParenthesisContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_columnRefOrderInParenthesis
}

func (*ColumnRefOrderInParenthesisContext) IsColumnRefOrderInParenthesisContext() {}

func NewColumnRefOrderInParenthesisContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnRefOrderInParenthesisContext {
	var p = new(ColumnRefOrderInParenthesisContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_columnRefOrderInParenthesis

	return p
}

func (s *ColumnRefOrderInParenthesisContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnRefOrderInParenthesisContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserLPAREN, 0)
}

func (s *ColumnRefOrderInParenthesisContext) AllColumnRefOrder() []IColumnRefOrderContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnRefOrderContext); ok {
			len++
		}
	}

	tst := make([]IColumnRefOrderContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnRefOrderContext); ok {
			tst[i] = t.(IColumnRefOrderContext)
			i++
		}
	}

	return tst
}

func (s *ColumnRefOrderInParenthesisContext) ColumnRefOrder(i int) IColumnRefOrderContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnRefOrderContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnRefOrderContext)
}

func (s *ColumnRefOrderInParenthesisContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserRPAREN, 0)
}

func (s *ColumnRefOrderInParenthesisContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(HiveParserCOMMA)
}

func (s *ColumnRefOrderInParenthesisContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserCOMMA, i)
}

func (s *ColumnRefOrderInParenthesisContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnRefOrderInParenthesisContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ColumnRefOrderInParenthesisContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterColumnRefOrderInParenthesis(s)
	}
}

func (s *ColumnRefOrderInParenthesisContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitColumnRefOrderInParenthesis(s)
	}
}

func (s *ColumnRefOrderInParenthesisContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitColumnRefOrderInParenthesis(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ColumnRefOrderInParenthesis() (localctx IColumnRefOrderInParenthesisContext) {
	localctx = NewColumnRefOrderInParenthesisContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 736, HiveParserRULE_columnRefOrderInParenthesis)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4354)
		p.Match(HiveParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4355)
		p.ColumnRefOrder()
	}
	p.SetState(4360)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HiveParserCOMMA {
		{
			p.SetState(4356)
			p.Match(HiveParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4357)
			p.ColumnRefOrder()
		}


		p.SetState(4362)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(4363)
		p.Match(HiveParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IColumnRefOrderNotInParenthesisContext is an interface to support dynamic dispatch.
type IColumnRefOrderNotInParenthesisContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllColumnRefOrder() []IColumnRefOrderContext
	ColumnRefOrder(i int) IColumnRefOrderContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsColumnRefOrderNotInParenthesisContext differentiates from other interfaces.
	IsColumnRefOrderNotInParenthesisContext()
}

type ColumnRefOrderNotInParenthesisContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnRefOrderNotInParenthesisContext() *ColumnRefOrderNotInParenthesisContext {
	var p = new(ColumnRefOrderNotInParenthesisContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_columnRefOrderNotInParenthesis
	return p
}

func InitEmptyColumnRefOrderNotInParenthesisContext(p *ColumnRefOrderNotInParenthesisContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_columnRefOrderNotInParenthesis
}

func (*ColumnRefOrderNotInParenthesisContext) IsColumnRefOrderNotInParenthesisContext() {}

func NewColumnRefOrderNotInParenthesisContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnRefOrderNotInParenthesisContext {
	var p = new(ColumnRefOrderNotInParenthesisContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_columnRefOrderNotInParenthesis

	return p
}

func (s *ColumnRefOrderNotInParenthesisContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnRefOrderNotInParenthesisContext) AllColumnRefOrder() []IColumnRefOrderContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnRefOrderContext); ok {
			len++
		}
	}

	tst := make([]IColumnRefOrderContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnRefOrderContext); ok {
			tst[i] = t.(IColumnRefOrderContext)
			i++
		}
	}

	return tst
}

func (s *ColumnRefOrderNotInParenthesisContext) ColumnRefOrder(i int) IColumnRefOrderContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnRefOrderContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnRefOrderContext)
}

func (s *ColumnRefOrderNotInParenthesisContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(HiveParserCOMMA)
}

func (s *ColumnRefOrderNotInParenthesisContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserCOMMA, i)
}

func (s *ColumnRefOrderNotInParenthesisContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnRefOrderNotInParenthesisContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ColumnRefOrderNotInParenthesisContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterColumnRefOrderNotInParenthesis(s)
	}
}

func (s *ColumnRefOrderNotInParenthesisContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitColumnRefOrderNotInParenthesis(s)
	}
}

func (s *ColumnRefOrderNotInParenthesisContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitColumnRefOrderNotInParenthesis(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ColumnRefOrderNotInParenthesis() (localctx IColumnRefOrderNotInParenthesisContext) {
	localctx = NewColumnRefOrderNotInParenthesisContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 738, HiveParserRULE_columnRefOrderNotInParenthesis)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4365)
		p.ColumnRefOrder()
	}
	p.SetState(4370)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HiveParserCOMMA {
		{
			p.SetState(4366)
			p.Match(HiveParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4367)
			p.ColumnRefOrder()
		}


		p.SetState(4372)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IOrderByClauseContext is an interface to support dynamic dispatch.
type IOrderByClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_ORDER() antlr.TerminalNode
	KW_BY() antlr.TerminalNode
	AllColumnRefOrder() []IColumnRefOrderContext
	ColumnRefOrder(i int) IColumnRefOrderContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsOrderByClauseContext differentiates from other interfaces.
	IsOrderByClauseContext()
}

type OrderByClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrderByClauseContext() *OrderByClauseContext {
	var p = new(OrderByClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_orderByClause
	return p
}

func InitEmptyOrderByClauseContext(p *OrderByClauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_orderByClause
}

func (*OrderByClauseContext) IsOrderByClauseContext() {}

func NewOrderByClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrderByClauseContext {
	var p = new(OrderByClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_orderByClause

	return p
}

func (s *OrderByClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *OrderByClauseContext) KW_ORDER() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ORDER, 0)
}

func (s *OrderByClauseContext) KW_BY() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_BY, 0)
}

func (s *OrderByClauseContext) AllColumnRefOrder() []IColumnRefOrderContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnRefOrderContext); ok {
			len++
		}
	}

	tst := make([]IColumnRefOrderContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnRefOrderContext); ok {
			tst[i] = t.(IColumnRefOrderContext)
			i++
		}
	}

	return tst
}

func (s *OrderByClauseContext) ColumnRefOrder(i int) IColumnRefOrderContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnRefOrderContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnRefOrderContext)
}

func (s *OrderByClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(HiveParserCOMMA)
}

func (s *OrderByClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserCOMMA, i)
}

func (s *OrderByClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrderByClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OrderByClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterOrderByClause(s)
	}
}

func (s *OrderByClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitOrderByClause(s)
	}
}

func (s *OrderByClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitOrderByClause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) OrderByClause() (localctx IOrderByClauseContext) {
	localctx = NewOrderByClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 740, HiveParserRULE_orderByClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4373)
		p.Match(HiveParserKW_ORDER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4374)
		p.Match(HiveParserKW_BY)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4375)
		p.ColumnRefOrder()
	}
	p.SetState(4380)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HiveParserCOMMA {
		{
			p.SetState(4376)
			p.Match(HiveParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4377)
			p.ColumnRefOrder()
		}


		p.SetState(4382)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IClusterByClauseContext is an interface to support dynamic dispatch.
type IClusterByClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_CLUSTER() antlr.TerminalNode
	KW_BY() antlr.TerminalNode
	Expressions() IExpressionsContext

	// IsClusterByClauseContext differentiates from other interfaces.
	IsClusterByClauseContext()
}

type ClusterByClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClusterByClauseContext() *ClusterByClauseContext {
	var p = new(ClusterByClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_clusterByClause
	return p
}

func InitEmptyClusterByClauseContext(p *ClusterByClauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_clusterByClause
}

func (*ClusterByClauseContext) IsClusterByClauseContext() {}

func NewClusterByClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClusterByClauseContext {
	var p = new(ClusterByClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_clusterByClause

	return p
}

func (s *ClusterByClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ClusterByClauseContext) KW_CLUSTER() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_CLUSTER, 0)
}

func (s *ClusterByClauseContext) KW_BY() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_BY, 0)
}

func (s *ClusterByClauseContext) Expressions() IExpressionsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionsContext)
}

func (s *ClusterByClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClusterByClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ClusterByClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterClusterByClause(s)
	}
}

func (s *ClusterByClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitClusterByClause(s)
	}
}

func (s *ClusterByClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitClusterByClause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ClusterByClause() (localctx IClusterByClauseContext) {
	localctx = NewClusterByClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 742, HiveParserRULE_clusterByClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4383)
		p.Match(HiveParserKW_CLUSTER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4384)
		p.Match(HiveParserKW_BY)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4385)
		p.Expressions()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPartitionByClauseContext is an interface to support dynamic dispatch.
type IPartitionByClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_PARTITION() antlr.TerminalNode
	KW_BY() antlr.TerminalNode
	Expressions() IExpressionsContext

	// IsPartitionByClauseContext differentiates from other interfaces.
	IsPartitionByClauseContext()
}

type PartitionByClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionByClauseContext() *PartitionByClauseContext {
	var p = new(PartitionByClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_partitionByClause
	return p
}

func InitEmptyPartitionByClauseContext(p *PartitionByClauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_partitionByClause
}

func (*PartitionByClauseContext) IsPartitionByClauseContext() {}

func NewPartitionByClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionByClauseContext {
	var p = new(PartitionByClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_partitionByClause

	return p
}

func (s *PartitionByClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionByClauseContext) KW_PARTITION() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_PARTITION, 0)
}

func (s *PartitionByClauseContext) KW_BY() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_BY, 0)
}

func (s *PartitionByClauseContext) Expressions() IExpressionsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionsContext)
}

func (s *PartitionByClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionByClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PartitionByClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterPartitionByClause(s)
	}
}

func (s *PartitionByClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitPartitionByClause(s)
	}
}

func (s *PartitionByClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitPartitionByClause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) PartitionByClause() (localctx IPartitionByClauseContext) {
	localctx = NewPartitionByClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 744, HiveParserRULE_partitionByClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4387)
		p.Match(HiveParserKW_PARTITION)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4388)
		p.Match(HiveParserKW_BY)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4389)
		p.Expressions()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDistributeByClauseContext is an interface to support dynamic dispatch.
type IDistributeByClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_DISTRIBUTE() antlr.TerminalNode
	KW_BY() antlr.TerminalNode
	Expressions() IExpressionsContext

	// IsDistributeByClauseContext differentiates from other interfaces.
	IsDistributeByClauseContext()
}

type DistributeByClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDistributeByClauseContext() *DistributeByClauseContext {
	var p = new(DistributeByClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_distributeByClause
	return p
}

func InitEmptyDistributeByClauseContext(p *DistributeByClauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_distributeByClause
}

func (*DistributeByClauseContext) IsDistributeByClauseContext() {}

func NewDistributeByClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DistributeByClauseContext {
	var p = new(DistributeByClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_distributeByClause

	return p
}

func (s *DistributeByClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DistributeByClauseContext) KW_DISTRIBUTE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DISTRIBUTE, 0)
}

func (s *DistributeByClauseContext) KW_BY() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_BY, 0)
}

func (s *DistributeByClauseContext) Expressions() IExpressionsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionsContext)
}

func (s *DistributeByClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DistributeByClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DistributeByClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterDistributeByClause(s)
	}
}

func (s *DistributeByClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitDistributeByClause(s)
	}
}

func (s *DistributeByClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitDistributeByClause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) DistributeByClause() (localctx IDistributeByClauseContext) {
	localctx = NewDistributeByClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 746, HiveParserRULE_distributeByClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4391)
		p.Match(HiveParserKW_DISTRIBUTE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4392)
		p.Match(HiveParserKW_BY)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4393)
		p.Expressions()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISortByClauseContext is an interface to support dynamic dispatch.
type ISortByClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_SORT() antlr.TerminalNode
	KW_BY() antlr.TerminalNode
	ColumnRefOrderInParenthesis() IColumnRefOrderInParenthesisContext
	ColumnRefOrderNotInParenthesis() IColumnRefOrderNotInParenthesisContext

	// IsSortByClauseContext differentiates from other interfaces.
	IsSortByClauseContext()
}

type SortByClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySortByClauseContext() *SortByClauseContext {
	var p = new(SortByClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_sortByClause
	return p
}

func InitEmptySortByClauseContext(p *SortByClauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_sortByClause
}

func (*SortByClauseContext) IsSortByClauseContext() {}

func NewSortByClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortByClauseContext {
	var p = new(SortByClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_sortByClause

	return p
}

func (s *SortByClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SortByClauseContext) KW_SORT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SORT, 0)
}

func (s *SortByClauseContext) KW_BY() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_BY, 0)
}

func (s *SortByClauseContext) ColumnRefOrderInParenthesis() IColumnRefOrderInParenthesisContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnRefOrderInParenthesisContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnRefOrderInParenthesisContext)
}

func (s *SortByClauseContext) ColumnRefOrderNotInParenthesis() IColumnRefOrderNotInParenthesisContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnRefOrderNotInParenthesisContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnRefOrderNotInParenthesisContext)
}

func (s *SortByClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortByClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SortByClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterSortByClause(s)
	}
}

func (s *SortByClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitSortByClause(s)
	}
}

func (s *SortByClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitSortByClause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) SortByClause() (localctx ISortByClauseContext) {
	localctx = NewSortByClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 748, HiveParserRULE_sortByClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4395)
		p.Match(HiveParserKW_SORT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4396)
		p.Match(HiveParserKW_BY)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(4399)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 523, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4397)
			p.ColumnRefOrderInParenthesis()
		}


	case 2:
		{
			p.SetState(4398)
			p.ColumnRefOrderNotInParenthesis()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITrimFunctionContext is an interface to support dynamic dispatch.
type ITrimFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLeading returns the leading token.
	GetLeading() antlr.Token 

	// GetTrailing returns the trailing token.
	GetTrailing() antlr.Token 


	// SetLeading sets the leading token.
	SetLeading(antlr.Token) 

	// SetTrailing sets the trailing token.
	SetTrailing(antlr.Token) 


	// GetTrim_characters returns the trim_characters rule contexts.
	GetTrim_characters() ISelectExpressionContext

	// GetStr returns the str rule contexts.
	GetStr() ISelectExpressionContext


	// SetTrim_characters sets the trim_characters rule contexts.
	SetTrim_characters(ISelectExpressionContext)

	// SetStr sets the str rule contexts.
	SetStr(ISelectExpressionContext)


	// Getter signatures
	KW_TRIM() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	KW_FROM() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	AllSelectExpression() []ISelectExpressionContext
	SelectExpression(i int) ISelectExpressionContext
	KW_BOTH() antlr.TerminalNode
	KW_LEADING() antlr.TerminalNode
	KW_TRAILING() antlr.TerminalNode

	// IsTrimFunctionContext differentiates from other interfaces.
	IsTrimFunctionContext()
}

type TrimFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	leading antlr.Token
	trailing antlr.Token
	trim_characters ISelectExpressionContext 
	str ISelectExpressionContext 
}

func NewEmptyTrimFunctionContext() *TrimFunctionContext {
	var p = new(TrimFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_trimFunction
	return p
}

func InitEmptyTrimFunctionContext(p *TrimFunctionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_trimFunction
}

func (*TrimFunctionContext) IsTrimFunctionContext() {}

func NewTrimFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TrimFunctionContext {
	var p = new(TrimFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_trimFunction

	return p
}

func (s *TrimFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *TrimFunctionContext) GetLeading() antlr.Token { return s.leading }

func (s *TrimFunctionContext) GetTrailing() antlr.Token { return s.trailing }


func (s *TrimFunctionContext) SetLeading(v antlr.Token) { s.leading = v }

func (s *TrimFunctionContext) SetTrailing(v antlr.Token) { s.trailing = v }


func (s *TrimFunctionContext) GetTrim_characters() ISelectExpressionContext { return s.trim_characters }

func (s *TrimFunctionContext) GetStr() ISelectExpressionContext { return s.str }


func (s *TrimFunctionContext) SetTrim_characters(v ISelectExpressionContext) { s.trim_characters = v }

func (s *TrimFunctionContext) SetStr(v ISelectExpressionContext) { s.str = v }


func (s *TrimFunctionContext) KW_TRIM() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TRIM, 0)
}

func (s *TrimFunctionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserLPAREN, 0)
}

func (s *TrimFunctionContext) KW_FROM() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_FROM, 0)
}

func (s *TrimFunctionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserRPAREN, 0)
}

func (s *TrimFunctionContext) AllSelectExpression() []ISelectExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelectExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISelectExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelectExpressionContext); ok {
			tst[i] = t.(ISelectExpressionContext)
			i++
		}
	}

	return tst
}

func (s *TrimFunctionContext) SelectExpression(i int) ISelectExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectExpressionContext)
}

func (s *TrimFunctionContext) KW_BOTH() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_BOTH, 0)
}

func (s *TrimFunctionContext) KW_LEADING() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_LEADING, 0)
}

func (s *TrimFunctionContext) KW_TRAILING() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TRAILING, 0)
}

func (s *TrimFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TrimFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TrimFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterTrimFunction(s)
	}
}

func (s *TrimFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitTrimFunction(s)
	}
}

func (s *TrimFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitTrimFunction(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) TrimFunction() (localctx ITrimFunctionContext) {
	localctx = NewTrimFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 750, HiveParserRULE_trimFunction)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4401)
		p.Match(HiveParserKW_TRIM)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4402)
		p.Match(HiveParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(4406)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case HiveParserKW_LEADING:
		{
			p.SetState(4403)

			var _m = p.Match(HiveParserKW_LEADING)

			localctx.(*TrimFunctionContext).leading = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HiveParserKW_TRAILING:
		{
			p.SetState(4404)

			var _m = p.Match(HiveParserKW_TRAILING)

			localctx.(*TrimFunctionContext).trailing = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HiveParserKW_BOTH:
		{
			p.SetState(4405)
			p.Match(HiveParserKW_BOTH)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HiveParserKW_ABORT, HiveParserKW_ACTIVATE, HiveParserKW_ACTIVE, HiveParserKW_ADD, HiveParserKW_ADMIN, HiveParserKW_AFTER, HiveParserKW_ALLOC_FRACTION, HiveParserKW_ANALYZE, HiveParserKW_ARCHIVE, HiveParserKW_ARRAY, HiveParserKW_ASC, HiveParserKW_AST, HiveParserKW_AT, HiveParserKW_AUTOCOMMIT, HiveParserKW_BATCH, HiveParserKW_BEFORE, HiveParserKW_BIGINT, HiveParserKW_BINARY, HiveParserKW_BOOLEAN, HiveParserKW_BUCKET, HiveParserKW_BUCKETS, HiveParserKW_CACHE, HiveParserKW_CASCADE, HiveParserKW_CASE, HiveParserKW_CAST, HiveParserKW_CBO, HiveParserKW_CHANGE, HiveParserKW_CHECK, HiveParserKW_CLUSTER, HiveParserKW_CLUSTERED, HiveParserKW_CLUSTERSTATUS, HiveParserKW_COLLECTION, HiveParserKW_COLUMNS, HiveParserKW_COMMENT, HiveParserKW_COMPACT, HiveParserKW_COMPACTIONS, HiveParserKW_COMPUTE, HiveParserKW_CONCATENATE, HiveParserKW_CONTINUE, HiveParserKW_COST, HiveParserKW_CRON, HiveParserKW_CURRENT_DATE, HiveParserKW_CURRENT_TIMESTAMP, HiveParserKW_DATA, HiveParserKW_DATABASES, HiveParserKW_DATE, HiveParserKW_DATETIME, HiveParserKW_DAY, HiveParserKW_DAYOFWEEK, HiveParserKW_DBPROPERTIES, HiveParserKW_DCPROPERTIES, HiveParserKW_DEBUG, HiveParserKW_DEFAULT, HiveParserKW_DEFERRED, HiveParserKW_DEFINED, HiveParserKW_DELIMITED, HiveParserKW_DEPENDENCY, HiveParserKW_DESC, HiveParserKW_DETAIL, HiveParserKW_DIRECTORIES, HiveParserKW_DIRECTORY, HiveParserKW_DISABLE, HiveParserKW_DISTRIBUTE, HiveParserKW_DISTRIBUTED, HiveParserKW_DO, HiveParserKW_DOUBLE, HiveParserKW_DOW, HiveParserKW_DUMP, HiveParserKW_ELEM_TYPE, HiveParserKW_ENABLE, HiveParserKW_ENFORCED, HiveParserKW_ESCAPED, HiveParserKW_EVERY, HiveParserKW_EXCLUSIVE, HiveParserKW_EXECUTE, HiveParserKW_EXECUTED, HiveParserKW_EXISTS, HiveParserKW_EXPIRE_SNAPSHOTS, HiveParserKW_EXPLAIN, HiveParserKW_EXPORT, HiveParserKW_EXPRESSION, HiveParserKW_EXTRACT, HiveParserKW_FALSE, HiveParserKW_FIELDS, HiveParserKW_FILE, HiveParserKW_FILEFORMAT, HiveParserKW_FIRST, HiveParserKW_FLOAT, HiveParserKW_FLOOR, HiveParserKW_FORMAT, HiveParserKW_FORMATTED, HiveParserKW_FROM, HiveParserKW_FUNCTIONS, HiveParserKW_GROUPING, HiveParserKW_HOLD_DDLTIME, HiveParserKW_HOUR, HiveParserKW_IDXPROPERTIES, HiveParserKW_IF, HiveParserKW_IGNORE, HiveParserKW_INDEX, HiveParserKW_INDEXES, HiveParserKW_INPATH, HiveParserKW_INPUTDRIVER, HiveParserKW_INPUTFORMAT, HiveParserKW_INT, HiveParserKW_INTERVAL, HiveParserKW_ISOLATION, HiveParserKW_ITEMS, HiveParserKW_JAR, HiveParserKW_JOINCOST, HiveParserKW_KEY, HiveParserKW_KEYS, HiveParserKW_KEY_TYPE, HiveParserKW_KILL, HiveParserKW_LAST, HiveParserKW_LEVEL, HiveParserKW_LIMIT, HiveParserKW_LINES, HiveParserKW_LOAD, HiveParserKW_LOCATION, HiveParserKW_LOCK, HiveParserKW_LOCKS, HiveParserKW_LOGICAL, HiveParserKW_LONG, HiveParserKW_MANAGED, HiveParserKW_MANAGEDLOCATION, HiveParserKW_MANAGEMENT, HiveParserKW_MAP, HiveParserKW_MAPJOIN, HiveParserKW_MAPPING, HiveParserKW_MATCHED, HiveParserKW_MATERIALIZED, HiveParserKW_METADATA, HiveParserKW_MINUTE, HiveParserKW_MONTH, HiveParserKW_MOVE, HiveParserKW_MSCK, HiveParserKW_NORELY, HiveParserKW_NOSCAN, HiveParserKW_NOT, HiveParserKW_NOVALIDATE, HiveParserKW_NO_DROP, HiveParserKW_NULL, HiveParserKW_NULLS, HiveParserKW_OFFLINE, HiveParserKW_OFFSET, HiveParserKW_OPERATOR, HiveParserKW_OPTION, HiveParserKW_OUTPUTDRIVER, HiveParserKW_OUTPUTFORMAT, HiveParserKW_OVERWRITE, HiveParserKW_OWNER, HiveParserKW_PARTITIONED, HiveParserKW_PARTITIONS, HiveParserKW_PATH, HiveParserKW_PLAN, HiveParserKW_PLANS, HiveParserKW_PLUS, HiveParserKW_POOL, HiveParserKW_PRINCIPALS, HiveParserKW_PROTECTION, HiveParserKW_PURGE, HiveParserKW_QUARTER, HiveParserKW_QUERY, HiveParserKW_QUERY_PARALLELISM, HiveParserKW_READ, HiveParserKW_READONLY, HiveParserKW_REAL, HiveParserKW_REBUILD, HiveParserKW_RECORDREADER, HiveParserKW_RECORDWRITER, HiveParserKW_RELOAD, HiveParserKW_RELY, HiveParserKW_REMOTE, HiveParserKW_RENAME, HiveParserKW_REOPTIMIZATION, HiveParserKW_REPAIR, HiveParserKW_REPL, HiveParserKW_REPLACE, HiveParserKW_REPLICATION, HiveParserKW_RESOURCE, HiveParserKW_RESPECT, HiveParserKW_RESTRICT, HiveParserKW_REWRITE, HiveParserKW_ROLE, HiveParserKW_ROLES, HiveParserKW_SCHEDULED, HiveParserKW_SCHEDULING_POLICY, HiveParserKW_SCHEMA, HiveParserKW_SCHEMAS, HiveParserKW_SECOND, HiveParserKW_SEMI, HiveParserKW_SERDE, HiveParserKW_SERDEPROPERTIES, HiveParserKW_SERVER, HiveParserKW_SETS, HiveParserKW_SET_CURRENT_SNAPSHOT, HiveParserKW_SHARED, HiveParserKW_SHOW, HiveParserKW_SHOW_DATABASE, HiveParserKW_SKEWED, HiveParserKW_SMALLINT, HiveParserKW_SNAPSHOT, HiveParserKW_SORT, HiveParserKW_SORTED, HiveParserKW_SPEC, HiveParserKW_SSL, HiveParserKW_STATISTICS, HiveParserKW_STATUS, HiveParserKW_STORED, HiveParserKW_STREAMTABLE, HiveParserKW_STRING, HiveParserKW_STRUCT, HiveParserKW_SUMMARY, HiveParserKW_SYSTEM_TIME, HiveParserKW_SYSTEM_VERSION, HiveParserKW_TABLES, HiveParserKW_TBLPROPERTIES, HiveParserKW_TEMPORARY, HiveParserKW_TERMINATED, HiveParserKW_TIMESTAMP, HiveParserKW_TIMESTAMPLOCALTZ, HiveParserKW_TIMESTAMPTZ, HiveParserKW_TINYINT, HiveParserKW_TOUCH, HiveParserKW_TRANSACTION, HiveParserKW_TRANSACTIONAL, HiveParserKW_TRANSACTIONS, HiveParserKW_TRIM, HiveParserKW_TRUE, HiveParserKW_TYPE, HiveParserKW_UNARCHIVE, HiveParserKW_UNDO, HiveParserKW_UNIONTYPE, HiveParserKW_UNKNOWN, HiveParserKW_UNLOCK, HiveParserKW_UNMANAGED, HiveParserKW_UNSET, HiveParserKW_UNSIGNED, HiveParserKW_URI, HiveParserKW_URL, HiveParserKW_USE, HiveParserKW_UTC, HiveParserKW_UTCTIMESTAMP, HiveParserKW_VALIDATE, HiveParserKW_VALUE_TYPE, HiveParserKW_VECTORIZATION, HiveParserKW_VIEW, HiveParserKW_VIEWS, HiveParserKW_WAIT, HiveParserKW_WEEK, HiveParserKW_WHILE, HiveParserKW_WITHIN, HiveParserKW_WORK, HiveParserKW_WORKLOAD, HiveParserKW_WRITE, HiveParserKW_YEAR, HiveParserKW_ZONE, HiveParserLPAREN, HiveParserPLUS, HiveParserMINUS, HiveParserSTAR, HiveParserTILDE, HiveParserQUESTION, HiveParserStringLiteral, HiveParserIntegralLiteral, HiveParserNumberLiteral, HiveParserNumber, HiveParserIdentifier, HiveParserCharSetName:



	default:
	}
	p.SetState(4409)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & -8415293117714037378) != 0) || ((int64((_la - 64)) & ^0x3f) == 0 && ((int64(1) << (_la - 64)) & -171163878771171435) != 0) || ((int64((_la - 132)) & ^0x3f) == 0 && ((int64(1) << (_la - 132)) & 9205050320105143587) != 0) || ((int64((_la - 196)) & ^0x3f) == 0 && ((int64(1) << (_la - 196)) & 4448221519167061869) != 0) || ((int64((_la - 261)) & ^0x3f) == 0 && ((int64(1) << (_la - 261)) & 8484709125765410815) != 0) || ((int64((_la - 326)) & ^0x3f) == 0 && ((int64(1) << (_la - 326)) & 1224028420243305391) != 0) || ((int64((_la - 400)) & ^0x3f) == 0 && ((int64(1) << (_la - 400)) & 971847) != 0) {
		{
			p.SetState(4408)

			var _x = p.SelectExpression()


			localctx.(*TrimFunctionContext).trim_characters = _x
		}

	}
	{
		p.SetState(4411)
		p.Match(HiveParserKW_FROM)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4412)

		var _x = p.SelectExpression()


		localctx.(*TrimFunctionContext).str = _x
	}
	{
		p.SetState(4413)
		p.Match(HiveParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFunction_Context is an interface to support dynamic dispatch.
type IFunction_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetStar returns the star token.
	GetStar() antlr.Token 

	// GetWithin returns the within token.
	GetWithin() antlr.Token 


	// SetStar sets the star token.
	SetStar(antlr.Token) 

	// SetWithin sets the within token.
	SetWithin(antlr.Token) 


	// GetDist returns the dist rule contexts.
	GetDist() IAll_distinctContext

	// GetOrdBy returns the ordBy rule contexts.
	GetOrdBy() IOrderByClauseContext

	// GetNt returns the nt rule contexts.
	GetNt() INull_treatmentContext

	// GetWs returns the ws rule contexts.
	GetWs() IWindow_specificationContext


	// SetDist sets the dist rule contexts.
	SetDist(IAll_distinctContext)

	// SetOrdBy sets the ordBy rule contexts.
	SetOrdBy(IOrderByClauseContext)

	// SetNt sets the nt rule contexts.
	SetNt(INull_treatmentContext)

	// SetWs sets the ws rule contexts.
	SetWs(IWindow_specificationContext)


	// Getter signatures
	TrimFunction() ITrimFunctionContext
	FunctionName() IFunctionNameContext
	AllLPAREN() []antlr.TerminalNode
	LPAREN(i int) antlr.TerminalNode
	AllRPAREN() []antlr.TerminalNode
	RPAREN(i int) antlr.TerminalNode
	KW_GROUP() antlr.TerminalNode
	KW_OVER() antlr.TerminalNode
	STAR() antlr.TerminalNode
	KW_WITHIN() antlr.TerminalNode
	OrderByClause() IOrderByClauseContext
	Window_specification() IWindow_specificationContext
	Null_treatment() INull_treatmentContext
	AllSelectExpression() []ISelectExpressionContext
	SelectExpression(i int) ISelectExpressionContext
	All_distinct() IAll_distinctContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsFunction_Context differentiates from other interfaces.
	IsFunction_Context()
}

type Function_Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	star antlr.Token
	dist IAll_distinctContext 
	within antlr.Token
	ordBy IOrderByClauseContext 
	nt INull_treatmentContext 
	ws IWindow_specificationContext 
}

func NewEmptyFunction_Context() *Function_Context {
	var p = new(Function_Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_function_
	return p
}

func InitEmptyFunction_Context(p *Function_Context)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_function_
}

func (*Function_Context) IsFunction_Context() {}

func NewFunction_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_Context {
	var p = new(Function_Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_function_

	return p
}

func (s *Function_Context) GetParser() antlr.Parser { return s.parser }

func (s *Function_Context) GetStar() antlr.Token { return s.star }

func (s *Function_Context) GetWithin() antlr.Token { return s.within }


func (s *Function_Context) SetStar(v antlr.Token) { s.star = v }

func (s *Function_Context) SetWithin(v antlr.Token) { s.within = v }


func (s *Function_Context) GetDist() IAll_distinctContext { return s.dist }

func (s *Function_Context) GetOrdBy() IOrderByClauseContext { return s.ordBy }

func (s *Function_Context) GetNt() INull_treatmentContext { return s.nt }

func (s *Function_Context) GetWs() IWindow_specificationContext { return s.ws }


func (s *Function_Context) SetDist(v IAll_distinctContext) { s.dist = v }

func (s *Function_Context) SetOrdBy(v IOrderByClauseContext) { s.ordBy = v }

func (s *Function_Context) SetNt(v INull_treatmentContext) { s.nt = v }

func (s *Function_Context) SetWs(v IWindow_specificationContext) { s.ws = v }


func (s *Function_Context) TrimFunction() ITrimFunctionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITrimFunctionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITrimFunctionContext)
}

func (s *Function_Context) FunctionName() IFunctionNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionNameContext)
}

func (s *Function_Context) AllLPAREN() []antlr.TerminalNode {
	return s.GetTokens(HiveParserLPAREN)
}

func (s *Function_Context) LPAREN(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserLPAREN, i)
}

func (s *Function_Context) AllRPAREN() []antlr.TerminalNode {
	return s.GetTokens(HiveParserRPAREN)
}

func (s *Function_Context) RPAREN(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserRPAREN, i)
}

func (s *Function_Context) KW_GROUP() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_GROUP, 0)
}

func (s *Function_Context) KW_OVER() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_OVER, 0)
}

func (s *Function_Context) STAR() antlr.TerminalNode {
	return s.GetToken(HiveParserSTAR, 0)
}

func (s *Function_Context) KW_WITHIN() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_WITHIN, 0)
}

func (s *Function_Context) OrderByClause() IOrderByClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByClauseContext)
}

func (s *Function_Context) Window_specification() IWindow_specificationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindow_specificationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindow_specificationContext)
}

func (s *Function_Context) Null_treatment() INull_treatmentContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INull_treatmentContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INull_treatmentContext)
}

func (s *Function_Context) AllSelectExpression() []ISelectExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelectExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISelectExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelectExpressionContext); ok {
			tst[i] = t.(ISelectExpressionContext)
			i++
		}
	}

	return tst
}

func (s *Function_Context) SelectExpression(i int) ISelectExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectExpressionContext)
}

func (s *Function_Context) All_distinct() IAll_distinctContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAll_distinctContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAll_distinctContext)
}

func (s *Function_Context) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(HiveParserCOMMA)
}

func (s *Function_Context) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserCOMMA, i)
}

func (s *Function_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Function_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterFunction_(s)
	}
}

func (s *Function_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitFunction_(s)
	}
}

func (s *Function_Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitFunction_(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) Function_() (localctx IFunction_Context) {
	localctx = NewFunction_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 752, HiveParserRULE_function_)
	var _la int

	p.SetState(4455)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 532, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4415)
			p.TrimFunction()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4416)
			p.FunctionName()
		}
		{
			p.SetState(4417)
			p.Match(HiveParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(4432)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 529, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(4418)

				var _m = p.Match(HiveParserSTAR)

				localctx.(*Function_Context).star = _m
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


		case 2:
			p.SetState(4420)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == HiveParserKW_ALL || _la == HiveParserKW_DISTINCT {
				{
					p.SetState(4419)

					var _x = p.All_distinct()


					localctx.(*Function_Context).dist = _x
				}

			}
			p.SetState(4430)
			p.GetErrorHandler().Sync(p)


			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 528, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(4422)
					p.SelectExpression()
				}
				p.SetState(4427)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)


				for _la == HiveParserCOMMA {
					{
						p.SetState(4423)
						p.Match(HiveParserCOMMA)
						if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
						}
					}
					{
						p.SetState(4424)
						p.SelectExpression()
					}


					p.SetState(4429)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
				    	goto errorExit
				    }
					_la = p.GetTokenStream().LA(1)
				}

				} else if p.HasError() { // JIM
					goto errorExit
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		p.SetState(4453)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 531, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(4434)
				p.Match(HiveParserRPAREN)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(4435)

				var _m = p.Match(HiveParserKW_WITHIN)

				localctx.(*Function_Context).within = _m
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(4436)
				p.Match(HiveParserKW_GROUP)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(4437)
				p.Match(HiveParserLPAREN)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(4438)

				var _x = p.OrderByClause()


				localctx.(*Function_Context).ordBy = _x
			}
			{
				p.SetState(4439)
				p.Match(HiveParserRPAREN)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


		case 2:
			{
				p.SetState(4441)
				p.Match(HiveParserRPAREN)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			p.SetState(4443)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == HiveParserKW_IGNORE || _la == HiveParserKW_RESPECT {
				{
					p.SetState(4442)

					var _x = p.Null_treatment()


					localctx.(*Function_Context).nt = _x
				}

			}
			{
				p.SetState(4445)
				p.Match(HiveParserKW_OVER)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(4446)

				var _x = p.Window_specification()


				localctx.(*Function_Context).ws = _x
			}


		case 3:
			{
				p.SetState(4447)

				var _x = p.Null_treatment()


				localctx.(*Function_Context).nt = _x
			}
			{
				p.SetState(4448)
				p.Match(HiveParserRPAREN)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(4449)
				p.Match(HiveParserKW_OVER)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(4450)

				var _x = p.Window_specification()


				localctx.(*Function_Context).ws = _x
			}


		case 4:
			{
				p.SetState(4452)
				p.Match(HiveParserRPAREN)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// INull_treatmentContext is an interface to support dynamic dispatch.
type INull_treatmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_RESPECT() antlr.TerminalNode
	KW_NULLS() antlr.TerminalNode
	KW_IGNORE() antlr.TerminalNode

	// IsNull_treatmentContext differentiates from other interfaces.
	IsNull_treatmentContext()
}

type Null_treatmentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNull_treatmentContext() *Null_treatmentContext {
	var p = new(Null_treatmentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_null_treatment
	return p
}

func InitEmptyNull_treatmentContext(p *Null_treatmentContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_null_treatment
}

func (*Null_treatmentContext) IsNull_treatmentContext() {}

func NewNull_treatmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Null_treatmentContext {
	var p = new(Null_treatmentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_null_treatment

	return p
}

func (s *Null_treatmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Null_treatmentContext) KW_RESPECT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_RESPECT, 0)
}

func (s *Null_treatmentContext) KW_NULLS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_NULLS, 0)
}

func (s *Null_treatmentContext) KW_IGNORE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_IGNORE, 0)
}

func (s *Null_treatmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Null_treatmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Null_treatmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterNull_treatment(s)
	}
}

func (s *Null_treatmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitNull_treatment(s)
	}
}

func (s *Null_treatmentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitNull_treatment(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) Null_treatment() (localctx INull_treatmentContext) {
	localctx = NewNull_treatmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 754, HiveParserRULE_null_treatment)
	p.SetState(4461)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserKW_RESPECT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4457)
			p.Match(HiveParserKW_RESPECT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4458)
			p.Match(HiveParserKW_NULLS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HiveParserKW_IGNORE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4459)
			p.Match(HiveParserKW_IGNORE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4460)
			p.Match(HiveParserKW_NULLS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFunctionNameContext is an interface to support dynamic dispatch.
type IFunctionNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FunctionIdentifier() IFunctionIdentifierContext
	Sql11ReservedKeywordsUsedAsFunctionName() ISql11ReservedKeywordsUsedAsFunctionNameContext

	// IsFunctionNameContext differentiates from other interfaces.
	IsFunctionNameContext()
}

type FunctionNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionNameContext() *FunctionNameContext {
	var p = new(FunctionNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_functionName
	return p
}

func InitEmptyFunctionNameContext(p *FunctionNameContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_functionName
}

func (*FunctionNameContext) IsFunctionNameContext() {}

func NewFunctionNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionNameContext {
	var p = new(FunctionNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_functionName

	return p
}

func (s *FunctionNameContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionNameContext) FunctionIdentifier() IFunctionIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionIdentifierContext)
}

func (s *FunctionNameContext) Sql11ReservedKeywordsUsedAsFunctionName() ISql11ReservedKeywordsUsedAsFunctionNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql11ReservedKeywordsUsedAsFunctionNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql11ReservedKeywordsUsedAsFunctionNameContext)
}

func (s *FunctionNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *FunctionNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterFunctionName(s)
	}
}

func (s *FunctionNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitFunctionName(s)
	}
}

func (s *FunctionNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitFunctionName(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) FunctionName() (localctx IFunctionNameContext) {
	localctx = NewFunctionNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 756, HiveParserRULE_functionName)
	p.SetState(4465)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserKW_ABORT, HiveParserKW_ACTIVATE, HiveParserKW_ACTIVE, HiveParserKW_ADD, HiveParserKW_ADMIN, HiveParserKW_AFTER, HiveParserKW_ALLOC_FRACTION, HiveParserKW_ANALYZE, HiveParserKW_ARCHIVE, HiveParserKW_ASC, HiveParserKW_AST, HiveParserKW_AT, HiveParserKW_AUTOCOMMIT, HiveParserKW_BATCH, HiveParserKW_BEFORE, HiveParserKW_BUCKET, HiveParserKW_BUCKETS, HiveParserKW_CACHE, HiveParserKW_CASCADE, HiveParserKW_CBO, HiveParserKW_CHANGE, HiveParserKW_CHECK, HiveParserKW_CLUSTER, HiveParserKW_CLUSTERED, HiveParserKW_CLUSTERSTATUS, HiveParserKW_COLLECTION, HiveParserKW_COLUMNS, HiveParserKW_COMMENT, HiveParserKW_COMPACT, HiveParserKW_COMPACTIONS, HiveParserKW_COMPUTE, HiveParserKW_CONCATENATE, HiveParserKW_CONTINUE, HiveParserKW_COST, HiveParserKW_CRON, HiveParserKW_DATA, HiveParserKW_DATABASES, HiveParserKW_DATETIME, HiveParserKW_DAY, HiveParserKW_DAYOFWEEK, HiveParserKW_DBPROPERTIES, HiveParserKW_DCPROPERTIES, HiveParserKW_DEBUG, HiveParserKW_DEFAULT, HiveParserKW_DEFERRED, HiveParserKW_DEFINED, HiveParserKW_DELIMITED, HiveParserKW_DEPENDENCY, HiveParserKW_DESC, HiveParserKW_DETAIL, HiveParserKW_DIRECTORIES, HiveParserKW_DIRECTORY, HiveParserKW_DISABLE, HiveParserKW_DISTRIBUTE, HiveParserKW_DISTRIBUTED, HiveParserKW_DO, HiveParserKW_DOW, HiveParserKW_DUMP, HiveParserKW_ELEM_TYPE, HiveParserKW_ENABLE, HiveParserKW_ENFORCED, HiveParserKW_ESCAPED, HiveParserKW_EVERY, HiveParserKW_EXCLUSIVE, HiveParserKW_EXECUTE, HiveParserKW_EXECUTED, HiveParserKW_EXPIRE_SNAPSHOTS, HiveParserKW_EXPLAIN, HiveParserKW_EXPORT, HiveParserKW_EXPRESSION, HiveParserKW_FIELDS, HiveParserKW_FILE, HiveParserKW_FILEFORMAT, HiveParserKW_FIRST, HiveParserKW_FORMAT, HiveParserKW_FORMATTED, HiveParserKW_FUNCTIONS, HiveParserKW_HOLD_DDLTIME, HiveParserKW_HOUR, HiveParserKW_IDXPROPERTIES, HiveParserKW_IGNORE, HiveParserKW_INDEX, HiveParserKW_INDEXES, HiveParserKW_INPATH, HiveParserKW_INPUTDRIVER, HiveParserKW_INPUTFORMAT, HiveParserKW_ISOLATION, HiveParserKW_ITEMS, HiveParserKW_JAR, HiveParserKW_JOINCOST, HiveParserKW_KEY, HiveParserKW_KEYS, HiveParserKW_KEY_TYPE, HiveParserKW_KILL, HiveParserKW_LAST, HiveParserKW_LEVEL, HiveParserKW_LIMIT, HiveParserKW_LINES, HiveParserKW_LOAD, HiveParserKW_LOCATION, HiveParserKW_LOCK, HiveParserKW_LOCKS, HiveParserKW_LOGICAL, HiveParserKW_LONG, HiveParserKW_MANAGED, HiveParserKW_MANAGEDLOCATION, HiveParserKW_MANAGEMENT, HiveParserKW_MAPJOIN, HiveParserKW_MAPPING, HiveParserKW_MATCHED, HiveParserKW_MATERIALIZED, HiveParserKW_METADATA, HiveParserKW_MINUTE, HiveParserKW_MONTH, HiveParserKW_MOVE, HiveParserKW_MSCK, HiveParserKW_NORELY, HiveParserKW_NOSCAN, HiveParserKW_NOVALIDATE, HiveParserKW_NO_DROP, HiveParserKW_NULLS, HiveParserKW_OFFLINE, HiveParserKW_OFFSET, HiveParserKW_OPERATOR, HiveParserKW_OPTION, HiveParserKW_OUTPUTDRIVER, HiveParserKW_OUTPUTFORMAT, HiveParserKW_OVERWRITE, HiveParserKW_OWNER, HiveParserKW_PARTITIONED, HiveParserKW_PARTITIONS, HiveParserKW_PATH, HiveParserKW_PLAN, HiveParserKW_PLANS, HiveParserKW_PLUS, HiveParserKW_POOL, HiveParserKW_PRINCIPALS, HiveParserKW_PROTECTION, HiveParserKW_PURGE, HiveParserKW_QUARTER, HiveParserKW_QUERY, HiveParserKW_QUERY_PARALLELISM, HiveParserKW_READ, HiveParserKW_READONLY, HiveParserKW_REBUILD, HiveParserKW_RECORDREADER, HiveParserKW_RECORDWRITER, HiveParserKW_RELOAD, HiveParserKW_RELY, HiveParserKW_REMOTE, HiveParserKW_RENAME, HiveParserKW_REOPTIMIZATION, HiveParserKW_REPAIR, HiveParserKW_REPL, HiveParserKW_REPLACE, HiveParserKW_REPLICATION, HiveParserKW_RESOURCE, HiveParserKW_RESPECT, HiveParserKW_RESTRICT, HiveParserKW_REWRITE, HiveParserKW_ROLE, HiveParserKW_ROLES, HiveParserKW_SCHEDULED, HiveParserKW_SCHEDULING_POLICY, HiveParserKW_SCHEMA, HiveParserKW_SCHEMAS, HiveParserKW_SECOND, HiveParserKW_SEMI, HiveParserKW_SERDE, HiveParserKW_SERDEPROPERTIES, HiveParserKW_SERVER, HiveParserKW_SETS, HiveParserKW_SET_CURRENT_SNAPSHOT, HiveParserKW_SHARED, HiveParserKW_SHOW, HiveParserKW_SHOW_DATABASE, HiveParserKW_SKEWED, HiveParserKW_SNAPSHOT, HiveParserKW_SORT, HiveParserKW_SORTED, HiveParserKW_SPEC, HiveParserKW_SSL, HiveParserKW_STATISTICS, HiveParserKW_STATUS, HiveParserKW_STORED, HiveParserKW_STREAMTABLE, HiveParserKW_STRING, HiveParserKW_STRUCT, HiveParserKW_SUMMARY, HiveParserKW_SYSTEM_TIME, HiveParserKW_SYSTEM_VERSION, HiveParserKW_TABLES, HiveParserKW_TBLPROPERTIES, HiveParserKW_TEMPORARY, HiveParserKW_TERMINATED, HiveParserKW_TIMESTAMPTZ, HiveParserKW_TINYINT, HiveParserKW_TOUCH, HiveParserKW_TRANSACTION, HiveParserKW_TRANSACTIONAL, HiveParserKW_TRANSACTIONS, HiveParserKW_TRIM, HiveParserKW_TYPE, HiveParserKW_UNARCHIVE, HiveParserKW_UNDO, HiveParserKW_UNIONTYPE, HiveParserKW_UNKNOWN, HiveParserKW_UNLOCK, HiveParserKW_UNMANAGED, HiveParserKW_UNSET, HiveParserKW_UNSIGNED, HiveParserKW_URI, HiveParserKW_URL, HiveParserKW_USE, HiveParserKW_UTC, HiveParserKW_UTCTIMESTAMP, HiveParserKW_VALIDATE, HiveParserKW_VALUE_TYPE, HiveParserKW_VECTORIZATION, HiveParserKW_VIEW, HiveParserKW_VIEWS, HiveParserKW_WAIT, HiveParserKW_WEEK, HiveParserKW_WHILE, HiveParserKW_WITHIN, HiveParserKW_WORK, HiveParserKW_WORKLOAD, HiveParserKW_WRITE, HiveParserKW_YEAR, HiveParserKW_ZONE, HiveParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4463)
			p.FunctionIdentifier()
		}


	case HiveParserKW_ARRAY, HiveParserKW_BIGINT, HiveParserKW_BINARY, HiveParserKW_BOOLEAN, HiveParserKW_CURRENT_DATE, HiveParserKW_CURRENT_TIMESTAMP, HiveParserKW_DATE, HiveParserKW_DOUBLE, HiveParserKW_FLOAT, HiveParserKW_GROUPING, HiveParserKW_IF, HiveParserKW_INT, HiveParserKW_MAP, HiveParserKW_REAL, HiveParserKW_SMALLINT, HiveParserKW_TIMESTAMP:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4464)
			p.Sql11ReservedKeywordsUsedAsFunctionName()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICastExpressionContext is an interface to support dynamic dispatch.
type ICastExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFmt returns the fmt token.
	GetFmt() antlr.Token 


	// SetFmt sets the fmt token.
	SetFmt(antlr.Token) 


	// GetToType returns the toType rule contexts.
	GetToType() IPrimitiveTypeContext


	// SetToType sets the toType rule contexts.
	SetToType(IPrimitiveTypeContext)


	// Getter signatures
	KW_CAST() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Expression() IExpressionContext
	KW_AS() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	PrimitiveType() IPrimitiveTypeContext
	StringLiteral() antlr.TerminalNode
	KW_FORMAT() antlr.TerminalNode

	// IsCastExpressionContext differentiates from other interfaces.
	IsCastExpressionContext()
}

type CastExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	toType IPrimitiveTypeContext 
	fmt antlr.Token
}

func NewEmptyCastExpressionContext() *CastExpressionContext {
	var p = new(CastExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_castExpression
	return p
}

func InitEmptyCastExpressionContext(p *CastExpressionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_castExpression
}

func (*CastExpressionContext) IsCastExpressionContext() {}

func NewCastExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CastExpressionContext {
	var p = new(CastExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_castExpression

	return p
}

func (s *CastExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *CastExpressionContext) GetFmt() antlr.Token { return s.fmt }


func (s *CastExpressionContext) SetFmt(v antlr.Token) { s.fmt = v }


func (s *CastExpressionContext) GetToType() IPrimitiveTypeContext { return s.toType }


func (s *CastExpressionContext) SetToType(v IPrimitiveTypeContext) { s.toType = v }


func (s *CastExpressionContext) KW_CAST() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_CAST, 0)
}

func (s *CastExpressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserLPAREN, 0)
}

func (s *CastExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CastExpressionContext) KW_AS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_AS, 0)
}

func (s *CastExpressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserRPAREN, 0)
}

func (s *CastExpressionContext) PrimitiveType() IPrimitiveTypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimitiveTypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimitiveTypeContext)
}

func (s *CastExpressionContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(HiveParserStringLiteral, 0)
}

func (s *CastExpressionContext) KW_FORMAT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_FORMAT, 0)
}

func (s *CastExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CastExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterCastExpression(s)
	}
}

func (s *CastExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitCastExpression(s)
	}
}

func (s *CastExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitCastExpression(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) CastExpression() (localctx ICastExpressionContext) {
	localctx = NewCastExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 758, HiveParserRULE_castExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4467)
		p.Match(HiveParserKW_CAST)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4468)
		p.Match(HiveParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4469)
		p.Expression()
	}
	{
		p.SetState(4470)
		p.Match(HiveParserKW_AS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4471)

		var _x = p.PrimitiveType()


		localctx.(*CastExpressionContext).toType = _x
	}
	p.SetState(4474)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_FORMAT {
		{
			p.SetState(4472)

			var _m = p.Match(HiveParserKW_FORMAT)

			localctx.(*CastExpressionContext).fmt = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4473)
			p.Match(HiveParserStringLiteral)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(4476)
		p.Match(HiveParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICaseExpressionContext is an interface to support dynamic dispatch.
type ICaseExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_CASE() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	KW_END() antlr.TerminalNode
	AllKW_WHEN() []antlr.TerminalNode
	KW_WHEN(i int) antlr.TerminalNode
	AllKW_THEN() []antlr.TerminalNode
	KW_THEN(i int) antlr.TerminalNode
	KW_ELSE() antlr.TerminalNode

	// IsCaseExpressionContext differentiates from other interfaces.
	IsCaseExpressionContext()
}

type CaseExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseExpressionContext() *CaseExpressionContext {
	var p = new(CaseExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_caseExpression
	return p
}

func InitEmptyCaseExpressionContext(p *CaseExpressionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_caseExpression
}

func (*CaseExpressionContext) IsCaseExpressionContext() {}

func NewCaseExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseExpressionContext {
	var p = new(CaseExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_caseExpression

	return p
}

func (s *CaseExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseExpressionContext) KW_CASE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_CASE, 0)
}

func (s *CaseExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *CaseExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CaseExpressionContext) KW_END() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_END, 0)
}

func (s *CaseExpressionContext) AllKW_WHEN() []antlr.TerminalNode {
	return s.GetTokens(HiveParserKW_WHEN)
}

func (s *CaseExpressionContext) KW_WHEN(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserKW_WHEN, i)
}

func (s *CaseExpressionContext) AllKW_THEN() []antlr.TerminalNode {
	return s.GetTokens(HiveParserKW_THEN)
}

func (s *CaseExpressionContext) KW_THEN(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserKW_THEN, i)
}

func (s *CaseExpressionContext) KW_ELSE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ELSE, 0)
}

func (s *CaseExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CaseExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterCaseExpression(s)
	}
}

func (s *CaseExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitCaseExpression(s)
	}
}

func (s *CaseExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitCaseExpression(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) CaseExpression() (localctx ICaseExpressionContext) {
	localctx = NewCaseExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 760, HiveParserRULE_caseExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4478)
		p.Match(HiveParserKW_CASE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4479)
		p.Expression()
	}
	p.SetState(4485)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for ok := true; ok; ok = _la == HiveParserKW_WHEN {
		{
			p.SetState(4480)
			p.Match(HiveParserKW_WHEN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4481)
			p.Expression()
		}
		{
			p.SetState(4482)
			p.Match(HiveParserKW_THEN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4483)
			p.Expression()
		}


		p.SetState(4487)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(4491)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_ELSE {
		{
			p.SetState(4489)
			p.Match(HiveParserKW_ELSE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4490)
			p.Expression()
		}

	}
	{
		p.SetState(4493)
		p.Match(HiveParserKW_END)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IWhenExpressionContext is an interface to support dynamic dispatch.
type IWhenExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_CASE() antlr.TerminalNode
	KW_END() antlr.TerminalNode
	AllKW_WHEN() []antlr.TerminalNode
	KW_WHEN(i int) antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllKW_THEN() []antlr.TerminalNode
	KW_THEN(i int) antlr.TerminalNode
	KW_ELSE() antlr.TerminalNode

	// IsWhenExpressionContext differentiates from other interfaces.
	IsWhenExpressionContext()
}

type WhenExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhenExpressionContext() *WhenExpressionContext {
	var p = new(WhenExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_whenExpression
	return p
}

func InitEmptyWhenExpressionContext(p *WhenExpressionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_whenExpression
}

func (*WhenExpressionContext) IsWhenExpressionContext() {}

func NewWhenExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhenExpressionContext {
	var p = new(WhenExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_whenExpression

	return p
}

func (s *WhenExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *WhenExpressionContext) KW_CASE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_CASE, 0)
}

func (s *WhenExpressionContext) KW_END() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_END, 0)
}

func (s *WhenExpressionContext) AllKW_WHEN() []antlr.TerminalNode {
	return s.GetTokens(HiveParserKW_WHEN)
}

func (s *WhenExpressionContext) KW_WHEN(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserKW_WHEN, i)
}

func (s *WhenExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *WhenExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhenExpressionContext) AllKW_THEN() []antlr.TerminalNode {
	return s.GetTokens(HiveParserKW_THEN)
}

func (s *WhenExpressionContext) KW_THEN(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserKW_THEN, i)
}

func (s *WhenExpressionContext) KW_ELSE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ELSE, 0)
}

func (s *WhenExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *WhenExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterWhenExpression(s)
	}
}

func (s *WhenExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitWhenExpression(s)
	}
}

func (s *WhenExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitWhenExpression(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) WhenExpression() (localctx IWhenExpressionContext) {
	localctx = NewWhenExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 762, HiveParserRULE_whenExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4495)
		p.Match(HiveParserKW_CASE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(4501)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for ok := true; ok; ok = _la == HiveParserKW_WHEN {
		{
			p.SetState(4496)
			p.Match(HiveParserKW_WHEN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4497)
			p.Expression()
		}
		{
			p.SetState(4498)
			p.Match(HiveParserKW_THEN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4499)
			p.Expression()
		}


		p.SetState(4503)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(4507)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_ELSE {
		{
			p.SetState(4505)
			p.Match(HiveParserKW_ELSE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4506)
			p.Expression()
		}

	}
	{
		p.SetState(4509)
		p.Match(HiveParserKW_END)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFloorExpressionContext is an interface to support dynamic dispatch.
type IFloorExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFloorUnit returns the floorUnit rule contexts.
	GetFloorUnit() IFloorDateQualifiersContext


	// SetFloorUnit sets the floorUnit rule contexts.
	SetFloorUnit(IFloorDateQualifiersContext)


	// Getter signatures
	KW_FLOOR() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Expression() IExpressionContext
	RPAREN() antlr.TerminalNode
	KW_TO() antlr.TerminalNode
	FloorDateQualifiers() IFloorDateQualifiersContext

	// IsFloorExpressionContext differentiates from other interfaces.
	IsFloorExpressionContext()
}

type FloorExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	floorUnit IFloorDateQualifiersContext 
}

func NewEmptyFloorExpressionContext() *FloorExpressionContext {
	var p = new(FloorExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_floorExpression
	return p
}

func InitEmptyFloorExpressionContext(p *FloorExpressionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_floorExpression
}

func (*FloorExpressionContext) IsFloorExpressionContext() {}

func NewFloorExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FloorExpressionContext {
	var p = new(FloorExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_floorExpression

	return p
}

func (s *FloorExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *FloorExpressionContext) GetFloorUnit() IFloorDateQualifiersContext { return s.floorUnit }


func (s *FloorExpressionContext) SetFloorUnit(v IFloorDateQualifiersContext) { s.floorUnit = v }


func (s *FloorExpressionContext) KW_FLOOR() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_FLOOR, 0)
}

func (s *FloorExpressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserLPAREN, 0)
}

func (s *FloorExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FloorExpressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserRPAREN, 0)
}

func (s *FloorExpressionContext) KW_TO() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TO, 0)
}

func (s *FloorExpressionContext) FloorDateQualifiers() IFloorDateQualifiersContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFloorDateQualifiersContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFloorDateQualifiersContext)
}

func (s *FloorExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FloorExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *FloorExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterFloorExpression(s)
	}
}

func (s *FloorExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitFloorExpression(s)
	}
}

func (s *FloorExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitFloorExpression(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) FloorExpression() (localctx IFloorExpressionContext) {
	localctx = NewFloorExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 764, HiveParserRULE_floorExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4511)
		p.Match(HiveParserKW_FLOOR)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4512)
		p.Match(HiveParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4513)
		p.Expression()
	}
	p.SetState(4516)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_TO {
		{
			p.SetState(4514)
			p.Match(HiveParserKW_TO)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4515)

			var _x = p.FloorDateQualifiers()


			localctx.(*FloorExpressionContext).floorUnit = _x
		}

	}
	{
		p.SetState(4518)
		p.Match(HiveParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFloorDateQualifiersContext is an interface to support dynamic dispatch.
type IFloorDateQualifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_YEAR() antlr.TerminalNode
	KW_QUARTER() antlr.TerminalNode
	KW_MONTH() antlr.TerminalNode
	KW_WEEK() antlr.TerminalNode
	KW_DAY() antlr.TerminalNode
	KW_HOUR() antlr.TerminalNode
	KW_MINUTE() antlr.TerminalNode
	KW_SECOND() antlr.TerminalNode

	// IsFloorDateQualifiersContext differentiates from other interfaces.
	IsFloorDateQualifiersContext()
}

type FloorDateQualifiersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFloorDateQualifiersContext() *FloorDateQualifiersContext {
	var p = new(FloorDateQualifiersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_floorDateQualifiers
	return p
}

func InitEmptyFloorDateQualifiersContext(p *FloorDateQualifiersContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_floorDateQualifiers
}

func (*FloorDateQualifiersContext) IsFloorDateQualifiersContext() {}

func NewFloorDateQualifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FloorDateQualifiersContext {
	var p = new(FloorDateQualifiersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_floorDateQualifiers

	return p
}

func (s *FloorDateQualifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *FloorDateQualifiersContext) KW_YEAR() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_YEAR, 0)
}

func (s *FloorDateQualifiersContext) KW_QUARTER() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_QUARTER, 0)
}

func (s *FloorDateQualifiersContext) KW_MONTH() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_MONTH, 0)
}

func (s *FloorDateQualifiersContext) KW_WEEK() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_WEEK, 0)
}

func (s *FloorDateQualifiersContext) KW_DAY() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DAY, 0)
}

func (s *FloorDateQualifiersContext) KW_HOUR() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_HOUR, 0)
}

func (s *FloorDateQualifiersContext) KW_MINUTE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_MINUTE, 0)
}

func (s *FloorDateQualifiersContext) KW_SECOND() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SECOND, 0)
}

func (s *FloorDateQualifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FloorDateQualifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *FloorDateQualifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterFloorDateQualifiers(s)
	}
}

func (s *FloorDateQualifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitFloorDateQualifiers(s)
	}
}

func (s *FloorDateQualifiersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitFloorDateQualifiers(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) FloorDateQualifiers() (localctx IFloorDateQualifiersContext) {
	localctx = NewFloorDateQualifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 766, HiveParserRULE_floorDateQualifiers)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4520)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HiveParserKW_DAY || ((int64((_la - 143)) & ^0x3f) == 0 && ((int64(1) << (_la - 143)) & 108086391056891905) != 0) || _la == HiveParserKW_QUARTER || _la == HiveParserKW_SECOND || _la == HiveParserKW_WEEK || _la == HiveParserKW_YEAR) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExtractExpressionContext is an interface to support dynamic dispatch.
type IExtractExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTimeUnit returns the timeUnit rule contexts.
	GetTimeUnit() ITimeQualifiersContext


	// SetTimeUnit sets the timeUnit rule contexts.
	SetTimeUnit(ITimeQualifiersContext)


	// Getter signatures
	KW_EXTRACT() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	KW_FROM() antlr.TerminalNode
	Expression() IExpressionContext
	RPAREN() antlr.TerminalNode
	TimeQualifiers() ITimeQualifiersContext

	// IsExtractExpressionContext differentiates from other interfaces.
	IsExtractExpressionContext()
}

type ExtractExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	timeUnit ITimeQualifiersContext 
}

func NewEmptyExtractExpressionContext() *ExtractExpressionContext {
	var p = new(ExtractExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_extractExpression
	return p
}

func InitEmptyExtractExpressionContext(p *ExtractExpressionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_extractExpression
}

func (*ExtractExpressionContext) IsExtractExpressionContext() {}

func NewExtractExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtractExpressionContext {
	var p = new(ExtractExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_extractExpression

	return p
}

func (s *ExtractExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtractExpressionContext) GetTimeUnit() ITimeQualifiersContext { return s.timeUnit }


func (s *ExtractExpressionContext) SetTimeUnit(v ITimeQualifiersContext) { s.timeUnit = v }


func (s *ExtractExpressionContext) KW_EXTRACT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_EXTRACT, 0)
}

func (s *ExtractExpressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserLPAREN, 0)
}

func (s *ExtractExpressionContext) KW_FROM() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_FROM, 0)
}

func (s *ExtractExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExtractExpressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserRPAREN, 0)
}

func (s *ExtractExpressionContext) TimeQualifiers() ITimeQualifiersContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITimeQualifiersContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITimeQualifiersContext)
}

func (s *ExtractExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtractExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ExtractExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterExtractExpression(s)
	}
}

func (s *ExtractExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitExtractExpression(s)
	}
}

func (s *ExtractExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitExtractExpression(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ExtractExpression() (localctx IExtractExpressionContext) {
	localctx = NewExtractExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 768, HiveParserRULE_extractExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4522)
		p.Match(HiveParserKW_EXTRACT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4523)
		p.Match(HiveParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4524)

		var _x = p.TimeQualifiers()


		localctx.(*ExtractExpressionContext).timeUnit = _x
	}
	{
		p.SetState(4525)
		p.Match(HiveParserKW_FROM)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4526)
		p.Expression()
	}
	{
		p.SetState(4527)
		p.Match(HiveParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITimeQualifiersContext is an interface to support dynamic dispatch.
type ITimeQualifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_YEAR() antlr.TerminalNode
	KW_QUARTER() antlr.TerminalNode
	KW_MONTH() antlr.TerminalNode
	KW_WEEK() antlr.TerminalNode
	KW_DAY() antlr.TerminalNode
	KW_DOW() antlr.TerminalNode
	KW_HOUR() antlr.TerminalNode
	KW_MINUTE() antlr.TerminalNode
	KW_SECOND() antlr.TerminalNode

	// IsTimeQualifiersContext differentiates from other interfaces.
	IsTimeQualifiersContext()
}

type TimeQualifiersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTimeQualifiersContext() *TimeQualifiersContext {
	var p = new(TimeQualifiersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_timeQualifiers
	return p
}

func InitEmptyTimeQualifiersContext(p *TimeQualifiersContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_timeQualifiers
}

func (*TimeQualifiersContext) IsTimeQualifiersContext() {}

func NewTimeQualifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TimeQualifiersContext {
	var p = new(TimeQualifiersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_timeQualifiers

	return p
}

func (s *TimeQualifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *TimeQualifiersContext) KW_YEAR() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_YEAR, 0)
}

func (s *TimeQualifiersContext) KW_QUARTER() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_QUARTER, 0)
}

func (s *TimeQualifiersContext) KW_MONTH() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_MONTH, 0)
}

func (s *TimeQualifiersContext) KW_WEEK() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_WEEK, 0)
}

func (s *TimeQualifiersContext) KW_DAY() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DAY, 0)
}

func (s *TimeQualifiersContext) KW_DOW() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DOW, 0)
}

func (s *TimeQualifiersContext) KW_HOUR() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_HOUR, 0)
}

func (s *TimeQualifiersContext) KW_MINUTE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_MINUTE, 0)
}

func (s *TimeQualifiersContext) KW_SECOND() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SECOND, 0)
}

func (s *TimeQualifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimeQualifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TimeQualifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterTimeQualifiers(s)
	}
}

func (s *TimeQualifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitTimeQualifiers(s)
	}
}

func (s *TimeQualifiersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitTimeQualifiers(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) TimeQualifiers() (localctx ITimeQualifiersContext) {
	localctx = NewTimeQualifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 770, HiveParserRULE_timeQualifiers)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4529)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HiveParserKW_DAY || _la == HiveParserKW_DOW || ((int64((_la - 143)) & ^0x3f) == 0 && ((int64(1) << (_la - 143)) & 108086391056891905) != 0) || _la == HiveParserKW_QUARTER || _la == HiveParserKW_SECOND || _la == HiveParserKW_WEEK || _la == HiveParserKW_YEAR) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IConstantContext is an interface to support dynamic dispatch.
type IConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IntervalLiteral() IIntervalLiteralContext
	Number() antlr.TerminalNode
	DateLiteral() IDateLiteralContext
	TimestampLiteral() ITimestampLiteralContext
	TimestampLocalTZLiteral() ITimestampLocalTZLiteralContext
	StringLiteral() antlr.TerminalNode
	StringLiteralSequence() IStringLiteralSequenceContext
	IntegralLiteral() antlr.TerminalNode
	NumberLiteral() antlr.TerminalNode
	CharSetStringLiteral() ICharSetStringLiteralContext
	BooleanValue() IBooleanValueContext
	KW_NULL() antlr.TerminalNode
	PrepareStmtParam() IPrepareStmtParamContext

	// IsConstantContext differentiates from other interfaces.
	IsConstantContext()
}

type ConstantContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstantContext() *ConstantContext {
	var p = new(ConstantContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_constant
	return p
}

func InitEmptyConstantContext(p *ConstantContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_constant
}

func (*ConstantContext) IsConstantContext() {}

func NewConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantContext {
	var p = new(ConstantContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_constant

	return p
}

func (s *ConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantContext) IntervalLiteral() IIntervalLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalLiteralContext)
}

func (s *ConstantContext) Number() antlr.TerminalNode {
	return s.GetToken(HiveParserNumber, 0)
}

func (s *ConstantContext) DateLiteral() IDateLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDateLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDateLiteralContext)
}

func (s *ConstantContext) TimestampLiteral() ITimestampLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITimestampLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITimestampLiteralContext)
}

func (s *ConstantContext) TimestampLocalTZLiteral() ITimestampLocalTZLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITimestampLocalTZLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITimestampLocalTZLiteralContext)
}

func (s *ConstantContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(HiveParserStringLiteral, 0)
}

func (s *ConstantContext) StringLiteralSequence() IStringLiteralSequenceContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralSequenceContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralSequenceContext)
}

func (s *ConstantContext) IntegralLiteral() antlr.TerminalNode {
	return s.GetToken(HiveParserIntegralLiteral, 0)
}

func (s *ConstantContext) NumberLiteral() antlr.TerminalNode {
	return s.GetToken(HiveParserNumberLiteral, 0)
}

func (s *ConstantContext) CharSetStringLiteral() ICharSetStringLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharSetStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharSetStringLiteralContext)
}

func (s *ConstantContext) BooleanValue() IBooleanValueContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanValueContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanValueContext)
}

func (s *ConstantContext) KW_NULL() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_NULL, 0)
}

func (s *ConstantContext) PrepareStmtParam() IPrepareStmtParamContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrepareStmtParamContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrepareStmtParamContext)
}

func (s *ConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ConstantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterConstant(s)
	}
}

func (s *ConstantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitConstant(s)
	}
}

func (s *ConstantContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitConstant(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) Constant() (localctx IConstantContext) {
	localctx = NewConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 772, HiveParserRULE_constant)
	p.SetState(4544)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 541, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4531)
			p.IntervalLiteral()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4532)
			p.Match(HiveParserNumber)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4533)
			p.DateLiteral()
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4534)
			p.TimestampLiteral()
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4535)
			p.TimestampLocalTZLiteral()
		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4536)
			p.Match(HiveParserStringLiteral)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(4537)
			p.StringLiteralSequence()
		}


	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(4538)
			p.Match(HiveParserIntegralLiteral)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(4539)
			p.Match(HiveParserNumberLiteral)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(4540)
			p.CharSetStringLiteral()
		}


	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(4541)
			p.BooleanValue()
		}


	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(4542)
			p.Match(HiveParserKW_NULL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(4543)
			p.PrepareStmtParam()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPrepareStmtParamContext is an interface to support dynamic dispatch.
type IPrepareStmtParamContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetP returns the p rule contexts.
	GetP() IParameterIdxContext


	// SetP sets the p rule contexts.
	SetP(IParameterIdxContext)


	// Getter signatures
	ParameterIdx() IParameterIdxContext

	// IsPrepareStmtParamContext differentiates from other interfaces.
	IsPrepareStmtParamContext()
}

type PrepareStmtParamContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	p IParameterIdxContext 
}

func NewEmptyPrepareStmtParamContext() *PrepareStmtParamContext {
	var p = new(PrepareStmtParamContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_prepareStmtParam
	return p
}

func InitEmptyPrepareStmtParamContext(p *PrepareStmtParamContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_prepareStmtParam
}

func (*PrepareStmtParamContext) IsPrepareStmtParamContext() {}

func NewPrepareStmtParamContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrepareStmtParamContext {
	var p = new(PrepareStmtParamContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_prepareStmtParam

	return p
}

func (s *PrepareStmtParamContext) GetParser() antlr.Parser { return s.parser }

func (s *PrepareStmtParamContext) GetP() IParameterIdxContext { return s.p }


func (s *PrepareStmtParamContext) SetP(v IParameterIdxContext) { s.p = v }


func (s *PrepareStmtParamContext) ParameterIdx() IParameterIdxContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterIdxContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterIdxContext)
}

func (s *PrepareStmtParamContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrepareStmtParamContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PrepareStmtParamContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterPrepareStmtParam(s)
	}
}

func (s *PrepareStmtParamContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitPrepareStmtParam(s)
	}
}

func (s *PrepareStmtParamContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitPrepareStmtParam(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) PrepareStmtParam() (localctx IPrepareStmtParamContext) {
	localctx = NewPrepareStmtParamContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 774, HiveParserRULE_prepareStmtParam)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4546)

		var _x = p.ParameterIdx()


		localctx.(*PrepareStmtParamContext).p = _x
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IParameterIdxContext is an interface to support dynamic dispatch.
type IParameterIdxContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QUESTION() antlr.TerminalNode

	// IsParameterIdxContext differentiates from other interfaces.
	IsParameterIdxContext()
}

type ParameterIdxContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterIdxContext() *ParameterIdxContext {
	var p = new(ParameterIdxContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_parameterIdx
	return p
}

func InitEmptyParameterIdxContext(p *ParameterIdxContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_parameterIdx
}

func (*ParameterIdxContext) IsParameterIdxContext() {}

func NewParameterIdxContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterIdxContext {
	var p = new(ParameterIdxContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_parameterIdx

	return p
}

func (s *ParameterIdxContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterIdxContext) QUESTION() antlr.TerminalNode {
	return s.GetToken(HiveParserQUESTION, 0)
}

func (s *ParameterIdxContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterIdxContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ParameterIdxContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterParameterIdx(s)
	}
}

func (s *ParameterIdxContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitParameterIdx(s)
	}
}

func (s *ParameterIdxContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitParameterIdx(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ParameterIdx() (localctx IParameterIdxContext) {
	localctx = NewParameterIdxContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 776, HiveParserRULE_parameterIdx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4548)
		p.Match(HiveParserQUESTION)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IStringLiteralSequenceContext is an interface to support dynamic dispatch.
type IStringLiteralSequenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllStringLiteral() []antlr.TerminalNode
	StringLiteral(i int) antlr.TerminalNode

	// IsStringLiteralSequenceContext differentiates from other interfaces.
	IsStringLiteralSequenceContext()
}

type StringLiteralSequenceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringLiteralSequenceContext() *StringLiteralSequenceContext {
	var p = new(StringLiteralSequenceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_stringLiteralSequence
	return p
}

func InitEmptyStringLiteralSequenceContext(p *StringLiteralSequenceContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_stringLiteralSequence
}

func (*StringLiteralSequenceContext) IsStringLiteralSequenceContext() {}

func NewStringLiteralSequenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringLiteralSequenceContext {
	var p = new(StringLiteralSequenceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_stringLiteralSequence

	return p
}

func (s *StringLiteralSequenceContext) GetParser() antlr.Parser { return s.parser }

func (s *StringLiteralSequenceContext) AllStringLiteral() []antlr.TerminalNode {
	return s.GetTokens(HiveParserStringLiteral)
}

func (s *StringLiteralSequenceContext) StringLiteral(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserStringLiteral, i)
}

func (s *StringLiteralSequenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralSequenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *StringLiteralSequenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterStringLiteralSequence(s)
	}
}

func (s *StringLiteralSequenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitStringLiteralSequence(s)
	}
}

func (s *StringLiteralSequenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitStringLiteralSequence(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) StringLiteralSequence() (localctx IStringLiteralSequenceContext) {
	localctx = NewStringLiteralSequenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 778, HiveParserRULE_stringLiteralSequence)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4550)
		p.Match(HiveParserStringLiteral)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(4552)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for ok := true; ok; ok = _la == HiveParserStringLiteral {
		{
			p.SetState(4551)
			p.Match(HiveParserStringLiteral)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


		p.SetState(4554)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICharSetStringLiteralContext is an interface to support dynamic dispatch.
type ICharSetStringLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCsName returns the csName token.
	GetCsName() antlr.Token 

	// GetCsLiteral returns the csLiteral token.
	GetCsLiteral() antlr.Token 


	// SetCsName sets the csName token.
	SetCsName(antlr.Token) 

	// SetCsLiteral sets the csLiteral token.
	SetCsLiteral(antlr.Token) 


	// Getter signatures
	CharSetName() antlr.TerminalNode
	CharSetLiteral() antlr.TerminalNode

	// IsCharSetStringLiteralContext differentiates from other interfaces.
	IsCharSetStringLiteralContext()
}

type CharSetStringLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	csName antlr.Token
	csLiteral antlr.Token
}

func NewEmptyCharSetStringLiteralContext() *CharSetStringLiteralContext {
	var p = new(CharSetStringLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_charSetStringLiteral
	return p
}

func InitEmptyCharSetStringLiteralContext(p *CharSetStringLiteralContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_charSetStringLiteral
}

func (*CharSetStringLiteralContext) IsCharSetStringLiteralContext() {}

func NewCharSetStringLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CharSetStringLiteralContext {
	var p = new(CharSetStringLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_charSetStringLiteral

	return p
}

func (s *CharSetStringLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *CharSetStringLiteralContext) GetCsName() antlr.Token { return s.csName }

func (s *CharSetStringLiteralContext) GetCsLiteral() antlr.Token { return s.csLiteral }


func (s *CharSetStringLiteralContext) SetCsName(v antlr.Token) { s.csName = v }

func (s *CharSetStringLiteralContext) SetCsLiteral(v antlr.Token) { s.csLiteral = v }


func (s *CharSetStringLiteralContext) CharSetName() antlr.TerminalNode {
	return s.GetToken(HiveParserCharSetName, 0)
}

func (s *CharSetStringLiteralContext) CharSetLiteral() antlr.TerminalNode {
	return s.GetToken(HiveParserCharSetLiteral, 0)
}

func (s *CharSetStringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CharSetStringLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CharSetStringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterCharSetStringLiteral(s)
	}
}

func (s *CharSetStringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitCharSetStringLiteral(s)
	}
}

func (s *CharSetStringLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitCharSetStringLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) CharSetStringLiteral() (localctx ICharSetStringLiteralContext) {
	localctx = NewCharSetStringLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 780, HiveParserRULE_charSetStringLiteral)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4556)

		var _m = p.Match(HiveParserCharSetName)

		localctx.(*CharSetStringLiteralContext).csName = _m
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4557)

		var _m = p.Match(HiveParserCharSetLiteral)

		localctx.(*CharSetStringLiteralContext).csLiteral = _m
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDateLiteralContext is an interface to support dynamic dispatch.
type IDateLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_DATE() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode
	KW_CURRENT_DATE() antlr.TerminalNode

	// IsDateLiteralContext differentiates from other interfaces.
	IsDateLiteralContext()
}

type DateLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDateLiteralContext() *DateLiteralContext {
	var p = new(DateLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_dateLiteral
	return p
}

func InitEmptyDateLiteralContext(p *DateLiteralContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_dateLiteral
}

func (*DateLiteralContext) IsDateLiteralContext() {}

func NewDateLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DateLiteralContext {
	var p = new(DateLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_dateLiteral

	return p
}

func (s *DateLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *DateLiteralContext) KW_DATE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DATE, 0)
}

func (s *DateLiteralContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(HiveParserStringLiteral, 0)
}

func (s *DateLiteralContext) KW_CURRENT_DATE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_CURRENT_DATE, 0)
}

func (s *DateLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DateLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DateLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterDateLiteral(s)
	}
}

func (s *DateLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitDateLiteral(s)
	}
}

func (s *DateLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitDateLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) DateLiteral() (localctx IDateLiteralContext) {
	localctx = NewDateLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 782, HiveParserRULE_dateLiteral)
	p.SetState(4562)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserKW_DATE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4559)
			p.Match(HiveParserKW_DATE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4560)
			p.Match(HiveParserStringLiteral)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HiveParserKW_CURRENT_DATE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4561)
			p.Match(HiveParserKW_CURRENT_DATE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITimestampLiteralContext is an interface to support dynamic dispatch.
type ITimestampLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_TIMESTAMP() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode
	KW_CURRENT_TIMESTAMP() antlr.TerminalNode

	// IsTimestampLiteralContext differentiates from other interfaces.
	IsTimestampLiteralContext()
}

type TimestampLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTimestampLiteralContext() *TimestampLiteralContext {
	var p = new(TimestampLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_timestampLiteral
	return p
}

func InitEmptyTimestampLiteralContext(p *TimestampLiteralContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_timestampLiteral
}

func (*TimestampLiteralContext) IsTimestampLiteralContext() {}

func NewTimestampLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TimestampLiteralContext {
	var p = new(TimestampLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_timestampLiteral

	return p
}

func (s *TimestampLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *TimestampLiteralContext) KW_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TIMESTAMP, 0)
}

func (s *TimestampLiteralContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(HiveParserStringLiteral, 0)
}

func (s *TimestampLiteralContext) KW_CURRENT_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_CURRENT_TIMESTAMP, 0)
}

func (s *TimestampLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimestampLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TimestampLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterTimestampLiteral(s)
	}
}

func (s *TimestampLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitTimestampLiteral(s)
	}
}

func (s *TimestampLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitTimestampLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) TimestampLiteral() (localctx ITimestampLiteralContext) {
	localctx = NewTimestampLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 784, HiveParserRULE_timestampLiteral)
	p.SetState(4567)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserKW_TIMESTAMP:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4564)
			p.Match(HiveParserKW_TIMESTAMP)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4565)
			p.Match(HiveParserStringLiteral)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HiveParserKW_CURRENT_TIMESTAMP:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4566)
			p.Match(HiveParserKW_CURRENT_TIMESTAMP)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITimestampLocalTZLiteralContext is an interface to support dynamic dispatch.
type ITimestampLocalTZLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_TIMESTAMPLOCALTZ() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode

	// IsTimestampLocalTZLiteralContext differentiates from other interfaces.
	IsTimestampLocalTZLiteralContext()
}

type TimestampLocalTZLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTimestampLocalTZLiteralContext() *TimestampLocalTZLiteralContext {
	var p = new(TimestampLocalTZLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_timestampLocalTZLiteral
	return p
}

func InitEmptyTimestampLocalTZLiteralContext(p *TimestampLocalTZLiteralContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_timestampLocalTZLiteral
}

func (*TimestampLocalTZLiteralContext) IsTimestampLocalTZLiteralContext() {}

func NewTimestampLocalTZLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TimestampLocalTZLiteralContext {
	var p = new(TimestampLocalTZLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_timestampLocalTZLiteral

	return p
}

func (s *TimestampLocalTZLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *TimestampLocalTZLiteralContext) KW_TIMESTAMPLOCALTZ() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TIMESTAMPLOCALTZ, 0)
}

func (s *TimestampLocalTZLiteralContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(HiveParserStringLiteral, 0)
}

func (s *TimestampLocalTZLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimestampLocalTZLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TimestampLocalTZLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterTimestampLocalTZLiteral(s)
	}
}

func (s *TimestampLocalTZLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitTimestampLocalTZLiteral(s)
	}
}

func (s *TimestampLocalTZLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitTimestampLocalTZLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) TimestampLocalTZLiteral() (localctx ITimestampLocalTZLiteralContext) {
	localctx = NewTimestampLocalTZLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 786, HiveParserRULE_timestampLocalTZLiteral)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4569)
		p.Match(HiveParserKW_TIMESTAMPLOCALTZ)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4570)
		p.Match(HiveParserStringLiteral)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IIntervalValueContext is an interface to support dynamic dispatch.
type IIntervalValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	StringLiteral() antlr.TerminalNode
	Number() antlr.TerminalNode

	// IsIntervalValueContext differentiates from other interfaces.
	IsIntervalValueContext()
}

type IntervalValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntervalValueContext() *IntervalValueContext {
	var p = new(IntervalValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_intervalValue
	return p
}

func InitEmptyIntervalValueContext(p *IntervalValueContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_intervalValue
}

func (*IntervalValueContext) IsIntervalValueContext() {}

func NewIntervalValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntervalValueContext {
	var p = new(IntervalValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_intervalValue

	return p
}

func (s *IntervalValueContext) GetParser() antlr.Parser { return s.parser }

func (s *IntervalValueContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(HiveParserStringLiteral, 0)
}

func (s *IntervalValueContext) Number() antlr.TerminalNode {
	return s.GetToken(HiveParserNumber, 0)
}

func (s *IntervalValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *IntervalValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterIntervalValue(s)
	}
}

func (s *IntervalValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitIntervalValue(s)
	}
}

func (s *IntervalValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitIntervalValue(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) IntervalValue() (localctx IIntervalValueContext) {
	localctx = NewIntervalValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 788, HiveParserRULE_intervalValue)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4572)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HiveParserStringLiteral || _la == HiveParserNumber) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IIntervalLiteralContext is an interface to support dynamic dispatch.
type IIntervalLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetValue returns the value rule contexts.
	GetValue() IIntervalValueContext

	// GetQualifiers returns the qualifiers rule contexts.
	GetQualifiers() IIntervalQualifiersContext


	// SetValue sets the value rule contexts.
	SetValue(IIntervalValueContext)

	// SetQualifiers sets the qualifiers rule contexts.
	SetQualifiers(IIntervalQualifiersContext)


	// Getter signatures
	IntervalValue() IIntervalValueContext
	IntervalQualifiers() IIntervalQualifiersContext

	// IsIntervalLiteralContext differentiates from other interfaces.
	IsIntervalLiteralContext()
}

type IntervalLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	value IIntervalValueContext 
	qualifiers IIntervalQualifiersContext 
}

func NewEmptyIntervalLiteralContext() *IntervalLiteralContext {
	var p = new(IntervalLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_intervalLiteral
	return p
}

func InitEmptyIntervalLiteralContext(p *IntervalLiteralContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_intervalLiteral
}

func (*IntervalLiteralContext) IsIntervalLiteralContext() {}

func NewIntervalLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntervalLiteralContext {
	var p = new(IntervalLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_intervalLiteral

	return p
}

func (s *IntervalLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *IntervalLiteralContext) GetValue() IIntervalValueContext { return s.value }

func (s *IntervalLiteralContext) GetQualifiers() IIntervalQualifiersContext { return s.qualifiers }


func (s *IntervalLiteralContext) SetValue(v IIntervalValueContext) { s.value = v }

func (s *IntervalLiteralContext) SetQualifiers(v IIntervalQualifiersContext) { s.qualifiers = v }


func (s *IntervalLiteralContext) IntervalValue() IIntervalValueContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalValueContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalValueContext)
}

func (s *IntervalLiteralContext) IntervalQualifiers() IIntervalQualifiersContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalQualifiersContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalQualifiersContext)
}

func (s *IntervalLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *IntervalLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterIntervalLiteral(s)
	}
}

func (s *IntervalLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitIntervalLiteral(s)
	}
}

func (s *IntervalLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitIntervalLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) IntervalLiteral() (localctx IIntervalLiteralContext) {
	localctx = NewIntervalLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 790, HiveParserRULE_intervalLiteral)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4574)

		var _x = p.IntervalValue()


		localctx.(*IntervalLiteralContext).value = _x
	}
	{
		p.SetState(4575)

		var _x = p.IntervalQualifiers()


		localctx.(*IntervalLiteralContext).qualifiers = _x
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IIntervalExpressionContext is an interface to support dynamic dispatch.
type IIntervalExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetValue returns the value rule contexts.
	GetValue() IIntervalValueContext

	// GetQualifiers returns the qualifiers rule contexts.
	GetQualifiers() IIntervalQualifiersContext

	// GetExpr returns the expr rule contexts.
	GetExpr() IExpressionContext


	// SetValue sets the value rule contexts.
	SetValue(IIntervalValueContext)

	// SetQualifiers sets the qualifiers rule contexts.
	SetQualifiers(IIntervalQualifiersContext)

	// SetExpr sets the expr rule contexts.
	SetExpr(IExpressionContext)


	// Getter signatures
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	IntervalValue() IIntervalValueContext
	IntervalQualifiers() IIntervalQualifiersContext
	KW_INTERVAL() antlr.TerminalNode
	Expression() IExpressionContext

	// IsIntervalExpressionContext differentiates from other interfaces.
	IsIntervalExpressionContext()
}

type IntervalExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	value IIntervalValueContext 
	qualifiers IIntervalQualifiersContext 
	expr IExpressionContext 
}

func NewEmptyIntervalExpressionContext() *IntervalExpressionContext {
	var p = new(IntervalExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_intervalExpression
	return p
}

func InitEmptyIntervalExpressionContext(p *IntervalExpressionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_intervalExpression
}

func (*IntervalExpressionContext) IsIntervalExpressionContext() {}

func NewIntervalExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntervalExpressionContext {
	var p = new(IntervalExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_intervalExpression

	return p
}

func (s *IntervalExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *IntervalExpressionContext) GetValue() IIntervalValueContext { return s.value }

func (s *IntervalExpressionContext) GetQualifiers() IIntervalQualifiersContext { return s.qualifiers }

func (s *IntervalExpressionContext) GetExpr() IExpressionContext { return s.expr }


func (s *IntervalExpressionContext) SetValue(v IIntervalValueContext) { s.value = v }

func (s *IntervalExpressionContext) SetQualifiers(v IIntervalQualifiersContext) { s.qualifiers = v }

func (s *IntervalExpressionContext) SetExpr(v IExpressionContext) { s.expr = v }


func (s *IntervalExpressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserLPAREN, 0)
}

func (s *IntervalExpressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserRPAREN, 0)
}

func (s *IntervalExpressionContext) IntervalValue() IIntervalValueContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalValueContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalValueContext)
}

func (s *IntervalExpressionContext) IntervalQualifiers() IIntervalQualifiersContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalQualifiersContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalQualifiersContext)
}

func (s *IntervalExpressionContext) KW_INTERVAL() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_INTERVAL, 0)
}

func (s *IntervalExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IntervalExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *IntervalExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterIntervalExpression(s)
	}
}

func (s *IntervalExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitIntervalExpression(s)
	}
}

func (s *IntervalExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitIntervalExpression(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) IntervalExpression() (localctx IIntervalExpressionContext) {
	localctx = NewIntervalExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 792, HiveParserRULE_intervalExpression)
	p.SetState(4592)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserLPAREN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4577)
			p.Match(HiveParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4578)

			var _x = p.IntervalValue()


			localctx.(*IntervalExpressionContext).value = _x
		}
		{
			p.SetState(4579)
			p.Match(HiveParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4580)

			var _x = p.IntervalQualifiers()


			localctx.(*IntervalExpressionContext).qualifiers = _x
		}


	case HiveParserKW_INTERVAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4582)
			p.Match(HiveParserKW_INTERVAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(4588)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case HiveParserStringLiteral, HiveParserNumber:
			{
				p.SetState(4583)

				var _x = p.IntervalValue()


				localctx.(*IntervalExpressionContext).value = _x
			}


		case HiveParserLPAREN:
			{
				p.SetState(4584)
				p.Match(HiveParserLPAREN)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(4585)

				var _x = p.Expression()


				localctx.(*IntervalExpressionContext).expr = _x
			}
			{
				p.SetState(4586)
				p.Match(HiveParserRPAREN)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}



		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(4590)

			var _x = p.IntervalQualifiers()


			localctx.(*IntervalExpressionContext).qualifiers = _x
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IIntervalQualifiersContext is an interface to support dynamic dispatch.
type IIntervalQualifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_YEAR() antlr.TerminalNode
	KW_TO() antlr.TerminalNode
	KW_MONTH() antlr.TerminalNode
	KW_DAY() antlr.TerminalNode
	KW_SECOND() antlr.TerminalNode
	KW_HOUR() antlr.TerminalNode
	KW_MINUTE() antlr.TerminalNode

	// IsIntervalQualifiersContext differentiates from other interfaces.
	IsIntervalQualifiersContext()
}

type IntervalQualifiersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntervalQualifiersContext() *IntervalQualifiersContext {
	var p = new(IntervalQualifiersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_intervalQualifiers
	return p
}

func InitEmptyIntervalQualifiersContext(p *IntervalQualifiersContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_intervalQualifiers
}

func (*IntervalQualifiersContext) IsIntervalQualifiersContext() {}

func NewIntervalQualifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntervalQualifiersContext {
	var p = new(IntervalQualifiersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_intervalQualifiers

	return p
}

func (s *IntervalQualifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *IntervalQualifiersContext) KW_YEAR() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_YEAR, 0)
}

func (s *IntervalQualifiersContext) KW_TO() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TO, 0)
}

func (s *IntervalQualifiersContext) KW_MONTH() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_MONTH, 0)
}

func (s *IntervalQualifiersContext) KW_DAY() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DAY, 0)
}

func (s *IntervalQualifiersContext) KW_SECOND() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SECOND, 0)
}

func (s *IntervalQualifiersContext) KW_HOUR() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_HOUR, 0)
}

func (s *IntervalQualifiersContext) KW_MINUTE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_MINUTE, 0)
}

func (s *IntervalQualifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalQualifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *IntervalQualifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterIntervalQualifiers(s)
	}
}

func (s *IntervalQualifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitIntervalQualifiers(s)
	}
}

func (s *IntervalQualifiersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitIntervalQualifiers(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) IntervalQualifiers() (localctx IIntervalQualifiersContext) {
	localctx = NewIntervalQualifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 794, HiveParserRULE_intervalQualifiers)
	p.SetState(4606)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 547, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4594)
			p.Match(HiveParserKW_YEAR)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4595)
			p.Match(HiveParserKW_TO)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4596)
			p.Match(HiveParserKW_MONTH)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4597)
			p.Match(HiveParserKW_DAY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4598)
			p.Match(HiveParserKW_TO)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4599)
			p.Match(HiveParserKW_SECOND)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4600)
			p.Match(HiveParserKW_YEAR)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4601)
			p.Match(HiveParserKW_MONTH)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4602)
			p.Match(HiveParserKW_DAY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4603)
			p.Match(HiveParserKW_HOUR)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(4604)
			p.Match(HiveParserKW_MINUTE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(4605)
			p.Match(HiveParserKW_SECOND)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PrecedenceOrExpression() IPrecedenceOrExpressionContext

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_expression
	return p
}

func InitEmptyExpressionContext(p *ExpressionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_expression
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) PrecedenceOrExpression() IPrecedenceOrExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrecedenceOrExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrecedenceOrExpressionContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitExpression(s)
	}
}

func (s *ExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitExpression(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) Expression() (localctx IExpressionContext) {
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 796, HiveParserRULE_expression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4608)
		p.PrecedenceOrExpression()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAtomExpressionContext is an interface to support dynamic dispatch.
type IAtomExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Constant() IConstantContext
	IntervalExpression() IIntervalExpressionContext
	CastExpression() ICastExpressionContext
	ExtractExpression() IExtractExpressionContext
	FloorExpression() IFloorExpressionContext
	CaseExpression() ICaseExpressionContext
	WhenExpression() IWhenExpressionContext
	SubQueryExpression() ISubQueryExpressionContext
	Function_() IFunction_Context
	TableOrColumn() ITableOrColumnContext
	ExpressionsInParenthesis() IExpressionsInParenthesisContext

	// IsAtomExpressionContext differentiates from other interfaces.
	IsAtomExpressionContext()
}

type AtomExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtomExpressionContext() *AtomExpressionContext {
	var p = new(AtomExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_atomExpression
	return p
}

func InitEmptyAtomExpressionContext(p *AtomExpressionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_atomExpression
}

func (*AtomExpressionContext) IsAtomExpressionContext() {}

func NewAtomExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtomExpressionContext {
	var p = new(AtomExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_atomExpression

	return p
}

func (s *AtomExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *AtomExpressionContext) Constant() IConstantContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *AtomExpressionContext) IntervalExpression() IIntervalExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalExpressionContext)
}

func (s *AtomExpressionContext) CastExpression() ICastExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICastExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICastExpressionContext)
}

func (s *AtomExpressionContext) ExtractExpression() IExtractExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExtractExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExtractExpressionContext)
}

func (s *AtomExpressionContext) FloorExpression() IFloorExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFloorExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFloorExpressionContext)
}

func (s *AtomExpressionContext) CaseExpression() ICaseExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseExpressionContext)
}

func (s *AtomExpressionContext) WhenExpression() IWhenExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhenExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhenExpressionContext)
}

func (s *AtomExpressionContext) SubQueryExpression() ISubQueryExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubQueryExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubQueryExpressionContext)
}

func (s *AtomExpressionContext) Function_() IFunction_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunction_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunction_Context)
}

func (s *AtomExpressionContext) TableOrColumn() ITableOrColumnContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableOrColumnContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableOrColumnContext)
}

func (s *AtomExpressionContext) ExpressionsInParenthesis() IExpressionsInParenthesisContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionsInParenthesisContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionsInParenthesisContext)
}

func (s *AtomExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtomExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AtomExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterAtomExpression(s)
	}
}

func (s *AtomExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitAtomExpression(s)
	}
}

func (s *AtomExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitAtomExpression(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) AtomExpression() (localctx IAtomExpressionContext) {
	localctx = NewAtomExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 798, HiveParserRULE_atomExpression)
	p.SetState(4621)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 548, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4610)
			p.Constant()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4611)
			p.IntervalExpression()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4612)
			p.CastExpression()
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4613)
			p.ExtractExpression()
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4614)
			p.FloorExpression()
		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4615)
			p.CaseExpression()
		}


	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(4616)
			p.WhenExpression()
		}


	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(4617)
			p.SubQueryExpression()
		}


	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(4618)
			p.Function_()
		}


	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(4619)
			p.TableOrColumn()
		}


	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(4620)
			p.ExpressionsInParenthesis()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPrecedenceFieldExpressionContext is an interface to support dynamic dispatch.
type IPrecedenceFieldExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AtomExpression() IAtomExpressionContext
	AllLSQUARE() []antlr.TerminalNode
	LSQUARE(i int) antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllRSQUARE() []antlr.TerminalNode
	RSQUARE(i int) antlr.TerminalNode
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode
	AllId_() []IId_Context
	Id_(i int) IId_Context

	// IsPrecedenceFieldExpressionContext differentiates from other interfaces.
	IsPrecedenceFieldExpressionContext()
}

type PrecedenceFieldExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrecedenceFieldExpressionContext() *PrecedenceFieldExpressionContext {
	var p = new(PrecedenceFieldExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_precedenceFieldExpression
	return p
}

func InitEmptyPrecedenceFieldExpressionContext(p *PrecedenceFieldExpressionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_precedenceFieldExpression
}

func (*PrecedenceFieldExpressionContext) IsPrecedenceFieldExpressionContext() {}

func NewPrecedenceFieldExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrecedenceFieldExpressionContext {
	var p = new(PrecedenceFieldExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_precedenceFieldExpression

	return p
}

func (s *PrecedenceFieldExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PrecedenceFieldExpressionContext) AtomExpression() IAtomExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAtomExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAtomExpressionContext)
}

func (s *PrecedenceFieldExpressionContext) AllLSQUARE() []antlr.TerminalNode {
	return s.GetTokens(HiveParserLSQUARE)
}

func (s *PrecedenceFieldExpressionContext) LSQUARE(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserLSQUARE, i)
}

func (s *PrecedenceFieldExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *PrecedenceFieldExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PrecedenceFieldExpressionContext) AllRSQUARE() []antlr.TerminalNode {
	return s.GetTokens(HiveParserRSQUARE)
}

func (s *PrecedenceFieldExpressionContext) RSQUARE(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserRSQUARE, i)
}

func (s *PrecedenceFieldExpressionContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(HiveParserDOT)
}

func (s *PrecedenceFieldExpressionContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserDOT, i)
}

func (s *PrecedenceFieldExpressionContext) AllId_() []IId_Context {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IId_Context); ok {
			len++
		}
	}

	tst := make([]IId_Context, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IId_Context); ok {
			tst[i] = t.(IId_Context)
			i++
		}
	}

	return tst
}

func (s *PrecedenceFieldExpressionContext) Id_(i int) IId_Context {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *PrecedenceFieldExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrecedenceFieldExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PrecedenceFieldExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterPrecedenceFieldExpression(s)
	}
}

func (s *PrecedenceFieldExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitPrecedenceFieldExpression(s)
	}
}

func (s *PrecedenceFieldExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitPrecedenceFieldExpression(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) PrecedenceFieldExpression() (localctx IPrecedenceFieldExpressionContext) {
	localctx = NewPrecedenceFieldExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 800, HiveParserRULE_precedenceFieldExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4623)
		p.AtomExpression()
	}
	p.SetState(4632)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HiveParserDOT || _la == HiveParserLSQUARE {
		p.SetState(4630)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case HiveParserLSQUARE:
			{
				p.SetState(4624)
				p.Match(HiveParserLSQUARE)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(4625)
				p.Expression()
			}
			{
				p.SetState(4626)
				p.Match(HiveParserRSQUARE)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


		case HiveParserDOT:
			{
				p.SetState(4628)
				p.Match(HiveParserDOT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(4629)
				p.Id_()
			}



		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(4634)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPrecedenceUnaryOperatorContext is an interface to support dynamic dispatch.
type IPrecedenceUnaryOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PLUS() antlr.TerminalNode
	MINUS() antlr.TerminalNode
	TILDE() antlr.TerminalNode

	// IsPrecedenceUnaryOperatorContext differentiates from other interfaces.
	IsPrecedenceUnaryOperatorContext()
}

type PrecedenceUnaryOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrecedenceUnaryOperatorContext() *PrecedenceUnaryOperatorContext {
	var p = new(PrecedenceUnaryOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_precedenceUnaryOperator
	return p
}

func InitEmptyPrecedenceUnaryOperatorContext(p *PrecedenceUnaryOperatorContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_precedenceUnaryOperator
}

func (*PrecedenceUnaryOperatorContext) IsPrecedenceUnaryOperatorContext() {}

func NewPrecedenceUnaryOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrecedenceUnaryOperatorContext {
	var p = new(PrecedenceUnaryOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_precedenceUnaryOperator

	return p
}

func (s *PrecedenceUnaryOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *PrecedenceUnaryOperatorContext) PLUS() antlr.TerminalNode {
	return s.GetToken(HiveParserPLUS, 0)
}

func (s *PrecedenceUnaryOperatorContext) MINUS() antlr.TerminalNode {
	return s.GetToken(HiveParserMINUS, 0)
}

func (s *PrecedenceUnaryOperatorContext) TILDE() antlr.TerminalNode {
	return s.GetToken(HiveParserTILDE, 0)
}

func (s *PrecedenceUnaryOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrecedenceUnaryOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PrecedenceUnaryOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterPrecedenceUnaryOperator(s)
	}
}

func (s *PrecedenceUnaryOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitPrecedenceUnaryOperator(s)
	}
}

func (s *PrecedenceUnaryOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitPrecedenceUnaryOperator(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) PrecedenceUnaryOperator() (localctx IPrecedenceUnaryOperatorContext) {
	localctx = NewPrecedenceUnaryOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 802, HiveParserRULE_precedenceUnaryOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4635)
		_la = p.GetTokenStream().LA(1)

		if !(((int64((_la - 400)) & ^0x3f) == 0 && ((int64(1) << (_la - 400)) & 67) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPrecedenceUnaryPrefixExpressionContext is an interface to support dynamic dispatch.
type IPrecedenceUnaryPrefixExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PrecedenceFieldExpression() IPrecedenceFieldExpressionContext
	AllPrecedenceUnaryOperator() []IPrecedenceUnaryOperatorContext
	PrecedenceUnaryOperator(i int) IPrecedenceUnaryOperatorContext

	// IsPrecedenceUnaryPrefixExpressionContext differentiates from other interfaces.
	IsPrecedenceUnaryPrefixExpressionContext()
}

type PrecedenceUnaryPrefixExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrecedenceUnaryPrefixExpressionContext() *PrecedenceUnaryPrefixExpressionContext {
	var p = new(PrecedenceUnaryPrefixExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_precedenceUnaryPrefixExpression
	return p
}

func InitEmptyPrecedenceUnaryPrefixExpressionContext(p *PrecedenceUnaryPrefixExpressionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_precedenceUnaryPrefixExpression
}

func (*PrecedenceUnaryPrefixExpressionContext) IsPrecedenceUnaryPrefixExpressionContext() {}

func NewPrecedenceUnaryPrefixExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrecedenceUnaryPrefixExpressionContext {
	var p = new(PrecedenceUnaryPrefixExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_precedenceUnaryPrefixExpression

	return p
}

func (s *PrecedenceUnaryPrefixExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PrecedenceUnaryPrefixExpressionContext) PrecedenceFieldExpression() IPrecedenceFieldExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrecedenceFieldExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrecedenceFieldExpressionContext)
}

func (s *PrecedenceUnaryPrefixExpressionContext) AllPrecedenceUnaryOperator() []IPrecedenceUnaryOperatorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrecedenceUnaryOperatorContext); ok {
			len++
		}
	}

	tst := make([]IPrecedenceUnaryOperatorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrecedenceUnaryOperatorContext); ok {
			tst[i] = t.(IPrecedenceUnaryOperatorContext)
			i++
		}
	}

	return tst
}

func (s *PrecedenceUnaryPrefixExpressionContext) PrecedenceUnaryOperator(i int) IPrecedenceUnaryOperatorContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrecedenceUnaryOperatorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrecedenceUnaryOperatorContext)
}

func (s *PrecedenceUnaryPrefixExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrecedenceUnaryPrefixExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PrecedenceUnaryPrefixExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterPrecedenceUnaryPrefixExpression(s)
	}
}

func (s *PrecedenceUnaryPrefixExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitPrecedenceUnaryPrefixExpression(s)
	}
}

func (s *PrecedenceUnaryPrefixExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitPrecedenceUnaryPrefixExpression(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) PrecedenceUnaryPrefixExpression() (localctx IPrecedenceUnaryPrefixExpressionContext) {
	localctx = NewPrecedenceUnaryPrefixExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 804, HiveParserRULE_precedenceUnaryPrefixExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4640)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for ((int64((_la - 400)) & ^0x3f) == 0 && ((int64(1) << (_la - 400)) & 67) != 0) {
		{
			p.SetState(4637)
			p.PrecedenceUnaryOperator()
		}


		p.SetState(4642)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(4643)
		p.PrecedenceFieldExpression()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPrecedenceBitwiseXorOperatorContext is an interface to support dynamic dispatch.
type IPrecedenceBitwiseXorOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BITWISEXOR() antlr.TerminalNode

	// IsPrecedenceBitwiseXorOperatorContext differentiates from other interfaces.
	IsPrecedenceBitwiseXorOperatorContext()
}

type PrecedenceBitwiseXorOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrecedenceBitwiseXorOperatorContext() *PrecedenceBitwiseXorOperatorContext {
	var p = new(PrecedenceBitwiseXorOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_precedenceBitwiseXorOperator
	return p
}

func InitEmptyPrecedenceBitwiseXorOperatorContext(p *PrecedenceBitwiseXorOperatorContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_precedenceBitwiseXorOperator
}

func (*PrecedenceBitwiseXorOperatorContext) IsPrecedenceBitwiseXorOperatorContext() {}

func NewPrecedenceBitwiseXorOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrecedenceBitwiseXorOperatorContext {
	var p = new(PrecedenceBitwiseXorOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_precedenceBitwiseXorOperator

	return p
}

func (s *PrecedenceBitwiseXorOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *PrecedenceBitwiseXorOperatorContext) BITWISEXOR() antlr.TerminalNode {
	return s.GetToken(HiveParserBITWISEXOR, 0)
}

func (s *PrecedenceBitwiseXorOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrecedenceBitwiseXorOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PrecedenceBitwiseXorOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterPrecedenceBitwiseXorOperator(s)
	}
}

func (s *PrecedenceBitwiseXorOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitPrecedenceBitwiseXorOperator(s)
	}
}

func (s *PrecedenceBitwiseXorOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitPrecedenceBitwiseXorOperator(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) PrecedenceBitwiseXorOperator() (localctx IPrecedenceBitwiseXorOperatorContext) {
	localctx = NewPrecedenceBitwiseXorOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 806, HiveParserRULE_precedenceBitwiseXorOperator)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4645)
		p.Match(HiveParserBITWISEXOR)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPrecedenceBitwiseXorExpressionContext is an interface to support dynamic dispatch.
type IPrecedenceBitwiseXorExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPrecedenceUnaryPrefixExpression() []IPrecedenceUnaryPrefixExpressionContext
	PrecedenceUnaryPrefixExpression(i int) IPrecedenceUnaryPrefixExpressionContext
	AllPrecedenceBitwiseXorOperator() []IPrecedenceBitwiseXorOperatorContext
	PrecedenceBitwiseXorOperator(i int) IPrecedenceBitwiseXorOperatorContext

	// IsPrecedenceBitwiseXorExpressionContext differentiates from other interfaces.
	IsPrecedenceBitwiseXorExpressionContext()
}

type PrecedenceBitwiseXorExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrecedenceBitwiseXorExpressionContext() *PrecedenceBitwiseXorExpressionContext {
	var p = new(PrecedenceBitwiseXorExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_precedenceBitwiseXorExpression
	return p
}

func InitEmptyPrecedenceBitwiseXorExpressionContext(p *PrecedenceBitwiseXorExpressionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_precedenceBitwiseXorExpression
}

func (*PrecedenceBitwiseXorExpressionContext) IsPrecedenceBitwiseXorExpressionContext() {}

func NewPrecedenceBitwiseXorExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrecedenceBitwiseXorExpressionContext {
	var p = new(PrecedenceBitwiseXorExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_precedenceBitwiseXorExpression

	return p
}

func (s *PrecedenceBitwiseXorExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PrecedenceBitwiseXorExpressionContext) AllPrecedenceUnaryPrefixExpression() []IPrecedenceUnaryPrefixExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrecedenceUnaryPrefixExpressionContext); ok {
			len++
		}
	}

	tst := make([]IPrecedenceUnaryPrefixExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrecedenceUnaryPrefixExpressionContext); ok {
			tst[i] = t.(IPrecedenceUnaryPrefixExpressionContext)
			i++
		}
	}

	return tst
}

func (s *PrecedenceBitwiseXorExpressionContext) PrecedenceUnaryPrefixExpression(i int) IPrecedenceUnaryPrefixExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrecedenceUnaryPrefixExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrecedenceUnaryPrefixExpressionContext)
}

func (s *PrecedenceBitwiseXorExpressionContext) AllPrecedenceBitwiseXorOperator() []IPrecedenceBitwiseXorOperatorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrecedenceBitwiseXorOperatorContext); ok {
			len++
		}
	}

	tst := make([]IPrecedenceBitwiseXorOperatorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrecedenceBitwiseXorOperatorContext); ok {
			tst[i] = t.(IPrecedenceBitwiseXorOperatorContext)
			i++
		}
	}

	return tst
}

func (s *PrecedenceBitwiseXorExpressionContext) PrecedenceBitwiseXorOperator(i int) IPrecedenceBitwiseXorOperatorContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrecedenceBitwiseXorOperatorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrecedenceBitwiseXorOperatorContext)
}

func (s *PrecedenceBitwiseXorExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrecedenceBitwiseXorExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PrecedenceBitwiseXorExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterPrecedenceBitwiseXorExpression(s)
	}
}

func (s *PrecedenceBitwiseXorExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitPrecedenceBitwiseXorExpression(s)
	}
}

func (s *PrecedenceBitwiseXorExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitPrecedenceBitwiseXorExpression(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) PrecedenceBitwiseXorExpression() (localctx IPrecedenceBitwiseXorExpressionContext) {
	localctx = NewPrecedenceBitwiseXorExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 808, HiveParserRULE_precedenceBitwiseXorExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4647)
		p.PrecedenceUnaryPrefixExpression()
	}
	p.SetState(4653)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HiveParserBITWISEXOR {
		{
			p.SetState(4648)
			p.PrecedenceBitwiseXorOperator()
		}
		{
			p.SetState(4649)
			p.PrecedenceUnaryPrefixExpression()
		}


		p.SetState(4655)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPrecedenceStarOperatorContext is an interface to support dynamic dispatch.
type IPrecedenceStarOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STAR() antlr.TerminalNode
	DIVIDE() antlr.TerminalNode
	MOD() antlr.TerminalNode
	DIV() antlr.TerminalNode

	// IsPrecedenceStarOperatorContext differentiates from other interfaces.
	IsPrecedenceStarOperatorContext()
}

type PrecedenceStarOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrecedenceStarOperatorContext() *PrecedenceStarOperatorContext {
	var p = new(PrecedenceStarOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_precedenceStarOperator
	return p
}

func InitEmptyPrecedenceStarOperatorContext(p *PrecedenceStarOperatorContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_precedenceStarOperator
}

func (*PrecedenceStarOperatorContext) IsPrecedenceStarOperatorContext() {}

func NewPrecedenceStarOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrecedenceStarOperatorContext {
	var p = new(PrecedenceStarOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_precedenceStarOperator

	return p
}

func (s *PrecedenceStarOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *PrecedenceStarOperatorContext) STAR() antlr.TerminalNode {
	return s.GetToken(HiveParserSTAR, 0)
}

func (s *PrecedenceStarOperatorContext) DIVIDE() antlr.TerminalNode {
	return s.GetToken(HiveParserDIVIDE, 0)
}

func (s *PrecedenceStarOperatorContext) MOD() antlr.TerminalNode {
	return s.GetToken(HiveParserMOD, 0)
}

func (s *PrecedenceStarOperatorContext) DIV() antlr.TerminalNode {
	return s.GetToken(HiveParserDIV, 0)
}

func (s *PrecedenceStarOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrecedenceStarOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PrecedenceStarOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterPrecedenceStarOperator(s)
	}
}

func (s *PrecedenceStarOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitPrecedenceStarOperator(s)
	}
}

func (s *PrecedenceStarOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitPrecedenceStarOperator(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) PrecedenceStarOperator() (localctx IPrecedenceStarOperatorContext) {
	localctx = NewPrecedenceStarOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 810, HiveParserRULE_precedenceStarOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4656)
		_la = p.GetTokenStream().LA(1)

		if !(((int64((_la - 399)) & ^0x3f) == 0 && ((int64(1) << (_la - 399)) & 57) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPrecedenceStarExpressionContext is an interface to support dynamic dispatch.
type IPrecedenceStarExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPrecedenceBitwiseXorExpression() []IPrecedenceBitwiseXorExpressionContext
	PrecedenceBitwiseXorExpression(i int) IPrecedenceBitwiseXorExpressionContext
	AllPrecedenceStarOperator() []IPrecedenceStarOperatorContext
	PrecedenceStarOperator(i int) IPrecedenceStarOperatorContext

	// IsPrecedenceStarExpressionContext differentiates from other interfaces.
	IsPrecedenceStarExpressionContext()
}

type PrecedenceStarExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrecedenceStarExpressionContext() *PrecedenceStarExpressionContext {
	var p = new(PrecedenceStarExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_precedenceStarExpression
	return p
}

func InitEmptyPrecedenceStarExpressionContext(p *PrecedenceStarExpressionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_precedenceStarExpression
}

func (*PrecedenceStarExpressionContext) IsPrecedenceStarExpressionContext() {}

func NewPrecedenceStarExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrecedenceStarExpressionContext {
	var p = new(PrecedenceStarExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_precedenceStarExpression

	return p
}

func (s *PrecedenceStarExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PrecedenceStarExpressionContext) AllPrecedenceBitwiseXorExpression() []IPrecedenceBitwiseXorExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrecedenceBitwiseXorExpressionContext); ok {
			len++
		}
	}

	tst := make([]IPrecedenceBitwiseXorExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrecedenceBitwiseXorExpressionContext); ok {
			tst[i] = t.(IPrecedenceBitwiseXorExpressionContext)
			i++
		}
	}

	return tst
}

func (s *PrecedenceStarExpressionContext) PrecedenceBitwiseXorExpression(i int) IPrecedenceBitwiseXorExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrecedenceBitwiseXorExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrecedenceBitwiseXorExpressionContext)
}

func (s *PrecedenceStarExpressionContext) AllPrecedenceStarOperator() []IPrecedenceStarOperatorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrecedenceStarOperatorContext); ok {
			len++
		}
	}

	tst := make([]IPrecedenceStarOperatorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrecedenceStarOperatorContext); ok {
			tst[i] = t.(IPrecedenceStarOperatorContext)
			i++
		}
	}

	return tst
}

func (s *PrecedenceStarExpressionContext) PrecedenceStarOperator(i int) IPrecedenceStarOperatorContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrecedenceStarOperatorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrecedenceStarOperatorContext)
}

func (s *PrecedenceStarExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrecedenceStarExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PrecedenceStarExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterPrecedenceStarExpression(s)
	}
}

func (s *PrecedenceStarExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitPrecedenceStarExpression(s)
	}
}

func (s *PrecedenceStarExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitPrecedenceStarExpression(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) PrecedenceStarExpression() (localctx IPrecedenceStarExpressionContext) {
	localctx = NewPrecedenceStarExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 812, HiveParserRULE_precedenceStarExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4658)
		p.PrecedenceBitwiseXorExpression()
	}
	p.SetState(4664)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for ((int64((_la - 399)) & ^0x3f) == 0 && ((int64(1) << (_la - 399)) & 57) != 0) {
		{
			p.SetState(4659)
			p.PrecedenceStarOperator()
		}
		{
			p.SetState(4660)
			p.PrecedenceBitwiseXorExpression()
		}


		p.SetState(4666)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPrecedencePlusOperatorContext is an interface to support dynamic dispatch.
type IPrecedencePlusOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PLUS() antlr.TerminalNode
	MINUS() antlr.TerminalNode

	// IsPrecedencePlusOperatorContext differentiates from other interfaces.
	IsPrecedencePlusOperatorContext()
}

type PrecedencePlusOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrecedencePlusOperatorContext() *PrecedencePlusOperatorContext {
	var p = new(PrecedencePlusOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_precedencePlusOperator
	return p
}

func InitEmptyPrecedencePlusOperatorContext(p *PrecedencePlusOperatorContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_precedencePlusOperator
}

func (*PrecedencePlusOperatorContext) IsPrecedencePlusOperatorContext() {}

func NewPrecedencePlusOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrecedencePlusOperatorContext {
	var p = new(PrecedencePlusOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_precedencePlusOperator

	return p
}

func (s *PrecedencePlusOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *PrecedencePlusOperatorContext) PLUS() antlr.TerminalNode {
	return s.GetToken(HiveParserPLUS, 0)
}

func (s *PrecedencePlusOperatorContext) MINUS() antlr.TerminalNode {
	return s.GetToken(HiveParserMINUS, 0)
}

func (s *PrecedencePlusOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrecedencePlusOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PrecedencePlusOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterPrecedencePlusOperator(s)
	}
}

func (s *PrecedencePlusOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitPrecedencePlusOperator(s)
	}
}

func (s *PrecedencePlusOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitPrecedencePlusOperator(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) PrecedencePlusOperator() (localctx IPrecedencePlusOperatorContext) {
	localctx = NewPrecedencePlusOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 814, HiveParserRULE_precedencePlusOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4667)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HiveParserPLUS || _la == HiveParserMINUS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPrecedencePlusExpressionContext is an interface to support dynamic dispatch.
type IPrecedencePlusExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPrecedenceStarExpression() []IPrecedenceStarExpressionContext
	PrecedenceStarExpression(i int) IPrecedenceStarExpressionContext
	AllPrecedencePlusOperator() []IPrecedencePlusOperatorContext
	PrecedencePlusOperator(i int) IPrecedencePlusOperatorContext

	// IsPrecedencePlusExpressionContext differentiates from other interfaces.
	IsPrecedencePlusExpressionContext()
}

type PrecedencePlusExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrecedencePlusExpressionContext() *PrecedencePlusExpressionContext {
	var p = new(PrecedencePlusExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_precedencePlusExpression
	return p
}

func InitEmptyPrecedencePlusExpressionContext(p *PrecedencePlusExpressionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_precedencePlusExpression
}

func (*PrecedencePlusExpressionContext) IsPrecedencePlusExpressionContext() {}

func NewPrecedencePlusExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrecedencePlusExpressionContext {
	var p = new(PrecedencePlusExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_precedencePlusExpression

	return p
}

func (s *PrecedencePlusExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PrecedencePlusExpressionContext) AllPrecedenceStarExpression() []IPrecedenceStarExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrecedenceStarExpressionContext); ok {
			len++
		}
	}

	tst := make([]IPrecedenceStarExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrecedenceStarExpressionContext); ok {
			tst[i] = t.(IPrecedenceStarExpressionContext)
			i++
		}
	}

	return tst
}

func (s *PrecedencePlusExpressionContext) PrecedenceStarExpression(i int) IPrecedenceStarExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrecedenceStarExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrecedenceStarExpressionContext)
}

func (s *PrecedencePlusExpressionContext) AllPrecedencePlusOperator() []IPrecedencePlusOperatorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrecedencePlusOperatorContext); ok {
			len++
		}
	}

	tst := make([]IPrecedencePlusOperatorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrecedencePlusOperatorContext); ok {
			tst[i] = t.(IPrecedencePlusOperatorContext)
			i++
		}
	}

	return tst
}

func (s *PrecedencePlusExpressionContext) PrecedencePlusOperator(i int) IPrecedencePlusOperatorContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrecedencePlusOperatorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrecedencePlusOperatorContext)
}

func (s *PrecedencePlusExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrecedencePlusExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PrecedencePlusExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterPrecedencePlusExpression(s)
	}
}

func (s *PrecedencePlusExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitPrecedencePlusExpression(s)
	}
}

func (s *PrecedencePlusExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitPrecedencePlusExpression(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) PrecedencePlusExpression() (localctx IPrecedencePlusExpressionContext) {
	localctx = NewPrecedencePlusExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 816, HiveParserRULE_precedencePlusExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4669)
		p.PrecedenceStarExpression()
	}
	p.SetState(4675)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HiveParserPLUS || _la == HiveParserMINUS {
		{
			p.SetState(4670)
			p.PrecedencePlusOperator()
		}
		{
			p.SetState(4671)
			p.PrecedenceStarExpression()
		}


		p.SetState(4677)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPrecedenceConcatenateOperatorContext is an interface to support dynamic dispatch.
type IPrecedenceConcatenateOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CONCATENATE() antlr.TerminalNode

	// IsPrecedenceConcatenateOperatorContext differentiates from other interfaces.
	IsPrecedenceConcatenateOperatorContext()
}

type PrecedenceConcatenateOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrecedenceConcatenateOperatorContext() *PrecedenceConcatenateOperatorContext {
	var p = new(PrecedenceConcatenateOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_precedenceConcatenateOperator
	return p
}

func InitEmptyPrecedenceConcatenateOperatorContext(p *PrecedenceConcatenateOperatorContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_precedenceConcatenateOperator
}

func (*PrecedenceConcatenateOperatorContext) IsPrecedenceConcatenateOperatorContext() {}

func NewPrecedenceConcatenateOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrecedenceConcatenateOperatorContext {
	var p = new(PrecedenceConcatenateOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_precedenceConcatenateOperator

	return p
}

func (s *PrecedenceConcatenateOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *PrecedenceConcatenateOperatorContext) CONCATENATE() antlr.TerminalNode {
	return s.GetToken(HiveParserCONCATENATE, 0)
}

func (s *PrecedenceConcatenateOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrecedenceConcatenateOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PrecedenceConcatenateOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterPrecedenceConcatenateOperator(s)
	}
}

func (s *PrecedenceConcatenateOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitPrecedenceConcatenateOperator(s)
	}
}

func (s *PrecedenceConcatenateOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitPrecedenceConcatenateOperator(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) PrecedenceConcatenateOperator() (localctx IPrecedenceConcatenateOperatorContext) {
	localctx = NewPrecedenceConcatenateOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 818, HiveParserRULE_precedenceConcatenateOperator)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4678)
		p.Match(HiveParserCONCATENATE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPrecedenceConcatenateExpressionContext is an interface to support dynamic dispatch.
type IPrecedenceConcatenateExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPlus returns the plus rule contexts.
	GetPlus() IPrecedencePlusExpressionContext


	// SetPlus sets the plus rule contexts.
	SetPlus(IPrecedencePlusExpressionContext)


	// Getter signatures
	AllPrecedencePlusExpression() []IPrecedencePlusExpressionContext
	PrecedencePlusExpression(i int) IPrecedencePlusExpressionContext
	AllPrecedenceConcatenateOperator() []IPrecedenceConcatenateOperatorContext
	PrecedenceConcatenateOperator(i int) IPrecedenceConcatenateOperatorContext

	// IsPrecedenceConcatenateExpressionContext differentiates from other interfaces.
	IsPrecedenceConcatenateExpressionContext()
}

type PrecedenceConcatenateExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	plus IPrecedencePlusExpressionContext 
}

func NewEmptyPrecedenceConcatenateExpressionContext() *PrecedenceConcatenateExpressionContext {
	var p = new(PrecedenceConcatenateExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_precedenceConcatenateExpression
	return p
}

func InitEmptyPrecedenceConcatenateExpressionContext(p *PrecedenceConcatenateExpressionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_precedenceConcatenateExpression
}

func (*PrecedenceConcatenateExpressionContext) IsPrecedenceConcatenateExpressionContext() {}

func NewPrecedenceConcatenateExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrecedenceConcatenateExpressionContext {
	var p = new(PrecedenceConcatenateExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_precedenceConcatenateExpression

	return p
}

func (s *PrecedenceConcatenateExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PrecedenceConcatenateExpressionContext) GetPlus() IPrecedencePlusExpressionContext { return s.plus }


func (s *PrecedenceConcatenateExpressionContext) SetPlus(v IPrecedencePlusExpressionContext) { s.plus = v }


func (s *PrecedenceConcatenateExpressionContext) AllPrecedencePlusExpression() []IPrecedencePlusExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrecedencePlusExpressionContext); ok {
			len++
		}
	}

	tst := make([]IPrecedencePlusExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrecedencePlusExpressionContext); ok {
			tst[i] = t.(IPrecedencePlusExpressionContext)
			i++
		}
	}

	return tst
}

func (s *PrecedenceConcatenateExpressionContext) PrecedencePlusExpression(i int) IPrecedencePlusExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrecedencePlusExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrecedencePlusExpressionContext)
}

func (s *PrecedenceConcatenateExpressionContext) AllPrecedenceConcatenateOperator() []IPrecedenceConcatenateOperatorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrecedenceConcatenateOperatorContext); ok {
			len++
		}
	}

	tst := make([]IPrecedenceConcatenateOperatorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrecedenceConcatenateOperatorContext); ok {
			tst[i] = t.(IPrecedenceConcatenateOperatorContext)
			i++
		}
	}

	return tst
}

func (s *PrecedenceConcatenateExpressionContext) PrecedenceConcatenateOperator(i int) IPrecedenceConcatenateOperatorContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrecedenceConcatenateOperatorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrecedenceConcatenateOperatorContext)
}

func (s *PrecedenceConcatenateExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrecedenceConcatenateExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PrecedenceConcatenateExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterPrecedenceConcatenateExpression(s)
	}
}

func (s *PrecedenceConcatenateExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitPrecedenceConcatenateExpression(s)
	}
}

func (s *PrecedenceConcatenateExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitPrecedenceConcatenateExpression(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) PrecedenceConcatenateExpression() (localctx IPrecedenceConcatenateExpressionContext) {
	localctx = NewPrecedenceConcatenateExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 820, HiveParserRULE_precedenceConcatenateExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4680)
		p.PrecedencePlusExpression()
	}
	p.SetState(4686)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HiveParserCONCATENATE {
		{
			p.SetState(4681)
			p.PrecedenceConcatenateOperator()
		}
		{
			p.SetState(4682)

			var _x = p.PrecedencePlusExpression()


			localctx.(*PrecedenceConcatenateExpressionContext).plus = _x
		}


		p.SetState(4688)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPrecedenceAmpersandOperatorContext is an interface to support dynamic dispatch.
type IPrecedenceAmpersandOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AMPERSAND() antlr.TerminalNode

	// IsPrecedenceAmpersandOperatorContext differentiates from other interfaces.
	IsPrecedenceAmpersandOperatorContext()
}

type PrecedenceAmpersandOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrecedenceAmpersandOperatorContext() *PrecedenceAmpersandOperatorContext {
	var p = new(PrecedenceAmpersandOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_precedenceAmpersandOperator
	return p
}

func InitEmptyPrecedenceAmpersandOperatorContext(p *PrecedenceAmpersandOperatorContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_precedenceAmpersandOperator
}

func (*PrecedenceAmpersandOperatorContext) IsPrecedenceAmpersandOperatorContext() {}

func NewPrecedenceAmpersandOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrecedenceAmpersandOperatorContext {
	var p = new(PrecedenceAmpersandOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_precedenceAmpersandOperator

	return p
}

func (s *PrecedenceAmpersandOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *PrecedenceAmpersandOperatorContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(HiveParserAMPERSAND, 0)
}

func (s *PrecedenceAmpersandOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrecedenceAmpersandOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PrecedenceAmpersandOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterPrecedenceAmpersandOperator(s)
	}
}

func (s *PrecedenceAmpersandOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitPrecedenceAmpersandOperator(s)
	}
}

func (s *PrecedenceAmpersandOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitPrecedenceAmpersandOperator(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) PrecedenceAmpersandOperator() (localctx IPrecedenceAmpersandOperatorContext) {
	localctx = NewPrecedenceAmpersandOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 822, HiveParserRULE_precedenceAmpersandOperator)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4689)
		p.Match(HiveParserAMPERSAND)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPrecedenceAmpersandExpressionContext is an interface to support dynamic dispatch.
type IPrecedenceAmpersandExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPrecedenceConcatenateExpression() []IPrecedenceConcatenateExpressionContext
	PrecedenceConcatenateExpression(i int) IPrecedenceConcatenateExpressionContext
	AllPrecedenceAmpersandOperator() []IPrecedenceAmpersandOperatorContext
	PrecedenceAmpersandOperator(i int) IPrecedenceAmpersandOperatorContext

	// IsPrecedenceAmpersandExpressionContext differentiates from other interfaces.
	IsPrecedenceAmpersandExpressionContext()
}

type PrecedenceAmpersandExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrecedenceAmpersandExpressionContext() *PrecedenceAmpersandExpressionContext {
	var p = new(PrecedenceAmpersandExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_precedenceAmpersandExpression
	return p
}

func InitEmptyPrecedenceAmpersandExpressionContext(p *PrecedenceAmpersandExpressionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_precedenceAmpersandExpression
}

func (*PrecedenceAmpersandExpressionContext) IsPrecedenceAmpersandExpressionContext() {}

func NewPrecedenceAmpersandExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrecedenceAmpersandExpressionContext {
	var p = new(PrecedenceAmpersandExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_precedenceAmpersandExpression

	return p
}

func (s *PrecedenceAmpersandExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PrecedenceAmpersandExpressionContext) AllPrecedenceConcatenateExpression() []IPrecedenceConcatenateExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrecedenceConcatenateExpressionContext); ok {
			len++
		}
	}

	tst := make([]IPrecedenceConcatenateExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrecedenceConcatenateExpressionContext); ok {
			tst[i] = t.(IPrecedenceConcatenateExpressionContext)
			i++
		}
	}

	return tst
}

func (s *PrecedenceAmpersandExpressionContext) PrecedenceConcatenateExpression(i int) IPrecedenceConcatenateExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrecedenceConcatenateExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrecedenceConcatenateExpressionContext)
}

func (s *PrecedenceAmpersandExpressionContext) AllPrecedenceAmpersandOperator() []IPrecedenceAmpersandOperatorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrecedenceAmpersandOperatorContext); ok {
			len++
		}
	}

	tst := make([]IPrecedenceAmpersandOperatorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrecedenceAmpersandOperatorContext); ok {
			tst[i] = t.(IPrecedenceAmpersandOperatorContext)
			i++
		}
	}

	return tst
}

func (s *PrecedenceAmpersandExpressionContext) PrecedenceAmpersandOperator(i int) IPrecedenceAmpersandOperatorContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrecedenceAmpersandOperatorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrecedenceAmpersandOperatorContext)
}

func (s *PrecedenceAmpersandExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrecedenceAmpersandExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PrecedenceAmpersandExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterPrecedenceAmpersandExpression(s)
	}
}

func (s *PrecedenceAmpersandExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitPrecedenceAmpersandExpression(s)
	}
}

func (s *PrecedenceAmpersandExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitPrecedenceAmpersandExpression(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) PrecedenceAmpersandExpression() (localctx IPrecedenceAmpersandExpressionContext) {
	localctx = NewPrecedenceAmpersandExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 824, HiveParserRULE_precedenceAmpersandExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4691)
		p.PrecedenceConcatenateExpression()
	}
	p.SetState(4697)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HiveParserAMPERSAND {
		{
			p.SetState(4692)
			p.PrecedenceAmpersandOperator()
		}
		{
			p.SetState(4693)
			p.PrecedenceConcatenateExpression()
		}


		p.SetState(4699)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPrecedenceBitwiseOrOperatorContext is an interface to support dynamic dispatch.
type IPrecedenceBitwiseOrOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BITWISEOR() antlr.TerminalNode

	// IsPrecedenceBitwiseOrOperatorContext differentiates from other interfaces.
	IsPrecedenceBitwiseOrOperatorContext()
}

type PrecedenceBitwiseOrOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrecedenceBitwiseOrOperatorContext() *PrecedenceBitwiseOrOperatorContext {
	var p = new(PrecedenceBitwiseOrOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_precedenceBitwiseOrOperator
	return p
}

func InitEmptyPrecedenceBitwiseOrOperatorContext(p *PrecedenceBitwiseOrOperatorContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_precedenceBitwiseOrOperator
}

func (*PrecedenceBitwiseOrOperatorContext) IsPrecedenceBitwiseOrOperatorContext() {}

func NewPrecedenceBitwiseOrOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrecedenceBitwiseOrOperatorContext {
	var p = new(PrecedenceBitwiseOrOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_precedenceBitwiseOrOperator

	return p
}

func (s *PrecedenceBitwiseOrOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *PrecedenceBitwiseOrOperatorContext) BITWISEOR() antlr.TerminalNode {
	return s.GetToken(HiveParserBITWISEOR, 0)
}

func (s *PrecedenceBitwiseOrOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrecedenceBitwiseOrOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PrecedenceBitwiseOrOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterPrecedenceBitwiseOrOperator(s)
	}
}

func (s *PrecedenceBitwiseOrOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitPrecedenceBitwiseOrOperator(s)
	}
}

func (s *PrecedenceBitwiseOrOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitPrecedenceBitwiseOrOperator(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) PrecedenceBitwiseOrOperator() (localctx IPrecedenceBitwiseOrOperatorContext) {
	localctx = NewPrecedenceBitwiseOrOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 826, HiveParserRULE_precedenceBitwiseOrOperator)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4700)
		p.Match(HiveParserBITWISEOR)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPrecedenceBitwiseOrExpressionContext is an interface to support dynamic dispatch.
type IPrecedenceBitwiseOrExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPrecedenceAmpersandExpression() []IPrecedenceAmpersandExpressionContext
	PrecedenceAmpersandExpression(i int) IPrecedenceAmpersandExpressionContext
	AllPrecedenceBitwiseOrOperator() []IPrecedenceBitwiseOrOperatorContext
	PrecedenceBitwiseOrOperator(i int) IPrecedenceBitwiseOrOperatorContext

	// IsPrecedenceBitwiseOrExpressionContext differentiates from other interfaces.
	IsPrecedenceBitwiseOrExpressionContext()
}

type PrecedenceBitwiseOrExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrecedenceBitwiseOrExpressionContext() *PrecedenceBitwiseOrExpressionContext {
	var p = new(PrecedenceBitwiseOrExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_precedenceBitwiseOrExpression
	return p
}

func InitEmptyPrecedenceBitwiseOrExpressionContext(p *PrecedenceBitwiseOrExpressionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_precedenceBitwiseOrExpression
}

func (*PrecedenceBitwiseOrExpressionContext) IsPrecedenceBitwiseOrExpressionContext() {}

func NewPrecedenceBitwiseOrExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrecedenceBitwiseOrExpressionContext {
	var p = new(PrecedenceBitwiseOrExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_precedenceBitwiseOrExpression

	return p
}

func (s *PrecedenceBitwiseOrExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PrecedenceBitwiseOrExpressionContext) AllPrecedenceAmpersandExpression() []IPrecedenceAmpersandExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrecedenceAmpersandExpressionContext); ok {
			len++
		}
	}

	tst := make([]IPrecedenceAmpersandExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrecedenceAmpersandExpressionContext); ok {
			tst[i] = t.(IPrecedenceAmpersandExpressionContext)
			i++
		}
	}

	return tst
}

func (s *PrecedenceBitwiseOrExpressionContext) PrecedenceAmpersandExpression(i int) IPrecedenceAmpersandExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrecedenceAmpersandExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrecedenceAmpersandExpressionContext)
}

func (s *PrecedenceBitwiseOrExpressionContext) AllPrecedenceBitwiseOrOperator() []IPrecedenceBitwiseOrOperatorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrecedenceBitwiseOrOperatorContext); ok {
			len++
		}
	}

	tst := make([]IPrecedenceBitwiseOrOperatorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrecedenceBitwiseOrOperatorContext); ok {
			tst[i] = t.(IPrecedenceBitwiseOrOperatorContext)
			i++
		}
	}

	return tst
}

func (s *PrecedenceBitwiseOrExpressionContext) PrecedenceBitwiseOrOperator(i int) IPrecedenceBitwiseOrOperatorContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrecedenceBitwiseOrOperatorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrecedenceBitwiseOrOperatorContext)
}

func (s *PrecedenceBitwiseOrExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrecedenceBitwiseOrExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PrecedenceBitwiseOrExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterPrecedenceBitwiseOrExpression(s)
	}
}

func (s *PrecedenceBitwiseOrExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitPrecedenceBitwiseOrExpression(s)
	}
}

func (s *PrecedenceBitwiseOrExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitPrecedenceBitwiseOrExpression(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) PrecedenceBitwiseOrExpression() (localctx IPrecedenceBitwiseOrExpressionContext) {
	localctx = NewPrecedenceBitwiseOrExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 828, HiveParserRULE_precedenceBitwiseOrExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4702)
		p.PrecedenceAmpersandExpression()
	}
	p.SetState(4708)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HiveParserBITWISEOR {
		{
			p.SetState(4703)
			p.PrecedenceBitwiseOrOperator()
		}
		{
			p.SetState(4704)
			p.PrecedenceAmpersandExpression()
		}


		p.SetState(4710)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPrecedenceRegexpOperatorContext is an interface to support dynamic dispatch.
type IPrecedenceRegexpOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_LIKE() antlr.TerminalNode
	KW_RLIKE() antlr.TerminalNode
	KW_REGEXP() antlr.TerminalNode

	// IsPrecedenceRegexpOperatorContext differentiates from other interfaces.
	IsPrecedenceRegexpOperatorContext()
}

type PrecedenceRegexpOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrecedenceRegexpOperatorContext() *PrecedenceRegexpOperatorContext {
	var p = new(PrecedenceRegexpOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_precedenceRegexpOperator
	return p
}

func InitEmptyPrecedenceRegexpOperatorContext(p *PrecedenceRegexpOperatorContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_precedenceRegexpOperator
}

func (*PrecedenceRegexpOperatorContext) IsPrecedenceRegexpOperatorContext() {}

func NewPrecedenceRegexpOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrecedenceRegexpOperatorContext {
	var p = new(PrecedenceRegexpOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_precedenceRegexpOperator

	return p
}

func (s *PrecedenceRegexpOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *PrecedenceRegexpOperatorContext) KW_LIKE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_LIKE, 0)
}

func (s *PrecedenceRegexpOperatorContext) KW_RLIKE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_RLIKE, 0)
}

func (s *PrecedenceRegexpOperatorContext) KW_REGEXP() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_REGEXP, 0)
}

func (s *PrecedenceRegexpOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrecedenceRegexpOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PrecedenceRegexpOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterPrecedenceRegexpOperator(s)
	}
}

func (s *PrecedenceRegexpOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitPrecedenceRegexpOperator(s)
	}
}

func (s *PrecedenceRegexpOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitPrecedenceRegexpOperator(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) PrecedenceRegexpOperator() (localctx IPrecedenceRegexpOperatorContext) {
	localctx = NewPrecedenceRegexpOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 830, HiveParserRULE_precedenceRegexpOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4711)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HiveParserKW_LIKE || _la == HiveParserKW_REGEXP || _la == HiveParserKW_RLIKE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPrecedenceSimilarOperatorContext is an interface to support dynamic dispatch.
type IPrecedenceSimilarOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PrecedenceRegexpOperator() IPrecedenceRegexpOperatorContext
	LESSTHANOREQUALTO() antlr.TerminalNode
	LESSTHAN() antlr.TerminalNode
	GREATERTHANOREQUALTO() antlr.TerminalNode
	GREATERTHAN() antlr.TerminalNode

	// IsPrecedenceSimilarOperatorContext differentiates from other interfaces.
	IsPrecedenceSimilarOperatorContext()
}

type PrecedenceSimilarOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrecedenceSimilarOperatorContext() *PrecedenceSimilarOperatorContext {
	var p = new(PrecedenceSimilarOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_precedenceSimilarOperator
	return p
}

func InitEmptyPrecedenceSimilarOperatorContext(p *PrecedenceSimilarOperatorContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_precedenceSimilarOperator
}

func (*PrecedenceSimilarOperatorContext) IsPrecedenceSimilarOperatorContext() {}

func NewPrecedenceSimilarOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrecedenceSimilarOperatorContext {
	var p = new(PrecedenceSimilarOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_precedenceSimilarOperator

	return p
}

func (s *PrecedenceSimilarOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *PrecedenceSimilarOperatorContext) PrecedenceRegexpOperator() IPrecedenceRegexpOperatorContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrecedenceRegexpOperatorContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrecedenceRegexpOperatorContext)
}

func (s *PrecedenceSimilarOperatorContext) LESSTHANOREQUALTO() antlr.TerminalNode {
	return s.GetToken(HiveParserLESSTHANOREQUALTO, 0)
}

func (s *PrecedenceSimilarOperatorContext) LESSTHAN() antlr.TerminalNode {
	return s.GetToken(HiveParserLESSTHAN, 0)
}

func (s *PrecedenceSimilarOperatorContext) GREATERTHANOREQUALTO() antlr.TerminalNode {
	return s.GetToken(HiveParserGREATERTHANOREQUALTO, 0)
}

func (s *PrecedenceSimilarOperatorContext) GREATERTHAN() antlr.TerminalNode {
	return s.GetToken(HiveParserGREATERTHAN, 0)
}

func (s *PrecedenceSimilarOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrecedenceSimilarOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PrecedenceSimilarOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterPrecedenceSimilarOperator(s)
	}
}

func (s *PrecedenceSimilarOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitPrecedenceSimilarOperator(s)
	}
}

func (s *PrecedenceSimilarOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitPrecedenceSimilarOperator(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) PrecedenceSimilarOperator() (localctx IPrecedenceSimilarOperatorContext) {
	localctx = NewPrecedenceSimilarOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 832, HiveParserRULE_precedenceSimilarOperator)
	p.SetState(4718)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserKW_LIKE, HiveParserKW_REGEXP, HiveParserKW_RLIKE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4713)
			p.PrecedenceRegexpOperator()
		}


	case HiveParserLESSTHANOREQUALTO:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4714)
			p.Match(HiveParserLESSTHANOREQUALTO)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HiveParserLESSTHAN:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4715)
			p.Match(HiveParserLESSTHAN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HiveParserGREATERTHANOREQUALTO:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4716)
			p.Match(HiveParserGREATERTHANOREQUALTO)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HiveParserGREATERTHAN:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4717)
			p.Match(HiveParserGREATERTHAN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISubQueryExpressionContext is an interface to support dynamic dispatch.
type ISubQueryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	SelectStatement() ISelectStatementContext
	RPAREN() antlr.TerminalNode

	// IsSubQueryExpressionContext differentiates from other interfaces.
	IsSubQueryExpressionContext()
}

type SubQueryExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubQueryExpressionContext() *SubQueryExpressionContext {
	var p = new(SubQueryExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_subQueryExpression
	return p
}

func InitEmptySubQueryExpressionContext(p *SubQueryExpressionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_subQueryExpression
}

func (*SubQueryExpressionContext) IsSubQueryExpressionContext() {}

func NewSubQueryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubQueryExpressionContext {
	var p = new(SubQueryExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_subQueryExpression

	return p
}

func (s *SubQueryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *SubQueryExpressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserLPAREN, 0)
}

func (s *SubQueryExpressionContext) SelectStatement() ISelectStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *SubQueryExpressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserRPAREN, 0)
}

func (s *SubQueryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubQueryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SubQueryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterSubQueryExpression(s)
	}
}

func (s *SubQueryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitSubQueryExpression(s)
	}
}

func (s *SubQueryExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitSubQueryExpression(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) SubQueryExpression() (localctx ISubQueryExpressionContext) {
	localctx = NewSubQueryExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 834, HiveParserRULE_subQueryExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4720)
		p.Match(HiveParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4721)
		p.SelectStatement()
	}
	{
		p.SetState(4722)
		p.Match(HiveParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPrecedenceSimilarExpressionContext is an interface to support dynamic dispatch.
type IPrecedenceSimilarExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PrecedenceSimilarExpressionMain() IPrecedenceSimilarExpressionMainContext
	KW_EXISTS() antlr.TerminalNode
	SubQueryExpression() ISubQueryExpressionContext

	// IsPrecedenceSimilarExpressionContext differentiates from other interfaces.
	IsPrecedenceSimilarExpressionContext()
}

type PrecedenceSimilarExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrecedenceSimilarExpressionContext() *PrecedenceSimilarExpressionContext {
	var p = new(PrecedenceSimilarExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_precedenceSimilarExpression
	return p
}

func InitEmptyPrecedenceSimilarExpressionContext(p *PrecedenceSimilarExpressionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_precedenceSimilarExpression
}

func (*PrecedenceSimilarExpressionContext) IsPrecedenceSimilarExpressionContext() {}

func NewPrecedenceSimilarExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrecedenceSimilarExpressionContext {
	var p = new(PrecedenceSimilarExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_precedenceSimilarExpression

	return p
}

func (s *PrecedenceSimilarExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PrecedenceSimilarExpressionContext) PrecedenceSimilarExpressionMain() IPrecedenceSimilarExpressionMainContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrecedenceSimilarExpressionMainContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrecedenceSimilarExpressionMainContext)
}

func (s *PrecedenceSimilarExpressionContext) KW_EXISTS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_EXISTS, 0)
}

func (s *PrecedenceSimilarExpressionContext) SubQueryExpression() ISubQueryExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubQueryExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubQueryExpressionContext)
}

func (s *PrecedenceSimilarExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrecedenceSimilarExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PrecedenceSimilarExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterPrecedenceSimilarExpression(s)
	}
}

func (s *PrecedenceSimilarExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitPrecedenceSimilarExpression(s)
	}
}

func (s *PrecedenceSimilarExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitPrecedenceSimilarExpression(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) PrecedenceSimilarExpression() (localctx IPrecedenceSimilarExpressionContext) {
	localctx = NewPrecedenceSimilarExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 836, HiveParserRULE_precedenceSimilarExpression)
	p.SetState(4727)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserKW_ABORT, HiveParserKW_ACTIVATE, HiveParserKW_ACTIVE, HiveParserKW_ADD, HiveParserKW_ADMIN, HiveParserKW_AFTER, HiveParserKW_ALLOC_FRACTION, HiveParserKW_ANALYZE, HiveParserKW_ARCHIVE, HiveParserKW_ARRAY, HiveParserKW_ASC, HiveParserKW_AST, HiveParserKW_AT, HiveParserKW_AUTOCOMMIT, HiveParserKW_BATCH, HiveParserKW_BEFORE, HiveParserKW_BIGINT, HiveParserKW_BINARY, HiveParserKW_BOOLEAN, HiveParserKW_BUCKET, HiveParserKW_BUCKETS, HiveParserKW_CACHE, HiveParserKW_CASCADE, HiveParserKW_CASE, HiveParserKW_CAST, HiveParserKW_CBO, HiveParserKW_CHANGE, HiveParserKW_CHECK, HiveParserKW_CLUSTER, HiveParserKW_CLUSTERED, HiveParserKW_CLUSTERSTATUS, HiveParserKW_COLLECTION, HiveParserKW_COLUMNS, HiveParserKW_COMMENT, HiveParserKW_COMPACT, HiveParserKW_COMPACTIONS, HiveParserKW_COMPUTE, HiveParserKW_CONCATENATE, HiveParserKW_CONTINUE, HiveParserKW_COST, HiveParserKW_CRON, HiveParserKW_CURRENT_DATE, HiveParserKW_CURRENT_TIMESTAMP, HiveParserKW_DATA, HiveParserKW_DATABASES, HiveParserKW_DATE, HiveParserKW_DATETIME, HiveParserKW_DAY, HiveParserKW_DAYOFWEEK, HiveParserKW_DBPROPERTIES, HiveParserKW_DCPROPERTIES, HiveParserKW_DEBUG, HiveParserKW_DEFAULT, HiveParserKW_DEFERRED, HiveParserKW_DEFINED, HiveParserKW_DELIMITED, HiveParserKW_DEPENDENCY, HiveParserKW_DESC, HiveParserKW_DETAIL, HiveParserKW_DIRECTORIES, HiveParserKW_DIRECTORY, HiveParserKW_DISABLE, HiveParserKW_DISTRIBUTE, HiveParserKW_DISTRIBUTED, HiveParserKW_DO, HiveParserKW_DOUBLE, HiveParserKW_DOW, HiveParserKW_DUMP, HiveParserKW_ELEM_TYPE, HiveParserKW_ENABLE, HiveParserKW_ENFORCED, HiveParserKW_ESCAPED, HiveParserKW_EVERY, HiveParserKW_EXCLUSIVE, HiveParserKW_EXECUTE, HiveParserKW_EXECUTED, HiveParserKW_EXPIRE_SNAPSHOTS, HiveParserKW_EXPLAIN, HiveParserKW_EXPORT, HiveParserKW_EXPRESSION, HiveParserKW_EXTRACT, HiveParserKW_FALSE, HiveParserKW_FIELDS, HiveParserKW_FILE, HiveParserKW_FILEFORMAT, HiveParserKW_FIRST, HiveParserKW_FLOAT, HiveParserKW_FLOOR, HiveParserKW_FORMAT, HiveParserKW_FORMATTED, HiveParserKW_FUNCTIONS, HiveParserKW_GROUPING, HiveParserKW_HOLD_DDLTIME, HiveParserKW_HOUR, HiveParserKW_IDXPROPERTIES, HiveParserKW_IF, HiveParserKW_IGNORE, HiveParserKW_INDEX, HiveParserKW_INDEXES, HiveParserKW_INPATH, HiveParserKW_INPUTDRIVER, HiveParserKW_INPUTFORMAT, HiveParserKW_INT, HiveParserKW_INTERVAL, HiveParserKW_ISOLATION, HiveParserKW_ITEMS, HiveParserKW_JAR, HiveParserKW_JOINCOST, HiveParserKW_KEY, HiveParserKW_KEYS, HiveParserKW_KEY_TYPE, HiveParserKW_KILL, HiveParserKW_LAST, HiveParserKW_LEVEL, HiveParserKW_LIMIT, HiveParserKW_LINES, HiveParserKW_LOAD, HiveParserKW_LOCATION, HiveParserKW_LOCK, HiveParserKW_LOCKS, HiveParserKW_LOGICAL, HiveParserKW_LONG, HiveParserKW_MANAGED, HiveParserKW_MANAGEDLOCATION, HiveParserKW_MANAGEMENT, HiveParserKW_MAP, HiveParserKW_MAPJOIN, HiveParserKW_MAPPING, HiveParserKW_MATCHED, HiveParserKW_MATERIALIZED, HiveParserKW_METADATA, HiveParserKW_MINUTE, HiveParserKW_MONTH, HiveParserKW_MOVE, HiveParserKW_MSCK, HiveParserKW_NORELY, HiveParserKW_NOSCAN, HiveParserKW_NOVALIDATE, HiveParserKW_NO_DROP, HiveParserKW_NULL, HiveParserKW_NULLS, HiveParserKW_OFFLINE, HiveParserKW_OFFSET, HiveParserKW_OPERATOR, HiveParserKW_OPTION, HiveParserKW_OUTPUTDRIVER, HiveParserKW_OUTPUTFORMAT, HiveParserKW_OVERWRITE, HiveParserKW_OWNER, HiveParserKW_PARTITIONED, HiveParserKW_PARTITIONS, HiveParserKW_PATH, HiveParserKW_PLAN, HiveParserKW_PLANS, HiveParserKW_PLUS, HiveParserKW_POOL, HiveParserKW_PRINCIPALS, HiveParserKW_PROTECTION, HiveParserKW_PURGE, HiveParserKW_QUARTER, HiveParserKW_QUERY, HiveParserKW_QUERY_PARALLELISM, HiveParserKW_READ, HiveParserKW_READONLY, HiveParserKW_REAL, HiveParserKW_REBUILD, HiveParserKW_RECORDREADER, HiveParserKW_RECORDWRITER, HiveParserKW_RELOAD, HiveParserKW_RELY, HiveParserKW_REMOTE, HiveParserKW_RENAME, HiveParserKW_REOPTIMIZATION, HiveParserKW_REPAIR, HiveParserKW_REPL, HiveParserKW_REPLACE, HiveParserKW_REPLICATION, HiveParserKW_RESOURCE, HiveParserKW_RESPECT, HiveParserKW_RESTRICT, HiveParserKW_REWRITE, HiveParserKW_ROLE, HiveParserKW_ROLES, HiveParserKW_SCHEDULED, HiveParserKW_SCHEDULING_POLICY, HiveParserKW_SCHEMA, HiveParserKW_SCHEMAS, HiveParserKW_SECOND, HiveParserKW_SEMI, HiveParserKW_SERDE, HiveParserKW_SERDEPROPERTIES, HiveParserKW_SERVER, HiveParserKW_SETS, HiveParserKW_SET_CURRENT_SNAPSHOT, HiveParserKW_SHARED, HiveParserKW_SHOW, HiveParserKW_SHOW_DATABASE, HiveParserKW_SKEWED, HiveParserKW_SMALLINT, HiveParserKW_SNAPSHOT, HiveParserKW_SORT, HiveParserKW_SORTED, HiveParserKW_SPEC, HiveParserKW_SSL, HiveParserKW_STATISTICS, HiveParserKW_STATUS, HiveParserKW_STORED, HiveParserKW_STREAMTABLE, HiveParserKW_STRING, HiveParserKW_STRUCT, HiveParserKW_SUMMARY, HiveParserKW_SYSTEM_TIME, HiveParserKW_SYSTEM_VERSION, HiveParserKW_TABLES, HiveParserKW_TBLPROPERTIES, HiveParserKW_TEMPORARY, HiveParserKW_TERMINATED, HiveParserKW_TIMESTAMP, HiveParserKW_TIMESTAMPLOCALTZ, HiveParserKW_TIMESTAMPTZ, HiveParserKW_TINYINT, HiveParserKW_TOUCH, HiveParserKW_TRANSACTION, HiveParserKW_TRANSACTIONAL, HiveParserKW_TRANSACTIONS, HiveParserKW_TRIM, HiveParserKW_TRUE, HiveParserKW_TYPE, HiveParserKW_UNARCHIVE, HiveParserKW_UNDO, HiveParserKW_UNIONTYPE, HiveParserKW_UNKNOWN, HiveParserKW_UNLOCK, HiveParserKW_UNMANAGED, HiveParserKW_UNSET, HiveParserKW_UNSIGNED, HiveParserKW_URI, HiveParserKW_URL, HiveParserKW_USE, HiveParserKW_UTC, HiveParserKW_UTCTIMESTAMP, HiveParserKW_VALIDATE, HiveParserKW_VALUE_TYPE, HiveParserKW_VECTORIZATION, HiveParserKW_VIEW, HiveParserKW_VIEWS, HiveParserKW_WAIT, HiveParserKW_WEEK, HiveParserKW_WHILE, HiveParserKW_WITHIN, HiveParserKW_WORK, HiveParserKW_WORKLOAD, HiveParserKW_WRITE, HiveParserKW_YEAR, HiveParserKW_ZONE, HiveParserLPAREN, HiveParserPLUS, HiveParserMINUS, HiveParserTILDE, HiveParserQUESTION, HiveParserStringLiteral, HiveParserIntegralLiteral, HiveParserNumberLiteral, HiveParserNumber, HiveParserIdentifier, HiveParserCharSetName:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4724)
			p.PrecedenceSimilarExpressionMain()
		}


	case HiveParserKW_EXISTS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4725)
			p.Match(HiveParserKW_EXISTS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4726)
			p.SubQueryExpression()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPrecedenceSimilarExpressionMainContext is an interface to support dynamic dispatch.
type IPrecedenceSimilarExpressionMainContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetA returns the a rule contexts.
	GetA() IPrecedenceBitwiseOrExpressionContext

	// GetPart returns the part rule contexts.
	GetPart() IPrecedenceSimilarExpressionPartContext


	// SetA sets the a rule contexts.
	SetA(IPrecedenceBitwiseOrExpressionContext)

	// SetPart sets the part rule contexts.
	SetPart(IPrecedenceSimilarExpressionPartContext)


	// Getter signatures
	PrecedenceBitwiseOrExpression() IPrecedenceBitwiseOrExpressionContext
	PrecedenceSimilarExpressionPart() IPrecedenceSimilarExpressionPartContext

	// IsPrecedenceSimilarExpressionMainContext differentiates from other interfaces.
	IsPrecedenceSimilarExpressionMainContext()
}

type PrecedenceSimilarExpressionMainContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	a IPrecedenceBitwiseOrExpressionContext 
	part IPrecedenceSimilarExpressionPartContext 
}

func NewEmptyPrecedenceSimilarExpressionMainContext() *PrecedenceSimilarExpressionMainContext {
	var p = new(PrecedenceSimilarExpressionMainContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_precedenceSimilarExpressionMain
	return p
}

func InitEmptyPrecedenceSimilarExpressionMainContext(p *PrecedenceSimilarExpressionMainContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_precedenceSimilarExpressionMain
}

func (*PrecedenceSimilarExpressionMainContext) IsPrecedenceSimilarExpressionMainContext() {}

func NewPrecedenceSimilarExpressionMainContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrecedenceSimilarExpressionMainContext {
	var p = new(PrecedenceSimilarExpressionMainContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_precedenceSimilarExpressionMain

	return p
}

func (s *PrecedenceSimilarExpressionMainContext) GetParser() antlr.Parser { return s.parser }

func (s *PrecedenceSimilarExpressionMainContext) GetA() IPrecedenceBitwiseOrExpressionContext { return s.a }

func (s *PrecedenceSimilarExpressionMainContext) GetPart() IPrecedenceSimilarExpressionPartContext { return s.part }


func (s *PrecedenceSimilarExpressionMainContext) SetA(v IPrecedenceBitwiseOrExpressionContext) { s.a = v }

func (s *PrecedenceSimilarExpressionMainContext) SetPart(v IPrecedenceSimilarExpressionPartContext) { s.part = v }


func (s *PrecedenceSimilarExpressionMainContext) PrecedenceBitwiseOrExpression() IPrecedenceBitwiseOrExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrecedenceBitwiseOrExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrecedenceBitwiseOrExpressionContext)
}

func (s *PrecedenceSimilarExpressionMainContext) PrecedenceSimilarExpressionPart() IPrecedenceSimilarExpressionPartContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrecedenceSimilarExpressionPartContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrecedenceSimilarExpressionPartContext)
}

func (s *PrecedenceSimilarExpressionMainContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrecedenceSimilarExpressionMainContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PrecedenceSimilarExpressionMainContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterPrecedenceSimilarExpressionMain(s)
	}
}

func (s *PrecedenceSimilarExpressionMainContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitPrecedenceSimilarExpressionMain(s)
	}
}

func (s *PrecedenceSimilarExpressionMainContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitPrecedenceSimilarExpressionMain(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) PrecedenceSimilarExpressionMain() (localctx IPrecedenceSimilarExpressionMainContext) {
	localctx = NewPrecedenceSimilarExpressionMainContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 838, HiveParserRULE_precedenceSimilarExpressionMain)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4729)

		var _x = p.PrecedenceBitwiseOrExpression()


		localctx.(*PrecedenceSimilarExpressionMainContext).a = _x
	}
	p.SetState(4731)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 560, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4730)

			var _x = p.PrecedenceSimilarExpressionPart()


			localctx.(*PrecedenceSimilarExpressionMainContext).part = _x
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPrecedenceSimilarExpressionPartContext is an interface to support dynamic dispatch.
type IPrecedenceSimilarExpressionPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetEqualExpr returns the equalExpr rule contexts.
	GetEqualExpr() IPrecedenceBitwiseOrExpressionContext


	// SetEqualExpr sets the equalExpr rule contexts.
	SetEqualExpr(IPrecedenceBitwiseOrExpressionContext)


	// Getter signatures
	PrecedenceSimilarOperator() IPrecedenceSimilarOperatorContext
	PrecedenceBitwiseOrExpression() IPrecedenceBitwiseOrExpressionContext
	PrecedenceSimilarExpressionAtom() IPrecedenceSimilarExpressionAtomContext
	KW_NOT() antlr.TerminalNode
	PrecedenceSimilarExpressionPartNot() IPrecedenceSimilarExpressionPartNotContext

	// IsPrecedenceSimilarExpressionPartContext differentiates from other interfaces.
	IsPrecedenceSimilarExpressionPartContext()
}

type PrecedenceSimilarExpressionPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	equalExpr IPrecedenceBitwiseOrExpressionContext 
}

func NewEmptyPrecedenceSimilarExpressionPartContext() *PrecedenceSimilarExpressionPartContext {
	var p = new(PrecedenceSimilarExpressionPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_precedenceSimilarExpressionPart
	return p
}

func InitEmptyPrecedenceSimilarExpressionPartContext(p *PrecedenceSimilarExpressionPartContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_precedenceSimilarExpressionPart
}

func (*PrecedenceSimilarExpressionPartContext) IsPrecedenceSimilarExpressionPartContext() {}

func NewPrecedenceSimilarExpressionPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrecedenceSimilarExpressionPartContext {
	var p = new(PrecedenceSimilarExpressionPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_precedenceSimilarExpressionPart

	return p
}

func (s *PrecedenceSimilarExpressionPartContext) GetParser() antlr.Parser { return s.parser }

func (s *PrecedenceSimilarExpressionPartContext) GetEqualExpr() IPrecedenceBitwiseOrExpressionContext { return s.equalExpr }


func (s *PrecedenceSimilarExpressionPartContext) SetEqualExpr(v IPrecedenceBitwiseOrExpressionContext) { s.equalExpr = v }


func (s *PrecedenceSimilarExpressionPartContext) PrecedenceSimilarOperator() IPrecedenceSimilarOperatorContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrecedenceSimilarOperatorContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrecedenceSimilarOperatorContext)
}

func (s *PrecedenceSimilarExpressionPartContext) PrecedenceBitwiseOrExpression() IPrecedenceBitwiseOrExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrecedenceBitwiseOrExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrecedenceBitwiseOrExpressionContext)
}

func (s *PrecedenceSimilarExpressionPartContext) PrecedenceSimilarExpressionAtom() IPrecedenceSimilarExpressionAtomContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrecedenceSimilarExpressionAtomContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrecedenceSimilarExpressionAtomContext)
}

func (s *PrecedenceSimilarExpressionPartContext) KW_NOT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_NOT, 0)
}

func (s *PrecedenceSimilarExpressionPartContext) PrecedenceSimilarExpressionPartNot() IPrecedenceSimilarExpressionPartNotContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrecedenceSimilarExpressionPartNotContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrecedenceSimilarExpressionPartNotContext)
}

func (s *PrecedenceSimilarExpressionPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrecedenceSimilarExpressionPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PrecedenceSimilarExpressionPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterPrecedenceSimilarExpressionPart(s)
	}
}

func (s *PrecedenceSimilarExpressionPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitPrecedenceSimilarExpressionPart(s)
	}
}

func (s *PrecedenceSimilarExpressionPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitPrecedenceSimilarExpressionPart(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) PrecedenceSimilarExpressionPart() (localctx IPrecedenceSimilarExpressionPartContext) {
	localctx = NewPrecedenceSimilarExpressionPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 840, HiveParserRULE_precedenceSimilarExpressionPart)
	p.SetState(4739)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 561, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4733)
			p.PrecedenceSimilarOperator()
		}
		{
			p.SetState(4734)

			var _x = p.PrecedenceBitwiseOrExpression()


			localctx.(*PrecedenceSimilarExpressionPartContext).equalExpr = _x
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4736)
			p.PrecedenceSimilarExpressionAtom()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4737)
			p.Match(HiveParserKW_NOT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4738)
			p.PrecedenceSimilarExpressionPartNot()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPrecedenceSimilarExpressionAtomContext is an interface to support dynamic dispatch.
type IPrecedenceSimilarExpressionAtomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetMin returns the min rule contexts.
	GetMin() IPrecedenceBitwiseOrExpressionContext

	// GetMax returns the max rule contexts.
	GetMax() IPrecedenceBitwiseOrExpressionContext

	// GetExpr returns the expr rule contexts.
	GetExpr() IExpressionsInParenthesisContext


	// SetMin sets the min rule contexts.
	SetMin(IPrecedenceBitwiseOrExpressionContext)

	// SetMax sets the max rule contexts.
	SetMax(IPrecedenceBitwiseOrExpressionContext)

	// SetExpr sets the expr rule contexts.
	SetExpr(IExpressionsInParenthesisContext)


	// Getter signatures
	KW_IN() antlr.TerminalNode
	PrecedenceSimilarExpressionIn() IPrecedenceSimilarExpressionInContext
	KW_BETWEEN() antlr.TerminalNode
	KW_AND() antlr.TerminalNode
	AllPrecedenceBitwiseOrExpression() []IPrecedenceBitwiseOrExpressionContext
	PrecedenceBitwiseOrExpression(i int) IPrecedenceBitwiseOrExpressionContext
	KW_LIKE() antlr.TerminalNode
	KW_ANY() antlr.TerminalNode
	KW_ALL() antlr.TerminalNode
	ExpressionsInParenthesis() IExpressionsInParenthesisContext
	PrecedenceSimilarExpressionQuantifierPredicate() IPrecedenceSimilarExpressionQuantifierPredicateContext

	// IsPrecedenceSimilarExpressionAtomContext differentiates from other interfaces.
	IsPrecedenceSimilarExpressionAtomContext()
}

type PrecedenceSimilarExpressionAtomContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	min IPrecedenceBitwiseOrExpressionContext 
	max IPrecedenceBitwiseOrExpressionContext 
	expr IExpressionsInParenthesisContext 
}

func NewEmptyPrecedenceSimilarExpressionAtomContext() *PrecedenceSimilarExpressionAtomContext {
	var p = new(PrecedenceSimilarExpressionAtomContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_precedenceSimilarExpressionAtom
	return p
}

func InitEmptyPrecedenceSimilarExpressionAtomContext(p *PrecedenceSimilarExpressionAtomContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_precedenceSimilarExpressionAtom
}

func (*PrecedenceSimilarExpressionAtomContext) IsPrecedenceSimilarExpressionAtomContext() {}

func NewPrecedenceSimilarExpressionAtomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrecedenceSimilarExpressionAtomContext {
	var p = new(PrecedenceSimilarExpressionAtomContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_precedenceSimilarExpressionAtom

	return p
}

func (s *PrecedenceSimilarExpressionAtomContext) GetParser() antlr.Parser { return s.parser }

func (s *PrecedenceSimilarExpressionAtomContext) GetMin() IPrecedenceBitwiseOrExpressionContext { return s.min }

func (s *PrecedenceSimilarExpressionAtomContext) GetMax() IPrecedenceBitwiseOrExpressionContext { return s.max }

func (s *PrecedenceSimilarExpressionAtomContext) GetExpr() IExpressionsInParenthesisContext { return s.expr }


func (s *PrecedenceSimilarExpressionAtomContext) SetMin(v IPrecedenceBitwiseOrExpressionContext) { s.min = v }

func (s *PrecedenceSimilarExpressionAtomContext) SetMax(v IPrecedenceBitwiseOrExpressionContext) { s.max = v }

func (s *PrecedenceSimilarExpressionAtomContext) SetExpr(v IExpressionsInParenthesisContext) { s.expr = v }


func (s *PrecedenceSimilarExpressionAtomContext) KW_IN() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_IN, 0)
}

func (s *PrecedenceSimilarExpressionAtomContext) PrecedenceSimilarExpressionIn() IPrecedenceSimilarExpressionInContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrecedenceSimilarExpressionInContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrecedenceSimilarExpressionInContext)
}

func (s *PrecedenceSimilarExpressionAtomContext) KW_BETWEEN() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_BETWEEN, 0)
}

func (s *PrecedenceSimilarExpressionAtomContext) KW_AND() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_AND, 0)
}

func (s *PrecedenceSimilarExpressionAtomContext) AllPrecedenceBitwiseOrExpression() []IPrecedenceBitwiseOrExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrecedenceBitwiseOrExpressionContext); ok {
			len++
		}
	}

	tst := make([]IPrecedenceBitwiseOrExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrecedenceBitwiseOrExpressionContext); ok {
			tst[i] = t.(IPrecedenceBitwiseOrExpressionContext)
			i++
		}
	}

	return tst
}

func (s *PrecedenceSimilarExpressionAtomContext) PrecedenceBitwiseOrExpression(i int) IPrecedenceBitwiseOrExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrecedenceBitwiseOrExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrecedenceBitwiseOrExpressionContext)
}

func (s *PrecedenceSimilarExpressionAtomContext) KW_LIKE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_LIKE, 0)
}

func (s *PrecedenceSimilarExpressionAtomContext) KW_ANY() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ANY, 0)
}

func (s *PrecedenceSimilarExpressionAtomContext) KW_ALL() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ALL, 0)
}

func (s *PrecedenceSimilarExpressionAtomContext) ExpressionsInParenthesis() IExpressionsInParenthesisContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionsInParenthesisContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionsInParenthesisContext)
}

func (s *PrecedenceSimilarExpressionAtomContext) PrecedenceSimilarExpressionQuantifierPredicate() IPrecedenceSimilarExpressionQuantifierPredicateContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrecedenceSimilarExpressionQuantifierPredicateContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrecedenceSimilarExpressionQuantifierPredicateContext)
}

func (s *PrecedenceSimilarExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrecedenceSimilarExpressionAtomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PrecedenceSimilarExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterPrecedenceSimilarExpressionAtom(s)
	}
}

func (s *PrecedenceSimilarExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitPrecedenceSimilarExpressionAtom(s)
	}
}

func (s *PrecedenceSimilarExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitPrecedenceSimilarExpressionAtom(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) PrecedenceSimilarExpressionAtom() (localctx IPrecedenceSimilarExpressionAtomContext) {
	localctx = NewPrecedenceSimilarExpressionAtomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 842, HiveParserRULE_precedenceSimilarExpressionAtom)
	var _la int

	p.SetState(4752)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserKW_IN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4741)
			p.Match(HiveParserKW_IN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4742)
			p.PrecedenceSimilarExpressionIn()
		}


	case HiveParserKW_BETWEEN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4743)
			p.Match(HiveParserKW_BETWEEN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4744)

			var _x = p.PrecedenceBitwiseOrExpression()


			localctx.(*PrecedenceSimilarExpressionAtomContext).min = _x
		}
		{
			p.SetState(4745)
			p.Match(HiveParserKW_AND)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4746)

			var _x = p.PrecedenceBitwiseOrExpression()


			localctx.(*PrecedenceSimilarExpressionAtomContext).max = _x
		}


	case HiveParserKW_LIKE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4748)
			p.Match(HiveParserKW_LIKE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4749)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HiveParserKW_ALL || _la == HiveParserKW_ANY) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(4750)

			var _x = p.ExpressionsInParenthesis()


			localctx.(*PrecedenceSimilarExpressionAtomContext).expr = _x
		}


	case HiveParserEQUAL, HiveParserNOTEQUAL, HiveParserLESSTHANOREQUALTO, HiveParserLESSTHAN, HiveParserGREATERTHANOREQUALTO, HiveParserGREATERTHAN:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4751)
			p.PrecedenceSimilarExpressionQuantifierPredicate()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPrecedenceSimilarExpressionQuantifierPredicateContext is an interface to support dynamic dispatch.
type IPrecedenceSimilarExpressionQuantifierPredicateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SubQuerySelectorOperator() ISubQuerySelectorOperatorContext
	QuantifierType() IQuantifierTypeContext
	SubQueryExpression() ISubQueryExpressionContext

	// IsPrecedenceSimilarExpressionQuantifierPredicateContext differentiates from other interfaces.
	IsPrecedenceSimilarExpressionQuantifierPredicateContext()
}

type PrecedenceSimilarExpressionQuantifierPredicateContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrecedenceSimilarExpressionQuantifierPredicateContext() *PrecedenceSimilarExpressionQuantifierPredicateContext {
	var p = new(PrecedenceSimilarExpressionQuantifierPredicateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_precedenceSimilarExpressionQuantifierPredicate
	return p
}

func InitEmptyPrecedenceSimilarExpressionQuantifierPredicateContext(p *PrecedenceSimilarExpressionQuantifierPredicateContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_precedenceSimilarExpressionQuantifierPredicate
}

func (*PrecedenceSimilarExpressionQuantifierPredicateContext) IsPrecedenceSimilarExpressionQuantifierPredicateContext() {}

func NewPrecedenceSimilarExpressionQuantifierPredicateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrecedenceSimilarExpressionQuantifierPredicateContext {
	var p = new(PrecedenceSimilarExpressionQuantifierPredicateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_precedenceSimilarExpressionQuantifierPredicate

	return p
}

func (s *PrecedenceSimilarExpressionQuantifierPredicateContext) GetParser() antlr.Parser { return s.parser }

func (s *PrecedenceSimilarExpressionQuantifierPredicateContext) SubQuerySelectorOperator() ISubQuerySelectorOperatorContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubQuerySelectorOperatorContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubQuerySelectorOperatorContext)
}

func (s *PrecedenceSimilarExpressionQuantifierPredicateContext) QuantifierType() IQuantifierTypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuantifierTypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuantifierTypeContext)
}

func (s *PrecedenceSimilarExpressionQuantifierPredicateContext) SubQueryExpression() ISubQueryExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubQueryExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubQueryExpressionContext)
}

func (s *PrecedenceSimilarExpressionQuantifierPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrecedenceSimilarExpressionQuantifierPredicateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PrecedenceSimilarExpressionQuantifierPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterPrecedenceSimilarExpressionQuantifierPredicate(s)
	}
}

func (s *PrecedenceSimilarExpressionQuantifierPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitPrecedenceSimilarExpressionQuantifierPredicate(s)
	}
}

func (s *PrecedenceSimilarExpressionQuantifierPredicateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitPrecedenceSimilarExpressionQuantifierPredicate(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) PrecedenceSimilarExpressionQuantifierPredicate() (localctx IPrecedenceSimilarExpressionQuantifierPredicateContext) {
	localctx = NewPrecedenceSimilarExpressionQuantifierPredicateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 844, HiveParserRULE_precedenceSimilarExpressionQuantifierPredicate)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4754)
		p.SubQuerySelectorOperator()
	}
	{
		p.SetState(4755)
		p.QuantifierType()
	}
	{
		p.SetState(4756)
		p.SubQueryExpression()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IQuantifierTypeContext is an interface to support dynamic dispatch.
type IQuantifierTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_ANY() antlr.TerminalNode
	KW_SOME() antlr.TerminalNode
	KW_ALL() antlr.TerminalNode

	// IsQuantifierTypeContext differentiates from other interfaces.
	IsQuantifierTypeContext()
}

type QuantifierTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuantifierTypeContext() *QuantifierTypeContext {
	var p = new(QuantifierTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_quantifierType
	return p
}

func InitEmptyQuantifierTypeContext(p *QuantifierTypeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_quantifierType
}

func (*QuantifierTypeContext) IsQuantifierTypeContext() {}

func NewQuantifierTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuantifierTypeContext {
	var p = new(QuantifierTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_quantifierType

	return p
}

func (s *QuantifierTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *QuantifierTypeContext) KW_ANY() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ANY, 0)
}

func (s *QuantifierTypeContext) KW_SOME() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SOME, 0)
}

func (s *QuantifierTypeContext) KW_ALL() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ALL, 0)
}

func (s *QuantifierTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuantifierTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *QuantifierTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterQuantifierType(s)
	}
}

func (s *QuantifierTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitQuantifierType(s)
	}
}

func (s *QuantifierTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitQuantifierType(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) QuantifierType() (localctx IQuantifierTypeContext) {
	localctx = NewQuantifierTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 846, HiveParserRULE_quantifierType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4758)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HiveParserKW_ALL || _la == HiveParserKW_ANY || _la == HiveParserKW_SOME) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPrecedenceSimilarExpressionInContext is an interface to support dynamic dispatch.
type IPrecedenceSimilarExpressionInContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetExpr returns the expr rule contexts.
	GetExpr() IExpressionsInParenthesisContext


	// SetExpr sets the expr rule contexts.
	SetExpr(IExpressionsInParenthesisContext)


	// Getter signatures
	SubQueryExpression() ISubQueryExpressionContext
	ExpressionsInParenthesis() IExpressionsInParenthesisContext

	// IsPrecedenceSimilarExpressionInContext differentiates from other interfaces.
	IsPrecedenceSimilarExpressionInContext()
}

type PrecedenceSimilarExpressionInContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	expr IExpressionsInParenthesisContext 
}

func NewEmptyPrecedenceSimilarExpressionInContext() *PrecedenceSimilarExpressionInContext {
	var p = new(PrecedenceSimilarExpressionInContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_precedenceSimilarExpressionIn
	return p
}

func InitEmptyPrecedenceSimilarExpressionInContext(p *PrecedenceSimilarExpressionInContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_precedenceSimilarExpressionIn
}

func (*PrecedenceSimilarExpressionInContext) IsPrecedenceSimilarExpressionInContext() {}

func NewPrecedenceSimilarExpressionInContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrecedenceSimilarExpressionInContext {
	var p = new(PrecedenceSimilarExpressionInContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_precedenceSimilarExpressionIn

	return p
}

func (s *PrecedenceSimilarExpressionInContext) GetParser() antlr.Parser { return s.parser }

func (s *PrecedenceSimilarExpressionInContext) GetExpr() IExpressionsInParenthesisContext { return s.expr }


func (s *PrecedenceSimilarExpressionInContext) SetExpr(v IExpressionsInParenthesisContext) { s.expr = v }


func (s *PrecedenceSimilarExpressionInContext) SubQueryExpression() ISubQueryExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubQueryExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubQueryExpressionContext)
}

func (s *PrecedenceSimilarExpressionInContext) ExpressionsInParenthesis() IExpressionsInParenthesisContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionsInParenthesisContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionsInParenthesisContext)
}

func (s *PrecedenceSimilarExpressionInContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrecedenceSimilarExpressionInContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PrecedenceSimilarExpressionInContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterPrecedenceSimilarExpressionIn(s)
	}
}

func (s *PrecedenceSimilarExpressionInContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitPrecedenceSimilarExpressionIn(s)
	}
}

func (s *PrecedenceSimilarExpressionInContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitPrecedenceSimilarExpressionIn(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) PrecedenceSimilarExpressionIn() (localctx IPrecedenceSimilarExpressionInContext) {
	localctx = NewPrecedenceSimilarExpressionInContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 848, HiveParserRULE_precedenceSimilarExpressionIn)
	p.SetState(4762)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 563, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4760)
			p.SubQueryExpression()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4761)

			var _x = p.ExpressionsInParenthesis()


			localctx.(*PrecedenceSimilarExpressionInContext).expr = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPrecedenceSimilarExpressionPartNotContext is an interface to support dynamic dispatch.
type IPrecedenceSimilarExpressionPartNotContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetNotExpr returns the notExpr rule contexts.
	GetNotExpr() IPrecedenceBitwiseOrExpressionContext


	// SetNotExpr sets the notExpr rule contexts.
	SetNotExpr(IPrecedenceBitwiseOrExpressionContext)


	// Getter signatures
	PrecedenceRegexpOperator() IPrecedenceRegexpOperatorContext
	PrecedenceBitwiseOrExpression() IPrecedenceBitwiseOrExpressionContext
	PrecedenceSimilarExpressionAtom() IPrecedenceSimilarExpressionAtomContext

	// IsPrecedenceSimilarExpressionPartNotContext differentiates from other interfaces.
	IsPrecedenceSimilarExpressionPartNotContext()
}

type PrecedenceSimilarExpressionPartNotContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	notExpr IPrecedenceBitwiseOrExpressionContext 
}

func NewEmptyPrecedenceSimilarExpressionPartNotContext() *PrecedenceSimilarExpressionPartNotContext {
	var p = new(PrecedenceSimilarExpressionPartNotContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_precedenceSimilarExpressionPartNot
	return p
}

func InitEmptyPrecedenceSimilarExpressionPartNotContext(p *PrecedenceSimilarExpressionPartNotContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_precedenceSimilarExpressionPartNot
}

func (*PrecedenceSimilarExpressionPartNotContext) IsPrecedenceSimilarExpressionPartNotContext() {}

func NewPrecedenceSimilarExpressionPartNotContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrecedenceSimilarExpressionPartNotContext {
	var p = new(PrecedenceSimilarExpressionPartNotContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_precedenceSimilarExpressionPartNot

	return p
}

func (s *PrecedenceSimilarExpressionPartNotContext) GetParser() antlr.Parser { return s.parser }

func (s *PrecedenceSimilarExpressionPartNotContext) GetNotExpr() IPrecedenceBitwiseOrExpressionContext { return s.notExpr }


func (s *PrecedenceSimilarExpressionPartNotContext) SetNotExpr(v IPrecedenceBitwiseOrExpressionContext) { s.notExpr = v }


func (s *PrecedenceSimilarExpressionPartNotContext) PrecedenceRegexpOperator() IPrecedenceRegexpOperatorContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrecedenceRegexpOperatorContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrecedenceRegexpOperatorContext)
}

func (s *PrecedenceSimilarExpressionPartNotContext) PrecedenceBitwiseOrExpression() IPrecedenceBitwiseOrExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrecedenceBitwiseOrExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrecedenceBitwiseOrExpressionContext)
}

func (s *PrecedenceSimilarExpressionPartNotContext) PrecedenceSimilarExpressionAtom() IPrecedenceSimilarExpressionAtomContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrecedenceSimilarExpressionAtomContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrecedenceSimilarExpressionAtomContext)
}

func (s *PrecedenceSimilarExpressionPartNotContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrecedenceSimilarExpressionPartNotContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PrecedenceSimilarExpressionPartNotContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterPrecedenceSimilarExpressionPartNot(s)
	}
}

func (s *PrecedenceSimilarExpressionPartNotContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitPrecedenceSimilarExpressionPartNot(s)
	}
}

func (s *PrecedenceSimilarExpressionPartNotContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitPrecedenceSimilarExpressionPartNot(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) PrecedenceSimilarExpressionPartNot() (localctx IPrecedenceSimilarExpressionPartNotContext) {
	localctx = NewPrecedenceSimilarExpressionPartNotContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 850, HiveParserRULE_precedenceSimilarExpressionPartNot)
	p.SetState(4768)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 564, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4764)
			p.PrecedenceRegexpOperator()
		}
		{
			p.SetState(4765)

			var _x = p.PrecedenceBitwiseOrExpression()


			localctx.(*PrecedenceSimilarExpressionPartNotContext).notExpr = _x
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4767)
			p.PrecedenceSimilarExpressionAtom()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPrecedenceDistinctOperatorContext is an interface to support dynamic dispatch.
type IPrecedenceDistinctOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_IS() antlr.TerminalNode
	KW_DISTINCT() antlr.TerminalNode
	KW_FROM() antlr.TerminalNode

	// IsPrecedenceDistinctOperatorContext differentiates from other interfaces.
	IsPrecedenceDistinctOperatorContext()
}

type PrecedenceDistinctOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrecedenceDistinctOperatorContext() *PrecedenceDistinctOperatorContext {
	var p = new(PrecedenceDistinctOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_precedenceDistinctOperator
	return p
}

func InitEmptyPrecedenceDistinctOperatorContext(p *PrecedenceDistinctOperatorContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_precedenceDistinctOperator
}

func (*PrecedenceDistinctOperatorContext) IsPrecedenceDistinctOperatorContext() {}

func NewPrecedenceDistinctOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrecedenceDistinctOperatorContext {
	var p = new(PrecedenceDistinctOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_precedenceDistinctOperator

	return p
}

func (s *PrecedenceDistinctOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *PrecedenceDistinctOperatorContext) KW_IS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_IS, 0)
}

func (s *PrecedenceDistinctOperatorContext) KW_DISTINCT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DISTINCT, 0)
}

func (s *PrecedenceDistinctOperatorContext) KW_FROM() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_FROM, 0)
}

func (s *PrecedenceDistinctOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrecedenceDistinctOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PrecedenceDistinctOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterPrecedenceDistinctOperator(s)
	}
}

func (s *PrecedenceDistinctOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitPrecedenceDistinctOperator(s)
	}
}

func (s *PrecedenceDistinctOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitPrecedenceDistinctOperator(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) PrecedenceDistinctOperator() (localctx IPrecedenceDistinctOperatorContext) {
	localctx = NewPrecedenceDistinctOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 852, HiveParserRULE_precedenceDistinctOperator)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4770)
		p.Match(HiveParserKW_IS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4771)
		p.Match(HiveParserKW_DISTINCT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4772)
		p.Match(HiveParserKW_FROM)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPrecedenceEqualOperatorContext is an interface to support dynamic dispatch.
type IPrecedenceEqualOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EQUAL() antlr.TerminalNode
	EQUAL_NS() antlr.TerminalNode
	NOTEQUAL() antlr.TerminalNode
	KW_IS() antlr.TerminalNode
	KW_NOT() antlr.TerminalNode
	KW_DISTINCT() antlr.TerminalNode
	KW_FROM() antlr.TerminalNode

	// IsPrecedenceEqualOperatorContext differentiates from other interfaces.
	IsPrecedenceEqualOperatorContext()
}

type PrecedenceEqualOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrecedenceEqualOperatorContext() *PrecedenceEqualOperatorContext {
	var p = new(PrecedenceEqualOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_precedenceEqualOperator
	return p
}

func InitEmptyPrecedenceEqualOperatorContext(p *PrecedenceEqualOperatorContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_precedenceEqualOperator
}

func (*PrecedenceEqualOperatorContext) IsPrecedenceEqualOperatorContext() {}

func NewPrecedenceEqualOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrecedenceEqualOperatorContext {
	var p = new(PrecedenceEqualOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_precedenceEqualOperator

	return p
}

func (s *PrecedenceEqualOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *PrecedenceEqualOperatorContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(HiveParserEQUAL, 0)
}

func (s *PrecedenceEqualOperatorContext) EQUAL_NS() antlr.TerminalNode {
	return s.GetToken(HiveParserEQUAL_NS, 0)
}

func (s *PrecedenceEqualOperatorContext) NOTEQUAL() antlr.TerminalNode {
	return s.GetToken(HiveParserNOTEQUAL, 0)
}

func (s *PrecedenceEqualOperatorContext) KW_IS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_IS, 0)
}

func (s *PrecedenceEqualOperatorContext) KW_NOT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_NOT, 0)
}

func (s *PrecedenceEqualOperatorContext) KW_DISTINCT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DISTINCT, 0)
}

func (s *PrecedenceEqualOperatorContext) KW_FROM() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_FROM, 0)
}

func (s *PrecedenceEqualOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrecedenceEqualOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PrecedenceEqualOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterPrecedenceEqualOperator(s)
	}
}

func (s *PrecedenceEqualOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitPrecedenceEqualOperator(s)
	}
}

func (s *PrecedenceEqualOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitPrecedenceEqualOperator(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) PrecedenceEqualOperator() (localctx IPrecedenceEqualOperatorContext) {
	localctx = NewPrecedenceEqualOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 854, HiveParserRULE_precedenceEqualOperator)
	p.SetState(4781)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserEQUAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4774)
			p.Match(HiveParserEQUAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HiveParserEQUAL_NS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4775)
			p.Match(HiveParserEQUAL_NS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HiveParserNOTEQUAL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4776)
			p.Match(HiveParserNOTEQUAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HiveParserKW_IS:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4777)
			p.Match(HiveParserKW_IS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4778)
			p.Match(HiveParserKW_NOT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4779)
			p.Match(HiveParserKW_DISTINCT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4780)
			p.Match(HiveParserKW_FROM)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPrecedenceEqualExpressionContext is an interface to support dynamic dispatch.
type IPrecedenceEqualExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_precedenceEqualOperator returns the _precedenceEqualOperator rule contexts.
	Get_precedenceEqualOperator() IPrecedenceEqualOperatorContext

	// Get_precedenceSimilarExpression returns the _precedenceSimilarExpression rule contexts.
	Get_precedenceSimilarExpression() IPrecedenceSimilarExpressionContext

	// Get_precedenceDistinctOperator returns the _precedenceDistinctOperator rule contexts.
	Get_precedenceDistinctOperator() IPrecedenceDistinctOperatorContext


	// Set_precedenceEqualOperator sets the _precedenceEqualOperator rule contexts.
	Set_precedenceEqualOperator(IPrecedenceEqualOperatorContext)

	// Set_precedenceSimilarExpression sets the _precedenceSimilarExpression rule contexts.
	Set_precedenceSimilarExpression(IPrecedenceSimilarExpressionContext)

	// Set_precedenceDistinctOperator sets the _precedenceDistinctOperator rule contexts.
	Set_precedenceDistinctOperator(IPrecedenceDistinctOperatorContext)


	// GetEqual returns the equal rule context list.
	GetEqual() []IPrecedenceEqualOperatorContext

	// GetP returns the p rule context list.
	GetP() []IPrecedenceSimilarExpressionContext

	// GetDist returns the dist rule context list.
	GetDist() []IPrecedenceDistinctOperatorContext


	// SetEqual sets the equal rule context list.
	SetEqual([]IPrecedenceEqualOperatorContext) 

	// SetP sets the p rule context list.
	SetP([]IPrecedenceSimilarExpressionContext) 

	// SetDist sets the dist rule context list.
	SetDist([]IPrecedenceDistinctOperatorContext) 


	// Getter signatures
	AllPrecedenceSimilarExpression() []IPrecedenceSimilarExpressionContext
	PrecedenceSimilarExpression(i int) IPrecedenceSimilarExpressionContext
	AllPrecedenceEqualOperator() []IPrecedenceEqualOperatorContext
	PrecedenceEqualOperator(i int) IPrecedenceEqualOperatorContext
	AllPrecedenceDistinctOperator() []IPrecedenceDistinctOperatorContext
	PrecedenceDistinctOperator(i int) IPrecedenceDistinctOperatorContext

	// IsPrecedenceEqualExpressionContext differentiates from other interfaces.
	IsPrecedenceEqualExpressionContext()
}

type PrecedenceEqualExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	_precedenceEqualOperator IPrecedenceEqualOperatorContext 
	equal []IPrecedenceEqualOperatorContext
	_precedenceSimilarExpression IPrecedenceSimilarExpressionContext 
	p []IPrecedenceSimilarExpressionContext
	_precedenceDistinctOperator IPrecedenceDistinctOperatorContext 
	dist []IPrecedenceDistinctOperatorContext
}

func NewEmptyPrecedenceEqualExpressionContext() *PrecedenceEqualExpressionContext {
	var p = new(PrecedenceEqualExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_precedenceEqualExpression
	return p
}

func InitEmptyPrecedenceEqualExpressionContext(p *PrecedenceEqualExpressionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_precedenceEqualExpression
}

func (*PrecedenceEqualExpressionContext) IsPrecedenceEqualExpressionContext() {}

func NewPrecedenceEqualExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrecedenceEqualExpressionContext {
	var p = new(PrecedenceEqualExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_precedenceEqualExpression

	return p
}

func (s *PrecedenceEqualExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PrecedenceEqualExpressionContext) Get_precedenceEqualOperator() IPrecedenceEqualOperatorContext { return s._precedenceEqualOperator }

func (s *PrecedenceEqualExpressionContext) Get_precedenceSimilarExpression() IPrecedenceSimilarExpressionContext { return s._precedenceSimilarExpression }

func (s *PrecedenceEqualExpressionContext) Get_precedenceDistinctOperator() IPrecedenceDistinctOperatorContext { return s._precedenceDistinctOperator }


func (s *PrecedenceEqualExpressionContext) Set_precedenceEqualOperator(v IPrecedenceEqualOperatorContext) { s._precedenceEqualOperator = v }

func (s *PrecedenceEqualExpressionContext) Set_precedenceSimilarExpression(v IPrecedenceSimilarExpressionContext) { s._precedenceSimilarExpression = v }

func (s *PrecedenceEqualExpressionContext) Set_precedenceDistinctOperator(v IPrecedenceDistinctOperatorContext) { s._precedenceDistinctOperator = v }


func (s *PrecedenceEqualExpressionContext) GetEqual() []IPrecedenceEqualOperatorContext { return s.equal }

func (s *PrecedenceEqualExpressionContext) GetP() []IPrecedenceSimilarExpressionContext { return s.p }

func (s *PrecedenceEqualExpressionContext) GetDist() []IPrecedenceDistinctOperatorContext { return s.dist }


func (s *PrecedenceEqualExpressionContext) SetEqual(v []IPrecedenceEqualOperatorContext) { s.equal = v }

func (s *PrecedenceEqualExpressionContext) SetP(v []IPrecedenceSimilarExpressionContext) { s.p = v }

func (s *PrecedenceEqualExpressionContext) SetDist(v []IPrecedenceDistinctOperatorContext) { s.dist = v }


func (s *PrecedenceEqualExpressionContext) AllPrecedenceSimilarExpression() []IPrecedenceSimilarExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrecedenceSimilarExpressionContext); ok {
			len++
		}
	}

	tst := make([]IPrecedenceSimilarExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrecedenceSimilarExpressionContext); ok {
			tst[i] = t.(IPrecedenceSimilarExpressionContext)
			i++
		}
	}

	return tst
}

func (s *PrecedenceEqualExpressionContext) PrecedenceSimilarExpression(i int) IPrecedenceSimilarExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrecedenceSimilarExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrecedenceSimilarExpressionContext)
}

func (s *PrecedenceEqualExpressionContext) AllPrecedenceEqualOperator() []IPrecedenceEqualOperatorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrecedenceEqualOperatorContext); ok {
			len++
		}
	}

	tst := make([]IPrecedenceEqualOperatorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrecedenceEqualOperatorContext); ok {
			tst[i] = t.(IPrecedenceEqualOperatorContext)
			i++
		}
	}

	return tst
}

func (s *PrecedenceEqualExpressionContext) PrecedenceEqualOperator(i int) IPrecedenceEqualOperatorContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrecedenceEqualOperatorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrecedenceEqualOperatorContext)
}

func (s *PrecedenceEqualExpressionContext) AllPrecedenceDistinctOperator() []IPrecedenceDistinctOperatorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrecedenceDistinctOperatorContext); ok {
			len++
		}
	}

	tst := make([]IPrecedenceDistinctOperatorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrecedenceDistinctOperatorContext); ok {
			tst[i] = t.(IPrecedenceDistinctOperatorContext)
			i++
		}
	}

	return tst
}

func (s *PrecedenceEqualExpressionContext) PrecedenceDistinctOperator(i int) IPrecedenceDistinctOperatorContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrecedenceDistinctOperatorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrecedenceDistinctOperatorContext)
}

func (s *PrecedenceEqualExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrecedenceEqualExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PrecedenceEqualExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterPrecedenceEqualExpression(s)
	}
}

func (s *PrecedenceEqualExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitPrecedenceEqualExpression(s)
	}
}

func (s *PrecedenceEqualExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitPrecedenceEqualExpression(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) PrecedenceEqualExpression() (localctx IPrecedenceEqualExpressionContext) {
	localctx = NewPrecedenceEqualExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 856, HiveParserRULE_precedenceEqualExpression)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4783)
		p.PrecedenceSimilarExpression()
	}
	p.SetState(4792)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 567, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(4790)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 566, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(4784)

					var _x = p.PrecedenceEqualOperator()


					localctx.(*PrecedenceEqualExpressionContext)._precedenceEqualOperator = _x
				}
				localctx.(*PrecedenceEqualExpressionContext).equal = append(localctx.(*PrecedenceEqualExpressionContext).equal, localctx.(*PrecedenceEqualExpressionContext)._precedenceEqualOperator)
				{
					p.SetState(4785)

					var _x = p.PrecedenceSimilarExpression()


					localctx.(*PrecedenceEqualExpressionContext)._precedenceSimilarExpression = _x
				}
				localctx.(*PrecedenceEqualExpressionContext).p = append(localctx.(*PrecedenceEqualExpressionContext).p, localctx.(*PrecedenceEqualExpressionContext)._precedenceSimilarExpression)


			case 2:
				{
					p.SetState(4787)

					var _x = p.PrecedenceDistinctOperator()


					localctx.(*PrecedenceEqualExpressionContext)._precedenceDistinctOperator = _x
				}
				localctx.(*PrecedenceEqualExpressionContext).dist = append(localctx.(*PrecedenceEqualExpressionContext).dist, localctx.(*PrecedenceEqualExpressionContext)._precedenceDistinctOperator)
				{
					p.SetState(4788)

					var _x = p.PrecedenceSimilarExpression()


					localctx.(*PrecedenceEqualExpressionContext)._precedenceSimilarExpression = _x
				}
				localctx.(*PrecedenceEqualExpressionContext).p = append(localctx.(*PrecedenceEqualExpressionContext).p, localctx.(*PrecedenceEqualExpressionContext)._precedenceSimilarExpression)

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(4794)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 567, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IIsConditionContext is an interface to support dynamic dispatch.
type IIsConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_NULL() antlr.TerminalNode
	KW_TRUE() antlr.TerminalNode
	KW_FALSE() antlr.TerminalNode
	KW_UNKNOWN() antlr.TerminalNode
	KW_NOT() antlr.TerminalNode

	// IsIsConditionContext differentiates from other interfaces.
	IsIsConditionContext()
}

type IsConditionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIsConditionContext() *IsConditionContext {
	var p = new(IsConditionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_isCondition
	return p
}

func InitEmptyIsConditionContext(p *IsConditionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_isCondition
}

func (*IsConditionContext) IsIsConditionContext() {}

func NewIsConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IsConditionContext {
	var p = new(IsConditionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_isCondition

	return p
}

func (s *IsConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *IsConditionContext) KW_NULL() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_NULL, 0)
}

func (s *IsConditionContext) KW_TRUE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TRUE, 0)
}

func (s *IsConditionContext) KW_FALSE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_FALSE, 0)
}

func (s *IsConditionContext) KW_UNKNOWN() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_UNKNOWN, 0)
}

func (s *IsConditionContext) KW_NOT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_NOT, 0)
}

func (s *IsConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IsConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *IsConditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterIsCondition(s)
	}
}

func (s *IsConditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitIsCondition(s)
	}
}

func (s *IsConditionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitIsCondition(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) IsCondition() (localctx IIsConditionContext) {
	localctx = NewIsConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 858, HiveParserRULE_isCondition)
	p.SetState(4807)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 568, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4795)
			p.Match(HiveParserKW_NULL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4796)
			p.Match(HiveParserKW_TRUE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4797)
			p.Match(HiveParserKW_FALSE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4798)
			p.Match(HiveParserKW_UNKNOWN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4799)
			p.Match(HiveParserKW_NOT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4800)
			p.Match(HiveParserKW_NULL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4801)
			p.Match(HiveParserKW_NOT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4802)
			p.Match(HiveParserKW_TRUE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(4803)
			p.Match(HiveParserKW_NOT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4804)
			p.Match(HiveParserKW_FALSE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(4805)
			p.Match(HiveParserKW_NOT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4806)
			p.Match(HiveParserKW_UNKNOWN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPrecedenceUnarySuffixExpressionContext is an interface to support dynamic dispatch.
type IPrecedenceUnarySuffixExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetA returns the a token.
	GetA() antlr.Token 


	// SetA sets the a token.
	SetA(antlr.Token) 


	// Getter signatures
	PrecedenceEqualExpression() IPrecedenceEqualExpressionContext
	IsCondition() IIsConditionContext
	KW_IS() antlr.TerminalNode

	// IsPrecedenceUnarySuffixExpressionContext differentiates from other interfaces.
	IsPrecedenceUnarySuffixExpressionContext()
}

type PrecedenceUnarySuffixExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	a antlr.Token
}

func NewEmptyPrecedenceUnarySuffixExpressionContext() *PrecedenceUnarySuffixExpressionContext {
	var p = new(PrecedenceUnarySuffixExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_precedenceUnarySuffixExpression
	return p
}

func InitEmptyPrecedenceUnarySuffixExpressionContext(p *PrecedenceUnarySuffixExpressionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_precedenceUnarySuffixExpression
}

func (*PrecedenceUnarySuffixExpressionContext) IsPrecedenceUnarySuffixExpressionContext() {}

func NewPrecedenceUnarySuffixExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrecedenceUnarySuffixExpressionContext {
	var p = new(PrecedenceUnarySuffixExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_precedenceUnarySuffixExpression

	return p
}

func (s *PrecedenceUnarySuffixExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PrecedenceUnarySuffixExpressionContext) GetA() antlr.Token { return s.a }


func (s *PrecedenceUnarySuffixExpressionContext) SetA(v antlr.Token) { s.a = v }


func (s *PrecedenceUnarySuffixExpressionContext) PrecedenceEqualExpression() IPrecedenceEqualExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrecedenceEqualExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrecedenceEqualExpressionContext)
}

func (s *PrecedenceUnarySuffixExpressionContext) IsCondition() IIsConditionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIsConditionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIsConditionContext)
}

func (s *PrecedenceUnarySuffixExpressionContext) KW_IS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_IS, 0)
}

func (s *PrecedenceUnarySuffixExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrecedenceUnarySuffixExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PrecedenceUnarySuffixExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterPrecedenceUnarySuffixExpression(s)
	}
}

func (s *PrecedenceUnarySuffixExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitPrecedenceUnarySuffixExpression(s)
	}
}

func (s *PrecedenceUnarySuffixExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitPrecedenceUnarySuffixExpression(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) PrecedenceUnarySuffixExpression() (localctx IPrecedenceUnarySuffixExpressionContext) {
	localctx = NewPrecedenceUnarySuffixExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 860, HiveParserRULE_precedenceUnarySuffixExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4809)
		p.PrecedenceEqualExpression()
	}
	p.SetState(4812)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_IS {
		{
			p.SetState(4810)

			var _m = p.Match(HiveParserKW_IS)

			localctx.(*PrecedenceUnarySuffixExpressionContext).a = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4811)
			p.IsCondition()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPrecedenceNotOperatorContext is an interface to support dynamic dispatch.
type IPrecedenceNotOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_NOT() antlr.TerminalNode

	// IsPrecedenceNotOperatorContext differentiates from other interfaces.
	IsPrecedenceNotOperatorContext()
}

type PrecedenceNotOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrecedenceNotOperatorContext() *PrecedenceNotOperatorContext {
	var p = new(PrecedenceNotOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_precedenceNotOperator
	return p
}

func InitEmptyPrecedenceNotOperatorContext(p *PrecedenceNotOperatorContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_precedenceNotOperator
}

func (*PrecedenceNotOperatorContext) IsPrecedenceNotOperatorContext() {}

func NewPrecedenceNotOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrecedenceNotOperatorContext {
	var p = new(PrecedenceNotOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_precedenceNotOperator

	return p
}

func (s *PrecedenceNotOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *PrecedenceNotOperatorContext) KW_NOT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_NOT, 0)
}

func (s *PrecedenceNotOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrecedenceNotOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PrecedenceNotOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterPrecedenceNotOperator(s)
	}
}

func (s *PrecedenceNotOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitPrecedenceNotOperator(s)
	}
}

func (s *PrecedenceNotOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitPrecedenceNotOperator(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) PrecedenceNotOperator() (localctx IPrecedenceNotOperatorContext) {
	localctx = NewPrecedenceNotOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 862, HiveParserRULE_precedenceNotOperator)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4814)
		p.Match(HiveParserKW_NOT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPrecedenceNotExpressionContext is an interface to support dynamic dispatch.
type IPrecedenceNotExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PrecedenceUnarySuffixExpression() IPrecedenceUnarySuffixExpressionContext
	AllPrecedenceNotOperator() []IPrecedenceNotOperatorContext
	PrecedenceNotOperator(i int) IPrecedenceNotOperatorContext

	// IsPrecedenceNotExpressionContext differentiates from other interfaces.
	IsPrecedenceNotExpressionContext()
}

type PrecedenceNotExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrecedenceNotExpressionContext() *PrecedenceNotExpressionContext {
	var p = new(PrecedenceNotExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_precedenceNotExpression
	return p
}

func InitEmptyPrecedenceNotExpressionContext(p *PrecedenceNotExpressionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_precedenceNotExpression
}

func (*PrecedenceNotExpressionContext) IsPrecedenceNotExpressionContext() {}

func NewPrecedenceNotExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrecedenceNotExpressionContext {
	var p = new(PrecedenceNotExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_precedenceNotExpression

	return p
}

func (s *PrecedenceNotExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PrecedenceNotExpressionContext) PrecedenceUnarySuffixExpression() IPrecedenceUnarySuffixExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrecedenceUnarySuffixExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrecedenceUnarySuffixExpressionContext)
}

func (s *PrecedenceNotExpressionContext) AllPrecedenceNotOperator() []IPrecedenceNotOperatorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrecedenceNotOperatorContext); ok {
			len++
		}
	}

	tst := make([]IPrecedenceNotOperatorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrecedenceNotOperatorContext); ok {
			tst[i] = t.(IPrecedenceNotOperatorContext)
			i++
		}
	}

	return tst
}

func (s *PrecedenceNotExpressionContext) PrecedenceNotOperator(i int) IPrecedenceNotOperatorContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrecedenceNotOperatorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrecedenceNotOperatorContext)
}

func (s *PrecedenceNotExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrecedenceNotExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PrecedenceNotExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterPrecedenceNotExpression(s)
	}
}

func (s *PrecedenceNotExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitPrecedenceNotExpression(s)
	}
}

func (s *PrecedenceNotExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitPrecedenceNotExpression(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) PrecedenceNotExpression() (localctx IPrecedenceNotExpressionContext) {
	localctx = NewPrecedenceNotExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 864, HiveParserRULE_precedenceNotExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4819)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HiveParserKW_NOT {
		{
			p.SetState(4816)
			p.PrecedenceNotOperator()
		}


		p.SetState(4821)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(4822)
		p.PrecedenceUnarySuffixExpression()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPrecedenceAndOperatorContext is an interface to support dynamic dispatch.
type IPrecedenceAndOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_AND() antlr.TerminalNode

	// IsPrecedenceAndOperatorContext differentiates from other interfaces.
	IsPrecedenceAndOperatorContext()
}

type PrecedenceAndOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrecedenceAndOperatorContext() *PrecedenceAndOperatorContext {
	var p = new(PrecedenceAndOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_precedenceAndOperator
	return p
}

func InitEmptyPrecedenceAndOperatorContext(p *PrecedenceAndOperatorContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_precedenceAndOperator
}

func (*PrecedenceAndOperatorContext) IsPrecedenceAndOperatorContext() {}

func NewPrecedenceAndOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrecedenceAndOperatorContext {
	var p = new(PrecedenceAndOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_precedenceAndOperator

	return p
}

func (s *PrecedenceAndOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *PrecedenceAndOperatorContext) KW_AND() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_AND, 0)
}

func (s *PrecedenceAndOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrecedenceAndOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PrecedenceAndOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterPrecedenceAndOperator(s)
	}
}

func (s *PrecedenceAndOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitPrecedenceAndOperator(s)
	}
}

func (s *PrecedenceAndOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitPrecedenceAndOperator(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) PrecedenceAndOperator() (localctx IPrecedenceAndOperatorContext) {
	localctx = NewPrecedenceAndOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 866, HiveParserRULE_precedenceAndOperator)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4824)
		p.Match(HiveParserKW_AND)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPrecedenceAndExpressionContext is an interface to support dynamic dispatch.
type IPrecedenceAndExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPrecedenceNotExpression() []IPrecedenceNotExpressionContext
	PrecedenceNotExpression(i int) IPrecedenceNotExpressionContext
	AllPrecedenceAndOperator() []IPrecedenceAndOperatorContext
	PrecedenceAndOperator(i int) IPrecedenceAndOperatorContext

	// IsPrecedenceAndExpressionContext differentiates from other interfaces.
	IsPrecedenceAndExpressionContext()
}

type PrecedenceAndExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrecedenceAndExpressionContext() *PrecedenceAndExpressionContext {
	var p = new(PrecedenceAndExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_precedenceAndExpression
	return p
}

func InitEmptyPrecedenceAndExpressionContext(p *PrecedenceAndExpressionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_precedenceAndExpression
}

func (*PrecedenceAndExpressionContext) IsPrecedenceAndExpressionContext() {}

func NewPrecedenceAndExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrecedenceAndExpressionContext {
	var p = new(PrecedenceAndExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_precedenceAndExpression

	return p
}

func (s *PrecedenceAndExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PrecedenceAndExpressionContext) AllPrecedenceNotExpression() []IPrecedenceNotExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrecedenceNotExpressionContext); ok {
			len++
		}
	}

	tst := make([]IPrecedenceNotExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrecedenceNotExpressionContext); ok {
			tst[i] = t.(IPrecedenceNotExpressionContext)
			i++
		}
	}

	return tst
}

func (s *PrecedenceAndExpressionContext) PrecedenceNotExpression(i int) IPrecedenceNotExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrecedenceNotExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrecedenceNotExpressionContext)
}

func (s *PrecedenceAndExpressionContext) AllPrecedenceAndOperator() []IPrecedenceAndOperatorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrecedenceAndOperatorContext); ok {
			len++
		}
	}

	tst := make([]IPrecedenceAndOperatorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrecedenceAndOperatorContext); ok {
			tst[i] = t.(IPrecedenceAndOperatorContext)
			i++
		}
	}

	return tst
}

func (s *PrecedenceAndExpressionContext) PrecedenceAndOperator(i int) IPrecedenceAndOperatorContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrecedenceAndOperatorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrecedenceAndOperatorContext)
}

func (s *PrecedenceAndExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrecedenceAndExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PrecedenceAndExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterPrecedenceAndExpression(s)
	}
}

func (s *PrecedenceAndExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitPrecedenceAndExpression(s)
	}
}

func (s *PrecedenceAndExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitPrecedenceAndExpression(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) PrecedenceAndExpression() (localctx IPrecedenceAndExpressionContext) {
	localctx = NewPrecedenceAndExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 868, HiveParserRULE_precedenceAndExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4826)
		p.PrecedenceNotExpression()
	}
	p.SetState(4832)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HiveParserKW_AND {
		{
			p.SetState(4827)
			p.PrecedenceAndOperator()
		}
		{
			p.SetState(4828)
			p.PrecedenceNotExpression()
		}


		p.SetState(4834)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPrecedenceOrOperatorContext is an interface to support dynamic dispatch.
type IPrecedenceOrOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_OR() antlr.TerminalNode

	// IsPrecedenceOrOperatorContext differentiates from other interfaces.
	IsPrecedenceOrOperatorContext()
}

type PrecedenceOrOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrecedenceOrOperatorContext() *PrecedenceOrOperatorContext {
	var p = new(PrecedenceOrOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_precedenceOrOperator
	return p
}

func InitEmptyPrecedenceOrOperatorContext(p *PrecedenceOrOperatorContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_precedenceOrOperator
}

func (*PrecedenceOrOperatorContext) IsPrecedenceOrOperatorContext() {}

func NewPrecedenceOrOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrecedenceOrOperatorContext {
	var p = new(PrecedenceOrOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_precedenceOrOperator

	return p
}

func (s *PrecedenceOrOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *PrecedenceOrOperatorContext) KW_OR() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_OR, 0)
}

func (s *PrecedenceOrOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrecedenceOrOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PrecedenceOrOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterPrecedenceOrOperator(s)
	}
}

func (s *PrecedenceOrOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitPrecedenceOrOperator(s)
	}
}

func (s *PrecedenceOrOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitPrecedenceOrOperator(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) PrecedenceOrOperator() (localctx IPrecedenceOrOperatorContext) {
	localctx = NewPrecedenceOrOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 870, HiveParserRULE_precedenceOrOperator)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4835)
		p.Match(HiveParserKW_OR)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPrecedenceOrExpressionContext is an interface to support dynamic dispatch.
type IPrecedenceOrExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPrecedenceAndExpression() []IPrecedenceAndExpressionContext
	PrecedenceAndExpression(i int) IPrecedenceAndExpressionContext
	AllPrecedenceOrOperator() []IPrecedenceOrOperatorContext
	PrecedenceOrOperator(i int) IPrecedenceOrOperatorContext

	// IsPrecedenceOrExpressionContext differentiates from other interfaces.
	IsPrecedenceOrExpressionContext()
}

type PrecedenceOrExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrecedenceOrExpressionContext() *PrecedenceOrExpressionContext {
	var p = new(PrecedenceOrExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_precedenceOrExpression
	return p
}

func InitEmptyPrecedenceOrExpressionContext(p *PrecedenceOrExpressionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_precedenceOrExpression
}

func (*PrecedenceOrExpressionContext) IsPrecedenceOrExpressionContext() {}

func NewPrecedenceOrExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrecedenceOrExpressionContext {
	var p = new(PrecedenceOrExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_precedenceOrExpression

	return p
}

func (s *PrecedenceOrExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PrecedenceOrExpressionContext) AllPrecedenceAndExpression() []IPrecedenceAndExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrecedenceAndExpressionContext); ok {
			len++
		}
	}

	tst := make([]IPrecedenceAndExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrecedenceAndExpressionContext); ok {
			tst[i] = t.(IPrecedenceAndExpressionContext)
			i++
		}
	}

	return tst
}

func (s *PrecedenceOrExpressionContext) PrecedenceAndExpression(i int) IPrecedenceAndExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrecedenceAndExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrecedenceAndExpressionContext)
}

func (s *PrecedenceOrExpressionContext) AllPrecedenceOrOperator() []IPrecedenceOrOperatorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrecedenceOrOperatorContext); ok {
			len++
		}
	}

	tst := make([]IPrecedenceOrOperatorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrecedenceOrOperatorContext); ok {
			tst[i] = t.(IPrecedenceOrOperatorContext)
			i++
		}
	}

	return tst
}

func (s *PrecedenceOrExpressionContext) PrecedenceOrOperator(i int) IPrecedenceOrOperatorContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrecedenceOrOperatorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrecedenceOrOperatorContext)
}

func (s *PrecedenceOrExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrecedenceOrExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PrecedenceOrExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterPrecedenceOrExpression(s)
	}
}

func (s *PrecedenceOrExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitPrecedenceOrExpression(s)
	}
}

func (s *PrecedenceOrExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitPrecedenceOrExpression(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) PrecedenceOrExpression() (localctx IPrecedenceOrExpressionContext) {
	localctx = NewPrecedenceOrExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 872, HiveParserRULE_precedenceOrExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4837)
		p.PrecedenceAndExpression()
	}
	p.SetState(4843)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HiveParserKW_OR {
		{
			p.SetState(4838)
			p.PrecedenceOrOperator()
		}
		{
			p.SetState(4839)
			p.PrecedenceAndExpression()
		}


		p.SetState(4845)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IBooleanValueContext is an interface to support dynamic dispatch.
type IBooleanValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_TRUE() antlr.TerminalNode
	KW_FALSE() antlr.TerminalNode

	// IsBooleanValueContext differentiates from other interfaces.
	IsBooleanValueContext()
}

type BooleanValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanValueContext() *BooleanValueContext {
	var p = new(BooleanValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_booleanValue
	return p
}

func InitEmptyBooleanValueContext(p *BooleanValueContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_booleanValue
}

func (*BooleanValueContext) IsBooleanValueContext() {}

func NewBooleanValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanValueContext {
	var p = new(BooleanValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_booleanValue

	return p
}

func (s *BooleanValueContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanValueContext) KW_TRUE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TRUE, 0)
}

func (s *BooleanValueContext) KW_FALSE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_FALSE, 0)
}

func (s *BooleanValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *BooleanValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterBooleanValue(s)
	}
}

func (s *BooleanValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitBooleanValue(s)
	}
}

func (s *BooleanValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitBooleanValue(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) BooleanValue() (localctx IBooleanValueContext) {
	localctx = NewBooleanValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 874, HiveParserRULE_booleanValue)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4846)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HiveParserKW_FALSE || _la == HiveParserKW_TRUE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IBooleanValueTokContext is an interface to support dynamic dispatch.
type IBooleanValueTokContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_TRUE() antlr.TerminalNode
	KW_FALSE() antlr.TerminalNode

	// IsBooleanValueTokContext differentiates from other interfaces.
	IsBooleanValueTokContext()
}

type BooleanValueTokContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanValueTokContext() *BooleanValueTokContext {
	var p = new(BooleanValueTokContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_booleanValueTok
	return p
}

func InitEmptyBooleanValueTokContext(p *BooleanValueTokContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_booleanValueTok
}

func (*BooleanValueTokContext) IsBooleanValueTokContext() {}

func NewBooleanValueTokContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanValueTokContext {
	var p = new(BooleanValueTokContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_booleanValueTok

	return p
}

func (s *BooleanValueTokContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanValueTokContext) KW_TRUE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TRUE, 0)
}

func (s *BooleanValueTokContext) KW_FALSE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_FALSE, 0)
}

func (s *BooleanValueTokContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanValueTokContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *BooleanValueTokContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterBooleanValueTok(s)
	}
}

func (s *BooleanValueTokContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitBooleanValueTok(s)
	}
}

func (s *BooleanValueTokContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitBooleanValueTok(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) BooleanValueTok() (localctx IBooleanValueTokContext) {
	localctx = NewBooleanValueTokContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 876, HiveParserRULE_booleanValueTok)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4848)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HiveParserKW_FALSE || _la == HiveParserKW_TRUE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITableOrPartitionContext is an interface to support dynamic dispatch.
type ITableOrPartitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TableName() ITableNameContext
	PartitionSpec() IPartitionSpecContext

	// IsTableOrPartitionContext differentiates from other interfaces.
	IsTableOrPartitionContext()
}

type TableOrPartitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableOrPartitionContext() *TableOrPartitionContext {
	var p = new(TableOrPartitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_tableOrPartition
	return p
}

func InitEmptyTableOrPartitionContext(p *TableOrPartitionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_tableOrPartition
}

func (*TableOrPartitionContext) IsTableOrPartitionContext() {}

func NewTableOrPartitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableOrPartitionContext {
	var p = new(TableOrPartitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_tableOrPartition

	return p
}

func (s *TableOrPartitionContext) GetParser() antlr.Parser { return s.parser }

func (s *TableOrPartitionContext) TableName() ITableNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *TableOrPartitionContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *TableOrPartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOrPartitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TableOrPartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterTableOrPartition(s)
	}
}

func (s *TableOrPartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitTableOrPartition(s)
	}
}

func (s *TableOrPartitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitTableOrPartition(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) TableOrPartition() (localctx ITableOrPartitionContext) {
	localctx = NewTableOrPartitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 878, HiveParserRULE_tableOrPartition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4850)
		p.TableName()
	}
	p.SetState(4852)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_PARTITION {
		{
			p.SetState(4851)
			p.PartitionSpec()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPartitionSpecContext is an interface to support dynamic dispatch.
type IPartitionSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_PARTITION() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	AllPartitionVal() []IPartitionValContext
	PartitionVal(i int) IPartitionValContext
	RPAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPartitionSpecContext differentiates from other interfaces.
	IsPartitionSpecContext()
}

type PartitionSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionSpecContext() *PartitionSpecContext {
	var p = new(PartitionSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_partitionSpec
	return p
}

func InitEmptyPartitionSpecContext(p *PartitionSpecContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_partitionSpec
}

func (*PartitionSpecContext) IsPartitionSpecContext() {}

func NewPartitionSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionSpecContext {
	var p = new(PartitionSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_partitionSpec

	return p
}

func (s *PartitionSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionSpecContext) KW_PARTITION() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_PARTITION, 0)
}

func (s *PartitionSpecContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserLPAREN, 0)
}

func (s *PartitionSpecContext) AllPartitionVal() []IPartitionValContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionValContext); ok {
			len++
		}
	}

	tst := make([]IPartitionValContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionValContext); ok {
			tst[i] = t.(IPartitionValContext)
			i++
		}
	}

	return tst
}

func (s *PartitionSpecContext) PartitionVal(i int) IPartitionValContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionValContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionValContext)
}

func (s *PartitionSpecContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserRPAREN, 0)
}

func (s *PartitionSpecContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(HiveParserCOMMA)
}

func (s *PartitionSpecContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserCOMMA, i)
}

func (s *PartitionSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PartitionSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterPartitionSpec(s)
	}
}

func (s *PartitionSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitPartitionSpec(s)
	}
}

func (s *PartitionSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitPartitionSpec(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) PartitionSpec() (localctx IPartitionSpecContext) {
	localctx = NewPartitionSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 880, HiveParserRULE_partitionSpec)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4854)
		p.Match(HiveParserKW_PARTITION)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4855)
		p.Match(HiveParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4856)
		p.PartitionVal()
	}
	p.SetState(4861)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HiveParserCOMMA {
		{
			p.SetState(4857)
			p.Match(HiveParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4858)
			p.PartitionVal()
		}


		p.SetState(4863)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(4864)
		p.Match(HiveParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPartitionValContext is an interface to support dynamic dispatch.
type IPartitionValContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Id_() IId_Context
	EQUAL() antlr.TerminalNode
	Constant() IConstantContext

	// IsPartitionValContext differentiates from other interfaces.
	IsPartitionValContext()
}

type PartitionValContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionValContext() *PartitionValContext {
	var p = new(PartitionValContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_partitionVal
	return p
}

func InitEmptyPartitionValContext(p *PartitionValContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_partitionVal
}

func (*PartitionValContext) IsPartitionValContext() {}

func NewPartitionValContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionValContext {
	var p = new(PartitionValContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_partitionVal

	return p
}

func (s *PartitionValContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionValContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *PartitionValContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(HiveParserEQUAL, 0)
}

func (s *PartitionValContext) Constant() IConstantContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *PartitionValContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionValContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PartitionValContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterPartitionVal(s)
	}
}

func (s *PartitionValContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitPartitionVal(s)
	}
}

func (s *PartitionValContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitPartitionVal(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) PartitionVal() (localctx IPartitionValContext) {
	localctx = NewPartitionValContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 882, HiveParserRULE_partitionVal)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4866)
		p.Id_()
	}
	p.SetState(4869)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserEQUAL {
		{
			p.SetState(4867)
			p.Match(HiveParserEQUAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4868)
			p.Constant()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPartitionSelectorSpecContext is an interface to support dynamic dispatch.
type IPartitionSelectorSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	AllPartitionSelectorVal() []IPartitionSelectorValContext
	PartitionSelectorVal(i int) IPartitionSelectorValContext
	RPAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPartitionSelectorSpecContext differentiates from other interfaces.
	IsPartitionSelectorSpecContext()
}

type PartitionSelectorSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionSelectorSpecContext() *PartitionSelectorSpecContext {
	var p = new(PartitionSelectorSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_partitionSelectorSpec
	return p
}

func InitEmptyPartitionSelectorSpecContext(p *PartitionSelectorSpecContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_partitionSelectorSpec
}

func (*PartitionSelectorSpecContext) IsPartitionSelectorSpecContext() {}

func NewPartitionSelectorSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionSelectorSpecContext {
	var p = new(PartitionSelectorSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_partitionSelectorSpec

	return p
}

func (s *PartitionSelectorSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionSelectorSpecContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserLPAREN, 0)
}

func (s *PartitionSelectorSpecContext) AllPartitionSelectorVal() []IPartitionSelectorValContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionSelectorValContext); ok {
			len++
		}
	}

	tst := make([]IPartitionSelectorValContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionSelectorValContext); ok {
			tst[i] = t.(IPartitionSelectorValContext)
			i++
		}
	}

	return tst
}

func (s *PartitionSelectorSpecContext) PartitionSelectorVal(i int) IPartitionSelectorValContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSelectorValContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSelectorValContext)
}

func (s *PartitionSelectorSpecContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserRPAREN, 0)
}

func (s *PartitionSelectorSpecContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(HiveParserCOMMA)
}

func (s *PartitionSelectorSpecContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserCOMMA, i)
}

func (s *PartitionSelectorSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionSelectorSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PartitionSelectorSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterPartitionSelectorSpec(s)
	}
}

func (s *PartitionSelectorSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitPartitionSelectorSpec(s)
	}
}

func (s *PartitionSelectorSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitPartitionSelectorSpec(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) PartitionSelectorSpec() (localctx IPartitionSelectorSpecContext) {
	localctx = NewPartitionSelectorSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 884, HiveParserRULE_partitionSelectorSpec)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4871)
		p.Match(HiveParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4872)
		p.PartitionSelectorVal()
	}
	p.SetState(4877)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HiveParserCOMMA {
		{
			p.SetState(4873)
			p.Match(HiveParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4874)
			p.PartitionSelectorVal()
		}


		p.SetState(4879)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(4880)
		p.Match(HiveParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPartitionSelectorValContext is an interface to support dynamic dispatch.
type IPartitionSelectorValContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Id_() IId_Context
	PartitionSelectorOperator() IPartitionSelectorOperatorContext
	Constant() IConstantContext

	// IsPartitionSelectorValContext differentiates from other interfaces.
	IsPartitionSelectorValContext()
}

type PartitionSelectorValContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionSelectorValContext() *PartitionSelectorValContext {
	var p = new(PartitionSelectorValContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_partitionSelectorVal
	return p
}

func InitEmptyPartitionSelectorValContext(p *PartitionSelectorValContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_partitionSelectorVal
}

func (*PartitionSelectorValContext) IsPartitionSelectorValContext() {}

func NewPartitionSelectorValContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionSelectorValContext {
	var p = new(PartitionSelectorValContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_partitionSelectorVal

	return p
}

func (s *PartitionSelectorValContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionSelectorValContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *PartitionSelectorValContext) PartitionSelectorOperator() IPartitionSelectorOperatorContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSelectorOperatorContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSelectorOperatorContext)
}

func (s *PartitionSelectorValContext) Constant() IConstantContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *PartitionSelectorValContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionSelectorValContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PartitionSelectorValContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterPartitionSelectorVal(s)
	}
}

func (s *PartitionSelectorValContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitPartitionSelectorVal(s)
	}
}

func (s *PartitionSelectorValContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitPartitionSelectorVal(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) PartitionSelectorVal() (localctx IPartitionSelectorValContext) {
	localctx = NewPartitionSelectorValContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 886, HiveParserRULE_partitionSelectorVal)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4882)
		p.Id_()
	}
	{
		p.SetState(4883)
		p.PartitionSelectorOperator()
	}
	{
		p.SetState(4884)
		p.Constant()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPartitionSelectorOperatorContext is an interface to support dynamic dispatch.
type IPartitionSelectorOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_LIKE() antlr.TerminalNode
	SubQuerySelectorOperator() ISubQuerySelectorOperatorContext

	// IsPartitionSelectorOperatorContext differentiates from other interfaces.
	IsPartitionSelectorOperatorContext()
}

type PartitionSelectorOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionSelectorOperatorContext() *PartitionSelectorOperatorContext {
	var p = new(PartitionSelectorOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_partitionSelectorOperator
	return p
}

func InitEmptyPartitionSelectorOperatorContext(p *PartitionSelectorOperatorContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_partitionSelectorOperator
}

func (*PartitionSelectorOperatorContext) IsPartitionSelectorOperatorContext() {}

func NewPartitionSelectorOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionSelectorOperatorContext {
	var p = new(PartitionSelectorOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_partitionSelectorOperator

	return p
}

func (s *PartitionSelectorOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionSelectorOperatorContext) KW_LIKE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_LIKE, 0)
}

func (s *PartitionSelectorOperatorContext) SubQuerySelectorOperator() ISubQuerySelectorOperatorContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubQuerySelectorOperatorContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubQuerySelectorOperatorContext)
}

func (s *PartitionSelectorOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionSelectorOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PartitionSelectorOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterPartitionSelectorOperator(s)
	}
}

func (s *PartitionSelectorOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitPartitionSelectorOperator(s)
	}
}

func (s *PartitionSelectorOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitPartitionSelectorOperator(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) PartitionSelectorOperator() (localctx IPartitionSelectorOperatorContext) {
	localctx = NewPartitionSelectorOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 888, HiveParserRULE_partitionSelectorOperator)
	p.SetState(4888)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserKW_LIKE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4886)
			p.Match(HiveParserKW_LIKE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HiveParserEQUAL, HiveParserNOTEQUAL, HiveParserLESSTHANOREQUALTO, HiveParserLESSTHAN, HiveParserGREATERTHANOREQUALTO, HiveParserGREATERTHAN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4887)
			p.SubQuerySelectorOperator()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISubQuerySelectorOperatorContext is an interface to support dynamic dispatch.
type ISubQuerySelectorOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EQUAL() antlr.TerminalNode
	NOTEQUAL() antlr.TerminalNode
	LESSTHANOREQUALTO() antlr.TerminalNode
	LESSTHAN() antlr.TerminalNode
	GREATERTHANOREQUALTO() antlr.TerminalNode
	GREATERTHAN() antlr.TerminalNode

	// IsSubQuerySelectorOperatorContext differentiates from other interfaces.
	IsSubQuerySelectorOperatorContext()
}

type SubQuerySelectorOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubQuerySelectorOperatorContext() *SubQuerySelectorOperatorContext {
	var p = new(SubQuerySelectorOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_subQuerySelectorOperator
	return p
}

func InitEmptySubQuerySelectorOperatorContext(p *SubQuerySelectorOperatorContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_subQuerySelectorOperator
}

func (*SubQuerySelectorOperatorContext) IsSubQuerySelectorOperatorContext() {}

func NewSubQuerySelectorOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubQuerySelectorOperatorContext {
	var p = new(SubQuerySelectorOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_subQuerySelectorOperator

	return p
}

func (s *SubQuerySelectorOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *SubQuerySelectorOperatorContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(HiveParserEQUAL, 0)
}

func (s *SubQuerySelectorOperatorContext) NOTEQUAL() antlr.TerminalNode {
	return s.GetToken(HiveParserNOTEQUAL, 0)
}

func (s *SubQuerySelectorOperatorContext) LESSTHANOREQUALTO() antlr.TerminalNode {
	return s.GetToken(HiveParserLESSTHANOREQUALTO, 0)
}

func (s *SubQuerySelectorOperatorContext) LESSTHAN() antlr.TerminalNode {
	return s.GetToken(HiveParserLESSTHAN, 0)
}

func (s *SubQuerySelectorOperatorContext) GREATERTHANOREQUALTO() antlr.TerminalNode {
	return s.GetToken(HiveParserGREATERTHANOREQUALTO, 0)
}

func (s *SubQuerySelectorOperatorContext) GREATERTHAN() antlr.TerminalNode {
	return s.GetToken(HiveParserGREATERTHAN, 0)
}

func (s *SubQuerySelectorOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubQuerySelectorOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SubQuerySelectorOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterSubQuerySelectorOperator(s)
	}
}

func (s *SubQuerySelectorOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitSubQuerySelectorOperator(s)
	}
}

func (s *SubQuerySelectorOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitSubQuerySelectorOperator(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) SubQuerySelectorOperator() (localctx ISubQuerySelectorOperatorContext) {
	localctx = NewSubQuerySelectorOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 890, HiveParserRULE_subQuerySelectorOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4890)
		_la = p.GetTokenStream().LA(1)

		if !(((int64((_la - 392)) & ^0x3f) == 0 && ((int64(1) << (_la - 392)) & 125) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISysFuncNamesContext is an interface to support dynamic dispatch.
type ISysFuncNamesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_AND() antlr.TerminalNode
	KW_OR() antlr.TerminalNode
	KW_NOT() antlr.TerminalNode
	KW_LIKE() antlr.TerminalNode
	KW_IF() antlr.TerminalNode
	KW_CASE() antlr.TerminalNode
	KW_WHEN() antlr.TerminalNode
	KW_FLOOR() antlr.TerminalNode
	KW_TINYINT() antlr.TerminalNode
	KW_SMALLINT() antlr.TerminalNode
	KW_INT() antlr.TerminalNode
	KW_BIGINT() antlr.TerminalNode
	KW_FLOAT() antlr.TerminalNode
	KW_REAL() antlr.TerminalNode
	KW_DOUBLE() antlr.TerminalNode
	KW_BOOLEAN() antlr.TerminalNode
	KW_STRING() antlr.TerminalNode
	KW_BINARY() antlr.TerminalNode
	KW_ARRAY() antlr.TerminalNode
	KW_MAP() antlr.TerminalNode
	KW_STRUCT() antlr.TerminalNode
	KW_UNIONTYPE() antlr.TerminalNode
	EQUAL() antlr.TerminalNode
	EQUAL_NS() antlr.TerminalNode
	NOTEQUAL() antlr.TerminalNode
	LESSTHANOREQUALTO() antlr.TerminalNode
	LESSTHAN() antlr.TerminalNode
	GREATERTHANOREQUALTO() antlr.TerminalNode
	GREATERTHAN() antlr.TerminalNode
	DIVIDE() antlr.TerminalNode
	PLUS() antlr.TerminalNode
	MINUS() antlr.TerminalNode
	STAR() antlr.TerminalNode
	MOD() antlr.TerminalNode
	DIV() antlr.TerminalNode
	AMPERSAND() antlr.TerminalNode
	TILDE() antlr.TerminalNode
	BITWISEOR() antlr.TerminalNode
	BITWISEXOR() antlr.TerminalNode
	KW_RLIKE() antlr.TerminalNode
	KW_REGEXP() antlr.TerminalNode
	KW_IN() antlr.TerminalNode
	KW_BETWEEN() antlr.TerminalNode

	// IsSysFuncNamesContext differentiates from other interfaces.
	IsSysFuncNamesContext()
}

type SysFuncNamesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySysFuncNamesContext() *SysFuncNamesContext {
	var p = new(SysFuncNamesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_sysFuncNames
	return p
}

func InitEmptySysFuncNamesContext(p *SysFuncNamesContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_sysFuncNames
}

func (*SysFuncNamesContext) IsSysFuncNamesContext() {}

func NewSysFuncNamesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SysFuncNamesContext {
	var p = new(SysFuncNamesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_sysFuncNames

	return p
}

func (s *SysFuncNamesContext) GetParser() antlr.Parser { return s.parser }

func (s *SysFuncNamesContext) KW_AND() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_AND, 0)
}

func (s *SysFuncNamesContext) KW_OR() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_OR, 0)
}

func (s *SysFuncNamesContext) KW_NOT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_NOT, 0)
}

func (s *SysFuncNamesContext) KW_LIKE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_LIKE, 0)
}

func (s *SysFuncNamesContext) KW_IF() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_IF, 0)
}

func (s *SysFuncNamesContext) KW_CASE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_CASE, 0)
}

func (s *SysFuncNamesContext) KW_WHEN() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_WHEN, 0)
}

func (s *SysFuncNamesContext) KW_FLOOR() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_FLOOR, 0)
}

func (s *SysFuncNamesContext) KW_TINYINT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TINYINT, 0)
}

func (s *SysFuncNamesContext) KW_SMALLINT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SMALLINT, 0)
}

func (s *SysFuncNamesContext) KW_INT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_INT, 0)
}

func (s *SysFuncNamesContext) KW_BIGINT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_BIGINT, 0)
}

func (s *SysFuncNamesContext) KW_FLOAT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_FLOAT, 0)
}

func (s *SysFuncNamesContext) KW_REAL() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_REAL, 0)
}

func (s *SysFuncNamesContext) KW_DOUBLE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DOUBLE, 0)
}

func (s *SysFuncNamesContext) KW_BOOLEAN() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_BOOLEAN, 0)
}

func (s *SysFuncNamesContext) KW_STRING() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_STRING, 0)
}

func (s *SysFuncNamesContext) KW_BINARY() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_BINARY, 0)
}

func (s *SysFuncNamesContext) KW_ARRAY() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ARRAY, 0)
}

func (s *SysFuncNamesContext) KW_MAP() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_MAP, 0)
}

func (s *SysFuncNamesContext) KW_STRUCT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_STRUCT, 0)
}

func (s *SysFuncNamesContext) KW_UNIONTYPE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_UNIONTYPE, 0)
}

func (s *SysFuncNamesContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(HiveParserEQUAL, 0)
}

func (s *SysFuncNamesContext) EQUAL_NS() antlr.TerminalNode {
	return s.GetToken(HiveParserEQUAL_NS, 0)
}

func (s *SysFuncNamesContext) NOTEQUAL() antlr.TerminalNode {
	return s.GetToken(HiveParserNOTEQUAL, 0)
}

func (s *SysFuncNamesContext) LESSTHANOREQUALTO() antlr.TerminalNode {
	return s.GetToken(HiveParserLESSTHANOREQUALTO, 0)
}

func (s *SysFuncNamesContext) LESSTHAN() antlr.TerminalNode {
	return s.GetToken(HiveParserLESSTHAN, 0)
}

func (s *SysFuncNamesContext) GREATERTHANOREQUALTO() antlr.TerminalNode {
	return s.GetToken(HiveParserGREATERTHANOREQUALTO, 0)
}

func (s *SysFuncNamesContext) GREATERTHAN() antlr.TerminalNode {
	return s.GetToken(HiveParserGREATERTHAN, 0)
}

func (s *SysFuncNamesContext) DIVIDE() antlr.TerminalNode {
	return s.GetToken(HiveParserDIVIDE, 0)
}

func (s *SysFuncNamesContext) PLUS() antlr.TerminalNode {
	return s.GetToken(HiveParserPLUS, 0)
}

func (s *SysFuncNamesContext) MINUS() antlr.TerminalNode {
	return s.GetToken(HiveParserMINUS, 0)
}

func (s *SysFuncNamesContext) STAR() antlr.TerminalNode {
	return s.GetToken(HiveParserSTAR, 0)
}

func (s *SysFuncNamesContext) MOD() antlr.TerminalNode {
	return s.GetToken(HiveParserMOD, 0)
}

func (s *SysFuncNamesContext) DIV() antlr.TerminalNode {
	return s.GetToken(HiveParserDIV, 0)
}

func (s *SysFuncNamesContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(HiveParserAMPERSAND, 0)
}

func (s *SysFuncNamesContext) TILDE() antlr.TerminalNode {
	return s.GetToken(HiveParserTILDE, 0)
}

func (s *SysFuncNamesContext) BITWISEOR() antlr.TerminalNode {
	return s.GetToken(HiveParserBITWISEOR, 0)
}

func (s *SysFuncNamesContext) BITWISEXOR() antlr.TerminalNode {
	return s.GetToken(HiveParserBITWISEXOR, 0)
}

func (s *SysFuncNamesContext) KW_RLIKE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_RLIKE, 0)
}

func (s *SysFuncNamesContext) KW_REGEXP() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_REGEXP, 0)
}

func (s *SysFuncNamesContext) KW_IN() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_IN, 0)
}

func (s *SysFuncNamesContext) KW_BETWEEN() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_BETWEEN, 0)
}

func (s *SysFuncNamesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SysFuncNamesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SysFuncNamesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterSysFuncNames(s)
	}
}

func (s *SysFuncNamesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitSysFuncNames(s)
	}
}

func (s *SysFuncNamesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitSysFuncNames(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) SysFuncNames() (localctx ISysFuncNamesContext) {
	localctx = NewSysFuncNamesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 892, HiveParserRULE_sysFuncNames)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4892)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 34863122432) != 0) || ((int64((_la - 96)) & ^0x3f) == 0 && ((int64(1) << (_la - 96)) & 1157988057408864257) != 0) || ((int64((_la - 176)) & ^0x3f) == 0 && ((int64(1) << (_la - 176)) & 4399120269313) != 0) || ((int64((_la - 254)) & ^0x3f) == 0 && ((int64(1) << (_la - 254)) & 864761497203507265) != 0) || ((int64((_la - 329)) & ^0x3f) == 0 && ((int64(1) << (_la - 329)) & -9223367638808133631) != 0) || ((int64((_la - 393)) & ^0x3f) == 0 && ((int64(1) << (_la - 393)) & 98303) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDescFuncNamesContext is an interface to support dynamic dispatch.
type IDescFuncNamesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SysFuncNames() ISysFuncNamesContext
	StringLiteral() antlr.TerminalNode
	FunctionIdentifier() IFunctionIdentifierContext

	// IsDescFuncNamesContext differentiates from other interfaces.
	IsDescFuncNamesContext()
}

type DescFuncNamesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDescFuncNamesContext() *DescFuncNamesContext {
	var p = new(DescFuncNamesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_descFuncNames
	return p
}

func InitEmptyDescFuncNamesContext(p *DescFuncNamesContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_descFuncNames
}

func (*DescFuncNamesContext) IsDescFuncNamesContext() {}

func NewDescFuncNamesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DescFuncNamesContext {
	var p = new(DescFuncNamesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_descFuncNames

	return p
}

func (s *DescFuncNamesContext) GetParser() antlr.Parser { return s.parser }

func (s *DescFuncNamesContext) SysFuncNames() ISysFuncNamesContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISysFuncNamesContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISysFuncNamesContext)
}

func (s *DescFuncNamesContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(HiveParserStringLiteral, 0)
}

func (s *DescFuncNamesContext) FunctionIdentifier() IFunctionIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionIdentifierContext)
}

func (s *DescFuncNamesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescFuncNamesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DescFuncNamesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterDescFuncNames(s)
	}
}

func (s *DescFuncNamesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitDescFuncNames(s)
	}
}

func (s *DescFuncNamesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitDescFuncNames(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) DescFuncNames() (localctx IDescFuncNamesContext) {
	localctx = NewDescFuncNamesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 894, HiveParserRULE_descFuncNames)
	p.SetState(4897)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 578, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4894)
			p.SysFuncNames()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4895)
			p.Match(HiveParserStringLiteral)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4896)
			p.FunctionIdentifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IId_Context is an interface to support dynamic dispatch.
type IId_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() antlr.TerminalNode
	NonReserved() INonReservedContext

	// IsId_Context differentiates from other interfaces.
	IsId_Context()
}

type Id_Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyId_Context() *Id_Context {
	var p = new(Id_Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_id_
	return p
}

func InitEmptyId_Context(p *Id_Context)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_id_
}

func (*Id_Context) IsId_Context() {}

func NewId_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Id_Context {
	var p = new(Id_Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_id_

	return p
}

func (s *Id_Context) GetParser() antlr.Parser { return s.parser }

func (s *Id_Context) Identifier() antlr.TerminalNode {
	return s.GetToken(HiveParserIdentifier, 0)
}

func (s *Id_Context) NonReserved() INonReservedContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INonReservedContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INonReservedContext)
}

func (s *Id_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Id_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Id_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterId_(s)
	}
}

func (s *Id_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitId_(s)
	}
}

func (s *Id_Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitId_(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) Id_() (localctx IId_Context) {
	localctx = NewId_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 896, HiveParserRULE_id_)
	p.SetState(4901)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4899)
			p.Match(HiveParserIdentifier)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HiveParserKW_ABORT, HiveParserKW_ACTIVATE, HiveParserKW_ACTIVE, HiveParserKW_ADD, HiveParserKW_ADMIN, HiveParserKW_AFTER, HiveParserKW_ALLOC_FRACTION, HiveParserKW_ANALYZE, HiveParserKW_ARCHIVE, HiveParserKW_ASC, HiveParserKW_AST, HiveParserKW_AT, HiveParserKW_AUTOCOMMIT, HiveParserKW_BATCH, HiveParserKW_BEFORE, HiveParserKW_BUCKET, HiveParserKW_BUCKETS, HiveParserKW_CACHE, HiveParserKW_CASCADE, HiveParserKW_CBO, HiveParserKW_CHANGE, HiveParserKW_CHECK, HiveParserKW_CLUSTER, HiveParserKW_CLUSTERED, HiveParserKW_CLUSTERSTATUS, HiveParserKW_COLLECTION, HiveParserKW_COLUMNS, HiveParserKW_COMMENT, HiveParserKW_COMPACT, HiveParserKW_COMPACTIONS, HiveParserKW_COMPUTE, HiveParserKW_CONCATENATE, HiveParserKW_CONTINUE, HiveParserKW_COST, HiveParserKW_CRON, HiveParserKW_DATA, HiveParserKW_DATABASES, HiveParserKW_DATETIME, HiveParserKW_DAY, HiveParserKW_DAYOFWEEK, HiveParserKW_DBPROPERTIES, HiveParserKW_DCPROPERTIES, HiveParserKW_DEBUG, HiveParserKW_DEFAULT, HiveParserKW_DEFERRED, HiveParserKW_DEFINED, HiveParserKW_DELIMITED, HiveParserKW_DEPENDENCY, HiveParserKW_DESC, HiveParserKW_DETAIL, HiveParserKW_DIRECTORIES, HiveParserKW_DIRECTORY, HiveParserKW_DISABLE, HiveParserKW_DISTRIBUTE, HiveParserKW_DISTRIBUTED, HiveParserKW_DO, HiveParserKW_DOW, HiveParserKW_DUMP, HiveParserKW_ELEM_TYPE, HiveParserKW_ENABLE, HiveParserKW_ENFORCED, HiveParserKW_ESCAPED, HiveParserKW_EVERY, HiveParserKW_EXCLUSIVE, HiveParserKW_EXECUTE, HiveParserKW_EXECUTED, HiveParserKW_EXPIRE_SNAPSHOTS, HiveParserKW_EXPLAIN, HiveParserKW_EXPORT, HiveParserKW_EXPRESSION, HiveParserKW_FIELDS, HiveParserKW_FILE, HiveParserKW_FILEFORMAT, HiveParserKW_FIRST, HiveParserKW_FORMAT, HiveParserKW_FORMATTED, HiveParserKW_FUNCTIONS, HiveParserKW_HOLD_DDLTIME, HiveParserKW_HOUR, HiveParserKW_IDXPROPERTIES, HiveParserKW_IGNORE, HiveParserKW_INDEX, HiveParserKW_INDEXES, HiveParserKW_INPATH, HiveParserKW_INPUTDRIVER, HiveParserKW_INPUTFORMAT, HiveParserKW_ISOLATION, HiveParserKW_ITEMS, HiveParserKW_JAR, HiveParserKW_JOINCOST, HiveParserKW_KEY, HiveParserKW_KEYS, HiveParserKW_KEY_TYPE, HiveParserKW_KILL, HiveParserKW_LAST, HiveParserKW_LEVEL, HiveParserKW_LIMIT, HiveParserKW_LINES, HiveParserKW_LOAD, HiveParserKW_LOCATION, HiveParserKW_LOCK, HiveParserKW_LOCKS, HiveParserKW_LOGICAL, HiveParserKW_LONG, HiveParserKW_MANAGED, HiveParserKW_MANAGEDLOCATION, HiveParserKW_MANAGEMENT, HiveParserKW_MAPJOIN, HiveParserKW_MAPPING, HiveParserKW_MATCHED, HiveParserKW_MATERIALIZED, HiveParserKW_METADATA, HiveParserKW_MINUTE, HiveParserKW_MONTH, HiveParserKW_MOVE, HiveParserKW_MSCK, HiveParserKW_NORELY, HiveParserKW_NOSCAN, HiveParserKW_NOVALIDATE, HiveParserKW_NO_DROP, HiveParserKW_NULLS, HiveParserKW_OFFLINE, HiveParserKW_OFFSET, HiveParserKW_OPERATOR, HiveParserKW_OPTION, HiveParserKW_OUTPUTDRIVER, HiveParserKW_OUTPUTFORMAT, HiveParserKW_OVERWRITE, HiveParserKW_OWNER, HiveParserKW_PARTITIONED, HiveParserKW_PARTITIONS, HiveParserKW_PATH, HiveParserKW_PLAN, HiveParserKW_PLANS, HiveParserKW_PLUS, HiveParserKW_POOL, HiveParserKW_PRINCIPALS, HiveParserKW_PROTECTION, HiveParserKW_PURGE, HiveParserKW_QUARTER, HiveParserKW_QUERY, HiveParserKW_QUERY_PARALLELISM, HiveParserKW_READ, HiveParserKW_READONLY, HiveParserKW_REBUILD, HiveParserKW_RECORDREADER, HiveParserKW_RECORDWRITER, HiveParserKW_RELOAD, HiveParserKW_RELY, HiveParserKW_REMOTE, HiveParserKW_RENAME, HiveParserKW_REOPTIMIZATION, HiveParserKW_REPAIR, HiveParserKW_REPL, HiveParserKW_REPLACE, HiveParserKW_REPLICATION, HiveParserKW_RESOURCE, HiveParserKW_RESPECT, HiveParserKW_RESTRICT, HiveParserKW_REWRITE, HiveParserKW_ROLE, HiveParserKW_ROLES, HiveParserKW_SCHEDULED, HiveParserKW_SCHEDULING_POLICY, HiveParserKW_SCHEMA, HiveParserKW_SCHEMAS, HiveParserKW_SECOND, HiveParserKW_SEMI, HiveParserKW_SERDE, HiveParserKW_SERDEPROPERTIES, HiveParserKW_SERVER, HiveParserKW_SETS, HiveParserKW_SET_CURRENT_SNAPSHOT, HiveParserKW_SHARED, HiveParserKW_SHOW, HiveParserKW_SHOW_DATABASE, HiveParserKW_SKEWED, HiveParserKW_SNAPSHOT, HiveParserKW_SORT, HiveParserKW_SORTED, HiveParserKW_SPEC, HiveParserKW_SSL, HiveParserKW_STATISTICS, HiveParserKW_STATUS, HiveParserKW_STORED, HiveParserKW_STREAMTABLE, HiveParserKW_STRING, HiveParserKW_STRUCT, HiveParserKW_SUMMARY, HiveParserKW_SYSTEM_TIME, HiveParserKW_SYSTEM_VERSION, HiveParserKW_TABLES, HiveParserKW_TBLPROPERTIES, HiveParserKW_TEMPORARY, HiveParserKW_TERMINATED, HiveParserKW_TIMESTAMPTZ, HiveParserKW_TINYINT, HiveParserKW_TOUCH, HiveParserKW_TRANSACTION, HiveParserKW_TRANSACTIONAL, HiveParserKW_TRANSACTIONS, HiveParserKW_TRIM, HiveParserKW_TYPE, HiveParserKW_UNARCHIVE, HiveParserKW_UNDO, HiveParserKW_UNIONTYPE, HiveParserKW_UNKNOWN, HiveParserKW_UNLOCK, HiveParserKW_UNMANAGED, HiveParserKW_UNSET, HiveParserKW_UNSIGNED, HiveParserKW_URI, HiveParserKW_URL, HiveParserKW_USE, HiveParserKW_UTC, HiveParserKW_UTCTIMESTAMP, HiveParserKW_VALIDATE, HiveParserKW_VALUE_TYPE, HiveParserKW_VECTORIZATION, HiveParserKW_VIEW, HiveParserKW_VIEWS, HiveParserKW_WAIT, HiveParserKW_WEEK, HiveParserKW_WHILE, HiveParserKW_WITHIN, HiveParserKW_WORK, HiveParserKW_WORKLOAD, HiveParserKW_WRITE, HiveParserKW_YEAR, HiveParserKW_ZONE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4900)
			p.NonReserved()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFunctionIdentifierContext is an interface to support dynamic dispatch.
type IFunctionIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFn returns the fn rule contexts.
	GetFn() IId_Context


	// SetFn sets the fn rule contexts.
	SetFn(IId_Context)


	// Getter signatures
	AllId_() []IId_Context
	Id_(i int) IId_Context
	DOT() antlr.TerminalNode

	// IsFunctionIdentifierContext differentiates from other interfaces.
	IsFunctionIdentifierContext()
}

type FunctionIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	fn IId_Context 
}

func NewEmptyFunctionIdentifierContext() *FunctionIdentifierContext {
	var p = new(FunctionIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_functionIdentifier
	return p
}

func InitEmptyFunctionIdentifierContext(p *FunctionIdentifierContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_functionIdentifier
}

func (*FunctionIdentifierContext) IsFunctionIdentifierContext() {}

func NewFunctionIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionIdentifierContext {
	var p = new(FunctionIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_functionIdentifier

	return p
}

func (s *FunctionIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionIdentifierContext) GetFn() IId_Context { return s.fn }


func (s *FunctionIdentifierContext) SetFn(v IId_Context) { s.fn = v }


func (s *FunctionIdentifierContext) AllId_() []IId_Context {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IId_Context); ok {
			len++
		}
	}

	tst := make([]IId_Context, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IId_Context); ok {
			tst[i] = t.(IId_Context)
			i++
		}
	}

	return tst
}

func (s *FunctionIdentifierContext) Id_(i int) IId_Context {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *FunctionIdentifierContext) DOT() antlr.TerminalNode {
	return s.GetToken(HiveParserDOT, 0)
}

func (s *FunctionIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *FunctionIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterFunctionIdentifier(s)
	}
}

func (s *FunctionIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitFunctionIdentifier(s)
	}
}

func (s *FunctionIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitFunctionIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) FunctionIdentifier() (localctx IFunctionIdentifierContext) {
	localctx = NewFunctionIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 898, HiveParserRULE_functionIdentifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4903)
		p.Id_()
	}
	p.SetState(4906)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserDOT {
		{
			p.SetState(4904)
			p.Match(HiveParserDOT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4905)

			var _x = p.Id_()


			localctx.(*FunctionIdentifierContext).fn = _x
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPrincipalIdentifierContext is an interface to support dynamic dispatch.
type IPrincipalIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Id_() IId_Context

	// IsPrincipalIdentifierContext differentiates from other interfaces.
	IsPrincipalIdentifierContext()
}

type PrincipalIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrincipalIdentifierContext() *PrincipalIdentifierContext {
	var p = new(PrincipalIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_principalIdentifier
	return p
}

func InitEmptyPrincipalIdentifierContext(p *PrincipalIdentifierContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_principalIdentifier
}

func (*PrincipalIdentifierContext) IsPrincipalIdentifierContext() {}

func NewPrincipalIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrincipalIdentifierContext {
	var p = new(PrincipalIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_principalIdentifier

	return p
}

func (s *PrincipalIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *PrincipalIdentifierContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *PrincipalIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrincipalIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PrincipalIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterPrincipalIdentifier(s)
	}
}

func (s *PrincipalIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitPrincipalIdentifier(s)
	}
}

func (s *PrincipalIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitPrincipalIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) PrincipalIdentifier() (localctx IPrincipalIdentifierContext) {
	localctx = NewPrincipalIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 900, HiveParserRULE_principalIdentifier)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4908)
		p.Id_()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// INonReservedContext is an interface to support dynamic dispatch.
type INonReservedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_ABORT() antlr.TerminalNode
	KW_ACTIVATE() antlr.TerminalNode
	KW_ACTIVE() antlr.TerminalNode
	KW_ADD() antlr.TerminalNode
	KW_ADMIN() antlr.TerminalNode
	KW_AFTER() antlr.TerminalNode
	KW_ALLOC_FRACTION() antlr.TerminalNode
	KW_ANALYZE() antlr.TerminalNode
	KW_ARCHIVE() antlr.TerminalNode
	KW_ASC() antlr.TerminalNode
	KW_AST() antlr.TerminalNode
	KW_AT() antlr.TerminalNode
	KW_AUTOCOMMIT() antlr.TerminalNode
	KW_BATCH() antlr.TerminalNode
	KW_BEFORE() antlr.TerminalNode
	KW_BUCKET() antlr.TerminalNode
	KW_BUCKETS() antlr.TerminalNode
	KW_CACHE() antlr.TerminalNode
	KW_CASCADE() antlr.TerminalNode
	KW_CBO() antlr.TerminalNode
	KW_CHANGE() antlr.TerminalNode
	KW_CHECK() antlr.TerminalNode
	KW_CLUSTER() antlr.TerminalNode
	KW_CLUSTERED() antlr.TerminalNode
	KW_CLUSTERSTATUS() antlr.TerminalNode
	KW_COLLECTION() antlr.TerminalNode
	KW_COLUMNS() antlr.TerminalNode
	KW_COMMENT() antlr.TerminalNode
	KW_COMPACT() antlr.TerminalNode
	KW_COMPACTIONS() antlr.TerminalNode
	KW_COMPUTE() antlr.TerminalNode
	KW_CONCATENATE() antlr.TerminalNode
	KW_CONTINUE() antlr.TerminalNode
	KW_COST() antlr.TerminalNode
	KW_CRON() antlr.TerminalNode
	KW_DATA() antlr.TerminalNode
	KW_DATABASES() antlr.TerminalNode
	KW_DATETIME() antlr.TerminalNode
	KW_DAY() antlr.TerminalNode
	KW_DAYOFWEEK() antlr.TerminalNode
	KW_DBPROPERTIES() antlr.TerminalNode
	KW_DCPROPERTIES() antlr.TerminalNode
	KW_DEBUG() antlr.TerminalNode
	KW_DEFAULT() antlr.TerminalNode
	KW_DEFERRED() antlr.TerminalNode
	KW_DEFINED() antlr.TerminalNode
	KW_DELIMITED() antlr.TerminalNode
	KW_DEPENDENCY() antlr.TerminalNode
	KW_DESC() antlr.TerminalNode
	KW_DETAIL() antlr.TerminalNode
	KW_DIRECTORIES() antlr.TerminalNode
	KW_DIRECTORY() antlr.TerminalNode
	KW_DISABLE() antlr.TerminalNode
	KW_DISTRIBUTE() antlr.TerminalNode
	KW_DISTRIBUTED() antlr.TerminalNode
	KW_DO() antlr.TerminalNode
	KW_DOW() antlr.TerminalNode
	KW_DUMP() antlr.TerminalNode
	KW_ELEM_TYPE() antlr.TerminalNode
	KW_ENABLE() antlr.TerminalNode
	KW_ENFORCED() antlr.TerminalNode
	KW_ESCAPED() antlr.TerminalNode
	KW_EVERY() antlr.TerminalNode
	KW_EXCLUSIVE() antlr.TerminalNode
	KW_EXECUTE() antlr.TerminalNode
	KW_EXECUTED() antlr.TerminalNode
	KW_EXPIRE_SNAPSHOTS() antlr.TerminalNode
	KW_EXPLAIN() antlr.TerminalNode
	KW_EXPORT() antlr.TerminalNode
	KW_EXPRESSION() antlr.TerminalNode
	KW_FIELDS() antlr.TerminalNode
	KW_FILE() antlr.TerminalNode
	KW_FILEFORMAT() antlr.TerminalNode
	KW_FIRST() antlr.TerminalNode
	KW_FORMAT() antlr.TerminalNode
	KW_FORMATTED() antlr.TerminalNode
	KW_FUNCTIONS() antlr.TerminalNode
	KW_HOLD_DDLTIME() antlr.TerminalNode
	KW_HOUR() antlr.TerminalNode
	KW_IDXPROPERTIES() antlr.TerminalNode
	KW_IGNORE() antlr.TerminalNode
	KW_INDEX() antlr.TerminalNode
	KW_INDEXES() antlr.TerminalNode
	KW_INPATH() antlr.TerminalNode
	KW_INPUTDRIVER() antlr.TerminalNode
	KW_INPUTFORMAT() antlr.TerminalNode
	KW_ISOLATION() antlr.TerminalNode
	KW_ITEMS() antlr.TerminalNode
	KW_JAR() antlr.TerminalNode
	KW_JOINCOST() antlr.TerminalNode
	KW_KEY() antlr.TerminalNode
	KW_KEYS() antlr.TerminalNode
	KW_KEY_TYPE() antlr.TerminalNode
	KW_KILL() antlr.TerminalNode
	KW_LAST() antlr.TerminalNode
	KW_LEVEL() antlr.TerminalNode
	KW_LIMIT() antlr.TerminalNode
	KW_LINES() antlr.TerminalNode
	KW_LOAD() antlr.TerminalNode
	KW_LOCATION() antlr.TerminalNode
	KW_LOCK() antlr.TerminalNode
	KW_LOCKS() antlr.TerminalNode
	KW_LOGICAL() antlr.TerminalNode
	KW_LONG() antlr.TerminalNode
	KW_MANAGED() antlr.TerminalNode
	KW_MANAGEDLOCATION() antlr.TerminalNode
	KW_MANAGEMENT() antlr.TerminalNode
	KW_MAPJOIN() antlr.TerminalNode
	KW_MAPPING() antlr.TerminalNode
	KW_MATCHED() antlr.TerminalNode
	KW_MATERIALIZED() antlr.TerminalNode
	KW_METADATA() antlr.TerminalNode
	KW_MINUTE() antlr.TerminalNode
	KW_MONTH() antlr.TerminalNode
	KW_MOVE() antlr.TerminalNode
	KW_MSCK() antlr.TerminalNode
	KW_NORELY() antlr.TerminalNode
	KW_NOSCAN() antlr.TerminalNode
	KW_NOVALIDATE() antlr.TerminalNode
	KW_NO_DROP() antlr.TerminalNode
	KW_NULLS() antlr.TerminalNode
	KW_OFFLINE() antlr.TerminalNode
	KW_OFFSET() antlr.TerminalNode
	KW_OPERATOR() antlr.TerminalNode
	KW_OPTION() antlr.TerminalNode
	KW_OUTPUTDRIVER() antlr.TerminalNode
	KW_OUTPUTFORMAT() antlr.TerminalNode
	KW_OVERWRITE() antlr.TerminalNode
	KW_OWNER() antlr.TerminalNode
	KW_PARTITIONED() antlr.TerminalNode
	KW_PARTITIONS() antlr.TerminalNode
	KW_PATH() antlr.TerminalNode
	KW_PLAN() antlr.TerminalNode
	KW_PLANS() antlr.TerminalNode
	KW_PLUS() antlr.TerminalNode
	KW_POOL() antlr.TerminalNode
	KW_PRINCIPALS() antlr.TerminalNode
	KW_PROTECTION() antlr.TerminalNode
	KW_PURGE() antlr.TerminalNode
	KW_QUARTER() antlr.TerminalNode
	KW_QUERY() antlr.TerminalNode
	KW_QUERY_PARALLELISM() antlr.TerminalNode
	KW_READ() antlr.TerminalNode
	KW_READONLY() antlr.TerminalNode
	KW_REBUILD() antlr.TerminalNode
	KW_RECORDREADER() antlr.TerminalNode
	KW_RECORDWRITER() antlr.TerminalNode
	KW_RELOAD() antlr.TerminalNode
	KW_RELY() antlr.TerminalNode
	KW_REMOTE() antlr.TerminalNode
	KW_RENAME() antlr.TerminalNode
	KW_REOPTIMIZATION() antlr.TerminalNode
	KW_REPAIR() antlr.TerminalNode
	KW_REPL() antlr.TerminalNode
	KW_REPLACE() antlr.TerminalNode
	KW_REPLICATION() antlr.TerminalNode
	KW_RESOURCE() antlr.TerminalNode
	KW_RESPECT() antlr.TerminalNode
	KW_RESTRICT() antlr.TerminalNode
	KW_REWRITE() antlr.TerminalNode
	KW_ROLE() antlr.TerminalNode
	KW_ROLES() antlr.TerminalNode
	KW_SCHEDULED() antlr.TerminalNode
	KW_SCHEDULING_POLICY() antlr.TerminalNode
	KW_SCHEMA() antlr.TerminalNode
	KW_SCHEMAS() antlr.TerminalNode
	KW_SECOND() antlr.TerminalNode
	KW_SEMI() antlr.TerminalNode
	KW_SERDE() antlr.TerminalNode
	KW_SERDEPROPERTIES() antlr.TerminalNode
	KW_SERVER() antlr.TerminalNode
	KW_SETS() antlr.TerminalNode
	KW_SET_CURRENT_SNAPSHOT() antlr.TerminalNode
	KW_SHARED() antlr.TerminalNode
	KW_SHOW() antlr.TerminalNode
	KW_SHOW_DATABASE() antlr.TerminalNode
	KW_SKEWED() antlr.TerminalNode
	KW_SNAPSHOT() antlr.TerminalNode
	KW_SORT() antlr.TerminalNode
	KW_SORTED() antlr.TerminalNode
	KW_SPEC() antlr.TerminalNode
	KW_SSL() antlr.TerminalNode
	KW_STATISTICS() antlr.TerminalNode
	KW_STATUS() antlr.TerminalNode
	KW_STORED() antlr.TerminalNode
	KW_STREAMTABLE() antlr.TerminalNode
	KW_STRING() antlr.TerminalNode
	KW_STRUCT() antlr.TerminalNode
	KW_SUMMARY() antlr.TerminalNode
	KW_SYSTEM_TIME() antlr.TerminalNode
	KW_SYSTEM_VERSION() antlr.TerminalNode
	KW_TABLES() antlr.TerminalNode
	KW_TBLPROPERTIES() antlr.TerminalNode
	KW_TEMPORARY() antlr.TerminalNode
	KW_TERMINATED() antlr.TerminalNode
	KW_TIMESTAMPTZ() antlr.TerminalNode
	KW_TINYINT() antlr.TerminalNode
	KW_TOUCH() antlr.TerminalNode
	KW_TRANSACTION() antlr.TerminalNode
	KW_TRANSACTIONAL() antlr.TerminalNode
	KW_TRANSACTIONS() antlr.TerminalNode
	KW_TRIM() antlr.TerminalNode
	KW_TYPE() antlr.TerminalNode
	KW_UNARCHIVE() antlr.TerminalNode
	KW_UNDO() antlr.TerminalNode
	KW_UNIONTYPE() antlr.TerminalNode
	KW_UNKNOWN() antlr.TerminalNode
	KW_UNLOCK() antlr.TerminalNode
	KW_UNMANAGED() antlr.TerminalNode
	KW_UNSET() antlr.TerminalNode
	KW_UNSIGNED() antlr.TerminalNode
	KW_URI() antlr.TerminalNode
	KW_URL() antlr.TerminalNode
	KW_USE() antlr.TerminalNode
	KW_UTC() antlr.TerminalNode
	KW_UTCTIMESTAMP() antlr.TerminalNode
	KW_VALIDATE() antlr.TerminalNode
	KW_VALUE_TYPE() antlr.TerminalNode
	KW_VECTORIZATION() antlr.TerminalNode
	KW_VIEW() antlr.TerminalNode
	KW_VIEWS() antlr.TerminalNode
	KW_WAIT() antlr.TerminalNode
	KW_WEEK() antlr.TerminalNode
	KW_WHILE() antlr.TerminalNode
	KW_WITHIN() antlr.TerminalNode
	KW_WORK() antlr.TerminalNode
	KW_WORKLOAD() antlr.TerminalNode
	KW_WRITE() antlr.TerminalNode
	KW_YEAR() antlr.TerminalNode
	KW_ZONE() antlr.TerminalNode

	// IsNonReservedContext differentiates from other interfaces.
	IsNonReservedContext()
}

type NonReservedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNonReservedContext() *NonReservedContext {
	var p = new(NonReservedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_nonReserved
	return p
}

func InitEmptyNonReservedContext(p *NonReservedContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_nonReserved
}

func (*NonReservedContext) IsNonReservedContext() {}

func NewNonReservedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NonReservedContext {
	var p = new(NonReservedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_nonReserved

	return p
}

func (s *NonReservedContext) GetParser() antlr.Parser { return s.parser }

func (s *NonReservedContext) KW_ABORT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ABORT, 0)
}

func (s *NonReservedContext) KW_ACTIVATE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ACTIVATE, 0)
}

func (s *NonReservedContext) KW_ACTIVE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ACTIVE, 0)
}

func (s *NonReservedContext) KW_ADD() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ADD, 0)
}

func (s *NonReservedContext) KW_ADMIN() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ADMIN, 0)
}

func (s *NonReservedContext) KW_AFTER() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_AFTER, 0)
}

func (s *NonReservedContext) KW_ALLOC_FRACTION() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ALLOC_FRACTION, 0)
}

func (s *NonReservedContext) KW_ANALYZE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ANALYZE, 0)
}

func (s *NonReservedContext) KW_ARCHIVE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ARCHIVE, 0)
}

func (s *NonReservedContext) KW_ASC() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ASC, 0)
}

func (s *NonReservedContext) KW_AST() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_AST, 0)
}

func (s *NonReservedContext) KW_AT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_AT, 0)
}

func (s *NonReservedContext) KW_AUTOCOMMIT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_AUTOCOMMIT, 0)
}

func (s *NonReservedContext) KW_BATCH() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_BATCH, 0)
}

func (s *NonReservedContext) KW_BEFORE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_BEFORE, 0)
}

func (s *NonReservedContext) KW_BUCKET() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_BUCKET, 0)
}

func (s *NonReservedContext) KW_BUCKETS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_BUCKETS, 0)
}

func (s *NonReservedContext) KW_CACHE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_CACHE, 0)
}

func (s *NonReservedContext) KW_CASCADE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_CASCADE, 0)
}

func (s *NonReservedContext) KW_CBO() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_CBO, 0)
}

func (s *NonReservedContext) KW_CHANGE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_CHANGE, 0)
}

func (s *NonReservedContext) KW_CHECK() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_CHECK, 0)
}

func (s *NonReservedContext) KW_CLUSTER() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_CLUSTER, 0)
}

func (s *NonReservedContext) KW_CLUSTERED() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_CLUSTERED, 0)
}

func (s *NonReservedContext) KW_CLUSTERSTATUS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_CLUSTERSTATUS, 0)
}

func (s *NonReservedContext) KW_COLLECTION() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_COLLECTION, 0)
}

func (s *NonReservedContext) KW_COLUMNS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_COLUMNS, 0)
}

func (s *NonReservedContext) KW_COMMENT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_COMMENT, 0)
}

func (s *NonReservedContext) KW_COMPACT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_COMPACT, 0)
}

func (s *NonReservedContext) KW_COMPACTIONS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_COMPACTIONS, 0)
}

func (s *NonReservedContext) KW_COMPUTE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_COMPUTE, 0)
}

func (s *NonReservedContext) KW_CONCATENATE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_CONCATENATE, 0)
}

func (s *NonReservedContext) KW_CONTINUE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_CONTINUE, 0)
}

func (s *NonReservedContext) KW_COST() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_COST, 0)
}

func (s *NonReservedContext) KW_CRON() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_CRON, 0)
}

func (s *NonReservedContext) KW_DATA() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DATA, 0)
}

func (s *NonReservedContext) KW_DATABASES() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DATABASES, 0)
}

func (s *NonReservedContext) KW_DATETIME() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DATETIME, 0)
}

func (s *NonReservedContext) KW_DAY() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DAY, 0)
}

func (s *NonReservedContext) KW_DAYOFWEEK() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DAYOFWEEK, 0)
}

func (s *NonReservedContext) KW_DBPROPERTIES() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DBPROPERTIES, 0)
}

func (s *NonReservedContext) KW_DCPROPERTIES() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DCPROPERTIES, 0)
}

func (s *NonReservedContext) KW_DEBUG() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DEBUG, 0)
}

func (s *NonReservedContext) KW_DEFAULT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DEFAULT, 0)
}

func (s *NonReservedContext) KW_DEFERRED() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DEFERRED, 0)
}

func (s *NonReservedContext) KW_DEFINED() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DEFINED, 0)
}

func (s *NonReservedContext) KW_DELIMITED() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DELIMITED, 0)
}

func (s *NonReservedContext) KW_DEPENDENCY() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DEPENDENCY, 0)
}

func (s *NonReservedContext) KW_DESC() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DESC, 0)
}

func (s *NonReservedContext) KW_DETAIL() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DETAIL, 0)
}

func (s *NonReservedContext) KW_DIRECTORIES() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DIRECTORIES, 0)
}

func (s *NonReservedContext) KW_DIRECTORY() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DIRECTORY, 0)
}

func (s *NonReservedContext) KW_DISABLE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DISABLE, 0)
}

func (s *NonReservedContext) KW_DISTRIBUTE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DISTRIBUTE, 0)
}

func (s *NonReservedContext) KW_DISTRIBUTED() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DISTRIBUTED, 0)
}

func (s *NonReservedContext) KW_DO() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DO, 0)
}

func (s *NonReservedContext) KW_DOW() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DOW, 0)
}

func (s *NonReservedContext) KW_DUMP() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DUMP, 0)
}

func (s *NonReservedContext) KW_ELEM_TYPE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ELEM_TYPE, 0)
}

func (s *NonReservedContext) KW_ENABLE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ENABLE, 0)
}

func (s *NonReservedContext) KW_ENFORCED() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ENFORCED, 0)
}

func (s *NonReservedContext) KW_ESCAPED() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ESCAPED, 0)
}

func (s *NonReservedContext) KW_EVERY() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_EVERY, 0)
}

func (s *NonReservedContext) KW_EXCLUSIVE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_EXCLUSIVE, 0)
}

func (s *NonReservedContext) KW_EXECUTE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_EXECUTE, 0)
}

func (s *NonReservedContext) KW_EXECUTED() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_EXECUTED, 0)
}

func (s *NonReservedContext) KW_EXPIRE_SNAPSHOTS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_EXPIRE_SNAPSHOTS, 0)
}

func (s *NonReservedContext) KW_EXPLAIN() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_EXPLAIN, 0)
}

func (s *NonReservedContext) KW_EXPORT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_EXPORT, 0)
}

func (s *NonReservedContext) KW_EXPRESSION() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_EXPRESSION, 0)
}

func (s *NonReservedContext) KW_FIELDS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_FIELDS, 0)
}

func (s *NonReservedContext) KW_FILE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_FILE, 0)
}

func (s *NonReservedContext) KW_FILEFORMAT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_FILEFORMAT, 0)
}

func (s *NonReservedContext) KW_FIRST() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_FIRST, 0)
}

func (s *NonReservedContext) KW_FORMAT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_FORMAT, 0)
}

func (s *NonReservedContext) KW_FORMATTED() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_FORMATTED, 0)
}

func (s *NonReservedContext) KW_FUNCTIONS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_FUNCTIONS, 0)
}

func (s *NonReservedContext) KW_HOLD_DDLTIME() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_HOLD_DDLTIME, 0)
}

func (s *NonReservedContext) KW_HOUR() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_HOUR, 0)
}

func (s *NonReservedContext) KW_IDXPROPERTIES() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_IDXPROPERTIES, 0)
}

func (s *NonReservedContext) KW_IGNORE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_IGNORE, 0)
}

func (s *NonReservedContext) KW_INDEX() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_INDEX, 0)
}

func (s *NonReservedContext) KW_INDEXES() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_INDEXES, 0)
}

func (s *NonReservedContext) KW_INPATH() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_INPATH, 0)
}

func (s *NonReservedContext) KW_INPUTDRIVER() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_INPUTDRIVER, 0)
}

func (s *NonReservedContext) KW_INPUTFORMAT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_INPUTFORMAT, 0)
}

func (s *NonReservedContext) KW_ISOLATION() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ISOLATION, 0)
}

func (s *NonReservedContext) KW_ITEMS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ITEMS, 0)
}

func (s *NonReservedContext) KW_JAR() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_JAR, 0)
}

func (s *NonReservedContext) KW_JOINCOST() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_JOINCOST, 0)
}

func (s *NonReservedContext) KW_KEY() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_KEY, 0)
}

func (s *NonReservedContext) KW_KEYS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_KEYS, 0)
}

func (s *NonReservedContext) KW_KEY_TYPE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_KEY_TYPE, 0)
}

func (s *NonReservedContext) KW_KILL() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_KILL, 0)
}

func (s *NonReservedContext) KW_LAST() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_LAST, 0)
}

func (s *NonReservedContext) KW_LEVEL() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_LEVEL, 0)
}

func (s *NonReservedContext) KW_LIMIT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_LIMIT, 0)
}

func (s *NonReservedContext) KW_LINES() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_LINES, 0)
}

func (s *NonReservedContext) KW_LOAD() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_LOAD, 0)
}

func (s *NonReservedContext) KW_LOCATION() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_LOCATION, 0)
}

func (s *NonReservedContext) KW_LOCK() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_LOCK, 0)
}

func (s *NonReservedContext) KW_LOCKS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_LOCKS, 0)
}

func (s *NonReservedContext) KW_LOGICAL() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_LOGICAL, 0)
}

func (s *NonReservedContext) KW_LONG() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_LONG, 0)
}

func (s *NonReservedContext) KW_MANAGED() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_MANAGED, 0)
}

func (s *NonReservedContext) KW_MANAGEDLOCATION() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_MANAGEDLOCATION, 0)
}

func (s *NonReservedContext) KW_MANAGEMENT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_MANAGEMENT, 0)
}

func (s *NonReservedContext) KW_MAPJOIN() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_MAPJOIN, 0)
}

func (s *NonReservedContext) KW_MAPPING() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_MAPPING, 0)
}

func (s *NonReservedContext) KW_MATCHED() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_MATCHED, 0)
}

func (s *NonReservedContext) KW_MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_MATERIALIZED, 0)
}

func (s *NonReservedContext) KW_METADATA() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_METADATA, 0)
}

func (s *NonReservedContext) KW_MINUTE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_MINUTE, 0)
}

func (s *NonReservedContext) KW_MONTH() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_MONTH, 0)
}

func (s *NonReservedContext) KW_MOVE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_MOVE, 0)
}

func (s *NonReservedContext) KW_MSCK() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_MSCK, 0)
}

func (s *NonReservedContext) KW_NORELY() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_NORELY, 0)
}

func (s *NonReservedContext) KW_NOSCAN() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_NOSCAN, 0)
}

func (s *NonReservedContext) KW_NOVALIDATE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_NOVALIDATE, 0)
}

func (s *NonReservedContext) KW_NO_DROP() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_NO_DROP, 0)
}

func (s *NonReservedContext) KW_NULLS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_NULLS, 0)
}

func (s *NonReservedContext) KW_OFFLINE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_OFFLINE, 0)
}

func (s *NonReservedContext) KW_OFFSET() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_OFFSET, 0)
}

func (s *NonReservedContext) KW_OPERATOR() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_OPERATOR, 0)
}

func (s *NonReservedContext) KW_OPTION() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_OPTION, 0)
}

func (s *NonReservedContext) KW_OUTPUTDRIVER() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_OUTPUTDRIVER, 0)
}

func (s *NonReservedContext) KW_OUTPUTFORMAT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_OUTPUTFORMAT, 0)
}

func (s *NonReservedContext) KW_OVERWRITE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_OVERWRITE, 0)
}

func (s *NonReservedContext) KW_OWNER() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_OWNER, 0)
}

func (s *NonReservedContext) KW_PARTITIONED() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_PARTITIONED, 0)
}

func (s *NonReservedContext) KW_PARTITIONS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_PARTITIONS, 0)
}

func (s *NonReservedContext) KW_PATH() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_PATH, 0)
}

func (s *NonReservedContext) KW_PLAN() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_PLAN, 0)
}

func (s *NonReservedContext) KW_PLANS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_PLANS, 0)
}

func (s *NonReservedContext) KW_PLUS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_PLUS, 0)
}

func (s *NonReservedContext) KW_POOL() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_POOL, 0)
}

func (s *NonReservedContext) KW_PRINCIPALS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_PRINCIPALS, 0)
}

func (s *NonReservedContext) KW_PROTECTION() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_PROTECTION, 0)
}

func (s *NonReservedContext) KW_PURGE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_PURGE, 0)
}

func (s *NonReservedContext) KW_QUARTER() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_QUARTER, 0)
}

func (s *NonReservedContext) KW_QUERY() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_QUERY, 0)
}

func (s *NonReservedContext) KW_QUERY_PARALLELISM() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_QUERY_PARALLELISM, 0)
}

func (s *NonReservedContext) KW_READ() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_READ, 0)
}

func (s *NonReservedContext) KW_READONLY() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_READONLY, 0)
}

func (s *NonReservedContext) KW_REBUILD() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_REBUILD, 0)
}

func (s *NonReservedContext) KW_RECORDREADER() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_RECORDREADER, 0)
}

func (s *NonReservedContext) KW_RECORDWRITER() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_RECORDWRITER, 0)
}

func (s *NonReservedContext) KW_RELOAD() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_RELOAD, 0)
}

func (s *NonReservedContext) KW_RELY() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_RELY, 0)
}

func (s *NonReservedContext) KW_REMOTE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_REMOTE, 0)
}

func (s *NonReservedContext) KW_RENAME() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_RENAME, 0)
}

func (s *NonReservedContext) KW_REOPTIMIZATION() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_REOPTIMIZATION, 0)
}

func (s *NonReservedContext) KW_REPAIR() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_REPAIR, 0)
}

func (s *NonReservedContext) KW_REPL() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_REPL, 0)
}

func (s *NonReservedContext) KW_REPLACE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_REPLACE, 0)
}

func (s *NonReservedContext) KW_REPLICATION() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_REPLICATION, 0)
}

func (s *NonReservedContext) KW_RESOURCE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_RESOURCE, 0)
}

func (s *NonReservedContext) KW_RESPECT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_RESPECT, 0)
}

func (s *NonReservedContext) KW_RESTRICT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_RESTRICT, 0)
}

func (s *NonReservedContext) KW_REWRITE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_REWRITE, 0)
}

func (s *NonReservedContext) KW_ROLE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ROLE, 0)
}

func (s *NonReservedContext) KW_ROLES() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ROLES, 0)
}

func (s *NonReservedContext) KW_SCHEDULED() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SCHEDULED, 0)
}

func (s *NonReservedContext) KW_SCHEDULING_POLICY() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SCHEDULING_POLICY, 0)
}

func (s *NonReservedContext) KW_SCHEMA() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SCHEMA, 0)
}

func (s *NonReservedContext) KW_SCHEMAS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SCHEMAS, 0)
}

func (s *NonReservedContext) KW_SECOND() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SECOND, 0)
}

func (s *NonReservedContext) KW_SEMI() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SEMI, 0)
}

func (s *NonReservedContext) KW_SERDE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SERDE, 0)
}

func (s *NonReservedContext) KW_SERDEPROPERTIES() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SERDEPROPERTIES, 0)
}

func (s *NonReservedContext) KW_SERVER() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SERVER, 0)
}

func (s *NonReservedContext) KW_SETS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SETS, 0)
}

func (s *NonReservedContext) KW_SET_CURRENT_SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SET_CURRENT_SNAPSHOT, 0)
}

func (s *NonReservedContext) KW_SHARED() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SHARED, 0)
}

func (s *NonReservedContext) KW_SHOW() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SHOW, 0)
}

func (s *NonReservedContext) KW_SHOW_DATABASE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SHOW_DATABASE, 0)
}

func (s *NonReservedContext) KW_SKEWED() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SKEWED, 0)
}

func (s *NonReservedContext) KW_SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SNAPSHOT, 0)
}

func (s *NonReservedContext) KW_SORT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SORT, 0)
}

func (s *NonReservedContext) KW_SORTED() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SORTED, 0)
}

func (s *NonReservedContext) KW_SPEC() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SPEC, 0)
}

func (s *NonReservedContext) KW_SSL() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SSL, 0)
}

func (s *NonReservedContext) KW_STATISTICS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_STATISTICS, 0)
}

func (s *NonReservedContext) KW_STATUS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_STATUS, 0)
}

func (s *NonReservedContext) KW_STORED() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_STORED, 0)
}

func (s *NonReservedContext) KW_STREAMTABLE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_STREAMTABLE, 0)
}

func (s *NonReservedContext) KW_STRING() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_STRING, 0)
}

func (s *NonReservedContext) KW_STRUCT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_STRUCT, 0)
}

func (s *NonReservedContext) KW_SUMMARY() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SUMMARY, 0)
}

func (s *NonReservedContext) KW_SYSTEM_TIME() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SYSTEM_TIME, 0)
}

func (s *NonReservedContext) KW_SYSTEM_VERSION() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SYSTEM_VERSION, 0)
}

func (s *NonReservedContext) KW_TABLES() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TABLES, 0)
}

func (s *NonReservedContext) KW_TBLPROPERTIES() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TBLPROPERTIES, 0)
}

func (s *NonReservedContext) KW_TEMPORARY() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TEMPORARY, 0)
}

func (s *NonReservedContext) KW_TERMINATED() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TERMINATED, 0)
}

func (s *NonReservedContext) KW_TIMESTAMPTZ() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TIMESTAMPTZ, 0)
}

func (s *NonReservedContext) KW_TINYINT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TINYINT, 0)
}

func (s *NonReservedContext) KW_TOUCH() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TOUCH, 0)
}

func (s *NonReservedContext) KW_TRANSACTION() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TRANSACTION, 0)
}

func (s *NonReservedContext) KW_TRANSACTIONAL() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TRANSACTIONAL, 0)
}

func (s *NonReservedContext) KW_TRANSACTIONS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TRANSACTIONS, 0)
}

func (s *NonReservedContext) KW_TRIM() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TRIM, 0)
}

func (s *NonReservedContext) KW_TYPE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TYPE, 0)
}

func (s *NonReservedContext) KW_UNARCHIVE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_UNARCHIVE, 0)
}

func (s *NonReservedContext) KW_UNDO() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_UNDO, 0)
}

func (s *NonReservedContext) KW_UNIONTYPE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_UNIONTYPE, 0)
}

func (s *NonReservedContext) KW_UNKNOWN() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_UNKNOWN, 0)
}

func (s *NonReservedContext) KW_UNLOCK() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_UNLOCK, 0)
}

func (s *NonReservedContext) KW_UNMANAGED() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_UNMANAGED, 0)
}

func (s *NonReservedContext) KW_UNSET() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_UNSET, 0)
}

func (s *NonReservedContext) KW_UNSIGNED() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_UNSIGNED, 0)
}

func (s *NonReservedContext) KW_URI() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_URI, 0)
}

func (s *NonReservedContext) KW_URL() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_URL, 0)
}

func (s *NonReservedContext) KW_USE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_USE, 0)
}

func (s *NonReservedContext) KW_UTC() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_UTC, 0)
}

func (s *NonReservedContext) KW_UTCTIMESTAMP() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_UTCTIMESTAMP, 0)
}

func (s *NonReservedContext) KW_VALIDATE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_VALIDATE, 0)
}

func (s *NonReservedContext) KW_VALUE_TYPE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_VALUE_TYPE, 0)
}

func (s *NonReservedContext) KW_VECTORIZATION() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_VECTORIZATION, 0)
}

func (s *NonReservedContext) KW_VIEW() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_VIEW, 0)
}

func (s *NonReservedContext) KW_VIEWS() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_VIEWS, 0)
}

func (s *NonReservedContext) KW_WAIT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_WAIT, 0)
}

func (s *NonReservedContext) KW_WEEK() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_WEEK, 0)
}

func (s *NonReservedContext) KW_WHILE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_WHILE, 0)
}

func (s *NonReservedContext) KW_WITHIN() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_WITHIN, 0)
}

func (s *NonReservedContext) KW_WORK() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_WORK, 0)
}

func (s *NonReservedContext) KW_WORKLOAD() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_WORKLOAD, 0)
}

func (s *NonReservedContext) KW_WRITE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_WRITE, 0)
}

func (s *NonReservedContext) KW_YEAR() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_YEAR, 0)
}

func (s *NonReservedContext) KW_ZONE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ZONE, 0)
}

func (s *NonReservedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NonReservedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *NonReservedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterNonReserved(s)
	}
}

func (s *NonReservedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitNonReserved(s)
	}
}

func (s *NonReservedContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitNonReserved(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) NonReserved() (localctx INonReservedContext) {
	localctx = NewNonReservedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 902, HiveParserRULE_nonReserved)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4910)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 808078815591695742) != 0) || ((int64((_la - 66)) & ^0x3f) == 0 && ((int64(1) << (_la - 66)) & 1083038567331911621) != 0) || ((int64((_la - 132)) & ^0x3f) == 0 && ((int64(1) << (_la - 132)) & 8916819943869537315) != 0) || ((int64((_la - 196)) & ^0x3f) == 0 && ((int64(1) << (_la - 196)) & 4159991143015340909) != 0) || ((int64((_la - 261)) & ^0x3f) == 0 && ((int64(1) << (_la - 261)) & 8484708576009596927) != 0) || ((int64((_la - 328)) & ^0x3f) == 0 && ((int64(1) << (_la - 328)) & 17776728909112555) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISql11ReservedKeywordsUsedAsFunctionNameContext is an interface to support dynamic dispatch.
type ISql11ReservedKeywordsUsedAsFunctionNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_ARRAY() antlr.TerminalNode
	KW_BIGINT() antlr.TerminalNode
	KW_BINARY() antlr.TerminalNode
	KW_BOOLEAN() antlr.TerminalNode
	KW_CURRENT_DATE() antlr.TerminalNode
	KW_CURRENT_TIMESTAMP() antlr.TerminalNode
	KW_DATE() antlr.TerminalNode
	KW_DOUBLE() antlr.TerminalNode
	KW_FLOAT() antlr.TerminalNode
	KW_GROUPING() antlr.TerminalNode
	KW_IF() antlr.TerminalNode
	KW_INT() antlr.TerminalNode
	KW_MAP() antlr.TerminalNode
	KW_REAL() antlr.TerminalNode
	KW_SMALLINT() antlr.TerminalNode
	KW_TIMESTAMP() antlr.TerminalNode

	// IsSql11ReservedKeywordsUsedAsFunctionNameContext differentiates from other interfaces.
	IsSql11ReservedKeywordsUsedAsFunctionNameContext()
}

type Sql11ReservedKeywordsUsedAsFunctionNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySql11ReservedKeywordsUsedAsFunctionNameContext() *Sql11ReservedKeywordsUsedAsFunctionNameContext {
	var p = new(Sql11ReservedKeywordsUsedAsFunctionNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_sql11ReservedKeywordsUsedAsFunctionName
	return p
}

func InitEmptySql11ReservedKeywordsUsedAsFunctionNameContext(p *Sql11ReservedKeywordsUsedAsFunctionNameContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_sql11ReservedKeywordsUsedAsFunctionName
}

func (*Sql11ReservedKeywordsUsedAsFunctionNameContext) IsSql11ReservedKeywordsUsedAsFunctionNameContext() {}

func NewSql11ReservedKeywordsUsedAsFunctionNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sql11ReservedKeywordsUsedAsFunctionNameContext {
	var p = new(Sql11ReservedKeywordsUsedAsFunctionNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_sql11ReservedKeywordsUsedAsFunctionName

	return p
}

func (s *Sql11ReservedKeywordsUsedAsFunctionNameContext) GetParser() antlr.Parser { return s.parser }

func (s *Sql11ReservedKeywordsUsedAsFunctionNameContext) KW_ARRAY() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ARRAY, 0)
}

func (s *Sql11ReservedKeywordsUsedAsFunctionNameContext) KW_BIGINT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_BIGINT, 0)
}

func (s *Sql11ReservedKeywordsUsedAsFunctionNameContext) KW_BINARY() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_BINARY, 0)
}

func (s *Sql11ReservedKeywordsUsedAsFunctionNameContext) KW_BOOLEAN() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_BOOLEAN, 0)
}

func (s *Sql11ReservedKeywordsUsedAsFunctionNameContext) KW_CURRENT_DATE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_CURRENT_DATE, 0)
}

func (s *Sql11ReservedKeywordsUsedAsFunctionNameContext) KW_CURRENT_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_CURRENT_TIMESTAMP, 0)
}

func (s *Sql11ReservedKeywordsUsedAsFunctionNameContext) KW_DATE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DATE, 0)
}

func (s *Sql11ReservedKeywordsUsedAsFunctionNameContext) KW_DOUBLE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DOUBLE, 0)
}

func (s *Sql11ReservedKeywordsUsedAsFunctionNameContext) KW_FLOAT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_FLOAT, 0)
}

func (s *Sql11ReservedKeywordsUsedAsFunctionNameContext) KW_GROUPING() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_GROUPING, 0)
}

func (s *Sql11ReservedKeywordsUsedAsFunctionNameContext) KW_IF() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_IF, 0)
}

func (s *Sql11ReservedKeywordsUsedAsFunctionNameContext) KW_INT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_INT, 0)
}

func (s *Sql11ReservedKeywordsUsedAsFunctionNameContext) KW_MAP() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_MAP, 0)
}

func (s *Sql11ReservedKeywordsUsedAsFunctionNameContext) KW_REAL() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_REAL, 0)
}

func (s *Sql11ReservedKeywordsUsedAsFunctionNameContext) KW_SMALLINT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SMALLINT, 0)
}

func (s *Sql11ReservedKeywordsUsedAsFunctionNameContext) KW_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TIMESTAMP, 0)
}

func (s *Sql11ReservedKeywordsUsedAsFunctionNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sql11ReservedKeywordsUsedAsFunctionNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Sql11ReservedKeywordsUsedAsFunctionNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterSql11ReservedKeywordsUsedAsFunctionName(s)
	}
}

func (s *Sql11ReservedKeywordsUsedAsFunctionNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitSql11ReservedKeywordsUsedAsFunctionName(s)
	}
}

func (s *Sql11ReservedKeywordsUsedAsFunctionNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitSql11ReservedKeywordsUsedAsFunctionName(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) Sql11ReservedKeywordsUsedAsFunctionName() (localctx ISql11ReservedKeywordsUsedAsFunctionNameContext) {
	localctx = NewSql11ReservedKeywordsUsedAsFunctionNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 904, HiveParserRULE_sql11ReservedKeywordsUsedAsFunctionName)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4912)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & -9223372036384948224) != 0) || ((int64((_la - 64)) & ^0x3f) == 0 && ((int64(1) << (_la - 64)) & 4611686022722355329) != 0) || ((int64((_la - 140)) & ^0x3f) == 0 && ((int64(1) << (_la - 140)) & 1125899906908193) != 0) || _la == HiveParserKW_REAL || _la == HiveParserKW_SMALLINT || _la == HiveParserKW_TIMESTAMP) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IHintContext is an interface to support dynamic dispatch.
type IHintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HintList() IHintListContext
	EOF() antlr.TerminalNode

	// IsHintContext differentiates from other interfaces.
	IsHintContext()
}

type HintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHintContext() *HintContext {
	var p = new(HintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_hint
	return p
}

func InitEmptyHintContext(p *HintContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_hint
}

func (*HintContext) IsHintContext() {}

func NewHintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HintContext {
	var p = new(HintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_hint

	return p
}

func (s *HintContext) GetParser() antlr.Parser { return s.parser }

func (s *HintContext) HintList() IHintListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHintListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHintListContext)
}

func (s *HintContext) EOF() antlr.TerminalNode {
	return s.GetToken(HiveParserEOF, 0)
}

func (s *HintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *HintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterHint(s)
	}
}

func (s *HintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitHint(s)
	}
}

func (s *HintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitHint(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) Hint() (localctx IHintContext) {
	localctx = NewHintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 906, HiveParserRULE_hint)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4914)
		p.HintList()
	}
	{
		p.SetState(4915)
		p.Match(HiveParserEOF)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IHintListContext is an interface to support dynamic dispatch.
type IHintListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllHintItem() []IHintItemContext
	HintItem(i int) IHintItemContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsHintListContext differentiates from other interfaces.
	IsHintListContext()
}

type HintListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHintListContext() *HintListContext {
	var p = new(HintListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_hintList
	return p
}

func InitEmptyHintListContext(p *HintListContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_hintList
}

func (*HintListContext) IsHintListContext() {}

func NewHintListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HintListContext {
	var p = new(HintListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_hintList

	return p
}

func (s *HintListContext) GetParser() antlr.Parser { return s.parser }

func (s *HintListContext) AllHintItem() []IHintItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IHintItemContext); ok {
			len++
		}
	}

	tst := make([]IHintItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IHintItemContext); ok {
			tst[i] = t.(IHintItemContext)
			i++
		}
	}

	return tst
}

func (s *HintListContext) HintItem(i int) IHintItemContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHintItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHintItemContext)
}

func (s *HintListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(HiveParserCOMMA)
}

func (s *HintListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserCOMMA, i)
}

func (s *HintListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HintListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *HintListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterHintList(s)
	}
}

func (s *HintListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitHintList(s)
	}
}

func (s *HintListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitHintList(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) HintList() (localctx IHintListContext) {
	localctx = NewHintListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 908, HiveParserRULE_hintList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4917)
		p.HintItem()
	}
	p.SetState(4922)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HiveParserCOMMA {
		{
			p.SetState(4918)
			p.Match(HiveParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4919)
			p.HintItem()
		}


		p.SetState(4924)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IHintItemContext is an interface to support dynamic dispatch.
type IHintItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HintName() IHintNameContext
	LPAREN() antlr.TerminalNode
	HintArgs() IHintArgsContext
	RPAREN() antlr.TerminalNode

	// IsHintItemContext differentiates from other interfaces.
	IsHintItemContext()
}

type HintItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHintItemContext() *HintItemContext {
	var p = new(HintItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_hintItem
	return p
}

func InitEmptyHintItemContext(p *HintItemContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_hintItem
}

func (*HintItemContext) IsHintItemContext() {}

func NewHintItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HintItemContext {
	var p = new(HintItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_hintItem

	return p
}

func (s *HintItemContext) GetParser() antlr.Parser { return s.parser }

func (s *HintItemContext) HintName() IHintNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHintNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHintNameContext)
}

func (s *HintItemContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserLPAREN, 0)
}

func (s *HintItemContext) HintArgs() IHintArgsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHintArgsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHintArgsContext)
}

func (s *HintItemContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(HiveParserRPAREN, 0)
}

func (s *HintItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HintItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *HintItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterHintItem(s)
	}
}

func (s *HintItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitHintItem(s)
	}
}

func (s *HintItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitHintItem(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) HintItem() (localctx IHintItemContext) {
	localctx = NewHintItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 910, HiveParserRULE_hintItem)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4925)
		p.HintName()
	}
	p.SetState(4930)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserLPAREN {
		{
			p.SetState(4926)
			p.Match(HiveParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4927)
			p.HintArgs()
		}
		{
			p.SetState(4928)
			p.Match(HiveParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IHintNameContext is an interface to support dynamic dispatch.
type IHintNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_MAPJOIN() antlr.TerminalNode
	KW_SEMI() antlr.TerminalNode
	KW_STREAMTABLE() antlr.TerminalNode
	KW_PKFK_JOIN() antlr.TerminalNode

	// IsHintNameContext differentiates from other interfaces.
	IsHintNameContext()
}

type HintNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHintNameContext() *HintNameContext {
	var p = new(HintNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_hintName
	return p
}

func InitEmptyHintNameContext(p *HintNameContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_hintName
}

func (*HintNameContext) IsHintNameContext() {}

func NewHintNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HintNameContext {
	var p = new(HintNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_hintName

	return p
}

func (s *HintNameContext) GetParser() antlr.Parser { return s.parser }

func (s *HintNameContext) KW_MAPJOIN() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_MAPJOIN, 0)
}

func (s *HintNameContext) KW_SEMI() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SEMI, 0)
}

func (s *HintNameContext) KW_STREAMTABLE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_STREAMTABLE, 0)
}

func (s *HintNameContext) KW_PKFK_JOIN() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_PKFK_JOIN, 0)
}

func (s *HintNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HintNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *HintNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterHintName(s)
	}
}

func (s *HintNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitHintName(s)
	}
}

func (s *HintNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitHintName(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) HintName() (localctx IHintNameContext) {
	localctx = NewHintNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 912, HiveParserRULE_hintName)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4932)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HiveParserKW_MAPJOIN || _la == HiveParserKW_PKFK_JOIN || _la == HiveParserKW_SEMI || _la == HiveParserKW_STREAMTABLE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IHintArgsContext is an interface to support dynamic dispatch.
type IHintArgsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllHintArgName() []IHintArgNameContext
	HintArgName(i int) IHintArgNameContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsHintArgsContext differentiates from other interfaces.
	IsHintArgsContext()
}

type HintArgsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHintArgsContext() *HintArgsContext {
	var p = new(HintArgsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_hintArgs
	return p
}

func InitEmptyHintArgsContext(p *HintArgsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_hintArgs
}

func (*HintArgsContext) IsHintArgsContext() {}

func NewHintArgsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HintArgsContext {
	var p = new(HintArgsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_hintArgs

	return p
}

func (s *HintArgsContext) GetParser() antlr.Parser { return s.parser }

func (s *HintArgsContext) AllHintArgName() []IHintArgNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IHintArgNameContext); ok {
			len++
		}
	}

	tst := make([]IHintArgNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IHintArgNameContext); ok {
			tst[i] = t.(IHintArgNameContext)
			i++
		}
	}

	return tst
}

func (s *HintArgsContext) HintArgName(i int) IHintArgNameContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHintArgNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHintArgNameContext)
}

func (s *HintArgsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(HiveParserCOMMA)
}

func (s *HintArgsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserCOMMA, i)
}

func (s *HintArgsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HintArgsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *HintArgsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterHintArgs(s)
	}
}

func (s *HintArgsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitHintArgs(s)
	}
}

func (s *HintArgsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitHintArgs(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) HintArgs() (localctx IHintArgsContext) {
	localctx = NewHintArgsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 914, HiveParserRULE_hintArgs)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4934)
		p.HintArgName()
	}
	p.SetState(4939)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HiveParserCOMMA {
		{
			p.SetState(4935)
			p.Match(HiveParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4936)
			p.HintArgName()
		}


		p.SetState(4941)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IHintArgNameContext is an interface to support dynamic dispatch.
type IHintArgNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() antlr.TerminalNode
	Number() antlr.TerminalNode
	KW_NONE() antlr.TerminalNode

	// IsHintArgNameContext differentiates from other interfaces.
	IsHintArgNameContext()
}

type HintArgNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHintArgNameContext() *HintArgNameContext {
	var p = new(HintArgNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_hintArgName
	return p
}

func InitEmptyHintArgNameContext(p *HintArgNameContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_hintArgName
}

func (*HintArgNameContext) IsHintArgNameContext() {}

func NewHintArgNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HintArgNameContext {
	var p = new(HintArgNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_hintArgName

	return p
}

func (s *HintArgNameContext) GetParser() antlr.Parser { return s.parser }

func (s *HintArgNameContext) Identifier() antlr.TerminalNode {
	return s.GetToken(HiveParserIdentifier, 0)
}

func (s *HintArgNameContext) Number() antlr.TerminalNode {
	return s.GetToken(HiveParserNumber, 0)
}

func (s *HintArgNameContext) KW_NONE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_NONE, 0)
}

func (s *HintArgNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HintArgNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *HintArgNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterHintArgName(s)
	}
}

func (s *HintArgNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitHintArgName(s)
	}
}

func (s *HintArgNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitHintArgName(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) HintArgName() (localctx IHintArgNameContext) {
	localctx = NewHintArgNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 916, HiveParserRULE_hintArgName)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4942)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HiveParserKW_NONE || _la == HiveParserNumber || _la == HiveParserIdentifier) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPrepareStatementContext is an interface to support dynamic dispatch.
type IPrepareStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_PREPARE() antlr.TerminalNode
	Id_() IId_Context
	KW_FROM() antlr.TerminalNode
	QueryStatementExpression() IQueryStatementExpressionContext

	// IsPrepareStatementContext differentiates from other interfaces.
	IsPrepareStatementContext()
}

type PrepareStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrepareStatementContext() *PrepareStatementContext {
	var p = new(PrepareStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_prepareStatement
	return p
}

func InitEmptyPrepareStatementContext(p *PrepareStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_prepareStatement
}

func (*PrepareStatementContext) IsPrepareStatementContext() {}

func NewPrepareStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrepareStatementContext {
	var p = new(PrepareStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_prepareStatement

	return p
}

func (s *PrepareStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *PrepareStatementContext) KW_PREPARE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_PREPARE, 0)
}

func (s *PrepareStatementContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *PrepareStatementContext) KW_FROM() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_FROM, 0)
}

func (s *PrepareStatementContext) QueryStatementExpression() IQueryStatementExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryStatementExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryStatementExpressionContext)
}

func (s *PrepareStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrepareStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PrepareStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterPrepareStatement(s)
	}
}

func (s *PrepareStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitPrepareStatement(s)
	}
}

func (s *PrepareStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitPrepareStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) PrepareStatement() (localctx IPrepareStatementContext) {
	localctx = NewPrepareStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 918, HiveParserRULE_prepareStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4944)
		p.Match(HiveParserKW_PREPARE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4945)
		p.Id_()
	}
	{
		p.SetState(4946)
		p.Match(HiveParserKW_FROM)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4947)
		p.QueryStatementExpression()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExecuteStatementContext is an interface to support dynamic dispatch.
type IExecuteStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_EXECUTE() antlr.TerminalNode
	Id_() IId_Context
	KW_USING() antlr.TerminalNode
	ExecuteParamList() IExecuteParamListContext

	// IsExecuteStatementContext differentiates from other interfaces.
	IsExecuteStatementContext()
}

type ExecuteStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExecuteStatementContext() *ExecuteStatementContext {
	var p = new(ExecuteStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_executeStatement
	return p
}

func InitEmptyExecuteStatementContext(p *ExecuteStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_executeStatement
}

func (*ExecuteStatementContext) IsExecuteStatementContext() {}

func NewExecuteStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExecuteStatementContext {
	var p = new(ExecuteStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_executeStatement

	return p
}

func (s *ExecuteStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExecuteStatementContext) KW_EXECUTE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_EXECUTE, 0)
}

func (s *ExecuteStatementContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *ExecuteStatementContext) KW_USING() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_USING, 0)
}

func (s *ExecuteStatementContext) ExecuteParamList() IExecuteParamListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExecuteParamListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExecuteParamListContext)
}

func (s *ExecuteStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExecuteStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ExecuteStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterExecuteStatement(s)
	}
}

func (s *ExecuteStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitExecuteStatement(s)
	}
}

func (s *ExecuteStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitExecuteStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ExecuteStatement() (localctx IExecuteStatementContext) {
	localctx = NewExecuteStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 920, HiveParserRULE_executeStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4949)
		p.Match(HiveParserKW_EXECUTE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4950)
		p.Id_()
	}
	{
		p.SetState(4951)
		p.Match(HiveParserKW_USING)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4952)
		p.ExecuteParamList()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExecuteParamListContext is an interface to support dynamic dispatch.
type IExecuteParamListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllConstant() []IConstantContext
	Constant(i int) IConstantContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsExecuteParamListContext differentiates from other interfaces.
	IsExecuteParamListContext()
}

type ExecuteParamListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExecuteParamListContext() *ExecuteParamListContext {
	var p = new(ExecuteParamListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_executeParamList
	return p
}

func InitEmptyExecuteParamListContext(p *ExecuteParamListContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_executeParamList
}

func (*ExecuteParamListContext) IsExecuteParamListContext() {}

func NewExecuteParamListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExecuteParamListContext {
	var p = new(ExecuteParamListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_executeParamList

	return p
}

func (s *ExecuteParamListContext) GetParser() antlr.Parser { return s.parser }

func (s *ExecuteParamListContext) AllConstant() []IConstantContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstantContext); ok {
			len++
		}
	}

	tst := make([]IConstantContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstantContext); ok {
			tst[i] = t.(IConstantContext)
			i++
		}
	}

	return tst
}

func (s *ExecuteParamListContext) Constant(i int) IConstantContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *ExecuteParamListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(HiveParserCOMMA)
}

func (s *ExecuteParamListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserCOMMA, i)
}

func (s *ExecuteParamListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExecuteParamListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ExecuteParamListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterExecuteParamList(s)
	}
}

func (s *ExecuteParamListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitExecuteParamList(s)
	}
}

func (s *ExecuteParamListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitExecuteParamList(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ExecuteParamList() (localctx IExecuteParamListContext) {
	localctx = NewExecuteParamListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 922, HiveParserRULE_executeParamList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4954)
		p.Constant()
	}
	p.SetState(4959)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HiveParserCOMMA {
		{
			p.SetState(4955)
			p.Match(HiveParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4956)
			p.Constant()
		}


		p.SetState(4961)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IResourcePlanDdlStatementsContext is an interface to support dynamic dispatch.
type IResourcePlanDdlStatementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CreateResourcePlanStatement() ICreateResourcePlanStatementContext
	AlterResourcePlanStatement() IAlterResourcePlanStatementContext
	DropResourcePlanStatement() IDropResourcePlanStatementContext
	GlobalWmStatement() IGlobalWmStatementContext
	ReplaceResourcePlanStatement() IReplaceResourcePlanStatementContext
	CreateTriggerStatement() ICreateTriggerStatementContext
	AlterTriggerStatement() IAlterTriggerStatementContext
	DropTriggerStatement() IDropTriggerStatementContext
	CreatePoolStatement() ICreatePoolStatementContext
	AlterPoolStatement() IAlterPoolStatementContext
	DropPoolStatement() IDropPoolStatementContext
	CreateMappingStatement() ICreateMappingStatementContext
	AlterMappingStatement() IAlterMappingStatementContext
	DropMappingStatement() IDropMappingStatementContext

	// IsResourcePlanDdlStatementsContext differentiates from other interfaces.
	IsResourcePlanDdlStatementsContext()
}

type ResourcePlanDdlStatementsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResourcePlanDdlStatementsContext() *ResourcePlanDdlStatementsContext {
	var p = new(ResourcePlanDdlStatementsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_resourcePlanDdlStatements
	return p
}

func InitEmptyResourcePlanDdlStatementsContext(p *ResourcePlanDdlStatementsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_resourcePlanDdlStatements
}

func (*ResourcePlanDdlStatementsContext) IsResourcePlanDdlStatementsContext() {}

func NewResourcePlanDdlStatementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResourcePlanDdlStatementsContext {
	var p = new(ResourcePlanDdlStatementsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_resourcePlanDdlStatements

	return p
}

func (s *ResourcePlanDdlStatementsContext) GetParser() antlr.Parser { return s.parser }

func (s *ResourcePlanDdlStatementsContext) CreateResourcePlanStatement() ICreateResourcePlanStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateResourcePlanStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateResourcePlanStatementContext)
}

func (s *ResourcePlanDdlStatementsContext) AlterResourcePlanStatement() IAlterResourcePlanStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterResourcePlanStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterResourcePlanStatementContext)
}

func (s *ResourcePlanDdlStatementsContext) DropResourcePlanStatement() IDropResourcePlanStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropResourcePlanStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropResourcePlanStatementContext)
}

func (s *ResourcePlanDdlStatementsContext) GlobalWmStatement() IGlobalWmStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGlobalWmStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGlobalWmStatementContext)
}

func (s *ResourcePlanDdlStatementsContext) ReplaceResourcePlanStatement() IReplaceResourcePlanStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplaceResourcePlanStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplaceResourcePlanStatementContext)
}

func (s *ResourcePlanDdlStatementsContext) CreateTriggerStatement() ICreateTriggerStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateTriggerStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateTriggerStatementContext)
}

func (s *ResourcePlanDdlStatementsContext) AlterTriggerStatement() IAlterTriggerStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterTriggerStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterTriggerStatementContext)
}

func (s *ResourcePlanDdlStatementsContext) DropTriggerStatement() IDropTriggerStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropTriggerStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropTriggerStatementContext)
}

func (s *ResourcePlanDdlStatementsContext) CreatePoolStatement() ICreatePoolStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreatePoolStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreatePoolStatementContext)
}

func (s *ResourcePlanDdlStatementsContext) AlterPoolStatement() IAlterPoolStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterPoolStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterPoolStatementContext)
}

func (s *ResourcePlanDdlStatementsContext) DropPoolStatement() IDropPoolStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropPoolStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropPoolStatementContext)
}

func (s *ResourcePlanDdlStatementsContext) CreateMappingStatement() ICreateMappingStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateMappingStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateMappingStatementContext)
}

func (s *ResourcePlanDdlStatementsContext) AlterMappingStatement() IAlterMappingStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterMappingStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterMappingStatementContext)
}

func (s *ResourcePlanDdlStatementsContext) DropMappingStatement() IDropMappingStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropMappingStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropMappingStatementContext)
}

func (s *ResourcePlanDdlStatementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResourcePlanDdlStatementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ResourcePlanDdlStatementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterResourcePlanDdlStatements(s)
	}
}

func (s *ResourcePlanDdlStatementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitResourcePlanDdlStatements(s)
	}
}

func (s *ResourcePlanDdlStatementsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitResourcePlanDdlStatements(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ResourcePlanDdlStatements() (localctx IResourcePlanDdlStatementsContext) {
	localctx = NewResourcePlanDdlStatementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 924, HiveParserRULE_resourcePlanDdlStatements)
	p.SetState(4976)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 585, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4962)
			p.CreateResourcePlanStatement()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4963)
			p.AlterResourcePlanStatement()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4964)
			p.DropResourcePlanStatement()
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4965)
			p.GlobalWmStatement()
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4966)
			p.ReplaceResourcePlanStatement()
		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4967)
			p.CreateTriggerStatement()
		}


	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(4968)
			p.AlterTriggerStatement()
		}


	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(4969)
			p.DropTriggerStatement()
		}


	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(4970)
			p.CreatePoolStatement()
		}


	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(4971)
			p.AlterPoolStatement()
		}


	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(4972)
			p.DropPoolStatement()
		}


	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(4973)
			p.CreateMappingStatement()
		}


	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(4974)
			p.AlterMappingStatement()
		}


	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(4975)
			p.DropMappingStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRpAssignContext is an interface to support dynamic dispatch.
type IRpAssignContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetParallelism returns the parallelism token.
	GetParallelism() antlr.Token 


	// SetParallelism sets the parallelism token.
	SetParallelism(antlr.Token) 


	// Getter signatures
	KW_QUERY_PARALLELISM() antlr.TerminalNode
	EQUAL() antlr.TerminalNode
	Number() antlr.TerminalNode
	KW_DEFAULT() antlr.TerminalNode
	KW_POOL() antlr.TerminalNode
	PoolPath() IPoolPathContext

	// IsRpAssignContext differentiates from other interfaces.
	IsRpAssignContext()
}

type RpAssignContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	parallelism antlr.Token
}

func NewEmptyRpAssignContext() *RpAssignContext {
	var p = new(RpAssignContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_rpAssign
	return p
}

func InitEmptyRpAssignContext(p *RpAssignContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_rpAssign
}

func (*RpAssignContext) IsRpAssignContext() {}

func NewRpAssignContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RpAssignContext {
	var p = new(RpAssignContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_rpAssign

	return p
}

func (s *RpAssignContext) GetParser() antlr.Parser { return s.parser }

func (s *RpAssignContext) GetParallelism() antlr.Token { return s.parallelism }


func (s *RpAssignContext) SetParallelism(v antlr.Token) { s.parallelism = v }


func (s *RpAssignContext) KW_QUERY_PARALLELISM() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_QUERY_PARALLELISM, 0)
}

func (s *RpAssignContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(HiveParserEQUAL, 0)
}

func (s *RpAssignContext) Number() antlr.TerminalNode {
	return s.GetToken(HiveParserNumber, 0)
}

func (s *RpAssignContext) KW_DEFAULT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DEFAULT, 0)
}

func (s *RpAssignContext) KW_POOL() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_POOL, 0)
}

func (s *RpAssignContext) PoolPath() IPoolPathContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPoolPathContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPoolPathContext)
}

func (s *RpAssignContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RpAssignContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *RpAssignContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterRpAssign(s)
	}
}

func (s *RpAssignContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitRpAssign(s)
	}
}

func (s *RpAssignContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitRpAssign(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) RpAssign() (localctx IRpAssignContext) {
	localctx = NewRpAssignContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 926, HiveParserRULE_rpAssign)
	p.SetState(4985)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserKW_QUERY_PARALLELISM:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4978)
			p.Match(HiveParserKW_QUERY_PARALLELISM)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4979)
			p.Match(HiveParserEQUAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4980)

			var _m = p.Match(HiveParserNumber)

			localctx.(*RpAssignContext).parallelism = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HiveParserKW_DEFAULT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4981)
			p.Match(HiveParserKW_DEFAULT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4982)
			p.Match(HiveParserKW_POOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4983)
			p.Match(HiveParserEQUAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4984)
			p.PoolPath()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRpAssignListContext is an interface to support dynamic dispatch.
type IRpAssignListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllRpAssign() []IRpAssignContext
	RpAssign(i int) IRpAssignContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsRpAssignListContext differentiates from other interfaces.
	IsRpAssignListContext()
}

type RpAssignListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRpAssignListContext() *RpAssignListContext {
	var p = new(RpAssignListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_rpAssignList
	return p
}

func InitEmptyRpAssignListContext(p *RpAssignListContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_rpAssignList
}

func (*RpAssignListContext) IsRpAssignListContext() {}

func NewRpAssignListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RpAssignListContext {
	var p = new(RpAssignListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_rpAssignList

	return p
}

func (s *RpAssignListContext) GetParser() antlr.Parser { return s.parser }

func (s *RpAssignListContext) AllRpAssign() []IRpAssignContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRpAssignContext); ok {
			len++
		}
	}

	tst := make([]IRpAssignContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRpAssignContext); ok {
			tst[i] = t.(IRpAssignContext)
			i++
		}
	}

	return tst
}

func (s *RpAssignListContext) RpAssign(i int) IRpAssignContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRpAssignContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRpAssignContext)
}

func (s *RpAssignListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(HiveParserCOMMA)
}

func (s *RpAssignListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserCOMMA, i)
}

func (s *RpAssignListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RpAssignListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *RpAssignListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterRpAssignList(s)
	}
}

func (s *RpAssignListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitRpAssignList(s)
	}
}

func (s *RpAssignListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitRpAssignList(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) RpAssignList() (localctx IRpAssignListContext) {
	localctx = NewRpAssignListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 928, HiveParserRULE_rpAssignList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4987)
		p.RpAssign()
	}
	p.SetState(4992)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HiveParserCOMMA {
		{
			p.SetState(4988)
			p.Match(HiveParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4989)
			p.RpAssign()
		}


		p.SetState(4994)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRpUnassignContext is an interface to support dynamic dispatch.
type IRpUnassignContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_QUERY_PARALLELISM() antlr.TerminalNode
	KW_DEFAULT() antlr.TerminalNode
	KW_POOL() antlr.TerminalNode

	// IsRpUnassignContext differentiates from other interfaces.
	IsRpUnassignContext()
}

type RpUnassignContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRpUnassignContext() *RpUnassignContext {
	var p = new(RpUnassignContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_rpUnassign
	return p
}

func InitEmptyRpUnassignContext(p *RpUnassignContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_rpUnassign
}

func (*RpUnassignContext) IsRpUnassignContext() {}

func NewRpUnassignContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RpUnassignContext {
	var p = new(RpUnassignContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_rpUnassign

	return p
}

func (s *RpUnassignContext) GetParser() antlr.Parser { return s.parser }

func (s *RpUnassignContext) KW_QUERY_PARALLELISM() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_QUERY_PARALLELISM, 0)
}

func (s *RpUnassignContext) KW_DEFAULT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DEFAULT, 0)
}

func (s *RpUnassignContext) KW_POOL() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_POOL, 0)
}

func (s *RpUnassignContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RpUnassignContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *RpUnassignContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterRpUnassign(s)
	}
}

func (s *RpUnassignContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitRpUnassign(s)
	}
}

func (s *RpUnassignContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitRpUnassign(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) RpUnassign() (localctx IRpUnassignContext) {
	localctx = NewRpUnassignContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 930, HiveParserRULE_rpUnassign)
	p.SetState(4998)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserKW_QUERY_PARALLELISM:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4995)
			p.Match(HiveParserKW_QUERY_PARALLELISM)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HiveParserKW_DEFAULT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4996)
			p.Match(HiveParserKW_DEFAULT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4997)
			p.Match(HiveParserKW_POOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRpUnassignListContext is an interface to support dynamic dispatch.
type IRpUnassignListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllRpUnassign() []IRpUnassignContext
	RpUnassign(i int) IRpUnassignContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsRpUnassignListContext differentiates from other interfaces.
	IsRpUnassignListContext()
}

type RpUnassignListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRpUnassignListContext() *RpUnassignListContext {
	var p = new(RpUnassignListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_rpUnassignList
	return p
}

func InitEmptyRpUnassignListContext(p *RpUnassignListContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_rpUnassignList
}

func (*RpUnassignListContext) IsRpUnassignListContext() {}

func NewRpUnassignListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RpUnassignListContext {
	var p = new(RpUnassignListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_rpUnassignList

	return p
}

func (s *RpUnassignListContext) GetParser() antlr.Parser { return s.parser }

func (s *RpUnassignListContext) AllRpUnassign() []IRpUnassignContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRpUnassignContext); ok {
			len++
		}
	}

	tst := make([]IRpUnassignContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRpUnassignContext); ok {
			tst[i] = t.(IRpUnassignContext)
			i++
		}
	}

	return tst
}

func (s *RpUnassignListContext) RpUnassign(i int) IRpUnassignContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRpUnassignContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRpUnassignContext)
}

func (s *RpUnassignListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(HiveParserCOMMA)
}

func (s *RpUnassignListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserCOMMA, i)
}

func (s *RpUnassignListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RpUnassignListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *RpUnassignListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterRpUnassignList(s)
	}
}

func (s *RpUnassignListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitRpUnassignList(s)
	}
}

func (s *RpUnassignListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitRpUnassignList(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) RpUnassignList() (localctx IRpUnassignListContext) {
	localctx = NewRpUnassignListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 932, HiveParserRULE_rpUnassignList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5000)
		p.RpUnassign()
	}
	p.SetState(5005)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HiveParserCOMMA {
		{
			p.SetState(5001)
			p.Match(HiveParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5002)
			p.RpUnassign()
		}


		p.SetState(5007)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreateResourcePlanStatementContext is an interface to support dynamic dispatch.
type ICreateResourcePlanStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IId_Context

	// GetLikeName returns the likeName rule contexts.
	GetLikeName() IId_Context


	// SetName sets the name rule contexts.
	SetName(IId_Context)

	// SetLikeName sets the likeName rule contexts.
	SetLikeName(IId_Context)


	// Getter signatures
	KW_CREATE() antlr.TerminalNode
	KW_RESOURCE() antlr.TerminalNode
	KW_PLAN() antlr.TerminalNode
	KW_LIKE() antlr.TerminalNode
	IfNotExists() IIfNotExistsContext
	AllId_() []IId_Context
	Id_(i int) IId_Context
	KW_WITH() antlr.TerminalNode
	RpAssignList() IRpAssignListContext

	// IsCreateResourcePlanStatementContext differentiates from other interfaces.
	IsCreateResourcePlanStatementContext()
}

type CreateResourcePlanStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name IId_Context 
	likeName IId_Context 
}

func NewEmptyCreateResourcePlanStatementContext() *CreateResourcePlanStatementContext {
	var p = new(CreateResourcePlanStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_createResourcePlanStatement
	return p
}

func InitEmptyCreateResourcePlanStatementContext(p *CreateResourcePlanStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_createResourcePlanStatement
}

func (*CreateResourcePlanStatementContext) IsCreateResourcePlanStatementContext() {}

func NewCreateResourcePlanStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateResourcePlanStatementContext {
	var p = new(CreateResourcePlanStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_createResourcePlanStatement

	return p
}

func (s *CreateResourcePlanStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateResourcePlanStatementContext) GetName() IId_Context { return s.name }

func (s *CreateResourcePlanStatementContext) GetLikeName() IId_Context { return s.likeName }


func (s *CreateResourcePlanStatementContext) SetName(v IId_Context) { s.name = v }

func (s *CreateResourcePlanStatementContext) SetLikeName(v IId_Context) { s.likeName = v }


func (s *CreateResourcePlanStatementContext) KW_CREATE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_CREATE, 0)
}

func (s *CreateResourcePlanStatementContext) KW_RESOURCE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_RESOURCE, 0)
}

func (s *CreateResourcePlanStatementContext) KW_PLAN() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_PLAN, 0)
}

func (s *CreateResourcePlanStatementContext) KW_LIKE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_LIKE, 0)
}

func (s *CreateResourcePlanStatementContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *CreateResourcePlanStatementContext) AllId_() []IId_Context {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IId_Context); ok {
			len++
		}
	}

	tst := make([]IId_Context, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IId_Context); ok {
			tst[i] = t.(IId_Context)
			i++
		}
	}

	return tst
}

func (s *CreateResourcePlanStatementContext) Id_(i int) IId_Context {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *CreateResourcePlanStatementContext) KW_WITH() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_WITH, 0)
}

func (s *CreateResourcePlanStatementContext) RpAssignList() IRpAssignListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRpAssignListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRpAssignListContext)
}

func (s *CreateResourcePlanStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateResourcePlanStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CreateResourcePlanStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterCreateResourcePlanStatement(s)
	}
}

func (s *CreateResourcePlanStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitCreateResourcePlanStatement(s)
	}
}

func (s *CreateResourcePlanStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitCreateResourcePlanStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) CreateResourcePlanStatement() (localctx ICreateResourcePlanStatementContext) {
	localctx = NewCreateResourcePlanStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 934, HiveParserRULE_createResourcePlanStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5008)
		p.Match(HiveParserKW_CREATE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(5009)
		p.Match(HiveParserKW_RESOURCE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(5010)
		p.Match(HiveParserKW_PLAN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(5012)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_IF {
		{
			p.SetState(5011)
			p.IfNotExists()
		}

	}
	p.SetState(5023)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 592, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(5014)

			var _x = p.Id_()


			localctx.(*CreateResourcePlanStatementContext).name = _x
		}
		{
			p.SetState(5015)
			p.Match(HiveParserKW_LIKE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5016)

			var _x = p.Id_()


			localctx.(*CreateResourcePlanStatementContext).likeName = _x
		}


	case 2:
		{
			p.SetState(5018)

			var _x = p.Id_()


			localctx.(*CreateResourcePlanStatementContext).name = _x
		}
		p.SetState(5021)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_WITH {
			{
				p.SetState(5019)
				p.Match(HiveParserKW_WITH)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(5020)
				p.RpAssignList()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IWithReplaceContext is an interface to support dynamic dispatch.
type IWithReplaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_WITH() antlr.TerminalNode
	KW_REPLACE() antlr.TerminalNode

	// IsWithReplaceContext differentiates from other interfaces.
	IsWithReplaceContext()
}

type WithReplaceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithReplaceContext() *WithReplaceContext {
	var p = new(WithReplaceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_withReplace
	return p
}

func InitEmptyWithReplaceContext(p *WithReplaceContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_withReplace
}

func (*WithReplaceContext) IsWithReplaceContext() {}

func NewWithReplaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithReplaceContext {
	var p = new(WithReplaceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_withReplace

	return p
}

func (s *WithReplaceContext) GetParser() antlr.Parser { return s.parser }

func (s *WithReplaceContext) KW_WITH() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_WITH, 0)
}

func (s *WithReplaceContext) KW_REPLACE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_REPLACE, 0)
}

func (s *WithReplaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithReplaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *WithReplaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterWithReplace(s)
	}
}

func (s *WithReplaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitWithReplace(s)
	}
}

func (s *WithReplaceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitWithReplace(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) WithReplace() (localctx IWithReplaceContext) {
	localctx = NewWithReplaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 936, HiveParserRULE_withReplace)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5025)
		p.Match(HiveParserKW_WITH)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(5026)
		p.Match(HiveParserKW_REPLACE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IActivateContext is an interface to support dynamic dispatch.
type IActivateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_ACTIVATE() antlr.TerminalNode
	WithReplace() IWithReplaceContext

	// IsActivateContext differentiates from other interfaces.
	IsActivateContext()
}

type ActivateContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyActivateContext() *ActivateContext {
	var p = new(ActivateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_activate
	return p
}

func InitEmptyActivateContext(p *ActivateContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_activate
}

func (*ActivateContext) IsActivateContext() {}

func NewActivateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ActivateContext {
	var p = new(ActivateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_activate

	return p
}

func (s *ActivateContext) GetParser() antlr.Parser { return s.parser }

func (s *ActivateContext) KW_ACTIVATE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ACTIVATE, 0)
}

func (s *ActivateContext) WithReplace() IWithReplaceContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithReplaceContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithReplaceContext)
}

func (s *ActivateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ActivateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ActivateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterActivate(s)
	}
}

func (s *ActivateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitActivate(s)
	}
}

func (s *ActivateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitActivate(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) Activate() (localctx IActivateContext) {
	localctx = NewActivateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 938, HiveParserRULE_activate)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5028)
		p.Match(HiveParserKW_ACTIVATE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(5030)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_WITH {
		{
			p.SetState(5029)
			p.WithReplace()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IEnableContext is an interface to support dynamic dispatch.
type IEnableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_ENABLE() antlr.TerminalNode

	// IsEnableContext differentiates from other interfaces.
	IsEnableContext()
}

type EnableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnableContext() *EnableContext {
	var p = new(EnableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_enable
	return p
}

func InitEmptyEnableContext(p *EnableContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_enable
}

func (*EnableContext) IsEnableContext() {}

func NewEnableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnableContext {
	var p = new(EnableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_enable

	return p
}

func (s *EnableContext) GetParser() antlr.Parser { return s.parser }

func (s *EnableContext) KW_ENABLE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ENABLE, 0)
}

func (s *EnableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *EnableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterEnable(s)
	}
}

func (s *EnableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitEnable(s)
	}
}

func (s *EnableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitEnable(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) Enable() (localctx IEnableContext) {
	localctx = NewEnableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 940, HiveParserRULE_enable)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5032)
		p.Match(HiveParserKW_ENABLE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDisableContext is an interface to support dynamic dispatch.
type IDisableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_DISABLE() antlr.TerminalNode

	// IsDisableContext differentiates from other interfaces.
	IsDisableContext()
}

type DisableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDisableContext() *DisableContext {
	var p = new(DisableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_disable
	return p
}

func InitEmptyDisableContext(p *DisableContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_disable
}

func (*DisableContext) IsDisableContext() {}

func NewDisableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DisableContext {
	var p = new(DisableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_disable

	return p
}

func (s *DisableContext) GetParser() antlr.Parser { return s.parser }

func (s *DisableContext) KW_DISABLE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DISABLE, 0)
}

func (s *DisableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DisableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DisableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterDisable(s)
	}
}

func (s *DisableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitDisable(s)
	}
}

func (s *DisableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitDisable(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) Disable() (localctx IDisableContext) {
	localctx = NewDisableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 942, HiveParserRULE_disable)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5034)
		p.Match(HiveParserKW_DISABLE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IUnmanagedContext is an interface to support dynamic dispatch.
type IUnmanagedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_UNMANAGED() antlr.TerminalNode

	// IsUnmanagedContext differentiates from other interfaces.
	IsUnmanagedContext()
}

type UnmanagedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnmanagedContext() *UnmanagedContext {
	var p = new(UnmanagedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_unmanaged
	return p
}

func InitEmptyUnmanagedContext(p *UnmanagedContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_unmanaged
}

func (*UnmanagedContext) IsUnmanagedContext() {}

func NewUnmanagedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnmanagedContext {
	var p = new(UnmanagedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_unmanaged

	return p
}

func (s *UnmanagedContext) GetParser() antlr.Parser { return s.parser }

func (s *UnmanagedContext) KW_UNMANAGED() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_UNMANAGED, 0)
}

func (s *UnmanagedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnmanagedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *UnmanagedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterUnmanaged(s)
	}
}

func (s *UnmanagedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitUnmanaged(s)
	}
}

func (s *UnmanagedContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitUnmanaged(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) Unmanaged() (localctx IUnmanagedContext) {
	localctx = NewUnmanagedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 944, HiveParserRULE_unmanaged)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5036)
		p.Match(HiveParserKW_UNMANAGED)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlterResourcePlanStatementContext is an interface to support dynamic dispatch.
type IAlterResourcePlanStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IId_Context

	// GetNewName returns the newName rule contexts.
	GetNewName() IId_Context


	// SetName sets the name rule contexts.
	SetName(IId_Context)

	// SetNewName sets the newName rule contexts.
	SetNewName(IId_Context)


	// Getter signatures
	KW_ALTER() antlr.TerminalNode
	KW_RESOURCE() antlr.TerminalNode
	KW_PLAN() antlr.TerminalNode
	AllId_() []IId_Context
	Id_(i int) IId_Context
	KW_VALIDATE() antlr.TerminalNode
	KW_DISABLE() antlr.TerminalNode
	KW_SET() antlr.TerminalNode
	RpAssignList() IRpAssignListContext
	KW_UNSET() antlr.TerminalNode
	RpUnassignList() IRpUnassignListContext
	KW_RENAME() antlr.TerminalNode
	KW_TO() antlr.TerminalNode
	Activate() IActivateContext
	Enable() IEnableContext

	// IsAlterResourcePlanStatementContext differentiates from other interfaces.
	IsAlterResourcePlanStatementContext()
}

type AlterResourcePlanStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name IId_Context 
	newName IId_Context 
}

func NewEmptyAlterResourcePlanStatementContext() *AlterResourcePlanStatementContext {
	var p = new(AlterResourcePlanStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterResourcePlanStatement
	return p
}

func InitEmptyAlterResourcePlanStatementContext(p *AlterResourcePlanStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterResourcePlanStatement
}

func (*AlterResourcePlanStatementContext) IsAlterResourcePlanStatementContext() {}

func NewAlterResourcePlanStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterResourcePlanStatementContext {
	var p = new(AlterResourcePlanStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_alterResourcePlanStatement

	return p
}

func (s *AlterResourcePlanStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterResourcePlanStatementContext) GetName() IId_Context { return s.name }

func (s *AlterResourcePlanStatementContext) GetNewName() IId_Context { return s.newName }


func (s *AlterResourcePlanStatementContext) SetName(v IId_Context) { s.name = v }

func (s *AlterResourcePlanStatementContext) SetNewName(v IId_Context) { s.newName = v }


func (s *AlterResourcePlanStatementContext) KW_ALTER() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ALTER, 0)
}

func (s *AlterResourcePlanStatementContext) KW_RESOURCE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_RESOURCE, 0)
}

func (s *AlterResourcePlanStatementContext) KW_PLAN() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_PLAN, 0)
}

func (s *AlterResourcePlanStatementContext) AllId_() []IId_Context {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IId_Context); ok {
			len++
		}
	}

	tst := make([]IId_Context, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IId_Context); ok {
			tst[i] = t.(IId_Context)
			i++
		}
	}

	return tst
}

func (s *AlterResourcePlanStatementContext) Id_(i int) IId_Context {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *AlterResourcePlanStatementContext) KW_VALIDATE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_VALIDATE, 0)
}

func (s *AlterResourcePlanStatementContext) KW_DISABLE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DISABLE, 0)
}

func (s *AlterResourcePlanStatementContext) KW_SET() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SET, 0)
}

func (s *AlterResourcePlanStatementContext) RpAssignList() IRpAssignListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRpAssignListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRpAssignListContext)
}

func (s *AlterResourcePlanStatementContext) KW_UNSET() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_UNSET, 0)
}

func (s *AlterResourcePlanStatementContext) RpUnassignList() IRpUnassignListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRpUnassignListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRpUnassignListContext)
}

func (s *AlterResourcePlanStatementContext) KW_RENAME() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_RENAME, 0)
}

func (s *AlterResourcePlanStatementContext) KW_TO() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TO, 0)
}

func (s *AlterResourcePlanStatementContext) Activate() IActivateContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IActivateContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IActivateContext)
}

func (s *AlterResourcePlanStatementContext) Enable() IEnableContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnableContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnableContext)
}

func (s *AlterResourcePlanStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterResourcePlanStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AlterResourcePlanStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterAlterResourcePlanStatement(s)
	}
}

func (s *AlterResourcePlanStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitAlterResourcePlanStatement(s)
	}
}

func (s *AlterResourcePlanStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitAlterResourcePlanStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) AlterResourcePlanStatement() (localctx IAlterResourcePlanStatementContext) {
	localctx = NewAlterResourcePlanStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 946, HiveParserRULE_alterResourcePlanStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5038)
		p.Match(HiveParserKW_ALTER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(5039)
		p.Match(HiveParserKW_RESOURCE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(5040)
		p.Match(HiveParserKW_PLAN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(5041)

		var _x = p.Id_()


		localctx.(*AlterResourcePlanStatementContext).name = _x
	}
	p.SetState(5059)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserKW_VALIDATE:
		{
			p.SetState(5042)
			p.Match(HiveParserKW_VALIDATE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HiveParserKW_DISABLE:
		{
			p.SetState(5043)
			p.Match(HiveParserKW_DISABLE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HiveParserKW_SET:
		{
			p.SetState(5044)
			p.Match(HiveParserKW_SET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5045)
			p.RpAssignList()
		}


	case HiveParserKW_UNSET:
		{
			p.SetState(5046)
			p.Match(HiveParserKW_UNSET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5047)
			p.RpUnassignList()
		}


	case HiveParserKW_RENAME:
		{
			p.SetState(5048)
			p.Match(HiveParserKW_RENAME)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5049)
			p.Match(HiveParserKW_TO)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5050)

			var _x = p.Id_()


			localctx.(*AlterResourcePlanStatementContext).newName = _x
		}


	case HiveParserKW_ACTIVATE:
		{
			p.SetState(5051)
			p.Activate()
		}
		p.SetState(5053)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_ENABLE {
			{
				p.SetState(5052)
				p.Enable()
			}

		}


	case HiveParserKW_ENABLE:
		{
			p.SetState(5055)
			p.Enable()
		}
		p.SetState(5057)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HiveParserKW_ACTIVATE {
			{
				p.SetState(5056)
				p.Activate()
			}

		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IGlobalWmStatementContext is an interface to support dynamic dispatch.
type IGlobalWmStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_WORKLOAD() antlr.TerminalNode
	KW_MANAGEMENT() antlr.TerminalNode
	KW_ENABLE() antlr.TerminalNode
	KW_DISABLE() antlr.TerminalNode

	// IsGlobalWmStatementContext differentiates from other interfaces.
	IsGlobalWmStatementContext()
}

type GlobalWmStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGlobalWmStatementContext() *GlobalWmStatementContext {
	var p = new(GlobalWmStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_globalWmStatement
	return p
}

func InitEmptyGlobalWmStatementContext(p *GlobalWmStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_globalWmStatement
}

func (*GlobalWmStatementContext) IsGlobalWmStatementContext() {}

func NewGlobalWmStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GlobalWmStatementContext {
	var p = new(GlobalWmStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_globalWmStatement

	return p
}

func (s *GlobalWmStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *GlobalWmStatementContext) KW_WORKLOAD() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_WORKLOAD, 0)
}

func (s *GlobalWmStatementContext) KW_MANAGEMENT() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_MANAGEMENT, 0)
}

func (s *GlobalWmStatementContext) KW_ENABLE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ENABLE, 0)
}

func (s *GlobalWmStatementContext) KW_DISABLE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DISABLE, 0)
}

func (s *GlobalWmStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GlobalWmStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *GlobalWmStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterGlobalWmStatement(s)
	}
}

func (s *GlobalWmStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitGlobalWmStatement(s)
	}
}

func (s *GlobalWmStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitGlobalWmStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) GlobalWmStatement() (localctx IGlobalWmStatementContext) {
	localctx = NewGlobalWmStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 948, HiveParserRULE_globalWmStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5061)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HiveParserKW_DISABLE || _la == HiveParserKW_ENABLE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(5062)
		p.Match(HiveParserKW_WORKLOAD)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(5063)
		p.Match(HiveParserKW_MANAGEMENT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IReplaceResourcePlanStatementContext is an interface to support dynamic dispatch.
type IReplaceResourcePlanStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSrc returns the src rule contexts.
	GetSrc() IId_Context

	// GetDest returns the dest rule contexts.
	GetDest() IId_Context


	// SetSrc sets the src rule contexts.
	SetSrc(IId_Context)

	// SetDest sets the dest rule contexts.
	SetDest(IId_Context)


	// Getter signatures
	KW_REPLACE() antlr.TerminalNode
	KW_ACTIVE() antlr.TerminalNode
	KW_RESOURCE() antlr.TerminalNode
	KW_PLAN() antlr.TerminalNode
	KW_WITH() antlr.TerminalNode
	AllId_() []IId_Context
	Id_(i int) IId_Context

	// IsReplaceResourcePlanStatementContext differentiates from other interfaces.
	IsReplaceResourcePlanStatementContext()
}

type ReplaceResourcePlanStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	src IId_Context 
	dest IId_Context 
}

func NewEmptyReplaceResourcePlanStatementContext() *ReplaceResourcePlanStatementContext {
	var p = new(ReplaceResourcePlanStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_replaceResourcePlanStatement
	return p
}

func InitEmptyReplaceResourcePlanStatementContext(p *ReplaceResourcePlanStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_replaceResourcePlanStatement
}

func (*ReplaceResourcePlanStatementContext) IsReplaceResourcePlanStatementContext() {}

func NewReplaceResourcePlanStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReplaceResourcePlanStatementContext {
	var p = new(ReplaceResourcePlanStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_replaceResourcePlanStatement

	return p
}

func (s *ReplaceResourcePlanStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReplaceResourcePlanStatementContext) GetSrc() IId_Context { return s.src }

func (s *ReplaceResourcePlanStatementContext) GetDest() IId_Context { return s.dest }


func (s *ReplaceResourcePlanStatementContext) SetSrc(v IId_Context) { s.src = v }

func (s *ReplaceResourcePlanStatementContext) SetDest(v IId_Context) { s.dest = v }


func (s *ReplaceResourcePlanStatementContext) KW_REPLACE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_REPLACE, 0)
}

func (s *ReplaceResourcePlanStatementContext) KW_ACTIVE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ACTIVE, 0)
}

func (s *ReplaceResourcePlanStatementContext) KW_RESOURCE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_RESOURCE, 0)
}

func (s *ReplaceResourcePlanStatementContext) KW_PLAN() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_PLAN, 0)
}

func (s *ReplaceResourcePlanStatementContext) KW_WITH() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_WITH, 0)
}

func (s *ReplaceResourcePlanStatementContext) AllId_() []IId_Context {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IId_Context); ok {
			len++
		}
	}

	tst := make([]IId_Context, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IId_Context); ok {
			tst[i] = t.(IId_Context)
			i++
		}
	}

	return tst
}

func (s *ReplaceResourcePlanStatementContext) Id_(i int) IId_Context {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *ReplaceResourcePlanStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplaceResourcePlanStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ReplaceResourcePlanStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterReplaceResourcePlanStatement(s)
	}
}

func (s *ReplaceResourcePlanStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitReplaceResourcePlanStatement(s)
	}
}

func (s *ReplaceResourcePlanStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitReplaceResourcePlanStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ReplaceResourcePlanStatement() (localctx IReplaceResourcePlanStatementContext) {
	localctx = NewReplaceResourcePlanStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 950, HiveParserRULE_replaceResourcePlanStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5065)
		p.Match(HiveParserKW_REPLACE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(5077)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserKW_ACTIVE:
		{
			p.SetState(5066)
			p.Match(HiveParserKW_ACTIVE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5067)
			p.Match(HiveParserKW_RESOURCE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5068)
			p.Match(HiveParserKW_PLAN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5069)
			p.Match(HiveParserKW_WITH)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5070)

			var _x = p.Id_()


			localctx.(*ReplaceResourcePlanStatementContext).src = _x
		}


	case HiveParserKW_RESOURCE:
		{
			p.SetState(5071)
			p.Match(HiveParserKW_RESOURCE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5072)
			p.Match(HiveParserKW_PLAN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5073)

			var _x = p.Id_()


			localctx.(*ReplaceResourcePlanStatementContext).dest = _x
		}
		{
			p.SetState(5074)
			p.Match(HiveParserKW_WITH)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5075)

			var _x = p.Id_()


			localctx.(*ReplaceResourcePlanStatementContext).src = _x
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDropResourcePlanStatementContext is an interface to support dynamic dispatch.
type IDropResourcePlanStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IId_Context


	// SetName sets the name rule contexts.
	SetName(IId_Context)


	// Getter signatures
	KW_DROP() antlr.TerminalNode
	KW_RESOURCE() antlr.TerminalNode
	KW_PLAN() antlr.TerminalNode
	Id_() IId_Context
	IfExists() IIfExistsContext

	// IsDropResourcePlanStatementContext differentiates from other interfaces.
	IsDropResourcePlanStatementContext()
}

type DropResourcePlanStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name IId_Context 
}

func NewEmptyDropResourcePlanStatementContext() *DropResourcePlanStatementContext {
	var p = new(DropResourcePlanStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_dropResourcePlanStatement
	return p
}

func InitEmptyDropResourcePlanStatementContext(p *DropResourcePlanStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_dropResourcePlanStatement
}

func (*DropResourcePlanStatementContext) IsDropResourcePlanStatementContext() {}

func NewDropResourcePlanStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropResourcePlanStatementContext {
	var p = new(DropResourcePlanStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_dropResourcePlanStatement

	return p
}

func (s *DropResourcePlanStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropResourcePlanStatementContext) GetName() IId_Context { return s.name }


func (s *DropResourcePlanStatementContext) SetName(v IId_Context) { s.name = v }


func (s *DropResourcePlanStatementContext) KW_DROP() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DROP, 0)
}

func (s *DropResourcePlanStatementContext) KW_RESOURCE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_RESOURCE, 0)
}

func (s *DropResourcePlanStatementContext) KW_PLAN() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_PLAN, 0)
}

func (s *DropResourcePlanStatementContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *DropResourcePlanStatementContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropResourcePlanStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropResourcePlanStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DropResourcePlanStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterDropResourcePlanStatement(s)
	}
}

func (s *DropResourcePlanStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitDropResourcePlanStatement(s)
	}
}

func (s *DropResourcePlanStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitDropResourcePlanStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) DropResourcePlanStatement() (localctx IDropResourcePlanStatementContext) {
	localctx = NewDropResourcePlanStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 952, HiveParserRULE_dropResourcePlanStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5079)
		p.Match(HiveParserKW_DROP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(5080)
		p.Match(HiveParserKW_RESOURCE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(5081)
		p.Match(HiveParserKW_PLAN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(5083)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_IF {
		{
			p.SetState(5082)
			p.IfExists()
		}

	}
	{
		p.SetState(5085)

		var _x = p.Id_()


		localctx.(*DropResourcePlanStatementContext).name = _x
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPoolPathContext is an interface to support dynamic dispatch.
type IPoolPathContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllId_() []IId_Context
	Id_(i int) IId_Context
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode

	// IsPoolPathContext differentiates from other interfaces.
	IsPoolPathContext()
}

type PoolPathContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPoolPathContext() *PoolPathContext {
	var p = new(PoolPathContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_poolPath
	return p
}

func InitEmptyPoolPathContext(p *PoolPathContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_poolPath
}

func (*PoolPathContext) IsPoolPathContext() {}

func NewPoolPathContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PoolPathContext {
	var p = new(PoolPathContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_poolPath

	return p
}

func (s *PoolPathContext) GetParser() antlr.Parser { return s.parser }

func (s *PoolPathContext) AllId_() []IId_Context {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IId_Context); ok {
			len++
		}
	}

	tst := make([]IId_Context, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IId_Context); ok {
			tst[i] = t.(IId_Context)
			i++
		}
	}

	return tst
}

func (s *PoolPathContext) Id_(i int) IId_Context {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *PoolPathContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(HiveParserDOT)
}

func (s *PoolPathContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserDOT, i)
}

func (s *PoolPathContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PoolPathContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PoolPathContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterPoolPath(s)
	}
}

func (s *PoolPathContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitPoolPath(s)
	}
}

func (s *PoolPathContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitPoolPath(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) PoolPath() (localctx IPoolPathContext) {
	localctx = NewPoolPathContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 954, HiveParserRULE_poolPath)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5087)
		p.Id_()
	}
	p.SetState(5092)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HiveParserDOT {
		{
			p.SetState(5088)
			p.Match(HiveParserDOT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5089)
			p.Id_()
		}


		p.SetState(5094)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITriggerExpressionContext is an interface to support dynamic dispatch.
type ITriggerExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TriggerAtomExpression() ITriggerAtomExpressionContext

	// IsTriggerExpressionContext differentiates from other interfaces.
	IsTriggerExpressionContext()
}

type TriggerExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTriggerExpressionContext() *TriggerExpressionContext {
	var p = new(TriggerExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_triggerExpression
	return p
}

func InitEmptyTriggerExpressionContext(p *TriggerExpressionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_triggerExpression
}

func (*TriggerExpressionContext) IsTriggerExpressionContext() {}

func NewTriggerExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TriggerExpressionContext {
	var p = new(TriggerExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_triggerExpression

	return p
}

func (s *TriggerExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *TriggerExpressionContext) TriggerAtomExpression() ITriggerAtomExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITriggerAtomExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITriggerAtomExpressionContext)
}

func (s *TriggerExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TriggerExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TriggerExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterTriggerExpression(s)
	}
}

func (s *TriggerExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitTriggerExpression(s)
	}
}

func (s *TriggerExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitTriggerExpression(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) TriggerExpression() (localctx ITriggerExpressionContext) {
	localctx = NewTriggerExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 956, HiveParserRULE_triggerExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5095)
		p.TriggerAtomExpression()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITriggerExpressionStandaloneContext is an interface to support dynamic dispatch.
type ITriggerExpressionStandaloneContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TriggerExpression() ITriggerExpressionContext
	EOF() antlr.TerminalNode

	// IsTriggerExpressionStandaloneContext differentiates from other interfaces.
	IsTriggerExpressionStandaloneContext()
}

type TriggerExpressionStandaloneContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTriggerExpressionStandaloneContext() *TriggerExpressionStandaloneContext {
	var p = new(TriggerExpressionStandaloneContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_triggerExpressionStandalone
	return p
}

func InitEmptyTriggerExpressionStandaloneContext(p *TriggerExpressionStandaloneContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_triggerExpressionStandalone
}

func (*TriggerExpressionStandaloneContext) IsTriggerExpressionStandaloneContext() {}

func NewTriggerExpressionStandaloneContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TriggerExpressionStandaloneContext {
	var p = new(TriggerExpressionStandaloneContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_triggerExpressionStandalone

	return p
}

func (s *TriggerExpressionStandaloneContext) GetParser() antlr.Parser { return s.parser }

func (s *TriggerExpressionStandaloneContext) TriggerExpression() ITriggerExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITriggerExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITriggerExpressionContext)
}

func (s *TriggerExpressionStandaloneContext) EOF() antlr.TerminalNode {
	return s.GetToken(HiveParserEOF, 0)
}

func (s *TriggerExpressionStandaloneContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TriggerExpressionStandaloneContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TriggerExpressionStandaloneContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterTriggerExpressionStandalone(s)
	}
}

func (s *TriggerExpressionStandaloneContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitTriggerExpressionStandalone(s)
	}
}

func (s *TriggerExpressionStandaloneContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitTriggerExpressionStandalone(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) TriggerExpressionStandalone() (localctx ITriggerExpressionStandaloneContext) {
	localctx = NewTriggerExpressionStandaloneContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 958, HiveParserRULE_triggerExpressionStandalone)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5097)
		p.TriggerExpression()
	}
	{
		p.SetState(5098)
		p.Match(HiveParserEOF)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITriggerOrExpressionContext is an interface to support dynamic dispatch.
type ITriggerOrExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTriggerAndExpression() []ITriggerAndExpressionContext
	TriggerAndExpression(i int) ITriggerAndExpressionContext
	AllKW_OR() []antlr.TerminalNode
	KW_OR(i int) antlr.TerminalNode

	// IsTriggerOrExpressionContext differentiates from other interfaces.
	IsTriggerOrExpressionContext()
}

type TriggerOrExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTriggerOrExpressionContext() *TriggerOrExpressionContext {
	var p = new(TriggerOrExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_triggerOrExpression
	return p
}

func InitEmptyTriggerOrExpressionContext(p *TriggerOrExpressionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_triggerOrExpression
}

func (*TriggerOrExpressionContext) IsTriggerOrExpressionContext() {}

func NewTriggerOrExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TriggerOrExpressionContext {
	var p = new(TriggerOrExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_triggerOrExpression

	return p
}

func (s *TriggerOrExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *TriggerOrExpressionContext) AllTriggerAndExpression() []ITriggerAndExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITriggerAndExpressionContext); ok {
			len++
		}
	}

	tst := make([]ITriggerAndExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITriggerAndExpressionContext); ok {
			tst[i] = t.(ITriggerAndExpressionContext)
			i++
		}
	}

	return tst
}

func (s *TriggerOrExpressionContext) TriggerAndExpression(i int) ITriggerAndExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITriggerAndExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITriggerAndExpressionContext)
}

func (s *TriggerOrExpressionContext) AllKW_OR() []antlr.TerminalNode {
	return s.GetTokens(HiveParserKW_OR)
}

func (s *TriggerOrExpressionContext) KW_OR(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserKW_OR, i)
}

func (s *TriggerOrExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TriggerOrExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TriggerOrExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterTriggerOrExpression(s)
	}
}

func (s *TriggerOrExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitTriggerOrExpression(s)
	}
}

func (s *TriggerOrExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitTriggerOrExpression(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) TriggerOrExpression() (localctx ITriggerOrExpressionContext) {
	localctx = NewTriggerOrExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 960, HiveParserRULE_triggerOrExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5100)
		p.TriggerAndExpression()
	}
	p.SetState(5105)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HiveParserKW_OR {
		{
			p.SetState(5101)
			p.Match(HiveParserKW_OR)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5102)
			p.TriggerAndExpression()
		}


		p.SetState(5107)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITriggerAndExpressionContext is an interface to support dynamic dispatch.
type ITriggerAndExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTriggerAtomExpression() []ITriggerAtomExpressionContext
	TriggerAtomExpression(i int) ITriggerAtomExpressionContext
	AllKW_AND() []antlr.TerminalNode
	KW_AND(i int) antlr.TerminalNode

	// IsTriggerAndExpressionContext differentiates from other interfaces.
	IsTriggerAndExpressionContext()
}

type TriggerAndExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTriggerAndExpressionContext() *TriggerAndExpressionContext {
	var p = new(TriggerAndExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_triggerAndExpression
	return p
}

func InitEmptyTriggerAndExpressionContext(p *TriggerAndExpressionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_triggerAndExpression
}

func (*TriggerAndExpressionContext) IsTriggerAndExpressionContext() {}

func NewTriggerAndExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TriggerAndExpressionContext {
	var p = new(TriggerAndExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_triggerAndExpression

	return p
}

func (s *TriggerAndExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *TriggerAndExpressionContext) AllTriggerAtomExpression() []ITriggerAtomExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITriggerAtomExpressionContext); ok {
			len++
		}
	}

	tst := make([]ITriggerAtomExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITriggerAtomExpressionContext); ok {
			tst[i] = t.(ITriggerAtomExpressionContext)
			i++
		}
	}

	return tst
}

func (s *TriggerAndExpressionContext) TriggerAtomExpression(i int) ITriggerAtomExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITriggerAtomExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITriggerAtomExpressionContext)
}

func (s *TriggerAndExpressionContext) AllKW_AND() []antlr.TerminalNode {
	return s.GetTokens(HiveParserKW_AND)
}

func (s *TriggerAndExpressionContext) KW_AND(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserKW_AND, i)
}

func (s *TriggerAndExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TriggerAndExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TriggerAndExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterTriggerAndExpression(s)
	}
}

func (s *TriggerAndExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitTriggerAndExpression(s)
	}
}

func (s *TriggerAndExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitTriggerAndExpression(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) TriggerAndExpression() (localctx ITriggerAndExpressionContext) {
	localctx = NewTriggerAndExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 962, HiveParserRULE_triggerAndExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5108)
		p.TriggerAtomExpression()
	}
	p.SetState(5113)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HiveParserKW_AND {
		{
			p.SetState(5109)
			p.Match(HiveParserKW_AND)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5110)
			p.TriggerAtomExpression()
		}


		p.SetState(5115)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITriggerAtomExpressionContext is an interface to support dynamic dispatch.
type ITriggerAtomExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Id_() IId_Context
	ComparisionOperator() IComparisionOperatorContext
	TriggerLiteral() ITriggerLiteralContext

	// IsTriggerAtomExpressionContext differentiates from other interfaces.
	IsTriggerAtomExpressionContext()
}

type TriggerAtomExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTriggerAtomExpressionContext() *TriggerAtomExpressionContext {
	var p = new(TriggerAtomExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_triggerAtomExpression
	return p
}

func InitEmptyTriggerAtomExpressionContext(p *TriggerAtomExpressionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_triggerAtomExpression
}

func (*TriggerAtomExpressionContext) IsTriggerAtomExpressionContext() {}

func NewTriggerAtomExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TriggerAtomExpressionContext {
	var p = new(TriggerAtomExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_triggerAtomExpression

	return p
}

func (s *TriggerAtomExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *TriggerAtomExpressionContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *TriggerAtomExpressionContext) ComparisionOperator() IComparisionOperatorContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisionOperatorContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisionOperatorContext)
}

func (s *TriggerAtomExpressionContext) TriggerLiteral() ITriggerLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITriggerLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITriggerLiteralContext)
}

func (s *TriggerAtomExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TriggerAtomExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TriggerAtomExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterTriggerAtomExpression(s)
	}
}

func (s *TriggerAtomExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitTriggerAtomExpression(s)
	}
}

func (s *TriggerAtomExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitTriggerAtomExpression(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) TriggerAtomExpression() (localctx ITriggerAtomExpressionContext) {
	localctx = NewTriggerAtomExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 964, HiveParserRULE_triggerAtomExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5116)
		p.Id_()
	}
	{
		p.SetState(5117)
		p.ComparisionOperator()
	}
	{
		p.SetState(5118)
		p.TriggerLiteral()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITriggerLiteralContext is an interface to support dynamic dispatch.
type ITriggerLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Number() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode

	// IsTriggerLiteralContext differentiates from other interfaces.
	IsTriggerLiteralContext()
}

type TriggerLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTriggerLiteralContext() *TriggerLiteralContext {
	var p = new(TriggerLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_triggerLiteral
	return p
}

func InitEmptyTriggerLiteralContext(p *TriggerLiteralContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_triggerLiteral
}

func (*TriggerLiteralContext) IsTriggerLiteralContext() {}

func NewTriggerLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TriggerLiteralContext {
	var p = new(TriggerLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_triggerLiteral

	return p
}

func (s *TriggerLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *TriggerLiteralContext) Number() antlr.TerminalNode {
	return s.GetToken(HiveParserNumber, 0)
}

func (s *TriggerLiteralContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(HiveParserStringLiteral, 0)
}

func (s *TriggerLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TriggerLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TriggerLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterTriggerLiteral(s)
	}
}

func (s *TriggerLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitTriggerLiteral(s)
	}
}

func (s *TriggerLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitTriggerLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) TriggerLiteral() (localctx ITriggerLiteralContext) {
	localctx = NewTriggerLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 966, HiveParserRULE_triggerLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5120)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HiveParserStringLiteral || _la == HiveParserNumber) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IComparisionOperatorContext is an interface to support dynamic dispatch.
type IComparisionOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GREATERTHAN() antlr.TerminalNode

	// IsComparisionOperatorContext differentiates from other interfaces.
	IsComparisionOperatorContext()
}

type ComparisionOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisionOperatorContext() *ComparisionOperatorContext {
	var p = new(ComparisionOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_comparisionOperator
	return p
}

func InitEmptyComparisionOperatorContext(p *ComparisionOperatorContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_comparisionOperator
}

func (*ComparisionOperatorContext) IsComparisionOperatorContext() {}

func NewComparisionOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisionOperatorContext {
	var p = new(ComparisionOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_comparisionOperator

	return p
}

func (s *ComparisionOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisionOperatorContext) GREATERTHAN() antlr.TerminalNode {
	return s.GetToken(HiveParserGREATERTHAN, 0)
}

func (s *ComparisionOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisionOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ComparisionOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterComparisionOperator(s)
	}
}

func (s *ComparisionOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitComparisionOperator(s)
	}
}

func (s *ComparisionOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitComparisionOperator(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) ComparisionOperator() (localctx IComparisionOperatorContext) {
	localctx = NewComparisionOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 968, HiveParserRULE_comparisionOperator)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5122)
		p.Match(HiveParserGREATERTHAN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITriggerActionExpressionContext is an interface to support dynamic dispatch.
type ITriggerActionExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_KILL() antlr.TerminalNode
	KW_MOVE() antlr.TerminalNode
	KW_TO() antlr.TerminalNode
	PoolPath() IPoolPathContext

	// IsTriggerActionExpressionContext differentiates from other interfaces.
	IsTriggerActionExpressionContext()
}

type TriggerActionExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTriggerActionExpressionContext() *TriggerActionExpressionContext {
	var p = new(TriggerActionExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_triggerActionExpression
	return p
}

func InitEmptyTriggerActionExpressionContext(p *TriggerActionExpressionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_triggerActionExpression
}

func (*TriggerActionExpressionContext) IsTriggerActionExpressionContext() {}

func NewTriggerActionExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TriggerActionExpressionContext {
	var p = new(TriggerActionExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_triggerActionExpression

	return p
}

func (s *TriggerActionExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *TriggerActionExpressionContext) KW_KILL() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_KILL, 0)
}

func (s *TriggerActionExpressionContext) KW_MOVE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_MOVE, 0)
}

func (s *TriggerActionExpressionContext) KW_TO() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TO, 0)
}

func (s *TriggerActionExpressionContext) PoolPath() IPoolPathContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPoolPathContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPoolPathContext)
}

func (s *TriggerActionExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TriggerActionExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TriggerActionExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterTriggerActionExpression(s)
	}
}

func (s *TriggerActionExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitTriggerActionExpression(s)
	}
}

func (s *TriggerActionExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitTriggerActionExpression(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) TriggerActionExpression() (localctx ITriggerActionExpressionContext) {
	localctx = NewTriggerActionExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 970, HiveParserRULE_triggerActionExpression)
	p.SetState(5128)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserKW_KILL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5124)
			p.Match(HiveParserKW_KILL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HiveParserKW_MOVE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5125)
			p.Match(HiveParserKW_MOVE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5126)
			p.Match(HiveParserKW_TO)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5127)
			p.PoolPath()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITriggerActionExpressionStandaloneContext is an interface to support dynamic dispatch.
type ITriggerActionExpressionStandaloneContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TriggerActionExpression() ITriggerActionExpressionContext
	EOF() antlr.TerminalNode

	// IsTriggerActionExpressionStandaloneContext differentiates from other interfaces.
	IsTriggerActionExpressionStandaloneContext()
}

type TriggerActionExpressionStandaloneContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTriggerActionExpressionStandaloneContext() *TriggerActionExpressionStandaloneContext {
	var p = new(TriggerActionExpressionStandaloneContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_triggerActionExpressionStandalone
	return p
}

func InitEmptyTriggerActionExpressionStandaloneContext(p *TriggerActionExpressionStandaloneContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_triggerActionExpressionStandalone
}

func (*TriggerActionExpressionStandaloneContext) IsTriggerActionExpressionStandaloneContext() {}

func NewTriggerActionExpressionStandaloneContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TriggerActionExpressionStandaloneContext {
	var p = new(TriggerActionExpressionStandaloneContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_triggerActionExpressionStandalone

	return p
}

func (s *TriggerActionExpressionStandaloneContext) GetParser() antlr.Parser { return s.parser }

func (s *TriggerActionExpressionStandaloneContext) TriggerActionExpression() ITriggerActionExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITriggerActionExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITriggerActionExpressionContext)
}

func (s *TriggerActionExpressionStandaloneContext) EOF() antlr.TerminalNode {
	return s.GetToken(HiveParserEOF, 0)
}

func (s *TriggerActionExpressionStandaloneContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TriggerActionExpressionStandaloneContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TriggerActionExpressionStandaloneContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterTriggerActionExpressionStandalone(s)
	}
}

func (s *TriggerActionExpressionStandaloneContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitTriggerActionExpressionStandalone(s)
	}
}

func (s *TriggerActionExpressionStandaloneContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitTriggerActionExpressionStandalone(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) TriggerActionExpressionStandalone() (localctx ITriggerActionExpressionStandaloneContext) {
	localctx = NewTriggerActionExpressionStandaloneContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 972, HiveParserRULE_triggerActionExpressionStandalone)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5130)
		p.TriggerActionExpression()
	}
	{
		p.SetState(5131)
		p.Match(HiveParserEOF)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreateTriggerStatementContext is an interface to support dynamic dispatch.
type ICreateTriggerStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRpName returns the rpName rule contexts.
	GetRpName() IId_Context

	// GetTriggerName returns the triggerName rule contexts.
	GetTriggerName() IId_Context


	// SetRpName sets the rpName rule contexts.
	SetRpName(IId_Context)

	// SetTriggerName sets the triggerName rule contexts.
	SetTriggerName(IId_Context)


	// Getter signatures
	KW_CREATE() antlr.TerminalNode
	KW_TRIGGER() antlr.TerminalNode
	DOT() antlr.TerminalNode
	KW_WHEN() antlr.TerminalNode
	TriggerExpression() ITriggerExpressionContext
	KW_DO() antlr.TerminalNode
	TriggerActionExpression() ITriggerActionExpressionContext
	AllId_() []IId_Context
	Id_(i int) IId_Context

	// IsCreateTriggerStatementContext differentiates from other interfaces.
	IsCreateTriggerStatementContext()
}

type CreateTriggerStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	rpName IId_Context 
	triggerName IId_Context 
}

func NewEmptyCreateTriggerStatementContext() *CreateTriggerStatementContext {
	var p = new(CreateTriggerStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_createTriggerStatement
	return p
}

func InitEmptyCreateTriggerStatementContext(p *CreateTriggerStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_createTriggerStatement
}

func (*CreateTriggerStatementContext) IsCreateTriggerStatementContext() {}

func NewCreateTriggerStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateTriggerStatementContext {
	var p = new(CreateTriggerStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_createTriggerStatement

	return p
}

func (s *CreateTriggerStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateTriggerStatementContext) GetRpName() IId_Context { return s.rpName }

func (s *CreateTriggerStatementContext) GetTriggerName() IId_Context { return s.triggerName }


func (s *CreateTriggerStatementContext) SetRpName(v IId_Context) { s.rpName = v }

func (s *CreateTriggerStatementContext) SetTriggerName(v IId_Context) { s.triggerName = v }


func (s *CreateTriggerStatementContext) KW_CREATE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_CREATE, 0)
}

func (s *CreateTriggerStatementContext) KW_TRIGGER() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TRIGGER, 0)
}

func (s *CreateTriggerStatementContext) DOT() antlr.TerminalNode {
	return s.GetToken(HiveParserDOT, 0)
}

func (s *CreateTriggerStatementContext) KW_WHEN() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_WHEN, 0)
}

func (s *CreateTriggerStatementContext) TriggerExpression() ITriggerExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITriggerExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITriggerExpressionContext)
}

func (s *CreateTriggerStatementContext) KW_DO() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DO, 0)
}

func (s *CreateTriggerStatementContext) TriggerActionExpression() ITriggerActionExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITriggerActionExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITriggerActionExpressionContext)
}

func (s *CreateTriggerStatementContext) AllId_() []IId_Context {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IId_Context); ok {
			len++
		}
	}

	tst := make([]IId_Context, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IId_Context); ok {
			tst[i] = t.(IId_Context)
			i++
		}
	}

	return tst
}

func (s *CreateTriggerStatementContext) Id_(i int) IId_Context {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *CreateTriggerStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTriggerStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CreateTriggerStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterCreateTriggerStatement(s)
	}
}

func (s *CreateTriggerStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitCreateTriggerStatement(s)
	}
}

func (s *CreateTriggerStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitCreateTriggerStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) CreateTriggerStatement() (localctx ICreateTriggerStatementContext) {
	localctx = NewCreateTriggerStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 974, HiveParserRULE_createTriggerStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5133)
		p.Match(HiveParserKW_CREATE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(5134)
		p.Match(HiveParserKW_TRIGGER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(5135)

		var _x = p.Id_()


		localctx.(*CreateTriggerStatementContext).rpName = _x
	}
	{
		p.SetState(5136)
		p.Match(HiveParserDOT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(5137)

		var _x = p.Id_()


		localctx.(*CreateTriggerStatementContext).triggerName = _x
	}
	{
		p.SetState(5138)
		p.Match(HiveParserKW_WHEN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(5139)
		p.TriggerExpression()
	}
	{
		p.SetState(5140)
		p.Match(HiveParserKW_DO)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(5141)
		p.TriggerActionExpression()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlterTriggerStatementContext is an interface to support dynamic dispatch.
type IAlterTriggerStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRpName returns the rpName rule contexts.
	GetRpName() IId_Context

	// GetTriggerName returns the triggerName rule contexts.
	GetTriggerName() IId_Context

	// GetPoolName returns the poolName rule contexts.
	GetPoolName() IPoolPathContext


	// SetRpName sets the rpName rule contexts.
	SetRpName(IId_Context)

	// SetTriggerName sets the triggerName rule contexts.
	SetTriggerName(IId_Context)

	// SetPoolName sets the poolName rule contexts.
	SetPoolName(IPoolPathContext)


	// Getter signatures
	KW_ALTER() antlr.TerminalNode
	KW_TRIGGER() antlr.TerminalNode
	DOT() antlr.TerminalNode
	AllId_() []IId_Context
	Id_(i int) IId_Context
	KW_WHEN() antlr.TerminalNode
	TriggerExpression() ITriggerExpressionContext
	KW_DO() antlr.TerminalNode
	TriggerActionExpression() ITriggerActionExpressionContext
	KW_ADD() antlr.TerminalNode
	KW_TO() antlr.TerminalNode
	KW_DROP() antlr.TerminalNode
	KW_FROM() antlr.TerminalNode
	KW_POOL() antlr.TerminalNode
	KW_UNMANAGED() antlr.TerminalNode
	PoolPath() IPoolPathContext

	// IsAlterTriggerStatementContext differentiates from other interfaces.
	IsAlterTriggerStatementContext()
}

type AlterTriggerStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	rpName IId_Context 
	triggerName IId_Context 
	poolName IPoolPathContext 
}

func NewEmptyAlterTriggerStatementContext() *AlterTriggerStatementContext {
	var p = new(AlterTriggerStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterTriggerStatement
	return p
}

func InitEmptyAlterTriggerStatementContext(p *AlterTriggerStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterTriggerStatement
}

func (*AlterTriggerStatementContext) IsAlterTriggerStatementContext() {}

func NewAlterTriggerStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterTriggerStatementContext {
	var p = new(AlterTriggerStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_alterTriggerStatement

	return p
}

func (s *AlterTriggerStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterTriggerStatementContext) GetRpName() IId_Context { return s.rpName }

func (s *AlterTriggerStatementContext) GetTriggerName() IId_Context { return s.triggerName }

func (s *AlterTriggerStatementContext) GetPoolName() IPoolPathContext { return s.poolName }


func (s *AlterTriggerStatementContext) SetRpName(v IId_Context) { s.rpName = v }

func (s *AlterTriggerStatementContext) SetTriggerName(v IId_Context) { s.triggerName = v }

func (s *AlterTriggerStatementContext) SetPoolName(v IPoolPathContext) { s.poolName = v }


func (s *AlterTriggerStatementContext) KW_ALTER() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ALTER, 0)
}

func (s *AlterTriggerStatementContext) KW_TRIGGER() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TRIGGER, 0)
}

func (s *AlterTriggerStatementContext) DOT() antlr.TerminalNode {
	return s.GetToken(HiveParserDOT, 0)
}

func (s *AlterTriggerStatementContext) AllId_() []IId_Context {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IId_Context); ok {
			len++
		}
	}

	tst := make([]IId_Context, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IId_Context); ok {
			tst[i] = t.(IId_Context)
			i++
		}
	}

	return tst
}

func (s *AlterTriggerStatementContext) Id_(i int) IId_Context {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *AlterTriggerStatementContext) KW_WHEN() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_WHEN, 0)
}

func (s *AlterTriggerStatementContext) TriggerExpression() ITriggerExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITriggerExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITriggerExpressionContext)
}

func (s *AlterTriggerStatementContext) KW_DO() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DO, 0)
}

func (s *AlterTriggerStatementContext) TriggerActionExpression() ITriggerActionExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITriggerActionExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITriggerActionExpressionContext)
}

func (s *AlterTriggerStatementContext) KW_ADD() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ADD, 0)
}

func (s *AlterTriggerStatementContext) KW_TO() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TO, 0)
}

func (s *AlterTriggerStatementContext) KW_DROP() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DROP, 0)
}

func (s *AlterTriggerStatementContext) KW_FROM() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_FROM, 0)
}

func (s *AlterTriggerStatementContext) KW_POOL() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_POOL, 0)
}

func (s *AlterTriggerStatementContext) KW_UNMANAGED() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_UNMANAGED, 0)
}

func (s *AlterTriggerStatementContext) PoolPath() IPoolPathContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPoolPathContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPoolPathContext)
}

func (s *AlterTriggerStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTriggerStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AlterTriggerStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterAlterTriggerStatement(s)
	}
}

func (s *AlterTriggerStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitAlterTriggerStatement(s)
	}
}

func (s *AlterTriggerStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitAlterTriggerStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) AlterTriggerStatement() (localctx IAlterTriggerStatementContext) {
	localctx = NewAlterTriggerStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 976, HiveParserRULE_alterTriggerStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5143)
		p.Match(HiveParserKW_ALTER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(5144)
		p.Match(HiveParserKW_TRIGGER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(5145)

		var _x = p.Id_()


		localctx.(*AlterTriggerStatementContext).rpName = _x
	}
	{
		p.SetState(5146)
		p.Match(HiveParserDOT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(5147)

		var _x = p.Id_()


		localctx.(*AlterTriggerStatementContext).triggerName = _x
	}
	p.SetState(5164)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserKW_WHEN:
		{
			p.SetState(5148)
			p.Match(HiveParserKW_WHEN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5149)
			p.TriggerExpression()
		}
		{
			p.SetState(5150)
			p.Match(HiveParserKW_DO)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5151)
			p.TriggerActionExpression()
		}


	case HiveParserKW_ADD, HiveParserKW_DROP:
		p.SetState(5157)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case HiveParserKW_ADD:
			{
				p.SetState(5153)
				p.Match(HiveParserKW_ADD)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(5154)
				p.Match(HiveParserKW_TO)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


		case HiveParserKW_DROP:
			{
				p.SetState(5155)
				p.Match(HiveParserKW_DROP)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(5156)
				p.Match(HiveParserKW_FROM)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}



		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(5162)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case HiveParserKW_POOL:
			{
				p.SetState(5159)
				p.Match(HiveParserKW_POOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(5160)

				var _x = p.PoolPath()


				localctx.(*AlterTriggerStatementContext).poolName = _x
			}


		case HiveParserKW_UNMANAGED:
			{
				p.SetState(5161)
				p.Match(HiveParserKW_UNMANAGED)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}



		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDropTriggerStatementContext is an interface to support dynamic dispatch.
type IDropTriggerStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRpName returns the rpName rule contexts.
	GetRpName() IId_Context

	// GetTriggerName returns the triggerName rule contexts.
	GetTriggerName() IId_Context


	// SetRpName sets the rpName rule contexts.
	SetRpName(IId_Context)

	// SetTriggerName sets the triggerName rule contexts.
	SetTriggerName(IId_Context)


	// Getter signatures
	KW_DROP() antlr.TerminalNode
	KW_TRIGGER() antlr.TerminalNode
	DOT() antlr.TerminalNode
	AllId_() []IId_Context
	Id_(i int) IId_Context

	// IsDropTriggerStatementContext differentiates from other interfaces.
	IsDropTriggerStatementContext()
}

type DropTriggerStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	rpName IId_Context 
	triggerName IId_Context 
}

func NewEmptyDropTriggerStatementContext() *DropTriggerStatementContext {
	var p = new(DropTriggerStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_dropTriggerStatement
	return p
}

func InitEmptyDropTriggerStatementContext(p *DropTriggerStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_dropTriggerStatement
}

func (*DropTriggerStatementContext) IsDropTriggerStatementContext() {}

func NewDropTriggerStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropTriggerStatementContext {
	var p = new(DropTriggerStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_dropTriggerStatement

	return p
}

func (s *DropTriggerStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropTriggerStatementContext) GetRpName() IId_Context { return s.rpName }

func (s *DropTriggerStatementContext) GetTriggerName() IId_Context { return s.triggerName }


func (s *DropTriggerStatementContext) SetRpName(v IId_Context) { s.rpName = v }

func (s *DropTriggerStatementContext) SetTriggerName(v IId_Context) { s.triggerName = v }


func (s *DropTriggerStatementContext) KW_DROP() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DROP, 0)
}

func (s *DropTriggerStatementContext) KW_TRIGGER() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TRIGGER, 0)
}

func (s *DropTriggerStatementContext) DOT() antlr.TerminalNode {
	return s.GetToken(HiveParserDOT, 0)
}

func (s *DropTriggerStatementContext) AllId_() []IId_Context {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IId_Context); ok {
			len++
		}
	}

	tst := make([]IId_Context, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IId_Context); ok {
			tst[i] = t.(IId_Context)
			i++
		}
	}

	return tst
}

func (s *DropTriggerStatementContext) Id_(i int) IId_Context {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *DropTriggerStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropTriggerStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DropTriggerStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterDropTriggerStatement(s)
	}
}

func (s *DropTriggerStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitDropTriggerStatement(s)
	}
}

func (s *DropTriggerStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitDropTriggerStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) DropTriggerStatement() (localctx IDropTriggerStatementContext) {
	localctx = NewDropTriggerStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 978, HiveParserRULE_dropTriggerStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5166)
		p.Match(HiveParserKW_DROP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(5167)
		p.Match(HiveParserKW_TRIGGER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(5168)

		var _x = p.Id_()


		localctx.(*DropTriggerStatementContext).rpName = _x
	}
	{
		p.SetState(5169)
		p.Match(HiveParserDOT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(5170)

		var _x = p.Id_()


		localctx.(*DropTriggerStatementContext).triggerName = _x
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPoolAssignContext is an interface to support dynamic dispatch.
type IPoolAssignContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetAllocFraction returns the allocFraction token.
	GetAllocFraction() antlr.Token 

	// GetParallelism returns the parallelism token.
	GetParallelism() antlr.Token 

	// GetPolicy returns the policy token.
	GetPolicy() antlr.Token 


	// SetAllocFraction sets the allocFraction token.
	SetAllocFraction(antlr.Token) 

	// SetParallelism sets the parallelism token.
	SetParallelism(antlr.Token) 

	// SetPolicy sets the policy token.
	SetPolicy(antlr.Token) 


	// GetPath returns the path rule contexts.
	GetPath() IPoolPathContext


	// SetPath sets the path rule contexts.
	SetPath(IPoolPathContext)


	// Getter signatures
	KW_ALLOC_FRACTION() antlr.TerminalNode
	EQUAL() antlr.TerminalNode
	KW_QUERY_PARALLELISM() antlr.TerminalNode
	KW_SCHEDULING_POLICY() antlr.TerminalNode
	KW_PATH() antlr.TerminalNode
	Number() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode
	PoolPath() IPoolPathContext

	// IsPoolAssignContext differentiates from other interfaces.
	IsPoolAssignContext()
}

type PoolAssignContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	allocFraction antlr.Token
	parallelism antlr.Token
	policy antlr.Token
	path IPoolPathContext 
}

func NewEmptyPoolAssignContext() *PoolAssignContext {
	var p = new(PoolAssignContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_poolAssign
	return p
}

func InitEmptyPoolAssignContext(p *PoolAssignContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_poolAssign
}

func (*PoolAssignContext) IsPoolAssignContext() {}

func NewPoolAssignContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PoolAssignContext {
	var p = new(PoolAssignContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_poolAssign

	return p
}

func (s *PoolAssignContext) GetParser() antlr.Parser { return s.parser }

func (s *PoolAssignContext) GetAllocFraction() antlr.Token { return s.allocFraction }

func (s *PoolAssignContext) GetParallelism() antlr.Token { return s.parallelism }

func (s *PoolAssignContext) GetPolicy() antlr.Token { return s.policy }


func (s *PoolAssignContext) SetAllocFraction(v antlr.Token) { s.allocFraction = v }

func (s *PoolAssignContext) SetParallelism(v antlr.Token) { s.parallelism = v }

func (s *PoolAssignContext) SetPolicy(v antlr.Token) { s.policy = v }


func (s *PoolAssignContext) GetPath() IPoolPathContext { return s.path }


func (s *PoolAssignContext) SetPath(v IPoolPathContext) { s.path = v }


func (s *PoolAssignContext) KW_ALLOC_FRACTION() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ALLOC_FRACTION, 0)
}

func (s *PoolAssignContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(HiveParserEQUAL, 0)
}

func (s *PoolAssignContext) KW_QUERY_PARALLELISM() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_QUERY_PARALLELISM, 0)
}

func (s *PoolAssignContext) KW_SCHEDULING_POLICY() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SCHEDULING_POLICY, 0)
}

func (s *PoolAssignContext) KW_PATH() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_PATH, 0)
}

func (s *PoolAssignContext) Number() antlr.TerminalNode {
	return s.GetToken(HiveParserNumber, 0)
}

func (s *PoolAssignContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(HiveParserStringLiteral, 0)
}

func (s *PoolAssignContext) PoolPath() IPoolPathContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPoolPathContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPoolPathContext)
}

func (s *PoolAssignContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PoolAssignContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PoolAssignContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterPoolAssign(s)
	}
}

func (s *PoolAssignContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitPoolAssign(s)
	}
}

func (s *PoolAssignContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitPoolAssign(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) PoolAssign() (localctx IPoolAssignContext) {
	localctx = NewPoolAssignContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 980, HiveParserRULE_poolAssign)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(5184)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserKW_ALLOC_FRACTION:
		{
			p.SetState(5172)
			p.Match(HiveParserKW_ALLOC_FRACTION)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5173)
			p.Match(HiveParserEQUAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5174)

			var _m = p.Match(HiveParserNumber)

			localctx.(*PoolAssignContext).allocFraction = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HiveParserKW_QUERY_PARALLELISM:
		{
			p.SetState(5175)
			p.Match(HiveParserKW_QUERY_PARALLELISM)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5176)
			p.Match(HiveParserEQUAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5177)

			var _m = p.Match(HiveParserNumber)

			localctx.(*PoolAssignContext).parallelism = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HiveParserKW_SCHEDULING_POLICY:
		{
			p.SetState(5178)
			p.Match(HiveParserKW_SCHEDULING_POLICY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5179)
			p.Match(HiveParserEQUAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5180)

			var _m = p.Match(HiveParserStringLiteral)

			localctx.(*PoolAssignContext).policy = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HiveParserKW_PATH:
		{
			p.SetState(5181)
			p.Match(HiveParserKW_PATH)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5182)
			p.Match(HiveParserEQUAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5183)

			var _x = p.PoolPath()


			localctx.(*PoolAssignContext).path = _x
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPoolAssignListContext is an interface to support dynamic dispatch.
type IPoolAssignListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPoolAssign() []IPoolAssignContext
	PoolAssign(i int) IPoolAssignContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPoolAssignListContext differentiates from other interfaces.
	IsPoolAssignListContext()
}

type PoolAssignListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPoolAssignListContext() *PoolAssignListContext {
	var p = new(PoolAssignListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_poolAssignList
	return p
}

func InitEmptyPoolAssignListContext(p *PoolAssignListContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_poolAssignList
}

func (*PoolAssignListContext) IsPoolAssignListContext() {}

func NewPoolAssignListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PoolAssignListContext {
	var p = new(PoolAssignListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_poolAssignList

	return p
}

func (s *PoolAssignListContext) GetParser() antlr.Parser { return s.parser }

func (s *PoolAssignListContext) AllPoolAssign() []IPoolAssignContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPoolAssignContext); ok {
			len++
		}
	}

	tst := make([]IPoolAssignContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPoolAssignContext); ok {
			tst[i] = t.(IPoolAssignContext)
			i++
		}
	}

	return tst
}

func (s *PoolAssignListContext) PoolAssign(i int) IPoolAssignContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPoolAssignContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPoolAssignContext)
}

func (s *PoolAssignListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(HiveParserCOMMA)
}

func (s *PoolAssignListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HiveParserCOMMA, i)
}

func (s *PoolAssignListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PoolAssignListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PoolAssignListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterPoolAssignList(s)
	}
}

func (s *PoolAssignListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitPoolAssignList(s)
	}
}

func (s *PoolAssignListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitPoolAssignList(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) PoolAssignList() (localctx IPoolAssignListContext) {
	localctx = NewPoolAssignListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 982, HiveParserRULE_poolAssignList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5186)
		p.PoolAssign()
	}
	p.SetState(5191)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HiveParserCOMMA {
		{
			p.SetState(5187)
			p.Match(HiveParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5188)
			p.PoolAssign()
		}


		p.SetState(5193)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreatePoolStatementContext is an interface to support dynamic dispatch.
type ICreatePoolStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRpName returns the rpName rule contexts.
	GetRpName() IId_Context


	// SetRpName sets the rpName rule contexts.
	SetRpName(IId_Context)


	// Getter signatures
	KW_CREATE() antlr.TerminalNode
	KW_POOL() antlr.TerminalNode
	DOT() antlr.TerminalNode
	PoolPath() IPoolPathContext
	KW_WITH() antlr.TerminalNode
	PoolAssignList() IPoolAssignListContext
	Id_() IId_Context

	// IsCreatePoolStatementContext differentiates from other interfaces.
	IsCreatePoolStatementContext()
}

type CreatePoolStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	rpName IId_Context 
}

func NewEmptyCreatePoolStatementContext() *CreatePoolStatementContext {
	var p = new(CreatePoolStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_createPoolStatement
	return p
}

func InitEmptyCreatePoolStatementContext(p *CreatePoolStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_createPoolStatement
}

func (*CreatePoolStatementContext) IsCreatePoolStatementContext() {}

func NewCreatePoolStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreatePoolStatementContext {
	var p = new(CreatePoolStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_createPoolStatement

	return p
}

func (s *CreatePoolStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreatePoolStatementContext) GetRpName() IId_Context { return s.rpName }


func (s *CreatePoolStatementContext) SetRpName(v IId_Context) { s.rpName = v }


func (s *CreatePoolStatementContext) KW_CREATE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_CREATE, 0)
}

func (s *CreatePoolStatementContext) KW_POOL() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_POOL, 0)
}

func (s *CreatePoolStatementContext) DOT() antlr.TerminalNode {
	return s.GetToken(HiveParserDOT, 0)
}

func (s *CreatePoolStatementContext) PoolPath() IPoolPathContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPoolPathContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPoolPathContext)
}

func (s *CreatePoolStatementContext) KW_WITH() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_WITH, 0)
}

func (s *CreatePoolStatementContext) PoolAssignList() IPoolAssignListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPoolAssignListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPoolAssignListContext)
}

func (s *CreatePoolStatementContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *CreatePoolStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreatePoolStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CreatePoolStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterCreatePoolStatement(s)
	}
}

func (s *CreatePoolStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitCreatePoolStatement(s)
	}
}

func (s *CreatePoolStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitCreatePoolStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) CreatePoolStatement() (localctx ICreatePoolStatementContext) {
	localctx = NewCreatePoolStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 984, HiveParserRULE_createPoolStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5194)
		p.Match(HiveParserKW_CREATE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(5195)
		p.Match(HiveParserKW_POOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(5196)

		var _x = p.Id_()


		localctx.(*CreatePoolStatementContext).rpName = _x
	}
	{
		p.SetState(5197)
		p.Match(HiveParserDOT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(5198)
		p.PoolPath()
	}
	{
		p.SetState(5199)
		p.Match(HiveParserKW_WITH)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(5200)
		p.PoolAssignList()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlterPoolStatementContext is an interface to support dynamic dispatch.
type IAlterPoolStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRpName returns the rpName rule contexts.
	GetRpName() IId_Context

	// GetTriggerName returns the triggerName rule contexts.
	GetTriggerName() IId_Context


	// SetRpName sets the rpName rule contexts.
	SetRpName(IId_Context)

	// SetTriggerName sets the triggerName rule contexts.
	SetTriggerName(IId_Context)


	// Getter signatures
	KW_ALTER() antlr.TerminalNode
	KW_POOL() antlr.TerminalNode
	DOT() antlr.TerminalNode
	PoolPath() IPoolPathContext
	AllId_() []IId_Context
	Id_(i int) IId_Context
	KW_SET() antlr.TerminalNode
	PoolAssignList() IPoolAssignListContext
	KW_UNSET() antlr.TerminalNode
	KW_SCHEDULING_POLICY() antlr.TerminalNode
	KW_TRIGGER() antlr.TerminalNode
	KW_ADD() antlr.TerminalNode
	KW_DROP() antlr.TerminalNode

	// IsAlterPoolStatementContext differentiates from other interfaces.
	IsAlterPoolStatementContext()
}

type AlterPoolStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	rpName IId_Context 
	triggerName IId_Context 
}

func NewEmptyAlterPoolStatementContext() *AlterPoolStatementContext {
	var p = new(AlterPoolStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterPoolStatement
	return p
}

func InitEmptyAlterPoolStatementContext(p *AlterPoolStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterPoolStatement
}

func (*AlterPoolStatementContext) IsAlterPoolStatementContext() {}

func NewAlterPoolStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterPoolStatementContext {
	var p = new(AlterPoolStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_alterPoolStatement

	return p
}

func (s *AlterPoolStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterPoolStatementContext) GetRpName() IId_Context { return s.rpName }

func (s *AlterPoolStatementContext) GetTriggerName() IId_Context { return s.triggerName }


func (s *AlterPoolStatementContext) SetRpName(v IId_Context) { s.rpName = v }

func (s *AlterPoolStatementContext) SetTriggerName(v IId_Context) { s.triggerName = v }


func (s *AlterPoolStatementContext) KW_ALTER() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ALTER, 0)
}

func (s *AlterPoolStatementContext) KW_POOL() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_POOL, 0)
}

func (s *AlterPoolStatementContext) DOT() antlr.TerminalNode {
	return s.GetToken(HiveParserDOT, 0)
}

func (s *AlterPoolStatementContext) PoolPath() IPoolPathContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPoolPathContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPoolPathContext)
}

func (s *AlterPoolStatementContext) AllId_() []IId_Context {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IId_Context); ok {
			len++
		}
	}

	tst := make([]IId_Context, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IId_Context); ok {
			tst[i] = t.(IId_Context)
			i++
		}
	}

	return tst
}

func (s *AlterPoolStatementContext) Id_(i int) IId_Context {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *AlterPoolStatementContext) KW_SET() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SET, 0)
}

func (s *AlterPoolStatementContext) PoolAssignList() IPoolAssignListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPoolAssignListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPoolAssignListContext)
}

func (s *AlterPoolStatementContext) KW_UNSET() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_UNSET, 0)
}

func (s *AlterPoolStatementContext) KW_SCHEDULING_POLICY() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_SCHEDULING_POLICY, 0)
}

func (s *AlterPoolStatementContext) KW_TRIGGER() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TRIGGER, 0)
}

func (s *AlterPoolStatementContext) KW_ADD() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ADD, 0)
}

func (s *AlterPoolStatementContext) KW_DROP() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DROP, 0)
}

func (s *AlterPoolStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterPoolStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AlterPoolStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterAlterPoolStatement(s)
	}
}

func (s *AlterPoolStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitAlterPoolStatement(s)
	}
}

func (s *AlterPoolStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitAlterPoolStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) AlterPoolStatement() (localctx IAlterPoolStatementContext) {
	localctx = NewAlterPoolStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 986, HiveParserRULE_alterPoolStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5202)
		p.Match(HiveParserKW_ALTER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(5203)
		p.Match(HiveParserKW_POOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(5204)

		var _x = p.Id_()


		localctx.(*AlterPoolStatementContext).rpName = _x
	}
	{
		p.SetState(5205)
		p.Match(HiveParserDOT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(5206)
		p.PoolPath()
	}
	p.SetState(5214)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserKW_SET:
		{
			p.SetState(5207)
			p.Match(HiveParserKW_SET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5208)
			p.PoolAssignList()
		}


	case HiveParserKW_UNSET:
		{
			p.SetState(5209)
			p.Match(HiveParserKW_UNSET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5210)
			p.Match(HiveParserKW_SCHEDULING_POLICY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HiveParserKW_ADD, HiveParserKW_DROP:
		{
			p.SetState(5211)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HiveParserKW_ADD || _la == HiveParserKW_DROP) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5212)
			p.Match(HiveParserKW_TRIGGER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5213)

			var _x = p.Id_()


			localctx.(*AlterPoolStatementContext).triggerName = _x
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDropPoolStatementContext is an interface to support dynamic dispatch.
type IDropPoolStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRpName returns the rpName rule contexts.
	GetRpName() IId_Context


	// SetRpName sets the rpName rule contexts.
	SetRpName(IId_Context)


	// Getter signatures
	KW_DROP() antlr.TerminalNode
	KW_POOL() antlr.TerminalNode
	DOT() antlr.TerminalNode
	PoolPath() IPoolPathContext
	Id_() IId_Context

	// IsDropPoolStatementContext differentiates from other interfaces.
	IsDropPoolStatementContext()
}

type DropPoolStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	rpName IId_Context 
}

func NewEmptyDropPoolStatementContext() *DropPoolStatementContext {
	var p = new(DropPoolStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_dropPoolStatement
	return p
}

func InitEmptyDropPoolStatementContext(p *DropPoolStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_dropPoolStatement
}

func (*DropPoolStatementContext) IsDropPoolStatementContext() {}

func NewDropPoolStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropPoolStatementContext {
	var p = new(DropPoolStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_dropPoolStatement

	return p
}

func (s *DropPoolStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropPoolStatementContext) GetRpName() IId_Context { return s.rpName }


func (s *DropPoolStatementContext) SetRpName(v IId_Context) { s.rpName = v }


func (s *DropPoolStatementContext) KW_DROP() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DROP, 0)
}

func (s *DropPoolStatementContext) KW_POOL() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_POOL, 0)
}

func (s *DropPoolStatementContext) DOT() antlr.TerminalNode {
	return s.GetToken(HiveParserDOT, 0)
}

func (s *DropPoolStatementContext) PoolPath() IPoolPathContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPoolPathContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPoolPathContext)
}

func (s *DropPoolStatementContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *DropPoolStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropPoolStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DropPoolStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterDropPoolStatement(s)
	}
}

func (s *DropPoolStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitDropPoolStatement(s)
	}
}

func (s *DropPoolStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitDropPoolStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) DropPoolStatement() (localctx IDropPoolStatementContext) {
	localctx = NewDropPoolStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 988, HiveParserRULE_dropPoolStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5216)
		p.Match(HiveParserKW_DROP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(5217)
		p.Match(HiveParserKW_POOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(5218)

		var _x = p.Id_()


		localctx.(*DropPoolStatementContext).rpName = _x
	}
	{
		p.SetState(5219)
		p.Match(HiveParserDOT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(5220)
		p.PoolPath()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreateMappingStatementContext is an interface to support dynamic dispatch.
type ICreateMappingStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetMappingType returns the mappingType token.
	GetMappingType() antlr.Token 

	// GetName returns the name token.
	GetName() antlr.Token 

	// GetOrder returns the order token.
	GetOrder() antlr.Token 


	// SetMappingType sets the mappingType token.
	SetMappingType(antlr.Token) 

	// SetName sets the name token.
	SetName(antlr.Token) 

	// SetOrder sets the order token.
	SetOrder(antlr.Token) 


	// GetRpName returns the rpName rule contexts.
	GetRpName() IId_Context

	// GetPath returns the path rule contexts.
	GetPath() IPoolPathContext


	// SetRpName sets the rpName rule contexts.
	SetRpName(IId_Context)

	// SetPath sets the path rule contexts.
	SetPath(IPoolPathContext)


	// Getter signatures
	KW_CREATE() antlr.TerminalNode
	KW_MAPPING() antlr.TerminalNode
	KW_IN() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode
	Id_() IId_Context
	KW_USER() antlr.TerminalNode
	KW_GROUP() antlr.TerminalNode
	KW_APPLICATION() antlr.TerminalNode
	KW_TO() antlr.TerminalNode
	Unmanaged() IUnmanagedContext
	PoolPath() IPoolPathContext
	KW_WITH() antlr.TerminalNode
	KW_ORDER() antlr.TerminalNode
	Number() antlr.TerminalNode

	// IsCreateMappingStatementContext differentiates from other interfaces.
	IsCreateMappingStatementContext()
}

type CreateMappingStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	mappingType antlr.Token
	name antlr.Token
	rpName IId_Context 
	path IPoolPathContext 
	order antlr.Token
}

func NewEmptyCreateMappingStatementContext() *CreateMappingStatementContext {
	var p = new(CreateMappingStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_createMappingStatement
	return p
}

func InitEmptyCreateMappingStatementContext(p *CreateMappingStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_createMappingStatement
}

func (*CreateMappingStatementContext) IsCreateMappingStatementContext() {}

func NewCreateMappingStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateMappingStatementContext {
	var p = new(CreateMappingStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_createMappingStatement

	return p
}

func (s *CreateMappingStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateMappingStatementContext) GetMappingType() antlr.Token { return s.mappingType }

func (s *CreateMappingStatementContext) GetName() antlr.Token { return s.name }

func (s *CreateMappingStatementContext) GetOrder() antlr.Token { return s.order }


func (s *CreateMappingStatementContext) SetMappingType(v antlr.Token) { s.mappingType = v }

func (s *CreateMappingStatementContext) SetName(v antlr.Token) { s.name = v }

func (s *CreateMappingStatementContext) SetOrder(v antlr.Token) { s.order = v }


func (s *CreateMappingStatementContext) GetRpName() IId_Context { return s.rpName }

func (s *CreateMappingStatementContext) GetPath() IPoolPathContext { return s.path }


func (s *CreateMappingStatementContext) SetRpName(v IId_Context) { s.rpName = v }

func (s *CreateMappingStatementContext) SetPath(v IPoolPathContext) { s.path = v }


func (s *CreateMappingStatementContext) KW_CREATE() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_CREATE, 0)
}

func (s *CreateMappingStatementContext) KW_MAPPING() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_MAPPING, 0)
}

func (s *CreateMappingStatementContext) KW_IN() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_IN, 0)
}

func (s *CreateMappingStatementContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(HiveParserStringLiteral, 0)
}

func (s *CreateMappingStatementContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *CreateMappingStatementContext) KW_USER() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_USER, 0)
}

func (s *CreateMappingStatementContext) KW_GROUP() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_GROUP, 0)
}

func (s *CreateMappingStatementContext) KW_APPLICATION() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_APPLICATION, 0)
}

func (s *CreateMappingStatementContext) KW_TO() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TO, 0)
}

func (s *CreateMappingStatementContext) Unmanaged() IUnmanagedContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnmanagedContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnmanagedContext)
}

func (s *CreateMappingStatementContext) PoolPath() IPoolPathContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPoolPathContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPoolPathContext)
}

func (s *CreateMappingStatementContext) KW_WITH() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_WITH, 0)
}

func (s *CreateMappingStatementContext) KW_ORDER() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ORDER, 0)
}

func (s *CreateMappingStatementContext) Number() antlr.TerminalNode {
	return s.GetToken(HiveParserNumber, 0)
}

func (s *CreateMappingStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateMappingStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CreateMappingStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterCreateMappingStatement(s)
	}
}

func (s *CreateMappingStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitCreateMappingStatement(s)
	}
}

func (s *CreateMappingStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitCreateMappingStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) CreateMappingStatement() (localctx ICreateMappingStatementContext) {
	localctx = NewCreateMappingStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 990, HiveParserRULE_createMappingStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5222)
		p.Match(HiveParserKW_CREATE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(5223)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*CreateMappingStatementContext).mappingType = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == HiveParserKW_APPLICATION || _la == HiveParserKW_GROUP || _la == HiveParserKW_USER) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*CreateMappingStatementContext).mappingType = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(5224)
		p.Match(HiveParserKW_MAPPING)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(5225)

		var _m = p.Match(HiveParserStringLiteral)

		localctx.(*CreateMappingStatementContext).name = _m
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(5226)
		p.Match(HiveParserKW_IN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(5227)

		var _x = p.Id_()


		localctx.(*CreateMappingStatementContext).rpName = _x
	}
	p.SetState(5231)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserKW_TO:
		{
			p.SetState(5228)
			p.Match(HiveParserKW_TO)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5229)

			var _x = p.PoolPath()


			localctx.(*CreateMappingStatementContext).path = _x
		}


	case HiveParserKW_UNMANAGED:
		{
			p.SetState(5230)
			p.Unmanaged()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(5236)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_WITH {
		{
			p.SetState(5233)
			p.Match(HiveParserKW_WITH)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5234)
			p.Match(HiveParserKW_ORDER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5235)

			var _m = p.Match(HiveParserNumber)

			localctx.(*CreateMappingStatementContext).order = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlterMappingStatementContext is an interface to support dynamic dispatch.
type IAlterMappingStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetMappingType returns the mappingType token.
	GetMappingType() antlr.Token 

	// GetName returns the name token.
	GetName() antlr.Token 

	// GetOrder returns the order token.
	GetOrder() antlr.Token 


	// SetMappingType sets the mappingType token.
	SetMappingType(antlr.Token) 

	// SetName sets the name token.
	SetName(antlr.Token) 

	// SetOrder sets the order token.
	SetOrder(antlr.Token) 


	// GetRpName returns the rpName rule contexts.
	GetRpName() IId_Context

	// GetPath returns the path rule contexts.
	GetPath() IPoolPathContext


	// SetRpName sets the rpName rule contexts.
	SetRpName(IId_Context)

	// SetPath sets the path rule contexts.
	SetPath(IPoolPathContext)


	// Getter signatures
	KW_ALTER() antlr.TerminalNode
	KW_MAPPING() antlr.TerminalNode
	KW_IN() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode
	Id_() IId_Context
	KW_USER() antlr.TerminalNode
	KW_GROUP() antlr.TerminalNode
	KW_APPLICATION() antlr.TerminalNode
	KW_TO() antlr.TerminalNode
	Unmanaged() IUnmanagedContext
	PoolPath() IPoolPathContext
	KW_WITH() antlr.TerminalNode
	KW_ORDER() antlr.TerminalNode
	Number() antlr.TerminalNode

	// IsAlterMappingStatementContext differentiates from other interfaces.
	IsAlterMappingStatementContext()
}

type AlterMappingStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	mappingType antlr.Token
	name antlr.Token
	rpName IId_Context 
	path IPoolPathContext 
	order antlr.Token
}

func NewEmptyAlterMappingStatementContext() *AlterMappingStatementContext {
	var p = new(AlterMappingStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterMappingStatement
	return p
}

func InitEmptyAlterMappingStatementContext(p *AlterMappingStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_alterMappingStatement
}

func (*AlterMappingStatementContext) IsAlterMappingStatementContext() {}

func NewAlterMappingStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterMappingStatementContext {
	var p = new(AlterMappingStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_alterMappingStatement

	return p
}

func (s *AlterMappingStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterMappingStatementContext) GetMappingType() antlr.Token { return s.mappingType }

func (s *AlterMappingStatementContext) GetName() antlr.Token { return s.name }

func (s *AlterMappingStatementContext) GetOrder() antlr.Token { return s.order }


func (s *AlterMappingStatementContext) SetMappingType(v antlr.Token) { s.mappingType = v }

func (s *AlterMappingStatementContext) SetName(v antlr.Token) { s.name = v }

func (s *AlterMappingStatementContext) SetOrder(v antlr.Token) { s.order = v }


func (s *AlterMappingStatementContext) GetRpName() IId_Context { return s.rpName }

func (s *AlterMappingStatementContext) GetPath() IPoolPathContext { return s.path }


func (s *AlterMappingStatementContext) SetRpName(v IId_Context) { s.rpName = v }

func (s *AlterMappingStatementContext) SetPath(v IPoolPathContext) { s.path = v }


func (s *AlterMappingStatementContext) KW_ALTER() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ALTER, 0)
}

func (s *AlterMappingStatementContext) KW_MAPPING() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_MAPPING, 0)
}

func (s *AlterMappingStatementContext) KW_IN() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_IN, 0)
}

func (s *AlterMappingStatementContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(HiveParserStringLiteral, 0)
}

func (s *AlterMappingStatementContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *AlterMappingStatementContext) KW_USER() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_USER, 0)
}

func (s *AlterMappingStatementContext) KW_GROUP() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_GROUP, 0)
}

func (s *AlterMappingStatementContext) KW_APPLICATION() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_APPLICATION, 0)
}

func (s *AlterMappingStatementContext) KW_TO() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_TO, 0)
}

func (s *AlterMappingStatementContext) Unmanaged() IUnmanagedContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnmanagedContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnmanagedContext)
}

func (s *AlterMappingStatementContext) PoolPath() IPoolPathContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPoolPathContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPoolPathContext)
}

func (s *AlterMappingStatementContext) KW_WITH() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_WITH, 0)
}

func (s *AlterMappingStatementContext) KW_ORDER() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_ORDER, 0)
}

func (s *AlterMappingStatementContext) Number() antlr.TerminalNode {
	return s.GetToken(HiveParserNumber, 0)
}

func (s *AlterMappingStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterMappingStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AlterMappingStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterAlterMappingStatement(s)
	}
}

func (s *AlterMappingStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitAlterMappingStatement(s)
	}
}

func (s *AlterMappingStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitAlterMappingStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) AlterMappingStatement() (localctx IAlterMappingStatementContext) {
	localctx = NewAlterMappingStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 992, HiveParserRULE_alterMappingStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5238)
		p.Match(HiveParserKW_ALTER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(5239)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*AlterMappingStatementContext).mappingType = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == HiveParserKW_APPLICATION || _la == HiveParserKW_GROUP || _la == HiveParserKW_USER) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*AlterMappingStatementContext).mappingType = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(5240)
		p.Match(HiveParserKW_MAPPING)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(5241)

		var _m = p.Match(HiveParserStringLiteral)

		localctx.(*AlterMappingStatementContext).name = _m
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(5242)
		p.Match(HiveParserKW_IN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(5243)

		var _x = p.Id_()


		localctx.(*AlterMappingStatementContext).rpName = _x
	}
	p.SetState(5247)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HiveParserKW_TO:
		{
			p.SetState(5244)
			p.Match(HiveParserKW_TO)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5245)

			var _x = p.PoolPath()


			localctx.(*AlterMappingStatementContext).path = _x
		}


	case HiveParserKW_UNMANAGED:
		{
			p.SetState(5246)
			p.Unmanaged()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(5252)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HiveParserKW_WITH {
		{
			p.SetState(5249)
			p.Match(HiveParserKW_WITH)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5250)
			p.Match(HiveParserKW_ORDER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5251)

			var _m = p.Match(HiveParserNumber)

			localctx.(*AlterMappingStatementContext).order = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDropMappingStatementContext is an interface to support dynamic dispatch.
type IDropMappingStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetMappingType returns the mappingType token.
	GetMappingType() antlr.Token 

	// GetName returns the name token.
	GetName() antlr.Token 


	// SetMappingType sets the mappingType token.
	SetMappingType(antlr.Token) 

	// SetName sets the name token.
	SetName(antlr.Token) 


	// GetRpName returns the rpName rule contexts.
	GetRpName() IId_Context


	// SetRpName sets the rpName rule contexts.
	SetRpName(IId_Context)


	// Getter signatures
	KW_DROP() antlr.TerminalNode
	KW_MAPPING() antlr.TerminalNode
	KW_IN() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode
	Id_() IId_Context
	KW_USER() antlr.TerminalNode
	KW_GROUP() antlr.TerminalNode
	KW_APPLICATION() antlr.TerminalNode

	// IsDropMappingStatementContext differentiates from other interfaces.
	IsDropMappingStatementContext()
}

type DropMappingStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	mappingType antlr.Token
	name antlr.Token
	rpName IId_Context 
}

func NewEmptyDropMappingStatementContext() *DropMappingStatementContext {
	var p = new(DropMappingStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_dropMappingStatement
	return p
}

func InitEmptyDropMappingStatementContext(p *DropMappingStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HiveParserRULE_dropMappingStatement
}

func (*DropMappingStatementContext) IsDropMappingStatementContext() {}

func NewDropMappingStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropMappingStatementContext {
	var p = new(DropMappingStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HiveParserRULE_dropMappingStatement

	return p
}

func (s *DropMappingStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropMappingStatementContext) GetMappingType() antlr.Token { return s.mappingType }

func (s *DropMappingStatementContext) GetName() antlr.Token { return s.name }


func (s *DropMappingStatementContext) SetMappingType(v antlr.Token) { s.mappingType = v }

func (s *DropMappingStatementContext) SetName(v antlr.Token) { s.name = v }


func (s *DropMappingStatementContext) GetRpName() IId_Context { return s.rpName }


func (s *DropMappingStatementContext) SetRpName(v IId_Context) { s.rpName = v }


func (s *DropMappingStatementContext) KW_DROP() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_DROP, 0)
}

func (s *DropMappingStatementContext) KW_MAPPING() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_MAPPING, 0)
}

func (s *DropMappingStatementContext) KW_IN() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_IN, 0)
}

func (s *DropMappingStatementContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(HiveParserStringLiteral, 0)
}

func (s *DropMappingStatementContext) Id_() IId_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *DropMappingStatementContext) KW_USER() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_USER, 0)
}

func (s *DropMappingStatementContext) KW_GROUP() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_GROUP, 0)
}

func (s *DropMappingStatementContext) KW_APPLICATION() antlr.TerminalNode {
	return s.GetToken(HiveParserKW_APPLICATION, 0)
}

func (s *DropMappingStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropMappingStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DropMappingStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.EnterDropMappingStatement(s)
	}
}

func (s *DropMappingStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HiveParserListener); ok {
		listenerT.ExitDropMappingStatement(s)
	}
}

func (s *DropMappingStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case HiveParserVisitor:
		return t.VisitDropMappingStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *HiveParser) DropMappingStatement() (localctx IDropMappingStatementContext) {
	localctx = NewDropMappingStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 994, HiveParserRULE_dropMappingStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5254)
		p.Match(HiveParserKW_DROP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(5255)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*DropMappingStatementContext).mappingType = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == HiveParserKW_APPLICATION || _la == HiveParserKW_GROUP || _la == HiveParserKW_USER) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*DropMappingStatementContext).mappingType = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(5256)
		p.Match(HiveParserKW_MAPPING)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(5257)

		var _m = p.Match(HiveParserStringLiteral)

		localctx.(*DropMappingStatementContext).name = _m
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(5258)
		p.Match(HiveParserKW_IN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(5259)

		var _x = p.Id_()


		localctx.(*DropMappingStatementContext).rpName = _x
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


